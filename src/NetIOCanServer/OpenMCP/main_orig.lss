
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c6  00800100  0000d5fa  0000d68e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000d5fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a37  008001c6  008001c6  0000d754  2**0
                  ALLOC
  3 .debug_aranges 00001220  00000000  00000000  0000d754  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00002594  00000000  00000000  0000e974  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00011649  00000000  00000000  00010f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00005b7b  00000000  00000000  00022551  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000c9eb  00000000  00000000  000280cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001ac0  00000000  00000000  00034ab8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003968  00000000  00000000  00036578  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00009170  00000000  00000000  00039ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000011d0  00000000  00000000  00043050  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
Beschreibung:    monthlen
Inputs: isleapyear = 0-1, month=0-11
Return:  Number of days per month
*************************************************************************/
unsigned char CLOCK_monthlen(unsigned char isleapyear,unsigned char month)
{
       0:	0c 94 50 11 	jmp	0x22a0	; 0x22a0 <wdt_init>
 * \param	pFunc		Zeiger auf die Aufzurufende Funktion.
 * \return	ErrorCode	TRUE oder FALSE.
 */
/* -----------------------------------------------------------------------------------------------------------*/ 
unsigned char timer1_RemoveCallbackFunction( TIMER1_CALLBACK_FUNC pFunc )
	{
       4:	0c 94 cb 17 	jmp	0x2f96	; 0x2f96 <__vector_1>
#endif

void SPI_InitCore( void )
{
	
}
       8:	0c 94 f2 17 	jmp	0x2fe4	; 0x2fe4 <__vector_2>
 * \param	NONE
 * \return  Anzahl der Byte im Enpfangpuffer
 */
/* -----------------------------------------------------------------------------------------------------------*/
unsigned int UART_Get_Bytes_in_TxBuffer( void )
{
       c:	0c 94 19 18 	jmp	0x3032	; 0x3032 <__vector_3>
//
// Hole ein empfangendes Packet
//
//*********************************************************************************************************
unsigned int enc28j60PacketReceiveLenght( void )
	{
      10:	0c 94 a9 20 	jmp	0x4152	; 0x4152 <__vector_4>
 * \param		NONE
 * \return		NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int PCINT_disablePCINT( unsigned char PCINT )
{
      14:	0c 94 d7 20 	jmp	0x41ae	; 0x41ae <__vector_5>
 */
/* -----------------------------------------------------------------------------------------------------------*/ 
void timer0_free(void)
	{
			TIMSK0 |= ( 1<<OCIE0A );  // Compare Match A Interupt sperren		
	}
      18:	0c 94 05 21 	jmp	0x420a	; 0x420a <__vector_6>
			}
	}

int	icmp_ping( unsigned long IP )
{
}
      1c:	0c 94 33 21 	jmp	0x4266	; 0x4266 <__vector_7>

/* -----------------------------------------------------------------------------------------------------------
Holt den n채chsten freien Socket
------------------------------------------------------------------------------------------------------------*/
int UDP_Getfreesocket( void )
	{
      20:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
 * \warning Die Funktion wir in der tcp_init() beim timerinterrupt registiert und fortan zyklisch aufgerufen.
 * \retval	SOCKET	Gibt die Nummer des naechsten Freien SOcket.
 */
/*------------------------------------------------------------------------------------------------------------*/
int Getfreesocket( void )
	{
      24:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>

/* -----------------------------------------------------------------------------------------------------------
Holt ein Ethernetframe
------------------------------------------------------------------------------------------------------------*/
unsigned int getEthernetframe( unsigned int maxlen, unsigned char *ethernetbuffer)
	{
      28:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
 * \return				R체ckgabewerd der Funktion
 * \retval 1			Die MAC-Anfrage war erfolgrich.
 * \retval 0			Die MAC-Anfrage ist Fehlgeschlagen.
 */
unsigned char GetARPtableEntry( unsigned int Entry, unsigned long * IP, unsigned char * MAC, unsigned char * ttl)
{
      2c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
		}
		return( DNS_ans->Adress );		
}

unsigned long DNS_ResolveName_P( const char * HOSTNAME_P )
{
      30:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
		default:			break;
	}
}

void STDOUT_SetXY( char x, char y )
{
      34:	0c 94 46 1c 	jmp	0x388c	; 0x388c <__vector_13>
 * \retval	1		Alles okay.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int deleteConfig_P( const char * ConfigName)
{
      38:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
 * \param	FIFO		Nummer des FIFO.
 * \return	Returncode	FIFO_OK oder FIFO_ERROR.
 */
/*------------------------------------------------------------------------------------------------------------*/
int Free_FIFO ( int FIFO )
{
      3c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
 * \param Digit		Zeichen welches gewandelt werden soll.
 * \return			R체chgabewert der Funktion.
 * \retval			Wandlung war erfolgreich. 
 */
char atoh( char Digit )
{
      40:	0c 94 e6 21 	jmp	0x43cc	; 0x43cc <__vector_16>
 * \param	ArgName	 Pointer auf einen String im RAM der den Namen enth채lt.
 * \return			 0 wenn gefunden, sonst -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
char PharseCheckName( void * pStruct , char * ArgName )
{
      44:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
 * \param 	entry			Eintrag der geholt werden soll.
 * \return	int				Anzahl der Argumente
 */
/*------------------------------------------------------------------------------------------------------------*/
int CRON_pharseentry( char * cronstring, char ** argv )
{
      48:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
	telnet_RegisterCMD( cmd_arp, PSTR("arp"));
#endif
}

int cmd_arp( int argc, char ** argv )
{
      4c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
	
	if ((status & 0x54) == 0x54)
		return false;		// all buffers used
	else
		return true;
}
      50:	0c 94 59 1d 	jmp	0x3ab2	; 0x3ab2 <__vector_20>
	} else if (Linie==0x4) {
		return (3) ;
	} 
	
	return (-1) ;
}
      54:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <__vector_21>
	}
    raw_block_written = 1;
#endif

   return 1;
}
      58:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <__vector_22>
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat_create_file
 */
uint8_t fat_delete_file(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry)
{
      5c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
#else
    partition->type = PARTITION_TYPE_FREE;
#endif

    return 1;
}
      60:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
      64:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
      68:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
      6c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>

00000070 <__c.1747>:
      70:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
      80:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

0000008e <__c.2042>:
      8e:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

0000009a <__c.2107>:
      9a:	20 66 65 68 6c 67 65 73 63 68 6c 61 67 65 6e 0d      fehlgeschlagen.
      aa:	0a 00                                               ..

000000ac <__c.2105>:
      ac:	20 66 65 68 6c 67 65 73 63 68 6c 61 67 65 6e 0d      fehlgeschlagen.
      bc:	0a 00                                               ..

000000be <__c.2103>:
      be:	20 5a 65 69 74 3a 20 25 30 32 64 3a 25 30 32 64      Zeit: %02d:%02d
      ce:	3a 25 30 32 64 2e 25 30 32 64 0d 0a 00              :%02d.%02d...

000000db <__c.2101>:
      db:	4e 54 50 53 45 52 56 45 52 00                       NTPSERVER.

000000e5 <__c.2099>:
      e5:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

000000ed <__c.2097>:
      ed:	20 7c 2d 3e 20 4e 54 50 2d 53 65 72 76 65 72 20      |-> NTP-Server 
      fd:	5a 65 69 74 20 61 6b 74 75 61 6c 69 73 69 65 72     Zeit aktualisier
     10d:	65 6e 3a 00                                         en:.

00000111 <__c.2095>:
     111:	6f 6e 00                                            on.

00000114 <__c.2093>:
     114:	4e 54 50 00                                         NTP.

00000118 <__c.2091>:
     118:	20 7c 20 20 20 44 4e 53 20 20 20 20 3a 20 25 73      |   DNS    : %s
     128:	0d 0a 00                                            ...

0000012b <__c.2089>:
     12b:	20 7c 20 20 20 47 61 74 65 77 61 79 3a 20 25 73      |   Gateway: %s
     13b:	0d 0a 00                                            ...

0000013e <__c.2087>:
     13e:	20 7c 20 20 20 4e 65 74 6d 61 73 6b 3a 20 25 73      |   Netmask: %s
     14e:	0d 0a 00                                            ...

00000151 <__c.2085>:
     151:	20 7c 20 20 20 49 50 20 20 20 20 20 3a 20 25 73      |   IP     : %s
     161:	0d 0a 00                                            ...

00000164 <__c.2083>:
     164:	44 4e 53 00                                         DNS.

00000168 <__c.2081>:
     168:	47 41 54 45 00                                      GATE.

0000016d <__c.2079>:
     16d:	4d 41 53 4b 00                                      MASK.

00000172 <__c.2077>:
     172:	49 50 00                                            IP.

00000175 <__c.2075>:
     175:	20 7c 2d 3e 20 54 43 50 20 28 48 75 72 72 69 63      |-> TCP (Hurric
     185:	61 6e 2d 65 6e 67 69 6e 65 29 20 69 6e 69 74 69     an-engine) initi
     195:	61 6c 69 73 69 65 72 74 0d 0a 00                    alisiert...

000001a0 <__c.2073>:
     1a0:	20 7c 2d 3e 20 55 44 50 20 28 54 6f 72 6e 61 64      |-> UDP (Tornad
     1b0:	6f 2d 65 6e 67 69 6e 65 29 20 69 6e 69 74 69 61     o-engine) initia
     1c0:	6c 69 73 69 65 72 74 0d 0a 00                       lisiert...

000001ca <__c.2071>:
     1ca:	2d 2b 2d 3e 20 41 52 50 20 69 6e 69 74 69 61 6c     -+-> ARP initial
     1da:	69 73 69 65 72 74 0d 0a 00                          isiert...

000001e3 <__c.2069>:
     1e3:	20 4c 69 6e 6b 20 72 65 61 64 79 0d 0a 00            Link ready...

000001f1 <__c.2064>:
     1f1:	20 46 75 6c 6c 64 75 70 6c 65 78 3a 00               Fullduplex:.

000001fe <__c.2062>:
     1fe:	45 4e 43 32 38 6a 36 30 20 69 6e 69 74 69 61 6c     ENC28j60 initial
     20e:	69 73 69 65 72 74 20 28 20 48 57 2d 41 64 64 3a     isiert ( HW-Add:
     21e:	20 25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a      %02x:%02x:%02x:
     22e:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 20 29     %02x:%02x:%02x )
	...

0000023f <__c.2060>:
     23f:	4d 41 43 00                                         MAC.

00000243 <__c.2058>:
     243:	4d 41 43 00                                         MAC.

00000247 <__c.1791>:
     247:	4d 43 50 63 6f 6e 66 69 67 00                       MCPconfig.

00000251 <__c.1769>:
     251:	0d 0a 00                                            ...

00000254 <__c.1764>:
     254:	0a 00                                               ..

00000256 <__c.1762>:
     256:	25 63 00                                            %c.

00000259 <__c.1757>:
     259:	43 6f 6e 66 69 67 20 69 73 74 20 25 64 20 62 79     Config ist %d by
     269:	74 65 73 20 67 72 6f 73 73 2c 20 25 64 20 62 79     tes gross, %d by
     279:	74 65 20 77 65 72 64 65 6e 20 62 65 6e 75 74 7a     te werden benutz
     289:	74 2e 20 4f 66 66 73 65 74 20 25 64 0d 0a 0d 0a     t. Offset %d....
	...

0000029a <__c.1741>:
     29a:	4f 46 46 00                                         OFF.

0000029e <__c.1739>:
     29e:	57 52 49 54 45 5f 50 52 4f 54 45 43 54 00           WRITE_PROTECT.

000002ac <config_ok>:
     2ac:	20 49 6e 69 74 69 61 6c 69 73 69 65 72 74 0d 0a      Initialisiert..
	...

000002bd <config_error>:
     2bd:	20 45 72 72 6f 72 0d 0a 00                           Error...

000002c6 <__c.1876>:
     2c6:	46 69 6c 65 73 79 73 74 65 6d 00                    Filesystem.

000002d1 <__c.1874>:
     2d1:	4d 4d 43 2f 53 44 00                                MMC/SD.

000002d8 <__c.1872>:
     2d8:	50 43 49 4e 54 00                                   PCINT.

000002de <__c.1870>:
     2de:	45 58 54 49 4e 54 00                                EXTINT.

000002e5 <__c.1868>:
     2e5:	43 6f 6e 66 69 67 00                                Config.

000002ec <__c.1866>:
     2ec:	43 4c 4f 43 4b 00                                   CLOCK.

000002f2 <__c.1864>:
     2f2:	53 54 44 4f 55 54 00                                STDOUT.

000002f9 <__c.1862>:
     2f9:	55 41 52 54 00                                      UART.

000002fe <__c.1860>:
     2fe:	4f 70 65 6e 4d 43 50 20 2e 2e 2e 0d 0a 00           OpenMCP ......

0000030c <__c.2008>:
     30c:	48 54 54 50 2f 31 2e 30 20 34 30 33 0d 0a 43 6f     HTTP/1.0 403..Co
     31c:	6e 74 65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74     ntent-Type: text
     32c:	2f 68 74 6d 6c 0d 0a 4b 65 65 70 2d 41 6c 69 76     /html..Keep-Aliv
     33c:	65 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 48 54 4d     e: close....<HTM
     34c:	4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a 3c 54 49 54     L>..<HEAD>..<TIT
     35c:	4c 45 3e 34 30 33 20 46 69 6c 65 20 6e 6f 74 20     LE>403 File not 
     36c:	66 6f 75 6e 64 21 3c 2f 54 49 54 4c 45 3e 0d 0a     found!</TITLE>..
     37c:	3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e 0d     </HEAD>..<BODY>.
     38c:	0a 34 30 33 20 46 69 6c 65 20 6e 6f 74 20 66 6f     .403 File not fo
     39c:	75 6e 64 21 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48     und!</BODY>..</H
     3ac:	54 4d 4c 3e 0d 0a 0d 0a 00                          TML>.....

000003b5 <__c.1997>:
     3b5:	68 74 74 70 64 00                                   httpd.

000003bb <__c.1995>:
     3bb:	48 54 54 50 2d 53 65 72 76 65 72 20 67 65 73 74     HTTP-Server gest
     3cb:	61 72 74 65 74 20 61 75 66 20 50 6f 72 74 20 25     artet auf Port %
     3db:	64 2e 0d 0a 00                                      d....

000003e0 <__c.1747>:
     3e0:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

000003eb <__c.1797>:
     3eb:	3c 2f 42 4f 44 59 3e 3c 2f 48 54 4d 4c 3e 0d 0a     </BODY></HTML>..
     3fb:	0d 0a 00                                            ...

000003fe <__c.1792>:
     3fe:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 2f 48 45     <HTML><HEAD></HE
     40e:	41 44 3e 3c 42 4f 44 59 3e 00                       AD><BODY>.

00000418 <__c.1779>:
     418:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 44 6f 63     HTTP/1.0 200 Doc
     428:	75 6d 65 6e 74 20 66 6f 6c 6c 6f 77 73 0d 0a 43     ument follows..C
     438:	6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74 65 78     ontent-Type: tex
     448:	74 2f 68 74 6d 6c 0d 0a 4b 65 65 70 2d 41 6c 69     t/html..Keep-Ali
     458:	76 65 3a 20 74 69 6d 65 6f 75 74 3d 31 2c 20 6d     ve: timeout=1, m
     468:	61 78 3d 35 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     ax=5..Connection
     478:	3a 20 63 6c 6f 73 65 0d 0a 0d 0a 00                 : close.....

00000484 <files1>:
     484:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

0000048f <data1>:
     48f:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 54 49 54     <HTML><HEAD><TIT
     49f:	4c 45 3e 4f 70 65 6e 4d 43 50 20 2d 20 57 65 6c     LE>OpenMCP - Wel
     4af:	63 6f 6d 65 20 6f 6e 20 4d 69 63 72 6f 63 6f 6e     come on Microcon
     4bf:	74 72 6f 6c 6c 65 72 20 42 6f 61 72 64 3c 2f 54     troller Board</T
     4cf:	49 54 4c 45 3e 3c 2f 48 45 41 44 3e 3c 66 72 61     ITLE></HEAD><fra
     4df:	6d 65 73 65 74 20 72 6f 77 73 3d 22 36 30 2c 33     meset rows="60,3
     4ef:	35 2c 2a 2c 34 30 22 20 73 63 72 6f 6c 6c 69 6e     5,*,40" scrollin
     4ff:	67 3d 22 6e 6f 22 20 66 72 61 6d 65 62 6f 72 64     g="no" framebord
     50f:	65 72 3d 22 32 22 20 62 6f 72 64 65 72 3d 22 32     er="2" border="2
     51f:	22 20 66 72 61 6d 65 73 70 61 63 69 6e 67 3d 22     " framespacing="
     52f:	32 22 20 62 6f 72 64 65 72 63 6f 6c 6f 72 3d 22     2" bordercolor="
     53f:	23 30 30 30 30 30 30 22 3e 3c 66 72 61 6d 65 20     #000000"><frame 
     54f:	73 72 63 3d 22 68 65 61 64 6c 69 6e 65 2e 68 74     src="headline.ht
     55f:	6d 6c 22 20 6e 61 6d 65 3d 22 4e 61 76 69 67 61     ml" name="Naviga
     56f:	74 69 6f 6e 31 22 20 73 63 72 6f 6c 6c 69 6e 67     tion1" scrolling
     57f:	3d 22 6e 6f 22 3e 3c 66 72 61 6d 65 20 73 72 63     ="no"><frame src
     58f:	3d 22 6d 61 69 6e 6d 65 6e 75 2e 68 74 6d 6c 22     ="mainmenu.html"
     59f:	20 6e 61 6d 65 3d 22 4e 61 76 69 67 61 74 69 6f      name="Navigatio
     5af:	6e 32 22 20 73 63 72 6f 6c 6c 69 6e 67 3d 22 6e     n2" scrolling="n
     5bf:	6f 22 3e 3c 66 72 61 6d 65 20 73 72 63 3d 22 69     o"><frame src="i
     5cf:	6e 66 6f 2e 68 74 6d 6c 22 20 6e 61 6d 65 3d 22     nfo.html" name="
     5df:	6d 61 69 6e 22 20 73 63 72 6f 6c 6c 69 6e 67 3d     main" scrolling=
     5ef:	22 6e 6f 22 3e 3c 66 72 61 6d 65 20 73 72 63 3d     "no"><frame src=
     5ff:	22 73 74 61 74 73 2e 63 67 69 22 20 6e 61 6d 65     "stats.cgi" name
     60f:	3d 22 75 70 64 61 74 65 22 20 73 63 72 6f 6c 6c     ="update" scroll
     61f:	69 6e 67 3d 22 6e 6f 22 3e 3c 6e 6f 66 72 61 6d     ing="no"><nofram
     62f:	65 73 3e 3c 62 6f 64 79 3e 3c 70 3e 49 68 72 20     es><body><p>Ihr 
     63f:	42 72 6f 77 73 65 72 20 75 6e 74 65 72 73 74 c3     Browser unterst.
     64f:	bc 74 7a 74 20 6b 65 69 6e 65 20 46 72 61 6d 65     .tzt keine Frame
     65f:	73 21 3c 2f 70 3e 3c 2f 62 6f 64 79 3e 3c 2f 6e     s!</p></body></n
     66f:	6f 66 72 61 6d 65 73 3e 3c 2f 66 72 61 6d 65 73     oframes></frames
     67f:	65 74 3e 3c 2f 48 54 4d 4c 3e 0d 0a 0d 0a 00        et></HTML>.....

0000068e <files2>:
     68e:	68 65 61 64 6c 69 6e 65 2e 68 74 6d 6c 00           headline.html.

0000069c <data2>:
     69c:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 54 49 54     <HTML><HEAD><TIT
     6ac:	4c 45 3e 4f 70 65 6e 4d 43 50 3c 2f 54 49 54 4c     LE>OpenMCP</TITL
     6bc:	45 3e 3c 2f 48 45 41 44 3e 3c 42 4f 44 59 20 62     E></HEAD><BODY b
     6cc:	67 63 6f 6c 6f 72 3d 22 23 30 30 36 34 30 30 22     gcolor="#006400"
     6dc:	20 74 65 78 74 3d 22 23 46 46 46 41 46 30 22 3e      text="#FFFAF0">
     6ec:	3c 68 31 3e 4f 70 65 6e 4d 43 50 20 2d 20 57 65     <h1>OpenMCP - We
     6fc:	6c 63 6f 6d 65 20 6f 6e 20 4d 69 63 72 6f 63 6f     lcome on Microco
     70c:	6e 74 72 6f 6c 6c 65 72 20 42 6f 61 72 64 3c 2f     ntroller Board</
     71c:	68 31 3e 3c 2f 42 4f 44 59 3e 3c 2f 48 54 4d 4c     h1></BODY></HTML
     72c:	3e 0d 0a 0d 0a 00                                   >.....

00000732 <files3>:
     732:	69 6f 2e 68 74 6d 6c 00                             io.html.

0000073a <data3>:
     73a:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 54 49 54     <HTML><HEAD><TIT
     74a:	4c 45 3e 4f 70 65 6e 4d 43 50 3c 2f 54 49 54 4c     LE>OpenMCP</TITL
     75a:	45 3e 3c 6c 69 6e 6b 20 72 65 6c 3d 22 73 74 79     E><link rel="sty
     76a:	6c 65 73 68 65 65 74 22 20 74 79 70 65 3d 22 74     lesheet" type="t
     77a:	65 78 74 2f 63 73 73 22 20 68 72 65 66 3d 22 73     ext/css" href="s
     78a:	74 79 6c 65 2e 63 73 73 22 3e 3c 2f 48 45 41 44     tyle.css"></HEAD
     79a:	3e 3c 42 4f 44 59 20 62 67 63 6f 6c 6f 72 3d 22     ><BODY bgcolor="
     7aa:	23 32 32 38 42 32 32 22 20 74 65 78 74 3d 22 23     #228B22" text="#
     7ba:	46 46 46 46 46 46 22 3e 3c 61 20 68 72 65 66 3d     FFFFFF"><a href=
     7ca:	22 6d 61 69 6e 6d 65 6e 75 2e 68 74 6d 6c 22 3e     "mainmenu.html">
     7da:	7a 75 72 75 65 63 6b 3c 2f 61 3e 3c 2f 42 4f 44     zurueck</a></BOD
     7ea:	59 3e 3c 2f 48 54 4d 4c 3e 0d 0a 0d 0a 00           Y></HTML>.....

000007f8 <files4>:
     7f8:	6d 61 69 6e 6d 65 6e 75 2e 68 74 6d 6c 00           mainmenu.html.

00000806 <data4>:
     806:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 54 49 54     <HTML><HEAD><TIT
     816:	4c 45 3e 4f 70 65 6e 4d 43 50 3c 2f 54 49 54 4c     LE>OpenMCP</TITL
     826:	45 3e 3c 6c 69 6e 6b 20 72 65 6c 3d 22 73 74 79     E><link rel="sty
     836:	6c 65 73 68 65 65 74 22 20 74 79 70 65 3d 22 74     lesheet" type="t
     846:	65 78 74 2f 63 73 73 22 20 68 72 65 66 3d 22 73     ext/css" href="s
     856:	74 79 6c 65 2e 63 73 73 22 3e 3c 2f 48 45 41 44     tyle.css"></HEAD
     866:	3e 3c 42 4f 44 59 20 62 67 63 6f 6c 6f 72 3d 22     ><BODY bgcolor="
     876:	23 32 32 38 42 32 32 22 20 74 65 78 74 3d 22 23     #228B22" text="#
     886:	46 46 46 46 46 46 22 3e 3c 61 20 68 72 65 66 3d     FFFFFF"><a href=
     896:	22 69 6e 66 6f 2e 68 74 6d 6c 22 74 61 72 67 65     "info.html"targe
     8a6:	74 3d 22 6d 61 69 6e 22 3e 49 6e 66 6f 72 6d 61     t="main">Informa
     8b6:	74 69 6f 6e 65 6e 3c 2f 61 3e 20 2f 20 3c 61 20     tionen</a> / <a 
     8c6:	68 72 65 66 3d 22 69 6f 2e 68 74 6d 6c 22 3e 49     href="io.html">I
     8d6:	4f 2d 50 6f 72 74 73 3c 2f 61 3e 20 2f 20 3c 61     O-Ports</a> / <a
     8e6:	20 68 72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68      href="network.h
     8f6:	74 6d 6c 22 3e 4e 65 74 7a 77 65 72 6b 3c 2f 61     tml">Netzwerk</a
     906:	3e 20 2f 20 3c 61 20 68 72 65 66 3d 22 73 79 73     > / <a href="sys
     916:	74 65 6d 2e 68 74 6d 6c 22 3e 53 79 73 74 65 6d     tem.html">System
     926:	3c 2f 61 3e 3c 2f 42 4f 44 59 3e 3c 2f 48 54 4d     </a></BODY></HTM
     936:	4c 3e 0d 0a 0d 0a 00                                L>.....

0000093d <files5>:
     93d:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

0000094a <data5>:
     94a:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 54 49 54     <HTML><HEAD><TIT
     95a:	4c 45 3e 4f 70 65 6e 4d 43 50 3c 2f 54 49 54 4c     LE>OpenMCP</TITL
     96a:	45 3e 3c 6c 69 6e 6b 20 72 65 6c 3d 22 73 74 79     E><link rel="sty
     97a:	6c 65 73 68 65 65 74 22 20 74 79 70 65 3d 22 74     lesheet" type="t
     98a:	65 78 74 2f 63 73 73 22 20 68 72 65 66 3d 22 73     ext/css" href="s
     99a:	74 79 6c 65 2e 63 73 73 22 3e 3c 2f 48 45 41 44     tyle.css"></HEAD
     9aa:	3e 3c 42 4f 44 59 20 62 67 63 6f 6c 6f 72 3d 22     ><BODY bgcolor="
     9ba:	23 32 32 38 42 32 32 22 20 74 65 78 74 3d 22 23     #228B22" text="#
     9ca:	46 46 46 46 46 46 22 3e 3c 61 20 68 72 65 66 3d     FFFFFF"><a href=
     9da:	22 6d 61 69 6e 6d 65 6e 75 2e 68 74 6d 6c 22 3e     "mainmenu.html">
     9ea:	7a 75 72 75 65 63 6b 3c 2f 61 3e 20 2f 20 3c 61     zurueck</a> / <a
     9fa:	20 68 72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 63      href="network.c
     a0a:	67 69 22 20 74 61 72 67 65 74 3d 22 6d 61 69 6e     gi" target="main
     a1a:	22 3e 49 6e 66 6f 73 3c 2f 61 3e 20 2f 20 3c 61     ">Infos</a> / <a
     a2a:	20 68 72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 63      href="network.c
     a3a:	67 69 3f 63 6f 6e 66 69 67 22 20 74 61 72 67 65     gi?config" targe
     a4a:	74 3d 22 6d 61 69 6e 22 3e 4b 6f 6e 66 69 67 75     t="main">Konfigu
     a5a:	72 61 74 69 6f 6e 3c 2f 61 3e 3c 2f 42 4f 44 59     ration</a></BODY
     a6a:	3e 3c 2f 48 54 4d 4c 3e 0d 0a 0d 0a 00              ></HTML>.....

00000a77 <files6>:
     a77:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

00000a83 <data6>:
     a83:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 54 49 54     <HTML><HEAD><TIT
     a93:	4c 45 3e 4f 70 65 6e 4d 43 50 3c 2f 54 49 54 4c     LE>OpenMCP</TITL
     aa3:	45 3e 3c 6c 69 6e 6b 20 72 65 6c 3d 22 73 74 79     E><link rel="sty
     ab3:	6c 65 73 68 65 65 74 22 20 74 79 70 65 3d 22 74     lesheet" type="t
     ac3:	65 78 74 2f 63 73 73 22 20 68 72 65 66 3d 22 73     ext/css" href="s
     ad3:	74 79 6c 65 2e 63 73 73 22 3e 3c 2f 48 45 41 44     tyle.css"></HEAD
     ae3:	3e 3c 42 4f 44 59 20 62 67 63 6f 6c 6f 72 3d 22     ><BODY bgcolor="
     af3:	23 32 32 38 42 32 32 22 20 74 65 78 74 3d 22 23     #228B22" text="#
     b03:	46 46 46 46 46 46 22 3e 3c 61 20 68 72 65 66 3d     FFFFFF"><a href=
     b13:	22 6d 61 69 6e 6d 65 6e 75 2e 68 74 6d 6c 22 3e     "mainmenu.html">
     b23:	7a 75 72 75 65 63 6b 3c 2f 61 3e 20 2f 20 3c 61     zurueck</a> / <a
     b33:	20 68 72 65 66 3d 22 72 65 73 65 74 2e 63 67 69      href="reset.cgi
     b43:	22 20 74 61 72 67 65 74 3d 22 6d 61 69 6e 22 3e     " target="main">
     b53:	52 65 73 65 74 3c 2f 61 3e 20 2f 20 3c 61 20 68     Reset</a> / <a h
     b63:	72 65 66 3d 22 6e 74 70 2e 63 67 69 22 20 74 61     ref="ntp.cgi" ta
     b73:	72 67 65 74 3d 22 6d 61 69 6e 22 3e 4e 54 50 3c     rget="main">NTP<
     b83:	2f 61 3e 20 2f 20 3c 61 20 68 72 65 66 3d 22 65     /a> / <a href="e
     b93:	65 6d 65 6d 2e 63 67 69 22 20 74 61 72 67 65 74     emem.cgi" target
     ba3:	3d 22 6d 61 69 6e 22 3e 45 45 6d 65 6d 3c 2f 61     ="main">EEmem</a
     bb3:	3e 20 2f 20 3c 61 20 68 72 65 66 3d 22 63 72 6f     > / <a href="cro
     bc3:	6e 2e 63 67 69 22 20 74 61 72 67 65 74 3d 22 6d     n.cgi" target="m
     bd3:	61 69 6e 22 3e 63 72 6f 6e 3c 2f 61 3e 3c 2f 42     ain">cron</a></B
     be3:	4f 44 59 3e 3c 2f 48 54 4d 4c 3e 0d 0a 0d 0a 00     ODY></HTML>.....

00000bf3 <files7>:
     bf3:	69 6e 66 6f 2e 68 74 6d 6c 00                       info.html.

00000bfd <data7>:
     bfd:	3c 48 54 4d 4c 3e 3c 42 4f 44 59 3e 3c 70 72 65     <HTML><BODY><pre
     c0d:	3e 3c 70 3e 20 20 57 65 6c 63 6f 6d 65 20 6f 6e     ><p>  Welcome on
     c1d:	0d 0a 20 20 20 20 20 20 20 5f 5f 5f 5f 20 20 20     ..       ____   
     c2d:	20 20 20 20 20 20 20 20 20 5f 5f 5f 5f 5f 5f 5f              _______
     c3d:	5f 5f 5f 5f 5f 5f 5f 0d 0a 20 20 20 20 20 20 2f     _______..      /
     c4d:	20 20 20 2f 20 20 20 20 20 20 20 20 20 20 20 2f        /           /
     c5d:	20 20 20 20 20 2f 20 5f 5f 2f 20 20 20 2f 0d 0a          / __/   /..
     c6d:	20 20 20 20 20 2f 20 2f 20 2f 5f 5f 5f 5f 5f 5f          / / /______
     c7d:	5f 5f 5f 5f 5f 2f 20 2f 20 2f 20 2f 20 2f 20 2f     _____/ / / / / /
     c8d:	20 2f 20 2f 0d 0a 20 20 20 20 2f 20 2f 20 2f 20      / /..    / / / 
     c9d:	20 20 2f 20 5f 5f 2f 20 20 20 2f 20 2f 20 2f 20       / __/   / / / 
     cad:	2f 20 2f 20 2f 20 5f 5f 2f 0d 0a 20 20 20 2f 20     / / / __/..   / 
     cbd:	2f 20 2f 20 2f 20 2f 20 5f 5f 2f 20 2f 20 2f 20     / / / / __/ / / 
     ccd:	2f 20 2f 20 2f 20 2f 5f 2f 20 2f 0d 0a 20 20 2f     / / / /_/ /..  /
     cdd:	5f 5f 5f 2f 20 5f 5f 2f 5f 5f 5f 2f 5f 2f 5f 2f     ___/ __/___/_/_/
     ced:	5f 2f 5f 2f 5f 2f 5f 5f 5f 2f 5f 2f 20 20 20 20     _/_/_/___/_/    
     cfd:	20 4f 70 65 6e 20 4d 69 63 72 6f 43 6f 6e 74 72      Open MicroContr
     d0d:	6f 6c 6c 65 72 50 72 6f 6a 65 6b 74 0d 0a 20 20     ollerProjekt..  
     d1d:	20 20 20 2f 5f 2f 0d 0a 20 20 0d 0a 46 6f 72 20        /_/..  ..For 
     d2d:	6d 6f 72 65 20 69 6e 66 6f 72 6d 61 74 69 6f 6e     more information
     d3d:	20 76 69 73 69 74 20 74 68 65 20 3c 61 20 68 72      visit the <a hr
     d4d:	65 66 3d 22 68 74 74 70 3a 2f 2f 77 69 6b 69 2e     ef="http://wiki.
     d5d:	6e 65 6f 2d 67 75 65 72 69 6c 6c 61 7a 2e 64 65     neo-guerillaz.de
     d6d:	22 20 74 61 72 67 65 74 3d 22 5f 62 6c 61 6e 6b     " target="_blank
     d7d:	22 3e 4f 70 65 6e 4d 43 50 3c 2f 61 3e 20 70 72     ">OpenMCP</a> pr
     d8d:	6f 6a 65 63 74 70 61 67 65 2e 0d 0a 4d 69 63 72     ojectpage...Micr
     d9d:	6f 77 65 62 73 65 72 76 65 72 20 62 75 69 6c 64     owebserver build
     dad:	20 6f 6e 20 41 56 52 2d 6c 69 62 63 20 76 65 72      on AVR-libc ver
     dbd:	73 69 6f 6e 3a 20 31 2e 36 2e 34 2f 32 30 30 38     sion: 1.6.4/2008
     dcd:	31 31 30 36 20 77 69 74 68 20 61 76 72 2d 67 63     1106 with avr-gc
     ddd:	63 20 34 2e 33 2e 32 2c 20 44 61 74 65 3a 20 4d     c 4.3.2, Date: M
     ded:	61 72 20 31 36 20 32 30 30 32 20 32 31 3a 32 37     ar 16 2002 21:27
     dfd:	3a 34 39 20 0d 0a 0d 0a 28 63 29 32 30 30 36 2d     :49 ....(c)2006-
     e0d:	32 30 30 39 20 20 20 53 6f 66 74 77 61 72 65 3a     2009   Software:
     e1d:	20 44 69 72 6b 20 42 72 6f 73 73 77 69 63 6b 20      Dirk Brosswick 
     e2d:	28 73 68 61 72 61 6e 64 61 63 40 73 6e 61 66 75     (sharandac@snafu
     e3d:	2e 64 65 29 0d 0a 3c 2f 70 72 65 3e 3c 2f 70 3e     .de)..</pre></p>
     e4d:	3c 2f 42 4f 44 59 3e 3c 2f 48 54 4d 4c 3e 0d 0a     </BODY></HTML>..
	...

00000e5e <files8>:
     e5e:	73 74 79 6c 65 2e 63 73 73 00                       style.css.

00000e68 <data8>:
     e68:	40 63 68 61 72 73 65 74 20 22 49 53 4f 2d 38 38     @charset "ISO-88
     e78:	35 39 2d 31 22 0d 0a 20 20 20 61 3a 6c 69 6e 6b     59-1"..   a:link
     e88:	20 7b 20 74 65 78 74 2d 64 65 63 6f 72 61 74 69      { text-decorati
     e98:	6f 6e 3a 6e 6f 6e 65 3b 20 66 6f 6e 74 2d 77 65     on:none; font-we
     ea8:	69 67 68 74 3a 62 6f 6c 64 3b 20 63 6f 6c 6f 72     ight:bold; color
     eb8:	3a 23 46 46 46 46 46 46 3b 20 7d 0d 0a 20 20 20     :#FFFFFF; }..   
     ec8:	61 3a 76 69 73 69 74 65 64 20 7b 20 74 65 78 74     a:visited { text
     ed8:	2d 64 65 63 6f 72 61 74 69 6f 6e 3a 6e 6f 6e 65     -decoration:none
     ee8:	3b 20 66 6f 6e 74 2d 77 65 69 67 68 74 3a 62 6f     ; font-weight:bo
     ef8:	6c 64 3b 20 63 6f 6c 6f 72 3a 23 46 46 46 46 46     ld; color:#FFFFF
     f08:	46 3b 20 7d 0d 0a 20 20 20 61 3a 68 6f 76 65 72     F; }..   a:hover
     f18:	20 7b 20 74 65 78 74 2d 64 65 63 6f 72 61 74 69      { text-decorati
     f28:	6f 6e 3a 6e 6f 6e 65 3b 20 66 6f 6e 74 2d 77 65     on:none; font-we
     f38:	69 67 68 74 3a 62 6f 6c 64 3b 20 62 61 63 6b 67     ight:bold; backg
     f48:	72 6f 75 6e 64 2d 63 6f 6c 6f 72 3a 23 34 31 36     round-color:#416
     f58:	39 45 31 3b 20 7d 0d 0a 20 20 20 61 3a 61 63 74     9E1; }..   a:act
     f68:	69 76 65 20 7b 20 74 65 78 74 2d 64 65 63 6f 72     ive { text-decor
     f78:	61 74 69 6f 6e 3a 6e 6f 6e 65 3b 20 66 6f 6e 74     ation:none; font
     f88:	2d 77 65 69 67 68 74 3a 62 6f 6c 64 3b 20 62 61     -weight:bold; ba
     f98:	63 6b 67 72 6f 75 6e 64 2d 63 6f 6c 6f 72 3a 23     ckground-color:#
     fa8:	46 46 46 46 46 46 3b 20 7d 0d 0a 20 20 20 61 3a     FFFFFF; }..   a:
     fb8:	66 6f 63 75 73 20 7b 20 74 65 78 74 2d 64 65 63     focus { text-dec
     fc8:	6f 72 61 74 69 6f 6e 3a 6e 6f 6e 65 3b 20 66 6f     oration:none; fo
     fd8:	6e 74 2d 77 65 69 67 68 74 3a 62 6f 6c 64 3b 20     nt-weight:bold; 
     fe8:	62 61 63 6b 67 72 6f 75 6e 64 2d 63 6f 6c 6f 72     background-color
     ff8:	3a 23 44 44 41 30 44 44 3b 20 7d 0d 0a 00           :#DDA0DD; }...

00001006 <__c.2007>:
    1006:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 44 6f 63     HTTP/1.0 200 Doc
    1016:	75 6d 65 6e 74 20 66 6f 6c 6c 6f 77 73 0d 0a 43     ument follows..C
    1026:	6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a 20 25     ontent-Length: %
    1036:	6c 64 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65     ld..Content-Type
    1046:	3a 20 62 69 6e 0d 0a 43 61 63 68 65 2d 43 6f 6e     : bin..Cache-Con
    1056:	74 72 6f 6c 3a 20 6d 61 78 2d 61 67 65 3d 33 36     trol: max-age=36
    1066:	30 30 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20     00..Connection: 
    1076:	63 6c 6f 73 65 0d 0a 0d 0a 00                       close.....

00001080 <__c.1993>:
    1080:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
    1090:	3a 20 25 64 0d 0a 43 61 63 68 65 2d 43 6f 6e 74     : %d..Cache-Cont
    10a0:	72 6f 6c 3a 20 6d 61 78 2d 61 67 65 3d 33 36 30     rol: max-age=360
    10b0:	30 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63     0..Connection: c
    10c0:	6c 6f 73 65 0d 0a 0d 0a 00                          lose.....

000010c9 <__c.1991>:
    10c9:	62 69 6e 00                                         bin.

000010cd <__c.1988>:
    10cd:	74 65 78 74 2f 68 74 6d 6c 00                       text/html.

000010d7 <__c.1985>:
    10d7:	6a 70 65 67 00                                      jpeg.

000010dc <__c.1981>:
    10dc:	70 6e 67 00                                         png.

000010e0 <__c.1978>:
    10e0:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 44 6f 63     HTTP/1.0 200 Doc
    10f0:	75 6d 65 6e 74 20 66 6f 6c 6c 6f 77 73 0d 0a 43     ument follows..C
    1100:	6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00           ontent-Type: .

0000110e <__c.1931>:
    110e:	3e 20 00                                            > .

00001111 <__c.1926>:
    1111:	0d 0a 00                                            ...

00001114 <__c.1924>:
    1114:	46 6f 6c 67 65 6e 64 65 20 42 65 66 65 68 6c 65     Folgende Befehle
    1124:	20 73 69 6e 64 20 76 6f 72 68 61 6e 64 65 6e 3a      sind vorhanden:
    1134:	0d 0a 0d 0a 00                                      .....

00001139 <__c.1922>:
    1139:	68 65 6c 70 00                                      help.

0000113e <__c.1920>:
    113e:	56 65 72 62 69 6e 64 75 6e 67 20 77 69 72 64 20     Verbindung wird 
    114e:	67 65 73 63 68 6c 6f 73 73 65 6e 0d 0a 00           geschlossen...

0000115c <__c.1918>:
    115c:	71 75 69 74 00                                      quit.

00001161 <__c.1913>:
    1161:	57 65 6c 63 6f 6d 65 20 6f 6e 20 54 69 6e 79 2d     Welcome on Tiny-
    1171:	54 65 6c 6e 65 74 73 65 72 76 65 72 20 30 2e 32     Telnetserver 0.2
    1181:	21 0d 0a 55 6e 64 2c 20 6c 6f 73 20 67 65 68 74     !..Und, los geht
    1191:	27 73 2e 2e 2e 21 21 21 20 28 22 68 65 6c 70 22     's...!!! ("help"
    11a1:	20 68 69 6c 66 74 20 3a 2d 29 29 0d 0a 3e 20 00      hilft :-))..> .

000011b1 <__c.1891>:
    11b1:	74 65 6c 6e 65 74 00                                telnet.

000011b8 <__c.1886>:
    11b8:	54 65 6c 6e 65 74 2d 53 65 72 76 65 72 20 67 65     Telnet-Server ge
    11c8:	73 74 61 72 74 65 74 20 61 75 66 20 50 6f 72 74     startet auf Port
    11d8:	20 25 64 2e 0d 0a 00                                 %d....

000011df <entrystring>:
    11df:	43 52 4f 4e 5f 45 4e 54 52 59 5f 25 30 32 64 00     CRON_ENTRY_%02d.

000011ef <__c.2010>:
    11ef:	25 64 3a 20 6e 69 63 68 74 20 67 65 6c 65 67 74     %d: nicht gelegt
    11ff:	0d 0a 00                                            ...

00001202 <__c.2008>:
    1202:	25 64 3a 20 25 64 20 25 64 20 25 73 0d 0a 00        %d: %d %d %s...

00001211 <__c.1905>:
    1211:	63 72 6f 6e 00                                      cron.

00001216 <__c.2332>:
    1216:	69 6e 20 25 6c 64 20 50 61 63 6b 65 74 65 6e 20     in %ld Packeten 
    1226:	3b 20 44 75 20 62 69 73 74 20 64 65 72 20 25 64     ; Du bist der %d
    1236:	2e 20 42 65 73 75 63 68 65 72 20 61 75 66 20 53     . Besucher auf S
    1246:	6f 63 6b 65 74 20 25 64 2e 3c 2f 42 4f 44 59 3e     ocket %d.</BODY>
    1256:	3c 2f 48 54 4d 4c 3e 0d 0a 0d 0a 00                 </HTML>.....

00001262 <__c.2330>:
    1262:	20 25 6c 64 2e 25 30 33 6c 64 20 47 42 79 74 65      %ld.%03ld GByte
    1272:	73 20 00                                            s .

00001275 <__c.2328>:
    1275:	20 25 6c 64 2e 25 30 33 6c 64 20 4d 42 79 74 65      %ld.%03ld MByte
    1285:	73 20 00                                            s .

00001288 <__c.2326>:
    1288:	20 25 6c 64 20 6b 42 79 74 65 73 20 00               %ld kBytes .

00001295 <__c.2324>:
    1295:	20 25 6c 64 20 42 79 74 65 73 20 00                  %ld Bytes .

000012a1 <__c.2322>:
    12a1:	2c 20 45 74 68 65 72 6e 65 74 3a 00                 , Ethernet:.

000012ad <__c.2320>:
    12ad:	25 6c 64 20 73 65 6b 00                             %ld sek.

000012b5 <__c.2318>:
    12b5:	25 6c 64 20 6d 69 6e 20 00                          %ld min .

000012be <__c.2316>:
    12be:	25 6c 64 20 73 74 64 20 00                          %ld std .

000012c7 <__c.2314>:
    12c7:	25 6c 64 20 74 61 67 65 20 00                       %ld tage .

000012d1 <__c.2312>:
    12d1:	25 6c 64 20 74 61 67 20 00                          %ld tag .

000012da <__c.2310>:
    12da:	3c 48 54 4d 4c 3e 3c 48 45 41 44 3e 3c 6d 65 74     <HTML><HEAD><met
    12ea:	61 20 68 74 74 70 2d 65 71 75 69 76 3d 22 72 65     a http-equiv="re
    12fa:	66 72 65 73 68 22 20 63 6f 6e 74 65 6e 74 3d 22     fresh" content="
    130a:	36 30 30 3b 20 22 3e 3c 54 49 54 4c 45 3e 53 74     600; "><TITLE>St
    131a:	72 65 61 6d 69 6e 67 3c 2f 54 49 54 4c 45 3e 3c     reaming</TITLE><
    132a:	2f 48 45 41 44 3e 3c 42 4f 44 59 20 62 67 63 6f     /HEAD><BODY bgco
    133a:	6c 6f 72 3d 22 23 32 32 38 42 32 32 22 20 74 65     lor="#228B22" te
    134a:	78 74 3d 22 23 46 46 46 46 46 46 22 3e 5a 65 69     xt="#FFFFFF">Zei
    135a:	74 3a 20 25 30 32 64 3a 25 30 32 64 3a 25 30 32     t: %02d:%02d:%02
    136a:	64 2e 25 30 32 64 20 28 20 25 75 2f 25 75 2f 25     d.%02d ( %u/%u/%
    137a:	30 34 75 20 29 2c 20 55 70 74 69 6d 65 3a 20 00     04u ), Uptime: .

0000138a <__c.2292>:
    138a:	50 48 53 54 41 54 32 20 7c 20 30 78 25 30 34 58     PHSTAT2 | 0x%04X
    139a:	0d 0a 00                                            ...

0000139d <__c.2290>:
    139d:	50 48 53 54 41 54 31 20 7c 20 30 78 25 30 34 58     PHSTAT1 | 0x%04X
    13ad:	0d 0a 00                                            ...

000013b0 <__c.2288>:
    13b0:	52 65 76 2e 49 44 20 20 7c 20 20 20 30 78 25 30     Rev.ID  |   0x%0
    13c0:	32 58 0d 0a 00                                      2X...

000013c5 <__c.2286>:
    13c5:	2d 2d 2d 2d 2d 2d 2d 2d 2b 2d 2d 2d 2d 2d 2d 2d     --------+-------
    13d5:	2d 0d 0a 00                                         -...

000013d9 <__c.2284>:
    13d9:	52 65 67 2e 20 20 20 20 7c 20 57 65 72 74 0d 0a     Reg.    | Wert..
	...

000013ea <__c.2282>:
    13ea:	45 4e 43 32 38 4a 36 30 3a 0d 0a 00                 ENC28J60:...

000013f6 <__c.2280>:
    13f6:	54 43 50 2d 54 58 20 45 72 72 6f 72 73 3a 20 25     TCP-TX Errors: %
    1406:	64 20 54 43 50 2d 52 58 20 45 72 72 6f 72 73 3a     d TCP-RX Errors:
    1416:	20 25 64 20 28 75 6e 73 6f 72 74 65 64 20 25 64      %d (unsorted %d
    1426:	2c 20 6f 6c 64 73 65 71 20 25 64 29 0d 0a 0d 0a     , oldseq %d)....
	...

00001437 <__c.2278>:
    1437:	45 74 68 65 72 6e 65 74 3a 20 25 6c 64 20 42 79     Ethernet: %ld By
    1447:	74 65 73 20 69 6e 20 25 6c 64 20 50 61 63 6b 65     tes in %ld Packe
    1457:	74 65 6e 0d 0a 00                                   ten...

0000145d <__c.2269>:
    145d:	73 74 61 74 73 2e 63 67 69 00                       stats.cgi.

00001467 <__c.2267>:
    1467:	73 74 61 74 73 00                                   stats.

0000146d <__c.2131>:
    146d:	52 65 73 65 74 3c 2f 42 4f 44 59 3e 3c 2f 48 54     Reset</BODY></HT
    147d:	4d 4c 3e 0d 0a 0d 0a 00                             ML>.....

00001485 <__c.2129>:
    1485:	72 65 73 65 74 00                                   reset.

0000148b <__c.2127>:
    148b:	72 65 73 65 74 00                                   reset.

00001491 <__c.2125>:
    1491:	72 65 73 65 74 00                                   reset.

00001497 <__c.2123>:
    1497:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 22 72 65     <form action="re
    14a7:	73 65 74 2e 63 67 69 22 20 6d 65 74 68 6f 64 3d     set.cgi" method=
    14b7:	22 67 65 74 22 20 61 63 63 65 70 74 2d 63 68 61     "get" accept-cha
    14c7:	72 73 65 74 3d 22 49 53 4f 2d 38 38 35 39 2d 31     rset="ISO-8859-1
    14d7:	22 3e 3c 70 3e 3c 69 6e 70 75 74 20 74 79 70 65     "><p><input type
    14e7:	3d 22 73 75 62 6d 69 74 22 20 6e 61 6d 65 3d 22     ="submit" name="
    14f7:	72 65 73 65 74 22 20 76 61 6c 75 65 3d 22 72 65     reset" value="re
    1507:	73 65 74 22 3e 3c 2f 70 3e 3c 2f 66 6f 72 6d 3e     set"></p></form>
    1517:	3c 2f 42 4f 44 59 3e 3c 2f 48 54 4d 4c 3e 0d 0a     </BODY></HTML>..
    1527:	0d 0a 00                                            ...

0000152a <__c.2113>:
    152a:	72 65 73 65 74 2e 63 67 69 00                       reset.cgi.

00001534 <__c.2111>:
    1534:	72 65 73 65 74 00                                   reset.

0000153a <__c.2085>:
    153a:	64 6e 73 20 3c 68 6f 73 74 6e 61 6d 65 3e 0d 0a     dns <hostname>..
	...

0000154b <__c.2083>:
    154b:	49 50 20 7a 75 20 25 73 20 3d 20 25 73 0d 0a 00     IP zu %s = %s...

0000155b <__c.2075>:
    155b:	64 6e 73 00                                         dns.

0000155f <__c.2276>:
    155f:	45 69 6e 73 74 65 6c 6c 75 6e 67 65 6e 20 75 65     Einstellungen ue
    156f:	62 65 72 6e 6f 6d 6d 65 6e 21 0d 0a 00              bernommen!...

0000157c <__c.2274>:
    157c:	45 54 48 5f 46 4c 44 58 00                          ETH_FLDX.

00001585 <__c.2272>:
    1585:	45 54 48 5f 46 4c 44 58 00                          ETH_FLDX.

0000158e <__c.2270>:
    158e:	45 54 48 5f 46 4c 44 58 00                          ETH_FLDX.

00001597 <__c.2268>:
    1597:	45 54 48 5f 46 4c 44 58 00                          ETH_FLDX.

000015a0 <__c.2266>:
    15a0:	4d 41 43 00                                         MAC.

000015a4 <__c.2264>:
    15a4:	4d 41 43 00                                         MAC.

000015a8 <__c.2262>:
    15a8:	4d 41 43 00                                         MAC.

000015ac <__c.2260>:
    15ac:	44 4e 53 00                                         DNS.

000015b0 <__c.2258>:
    15b0:	44 4e 53 00                                         DNS.

000015b4 <__c.2256>:
    15b4:	44 4e 53 00                                         DNS.

000015b8 <__c.2254>:
    15b8:	47 41 54 45 00                                      GATE.

000015bd <__c.2252>:
    15bd:	47 41 54 45 00                                      GATE.

000015c2 <__c.2250>:
    15c2:	47 41 54 45 00                                      GATE.

000015c7 <__c.2248>:
    15c7:	4d 41 53 4b 00                                      MASK.

000015cc <__c.2246>:
    15cc:	4d 41 53 4b 00                                      MASK.

000015d1 <__c.2244>:
    15d1:	4d 41 53 4b 00                                      MASK.

000015d6 <__c.2242>:
    15d6:	49 50 00                                            IP.

000015d9 <__c.2240>:
    15d9:	49 50 00                                            IP.

000015dc <__c.2238>:
    15dc:	49 50 00                                            IP.

000015df <__c.2236>:
    15df:	20 20 3c 74 72 3e 0d 20 20 20 3c 74 64 20 61 6c       <tr>.   <td al
    15ef:	69 67 6e 3d 22 72 69 67 68 74 22 3e 48 61 72 64     ign="right">Hard
    15ff:	77 61 72 65 2d 4d 41 43 3c 2f 74 64 3e 20 20 20     ware-MAC</td>   
    160f:	3c 74 64 3e 3c 69 6e 70 75 74 20 6e 61 6d 65 3d     <td><input name=
    161f:	22 4d 41 43 22 20 74 79 70 65 3d 22 74 65 78 74     "MAC" type="text
    162f:	22 20 73 69 7a 65 3d 22 31 37 22 20 76 61 6c 75     " size="17" valu
    163f:	65 3d 22 25 73 22 20 6d 61 78 6c 65 6e 67 74 68     e="%s" maxlength
    164f:	3d 22 31 37 22 3e 3c 2f 74 64 3e 20 20 3c 2f 74     ="17"></td>  </t
    165f:	72 3e 0d 20 20 3c 74 72 3e 0d 20 20 20 3c 74 64     r>.  <tr>.   <td
    166f:	3e 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75 74     ></td><td><input
    167f:	20 74 79 70 65 3d 22 73 75 62 6d 69 74 22 20 76      type="submit" v
    168f:	61 6c 75 65 3d 22 20 45 69 6e 73 74 65 6c 6c 75     alue=" Einstellu
    169f:	6e 67 20 26 55 75 6d 6c 3b 62 65 72 6e 65 68 6d     ng &Uuml;bernehm
    16af:	65 6e 20 22 3e 3c 2f 74 64 3e 20 20 3c 2f 74 72     en "></td>  </tr
    16bf:	3e 0d 20 3c 2f 74 61 62 6c 65 3e 0d 3c 2f 66 6f     >. </table>.</fo
    16cf:	72 6d 3e 00                                         rm>.

000016d3 <__c.2234>:
    16d3:	4d 41 43 00                                         MAC.

000016d7 <__c.2232>:
    16d7:	3e 3c 2f 74 64 3e 0d 20 20 3c 2f 74 72 3e 0d 00     ></td>.  </tr>..

000016e7 <__c.2230>:
    16e7:	63 68 65 63 6b 65 64 00                             checked.

000016ef <__c.2228>:
    16ef:	6f 6e 00                                            on.

000016f2 <__c.2226>:
    16f2:	20 20 3c 74 72 3e 0d 20 20 20 3c 74 64 20 61 6c       <tr>.   <td al
    1702:	69 67 6e 3d 22 72 69 67 68 74 22 3e 46 75 6c 6c     ign="right">Full
    1712:	64 75 70 6c 65 78 20 61 6b 74 69 76 69 65 72 65     duplex aktiviere
    1722:	6e 3c 2f 74 64 3e 20 20 20 3c 74 64 3e 3c 69 6e     n</td>   <td><in
    1732:	70 75 74 20 74 79 70 65 3d 22 63 68 65 63 6b 62     put type="checkb
    1742:	6f 78 22 20 6e 61 6d 65 3d 22 45 54 48 5f 46 4c     ox" name="ETH_FL
    1752:	44 58 22 20 76 61 6c 75 65 3d 22 6f 6e 22 20 00     DX" value="on" .

00001762 <__c.2224>:
    1762:	45 54 48 5f 46 4c 44 58 00                          ETH_FLDX.

0000176b <__c.2222>:
    176b:	20 20 3c 74 72 3e 0d 20 20 20 3c 74 64 20 61 6c       <tr>.   <td al
    177b:	69 67 6e 3d 22 72 69 67 68 74 22 3e 44 4e 53 2d     ign="right">DNS-
    178b:	53 65 72 76 65 72 3c 2f 74 64 3e 20 20 20 3c 74     Server</td>   <t
    179b:	64 3e 3c 69 6e 70 75 74 20 6e 61 6d 65 3d 22 44     d><input name="D
    17ab:	4e 53 22 20 74 79 70 65 3d 22 74 65 78 74 22 20     NS" type="text" 
    17bb:	73 69 7a 65 3d 22 31 35 22 20 76 61 6c 75 65 3d     size="15" value=
    17cb:	22 25 73 22 20 6d 61 78 6c 65 6e 67 74 68 3d 22     "%s" maxlength="
    17db:	31 35 22 3e 3c 2f 74 64 3e 20 20 3c 2f 74 72 3e     15"></td>  </tr>
    17eb:	0d 00                                               ..

000017ed <__c.2220>:
    17ed:	44 4e 53 00                                         DNS.

000017f1 <__c.2218>:
    17f1:	20 20 3c 74 72 3e 0d 20 20 20 3c 74 64 20 61 6c       <tr>.   <td al
    1801:	69 67 6e 3d 22 72 69 67 68 74 22 3e 47 61 74 65     ign="right">Gate
    1811:	77 61 79 3c 2f 74 64 3e 20 20 20 3c 74 64 3e 3c     way</td>   <td><
    1821:	69 6e 70 75 74 20 6e 61 6d 65 3d 22 47 41 54 45     input name="GATE
    1831:	22 20 74 79 70 65 3d 22 74 65 78 74 22 20 73 69     " type="text" si
    1841:	7a 65 3d 22 31 35 22 20 76 61 6c 75 65 3d 22 25     ze="15" value="%
    1851:	73 22 20 6d 61 78 6c 65 6e 67 74 68 3d 22 31 35     s" maxlength="15
    1861:	22 3e 3c 2f 74 64 3e 20 20 3c 2f 74 72 3e 0d 00     "></td>  </tr>..

00001871 <__c.2216>:
    1871:	47 41 54 45 00                                      GATE.

00001876 <__c.2214>:
    1876:	20 20 3c 74 72 3e 0d 20 20 20 3c 74 64 20 61 6c       <tr>.   <td al
    1886:	69 67 6e 3d 22 72 69 67 68 74 22 3e 4e 65 74 7a     ign="right">Netz
    1896:	77 65 72 6b 6d 61 73 6b 65 3c 2f 74 64 3e 20 20     werkmaske</td>  
    18a6:	20 3c 74 64 3e 3c 69 6e 70 75 74 20 6e 61 6d 65      <td><input name
    18b6:	3d 22 4d 41 53 4b 22 20 74 79 70 65 3d 22 74 65     ="MASK" type="te
    18c6:	78 74 22 20 73 69 7a 65 3d 22 31 35 22 20 76 61     xt" size="15" va
    18d6:	6c 75 65 3d 22 25 73 22 20 6d 61 78 6c 65 6e 67     lue="%s" maxleng
    18e6:	74 68 3d 22 31 35 22 3e 3c 2f 74 64 3e 20 20 3c     th="15"></td>  <
    18f6:	2f 74 72 3e 0d 00                                   /tr>..

000018fc <__c.2212>:
    18fc:	4d 41 53 4b 00                                      MASK.

00001901 <__c.2210>:
    1901:	20 20 3c 74 72 3e 0d 20 20 20 3c 74 64 20 61 6c       <tr>.   <td al
    1911:	69 67 6e 3d 22 72 69 67 68 74 22 3e 49 50 2d 41     ign="right">IP-A
    1921:	64 72 65 73 73 65 3c 2f 74 64 3e 20 20 20 3c 74     dresse</td>   <t
    1931:	64 3e 3c 69 6e 70 75 74 20 6e 61 6d 65 3d 22 49     d><input name="I
    1941:	50 22 20 74 79 70 65 3d 22 74 65 78 74 22 20 73     P" type="text" s
    1951:	69 7a 65 3d 22 31 35 22 20 76 61 6c 75 65 3d 22     ize="15" value="
    1961:	25 73 22 20 6d 61 78 6c 65 6e 67 74 68 3d 22 31     %s" maxlength="1
    1971:	35 22 3e 3c 2f 74 64 3e 20 20 3c 2f 74 72 3e 0d     5"></td>  </tr>.
	...

00001982 <__c.2208>:
    1982:	49 50 00                                            IP.

00001985 <__c.2206>:
    1985:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 22 6e 65     <form action="ne
    1995:	74 77 6f 72 6b 2e 63 67 69 22 3e 0d 20 3c 74 61     twork.cgi">. <ta
    19a5:	62 6c 65 20 62 6f 72 64 65 72 3d 22 30 22 20 63     ble border="0" c
    19b5:	65 6c 6c 70 61 64 64 69 6e 67 3d 22 35 22 20 63     ellpadding="5" c
    19c5:	65 6c 6c 73 70 61 63 69 6e 67 3d 22 30 22 3e 00     ellspacing="0">.

000019d5 <__c.2204>:
    19d5:	63 6f 6e 66 69 67 00                                config.

000019dc <__c.2202>:
    19dc:	3c 2f 70 72 65 3e 0d 0a 00                          </pre>...

000019e5 <__c.2200>:
    19e5:	73 74 61 74 73 00                                   stats.

000019eb <__c.2198>:
    19eb:	69 66 63 6f 6e 66 69 67 00                          ifconfig.

000019f4 <__c.2196>:
    19f4:	3c 70 72 65 3e 0d 0a 00                             <pre>...

000019fc <__c.2169>:
    19fc:	0d 0a 48 57 2d 41 64 72 3a 20 25 30 32 78 3a 25     ..HW-Adr: %02x:%
    1a0c:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25 30     02x:%02x:%02x:%0
    1a1c:	32 78 3a 25 30 32 78 0d 0a 0d 0a 00                 2x:%02x.....

00001a28 <__c.2167>:
    1a28:	44 4e 53 3a 20 20 20 20 20 20 20 25 73 0d 0a 00     DNS:       %s...

00001a38 <__c.2165>:
    1a38:	47 61 74 65 77 61 79 3a 20 20 20 25 73 0d 0a 00     Gateway:   %s...

00001a48 <__c.2163>:
    1a48:	4e 65 74 6d 61 73 6b 3a 20 20 20 25 73 0d 0a 00     Netmask:   %s...

00001a58 <__c.2161>:
    1a58:	49 50 3a 20 20 20 20 20 20 20 20 25 73 0d 0a 00     IP:        %s...

00001a68 <__c.2154>:
    1a68:	6e 65 74 77 6f 72 6b 2e 63 67 69 00                 network.cgi.

00001a74 <__c.2152>:
    1a74:	69 66 63 6f 6e 66 69 67 00                          ifconfig.

00001a7d <__c.2296>:
    1a7d:	45 69 6e 73 74 65 6c 6c 75 6e 67 65 6e 20 75 65     Einstellungen ue
    1a8d:	62 65 72 6e 6f 6d 6d 65 6e 21 0d 0a 00              bernommen!...

00001a9a <__c.2294>:
    1a9a:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001aa2 <__c.2292>:
    1aa2:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001aaa <__c.2290>:
    1aaa:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001ab2 <__c.2288>:
    1ab2:	4e 54 50 53 45 52 56 45 52 00                       NTPSERVER.

00001abc <__c.2286>:
    1abc:	4e 54 50 53 45 52 56 45 52 00                       NTPSERVER.

00001ac6 <__c.2284>:
    1ac6:	4e 54 50 53 45 52 56 45 52 00                       NTPSERVER.

00001ad0 <__c.2282>:
    1ad0:	4e 54 50 00                                         NTP.

00001ad4 <__c.2280>:
    1ad4:	4e 54 50 00                                         NTP.

00001ad8 <__c.2278>:
    1ad8:	4e 54 50 00                                         NTP.

00001adc <__c.2276>:
    1adc:	4e 54 50 00                                         NTP.

00001ae0 <__c.2274>:
    1ae0:	3c 74 72 3e 3c 74 64 20 61 6c 69 67 6e 3d 22 72     <tr><td align="r
    1af0:	69 67 68 74 22 3e 53 4e 54 50 2d 53 65 72 76 65     ight">SNTP-Serve
    1b00:	72 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75 74     r</td><td><input
    1b10:	20 6e 61 6d 65 3d 22 4e 54 50 53 45 52 56 45 52      name="NTPSERVER
    1b20:	22 20 74 79 70 65 3d 22 74 65 78 74 22 20 73 69     " type="text" si
    1b30:	7a 65 3d 22 32 35 22 20 76 61 6c 75 65 3d 22 25     ze="25" value="%
    1b40:	73 22 20 6d 61 78 6c 65 6e 67 74 68 3d 22 32 35     s" maxlength="25
    1b50:	22 3e 3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 3e     "></td></tr><tr>
    1b60:	3c 74 64 20 61 6c 69 67 6e 3d 22 72 69 67 68 74     <td align="right
    1b70:	22 3e 5a 65 69 74 7a 6f 6e 65 3c 2f 74 64 3e 3c     ">Zeitzone</td><
    1b80:	74 64 3e 3c 69 6e 70 75 74 20 6e 61 6d 65 3d 22     td><input name="
    1b90:	55 54 43 5a 4f 4e 45 22 20 74 79 70 65 3d 22 74     UTCZONE" type="t
    1ba0:	65 78 74 22 20 73 69 7a 65 3d 22 33 22 20 76 61     ext" size="3" va
    1bb0:	6c 75 65 3d 22 25 73 22 20 6d 61 78 6c 65 6e 67     lue="%s" maxleng
    1bc0:	74 68 3d 22 33 22 3e 3c 2f 74 64 3e 3c 2f 74 72     th="3"></td></tr
    1bd0:	3e 3c 74 72 3e 3c 74 64 3e 3c 2f 74 64 3e 3c 74     ><tr><td></td><t
    1be0:	64 3e 3c 69 6e 70 75 74 20 74 79 70 65 3d 22 73     d><input type="s
    1bf0:	75 62 6d 69 74 22 20 76 61 6c 75 65 3d 22 20 45     ubmit" value=" E
    1c00:	69 6e 73 74 65 6c 6c 75 6e 67 20 26 55 75 6d 6c     instellung &Uuml
    1c10:	3b 62 65 72 6e 65 68 6d 65 6e 20 22 3e 3c 2f 74     ;bernehmen "></t
    1c20:	64 3e 3c 2f 74 72 3e 3c 2f 74 61 62 6c 65 3e 3c     d></tr></table><
    1c30:	2f 66 6f 72 6d 3e 00                                /form>.

00001c37 <__c.2272>:
    1c37:	30 00                                               0.

00001c39 <__c.2270>:
    1c39:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001c41 <__c.2268>:
    1c41:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001c49 <__c.2266>:
    1c49:	74 69 6d 65 2e 66 75 2d 62 65 72 6c 69 6e 2e 64     time.fu-berlin.d
    1c59:	65 00                                               e.

00001c5b <__c.2264>:
    1c5b:	4e 54 50 53 45 52 56 45 52 00                       NTPSERVER.

00001c65 <__c.2262>:
    1c65:	4e 54 50 00                                         NTP.

00001c69 <__c.2260>:
    1c69:	3e 3c 2f 74 64 3e 3c 2f 74 72 3e 00                 ></td></tr>.

00001c75 <__c.2258>:
    1c75:	63 68 65 63 6b 65 64 00                             checked.

00001c7d <__c.2256>:
    1c7d:	6f 6e 00                                            on.

00001c80 <__c.2254>:
    1c80:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 22 6e 74     <form action="nt
    1c90:	70 2e 63 67 69 22 3e 0d 3c 74 61 62 6c 65 20 62     p.cgi">.<table b
    1ca0:	6f 72 64 65 72 3d 22 30 22 20 63 65 6c 6c 70 61     order="0" cellpa
    1cb0:	64 64 69 6e 67 3d 22 35 22 20 63 65 6c 6c 73 70     dding="5" cellsp
    1cc0:	61 63 69 6e 67 3d 22 30 22 3e 3c 74 72 3e 3c 74     acing="0"><tr><t
    1cd0:	64 20 61 6c 69 67 6e 3d 22 72 69 67 68 74 22 3e     d align="right">
    1ce0:	53 4e 54 50 20 61 6b 74 69 76 69 65 72 65 6e 3c     SNTP aktivieren<
    1cf0:	2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75 74 20 74     /td><td><input t
    1d00:	79 70 65 3d 22 63 68 65 63 6b 62 6f 78 22 20 6e     ype="checkbox" n
    1d10:	61 6d 65 3d 22 4e 54 50 22 20 76 61 6c 75 65 3d     ame="NTP" value=
    1d20:	22 6f 6e 22 20 00                                   "on" .

00001d26 <__c.2252>:
    1d26:	4e 54 50 00                                         NTP.

00001d2a <__c.2229>:
    1d2a:	6e 74 70 20 3c 6e 74 70 73 65 72 76 65 72 3e 0d     ntp <ntpserver>.
    1d3a:	0a 00                                               ..

00001d3c <__c.2227>:
    1d3c:	46 65 68 6c 65 72 0d 0a 00                          Fehler...

00001d45 <__c.2225>:
    1d45:	4e 65 75 65 20 5a 65 69 74 3a 20 25 30 32 64 3a     Neue Zeit: %02d:
    1d55:	25 30 32 64 3a 25 30 32 64 0d 0a 00                 %02d:%02d...

00001d61 <__c.2223>:
    1d61:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001d69 <__c.2221>:
    1d69:	55 54 43 5a 4f 4e 45 00                             UTCZONE.

00001d71 <__c.2219>:
    1d71:	48 6f 6c 65 20 5a 65 69 74 20 76 6f 6e 20 25 73     Hole Zeit von %s
    1d81:	0d 0a 00                                            ...

00001d84 <__c.2217>:
    1d84:	46 65 68 6c 65 72 0d 0a 00                          Fehler...

00001d8d <__c.2208>:
    1d8d:	6e 74 70 2e 63 67 69 00                             ntp.cgi.

00001d95 <__c.2206>:
    1d95:	6e 74 70 00                                         ntp.

00001d99 <__c.2069>:
    1d99:	44 42 65 6e 74 72 79 3a 20 25 64 20 67 65 6c 65     DBentry: %d gele
    1da9:	73 65 6e 0d 0a 00                                   sen...

00001daf <__c.2067>:
    1daf:	72 65 61 64 00                                      read.

00001db4 <__c.2065>:
    1db4:	44 42 65 6e 74 72 79 3a 20 25 64 20 0d 0a 00        DBentry: %d ...

00001dc3 <__c.2063>:
    1dc3:	67 65 74 00                                         get.

00001dc7 <__c.2061>:
    1dc7:	6d 61 6b 65 00                                      make.

00001dcc <__c.2059>:
    1dcc:	61 64 64 00                                         add.

00001dd0 <__c.2052>:
    1dd0:	74 65 6d 70 00                                      temp.

00001dd5 <__c.2175>:
    1dd5:	64 65 6c 00                                         del.

00001dd9 <__c.2173>:
    1dd9:	64 65 6c 00                                         del.

00001ddd <__c.2171>:
    1ddd:	45 69 6e 73 74 65 6c 6c 75 6e 67 65 6e 20 75 65     Einstellungen ue
    1ded:	62 65 72 6e 6f 6d 6d 65 6e 21 0d 0a 00              bernommen!...

00001dfa <__c.2169>:
    1dfa:	43 4d 44 00                                         CMD.

00001dfe <__c.2167>:
    1dfe:	25 64 20 25 64 20 22 25 73 22 00                    %d %d "%s".

00001e09 <__c.2165>:
    1e09:	4d 4d 00                                            MM.

00001e0c <__c.2163>:
    1e0c:	48 48 00                                            HH.

00001e0f <__c.2161>:
    1e0f:	43 4d 44 00                                         CMD.

00001e13 <__c.2159>:
    1e13:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 22 63 72     <form action="cr
    1e23:	6f 6e 2e 63 67 69 22 3e 3c 74 61 62 6c 65 20 62     on.cgi"><table b
    1e33:	6f 72 64 65 72 3d 22 30 22 20 63 65 6c 6c 70 61     order="0" cellpa
    1e43:	64 64 69 6e 67 3d 22 35 22 20 63 65 6c 6c 73 70     dding="5" cellsp
    1e53:	61 63 69 6e 67 3d 22 30 22 3e 3c 74 72 3e 3c 74     acing="0"><tr><t
    1e63:	64 20 61 6c 69 67 6e 3d 22 72 69 67 68 74 22 3e     d align="right">
    1e73:	53 74 75 6e 64 65 3c 2f 74 64 3e 3c 74 64 3e 3c     Stunde</td><td><
    1e83:	69 6e 70 75 74 20 6e 61 6d 65 3d 22 48 48 22 20     input name="HH" 
    1e93:	74 79 70 65 3d 22 74 65 78 74 22 20 73 69 7a 65     type="text" size
    1ea3:	3d 22 33 22 20 76 61 6c 75 65 3d 22 30 22 6d 61     ="3" value="0"ma
    1eb3:	78 6c 65 6e 67 74 68 3d 22 33 22 3e 3c 2f 74 64     xlength="3"></td
    1ec3:	3e 3c 2f 74 72 3e 3c 74 72 3e 3c 74 64 20 61 6c     ></tr><tr><td al
    1ed3:	69 67 6e 3d 22 72 69 67 68 74 22 3e 4d 69 6e 75     ign="right">Minu
    1ee3:	74 65 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75     te</td><td><inpu
    1ef3:	74 20 6e 61 6d 65 3d 22 4d 4d 22 20 74 79 70 65     t name="MM" type
    1f03:	3d 22 74 65 78 74 22 20 73 69 7a 65 3d 22 33 22     ="text" size="3"
    1f13:	20 76 61 6c 75 65 3d 22 30 22 20 6d 61 78 6c 65      value="0" maxle
    1f23:	6e 67 74 68 3d 22 33 22 3e 3c 2f 74 64 3e 3c 2f     ngth="3"></td></
    1f33:	74 72 3e 3c 74 72 3e 3c 74 64 20 61 6c 69 67 6e     tr><tr><td align
    1f43:	3d 22 72 69 67 68 74 22 3e 43 6f 6d 6d 61 6e 64     ="right">Command
    1f53:	3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75 74 20     </td><td><input 
    1f63:	6e 61 6d 65 3d 22 43 4d 44 22 20 74 79 70 65 3d     name="CMD" type=
    1f73:	22 74 65 78 74 22 20 73 69 7a 65 3d 22 33 30 22     "text" size="30"
    1f83:	20 6d 61 78 6c 65 6e 67 74 68 3d 22 33 30 22 3e      maxlength="30">
    1f93:	3c 2f 74 64 3e 3c 2f 74 72 3e 3c 74 72 3e 3c 74     </td></tr><tr><t
    1fa3:	64 3e 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6e 70 75     d></td><td><inpu
    1fb3:	74 20 74 79 70 65 3d 22 73 75 62 6d 69 74 22 20     t type="submit" 
    1fc3:	76 61 6c 75 65 3d 22 20 45 69 6e 74 72 61 67 20     value=" Eintrag 
    1fd3:	73 69 63 68 65 72 6e 20 22 3e 3c 2f 74 64 3e 3c     sichern "></td><
    1fe3:	2f 74 72 3e 3c 2f 74 61 62 6c 65 3e 3c 2f 66 6f     /tr></table></fo
    1ff3:	72 6d 3e 0d 00                                      rm>..

00001ff8 <__c.2157>:
    1ff8:	61 64 64 6e 65 77 00                                addnew.

00001fff <__c.2155>:
    1fff:	3c 74 72 3e 3c 74 64 20 61 6c 69 67 6e 3d 22 6c     <tr><td align="l
    200f:	65 66 74 22 3e 3c 61 20 68 72 65 66 3d 22 63 72     eft"><a href="cr
    201f:	6f 6e 2e 63 67 69 3f 61 64 64 6e 65 77 22 20 73     on.cgi?addnew" s
    202f:	74 79 6c 65 3d 22 74 65 78 74 2d 64 65 63 6f 72     tyle="text-decor
    203f:	61 74 69 6f 6e 3a 6e 6f 6e 65 22 20 74 69 74 6c     ation:none" titl
    204f:	65 3d 22 41 64 64 22 3e 3c 69 6e 70 75 74 20 74     e="Add"><input t
    205f:	79 70 65 3d 22 62 75 74 74 6f 6e 22 20 76 61 6c     ype="button" val
    206f:	75 65 3d 22 61 64 64 20 6e 65 77 20 63 72 6f 6e     ue="add new cron
    207f:	22 20 63 6c 61 73 73 3d 22 61 63 74 69 6f 6e 42     " class="actionB
    208f:	74 6e 22 3e 3c 2f 61 3e 3c 2f 74 64 3e 3c 2f 74     tn"></a></td></t
    209f:	72 3e 3c 2f 74 61 62 6c 65 3e 0d 00                 r></table>..

000020ab <__c.2150>:
    20ab:	3c 74 72 3e 3c 74 64 20 61 6c 69 67 6e 3d 22 6c     <tr><td align="l
    20bb:	65 66 74 22 3e 25 73 3c 2f 74 64 3e 3c 74 64 20     eft">%s</td><td 
    20cb:	61 6c 69 67 6e 3d 22 6c 65 66 74 22 3e 3c 61 20     align="left"><a 
    20db:	68 72 65 66 3d 22 63 72 6f 6e 2e 63 67 69 3f 64     href="cron.cgi?d
    20eb:	65 6c 3d 25 64 22 20 73 74 79 6c 65 3d 22 74 65     el=%d" style="te
    20fb:	78 74 2d 64 65 63 6f 72 61 74 69 6f 6e 3a 6e 6f     xt-decoration:no
    210b:	6e 65 22 20 74 69 74 6c 65 3d 22 44 65 6c 22 3e     ne" title="Del">
    211b:	3c 69 6e 70 75 74 20 74 79 70 65 3d 22 62 75 74     <input type="but
    212b:	74 6f 6e 22 20 76 61 6c 75 65 3d 22 64 65 6c 22     ton" value="del"
    213b:	20 63 6c 61 73 73 3d 22 61 63 74 69 6f 6e 42 74      class="actionBt
    214b:	6e 22 3e 3c 2f 61 3e 3c 2f 74 64 3e 3c 2f 74 72     n"></a></td></tr
    215b:	3e 00                                               >.

0000215d <__c.2148>:
    215d:	3c 74 61 62 6c 65 20 62 6f 72 64 65 72 3d 22 30     <table border="0
    216d:	22 20 63 65 6c 6c 70 61 64 64 69 6e 67 3d 22 35     " cellpadding="5
    217d:	22 20 63 65 6c 6c 73 70 61 63 69 6e 67 3d 22 30     " cellspacing="0
    218d:	22 3e 00                                            ">.

00002190 <__c.2138>:
    2190:	63 72 6f 6e 2e 63 67 69 00                          cron.cgi.

00002199 <__c.2051>:
    2199:	3c 2f 70 72 65 3e 00                                </pre>.

000021a0 <__c.2049>:
    21a0:	3c 70 72 65 3e 00                                   <pre>.

000021a6 <__c.2037>:
    21a6:	65 65 6d 65 6d 20 3c 70 72 6f 74 65 63 74 3e 7c     eemem <protect>|
    21b6:	3c 75 6e 70 72 6f 74 65 63 74 3e 20 3c 70 72 69     <unprotect> <pri
    21c6:	6e 74 3e 20 3c 63 6c 65 61 6e 3e 0d 0a 00           nt> <clean>...

000021d4 <__c.2035>:
    21d4:	63 6c 65 61 6e 00                                   clean.

000021da <__c.2033>:
    21da:	70 72 69 6e 74 00                                   print.

000021e0 <__c.2031>:
    21e0:	75 6e 70 72 6f 74 65 63 74 65 74 0d 0a 00           unprotectet...

000021ee <__c.2029>:
    21ee:	57 52 49 54 45 5f 50 52 4f 54 45 43 54 00           WRITE_PROTECT.

000021fc <__c.2027>:
    21fc:	4f 46 46 00                                         OFF.

00002200 <__c.2025>:
    2200:	75 6e 70 72 6f 74 65 63 74 00                       unprotect.

0000220a <__c.2023>:
    220a:	57 52 49 54 45 5f 50 52 4f 54 45 43 54 00           WRITE_PROTECT.

00002218 <__c.2021>:
    2218:	4f 4e 00                                            ON.

0000221b <__c.2019>:
    221b:	70 72 6f 74 65 63 74 00                             protect.

00002223 <__c.2011>:
    2223:	65 65 6d 65 6d 2e 63 67 69 00                       eemem.cgi.

0000222d <__c.2009>:
    222d:	65 65 6d 65 6d 00                                   eemem.

00002233 <can_filter>:
    2233:	00 08 10 00 00 08 00 00 00 08 00 00 00 08 00 00     ................
    2243:	00 08 00 00 00 08 00 00 00 08 00 00 ff eb ff ff     ................

00002253 <_mcp2515_cnf>:
    2253:	04 b6 e7 04 b6 d3 04 b6 c7 04 b6 c3 02 90 07 03     ................
    2263:	ac 81 03 ac 80 02 90 00                             ........

0000226b <__c.2017>:
    226b:	63 61 6e 5f 72 65 6c 61 79 00                       can_relay.

00002275 <__c.2015>:
    2275:	43 41 4e 2d 52 65 6c 61 79 2d 53 65 72 76 65 72     CAN-Relay-Server
    2285:	20 67 65 73 74 61 72 74 65 74 20 61 75 66 20 50      gestartet auf P
    2295:	6f 72 74 20 25 64 2e 0d 0a 00 00                    ort %d.....

000022a0 <wdt_init>:
	} while(0);
}

// Function Implementation
void wdt_init(void)
{
    22a0:	14 be       	out	0x34, r1	; 52
    MCUSR = 0;
    wdt_disable();
    22a2:	88 e1       	ldi	r24, 0x18	; 24
    22a4:	0f b6       	in	r0, 0x3f	; 63
    22a6:	f8 94       	cli
    22a8:	80 93 60 00 	sts	0x0060, r24
    22ac:	10 92 60 00 	sts	0x0060, r1
    22b0:	0f be       	out	0x3f, r0	; 63
    22b2:	11 24       	eor	r1, r1
    22b4:	1f be       	out	0x3f, r1	; 63
    22b6:	cf ef       	ldi	r28, 0xFF	; 255
    22b8:	d0 e1       	ldi	r29, 0x10	; 16
    22ba:	de bf       	out	0x3e, r29	; 62
    22bc:	cd bf       	out	0x3d, r28	; 61

000022be <__do_copy_data>:
    22be:	11 e0       	ldi	r17, 0x01	; 1
    22c0:	a0 e0       	ldi	r26, 0x00	; 0
    22c2:	b1 e0       	ldi	r27, 0x01	; 1
    22c4:	ea ef       	ldi	r30, 0xFA	; 250
    22c6:	f5 ed       	ldi	r31, 0xD5	; 213
    22c8:	02 c0       	rjmp	.+4      	; 0x22ce <.do_copy_data_start>

000022ca <.do_copy_data_loop>:
    22ca:	05 90       	lpm	r0, Z+
    22cc:	0d 92       	st	X+, r0

000022ce <.do_copy_data_start>:
    22ce:	a6 3c       	cpi	r26, 0xC6	; 198
    22d0:	b1 07       	cpc	r27, r17
    22d2:	d9 f7       	brne	.-10     	; 0x22ca <.do_copy_data_loop>

000022d4 <__do_clear_bss>:
    22d4:	1b e0       	ldi	r17, 0x0B	; 11
    22d6:	a6 ec       	ldi	r26, 0xC6	; 198
    22d8:	b1 e0       	ldi	r27, 0x01	; 1
    22da:	01 c0       	rjmp	.+2      	; 0x22de <.do_clear_bss_start>

000022dc <.do_clear_bss_loop>:
    22dc:	1d 92       	st	X+, r1

000022de <.do_clear_bss_start>:
    22de:	ad 3f       	cpi	r26, 0xFD	; 253
    22e0:	b1 07       	cpc	r27, r17
    22e2:	e1 f7       	brne	.-8      	; 0x22dc <.do_clear_bss_loop>
    22e4:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <main>
    22e8:	0c 94 fb 6a 	jmp	0xd5f6	; 0xd5f6 <_exit>

000022ec <__bad_interrupt>:
    22ec:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000022f0 <malloc>:
    22f0:	cf 93       	push	r28
    22f2:	df 93       	push	r29
    22f4:	bc 01       	movw	r22, r24
    22f6:	82 30       	cpi	r24, 0x02	; 2
    22f8:	91 05       	cpc	r25, r1
    22fa:	10 f4       	brcc	.+4      	; 0x2300 <malloc+0x10>
    22fc:	62 e0       	ldi	r22, 0x02	; 2
    22fe:	70 e0       	ldi	r23, 0x00	; 0
    2300:	a0 91 f3 0b 	lds	r26, 0x0BF3
    2304:	b0 91 f4 0b 	lds	r27, 0x0BF4
    2308:	ed 01       	movw	r28, r26
    230a:	e0 e0       	ldi	r30, 0x00	; 0
    230c:	f0 e0       	ldi	r31, 0x00	; 0
    230e:	40 e0       	ldi	r20, 0x00	; 0
    2310:	50 e0       	ldi	r21, 0x00	; 0
    2312:	21 c0       	rjmp	.+66     	; 0x2356 <malloc+0x66>
    2314:	88 81       	ld	r24, Y
    2316:	99 81       	ldd	r25, Y+1	; 0x01
    2318:	86 17       	cp	r24, r22
    231a:	97 07       	cpc	r25, r23
    231c:	69 f4       	brne	.+26     	; 0x2338 <malloc+0x48>
    231e:	8a 81       	ldd	r24, Y+2	; 0x02
    2320:	9b 81       	ldd	r25, Y+3	; 0x03
    2322:	30 97       	sbiw	r30, 0x00	; 0
    2324:	19 f0       	breq	.+6      	; 0x232c <malloc+0x3c>
    2326:	93 83       	std	Z+3, r25	; 0x03
    2328:	82 83       	std	Z+2, r24	; 0x02
    232a:	04 c0       	rjmp	.+8      	; 0x2334 <malloc+0x44>
    232c:	90 93 f4 0b 	sts	0x0BF4, r25
    2330:	80 93 f3 0b 	sts	0x0BF3, r24
    2334:	fe 01       	movw	r30, r28
    2336:	34 c0       	rjmp	.+104    	; 0x23a0 <malloc+0xb0>
    2338:	68 17       	cp	r22, r24
    233a:	79 07       	cpc	r23, r25
    233c:	38 f4       	brcc	.+14     	; 0x234c <malloc+0x5c>
    233e:	41 15       	cp	r20, r1
    2340:	51 05       	cpc	r21, r1
    2342:	19 f0       	breq	.+6      	; 0x234a <malloc+0x5a>
    2344:	84 17       	cp	r24, r20
    2346:	95 07       	cpc	r25, r21
    2348:	08 f4       	brcc	.+2      	; 0x234c <malloc+0x5c>
    234a:	ac 01       	movw	r20, r24
    234c:	fe 01       	movw	r30, r28
    234e:	8a 81       	ldd	r24, Y+2	; 0x02
    2350:	9b 81       	ldd	r25, Y+3	; 0x03
    2352:	9c 01       	movw	r18, r24
    2354:	e9 01       	movw	r28, r18
    2356:	20 97       	sbiw	r28, 0x00	; 0
    2358:	e9 f6       	brne	.-70     	; 0x2314 <malloc+0x24>
    235a:	41 15       	cp	r20, r1
    235c:	51 05       	cpc	r21, r1
    235e:	a9 f1       	breq	.+106    	; 0x23ca <malloc+0xda>
    2360:	ca 01       	movw	r24, r20
    2362:	86 1b       	sub	r24, r22
    2364:	97 0b       	sbc	r25, r23
    2366:	04 97       	sbiw	r24, 0x04	; 4
    2368:	08 f4       	brcc	.+2      	; 0x236c <malloc+0x7c>
    236a:	ba 01       	movw	r22, r20
    236c:	e0 e0       	ldi	r30, 0x00	; 0
    236e:	f0 e0       	ldi	r31, 0x00	; 0
    2370:	2a c0       	rjmp	.+84     	; 0x23c6 <malloc+0xd6>
    2372:	8d 91       	ld	r24, X+
    2374:	9c 91       	ld	r25, X
    2376:	11 97       	sbiw	r26, 0x01	; 1
    2378:	84 17       	cp	r24, r20
    237a:	95 07       	cpc	r25, r21
    237c:	f9 f4       	brne	.+62     	; 0x23bc <malloc+0xcc>
    237e:	64 17       	cp	r22, r20
    2380:	75 07       	cpc	r23, r21
    2382:	81 f4       	brne	.+32     	; 0x23a4 <malloc+0xb4>
    2384:	12 96       	adiw	r26, 0x02	; 2
    2386:	8d 91       	ld	r24, X+
    2388:	9c 91       	ld	r25, X
    238a:	13 97       	sbiw	r26, 0x03	; 3
    238c:	30 97       	sbiw	r30, 0x00	; 0
    238e:	19 f0       	breq	.+6      	; 0x2396 <malloc+0xa6>
    2390:	93 83       	std	Z+3, r25	; 0x03
    2392:	82 83       	std	Z+2, r24	; 0x02
    2394:	04 c0       	rjmp	.+8      	; 0x239e <malloc+0xae>
    2396:	90 93 f4 0b 	sts	0x0BF4, r25
    239a:	80 93 f3 0b 	sts	0x0BF3, r24
    239e:	fd 01       	movw	r30, r26
    23a0:	32 96       	adiw	r30, 0x02	; 2
    23a2:	4c c0       	rjmp	.+152    	; 0x243c <malloc+0x14c>
    23a4:	ca 01       	movw	r24, r20
    23a6:	86 1b       	sub	r24, r22
    23a8:	97 0b       	sbc	r25, r23
    23aa:	fd 01       	movw	r30, r26
    23ac:	e8 0f       	add	r30, r24
    23ae:	f9 1f       	adc	r31, r25
    23b0:	61 93       	st	Z+, r22
    23b2:	71 93       	st	Z+, r23
    23b4:	02 97       	sbiw	r24, 0x02	; 2
    23b6:	8d 93       	st	X+, r24
    23b8:	9c 93       	st	X, r25
    23ba:	40 c0       	rjmp	.+128    	; 0x243c <malloc+0x14c>
    23bc:	fd 01       	movw	r30, r26
    23be:	82 81       	ldd	r24, Z+2	; 0x02
    23c0:	93 81       	ldd	r25, Z+3	; 0x03
    23c2:	9c 01       	movw	r18, r24
    23c4:	d9 01       	movw	r26, r18
    23c6:	10 97       	sbiw	r26, 0x00	; 0
    23c8:	a1 f6       	brne	.-88     	; 0x2372 <malloc+0x82>
    23ca:	80 91 f1 0b 	lds	r24, 0x0BF1
    23ce:	90 91 f2 0b 	lds	r25, 0x0BF2
    23d2:	89 2b       	or	r24, r25
    23d4:	41 f4       	brne	.+16     	; 0x23e6 <malloc+0xf6>
    23d6:	80 91 35 01 	lds	r24, 0x0135
    23da:	90 91 36 01 	lds	r25, 0x0136
    23de:	90 93 f2 0b 	sts	0x0BF2, r25
    23e2:	80 93 f1 0b 	sts	0x0BF1, r24
    23e6:	40 91 37 01 	lds	r20, 0x0137
    23ea:	50 91 38 01 	lds	r21, 0x0138
    23ee:	41 15       	cp	r20, r1
    23f0:	51 05       	cpc	r21, r1
    23f2:	41 f4       	brne	.+16     	; 0x2404 <malloc+0x114>
    23f4:	4d b7       	in	r20, 0x3d	; 61
    23f6:	5e b7       	in	r21, 0x3e	; 62
    23f8:	80 91 33 01 	lds	r24, 0x0133
    23fc:	90 91 34 01 	lds	r25, 0x0134
    2400:	48 1b       	sub	r20, r24
    2402:	59 0b       	sbc	r21, r25
    2404:	20 91 f1 0b 	lds	r18, 0x0BF1
    2408:	30 91 f2 0b 	lds	r19, 0x0BF2
    240c:	ca 01       	movw	r24, r20
    240e:	82 1b       	sub	r24, r18
    2410:	93 0b       	sbc	r25, r19
    2412:	86 17       	cp	r24, r22
    2414:	97 07       	cpc	r25, r23
    2416:	80 f0       	brcs	.+32     	; 0x2438 <malloc+0x148>
    2418:	ab 01       	movw	r20, r22
    241a:	4e 5f       	subi	r20, 0xFE	; 254
    241c:	5f 4f       	sbci	r21, 0xFF	; 255
    241e:	84 17       	cp	r24, r20
    2420:	95 07       	cpc	r25, r21
    2422:	50 f0       	brcs	.+20     	; 0x2438 <malloc+0x148>
    2424:	42 0f       	add	r20, r18
    2426:	53 1f       	adc	r21, r19
    2428:	50 93 f2 0b 	sts	0x0BF2, r21
    242c:	40 93 f1 0b 	sts	0x0BF1, r20
    2430:	f9 01       	movw	r30, r18
    2432:	61 93       	st	Z+, r22
    2434:	71 93       	st	Z+, r23
    2436:	02 c0       	rjmp	.+4      	; 0x243c <malloc+0x14c>
    2438:	e0 e0       	ldi	r30, 0x00	; 0
    243a:	f0 e0       	ldi	r31, 0x00	; 0
    243c:	cf 01       	movw	r24, r30
    243e:	df 91       	pop	r29
    2440:	cf 91       	pop	r28
    2442:	08 95       	ret

00002444 <free>:
    2444:	cf 93       	push	r28
    2446:	df 93       	push	r29
    2448:	00 97       	sbiw	r24, 0x00	; 0
    244a:	09 f4       	brne	.+2      	; 0x244e <free+0xa>
    244c:	50 c0       	rjmp	.+160    	; 0x24ee <free+0xaa>
    244e:	ec 01       	movw	r28, r24
    2450:	22 97       	sbiw	r28, 0x02	; 2
    2452:	1b 82       	std	Y+3, r1	; 0x03
    2454:	1a 82       	std	Y+2, r1	; 0x02
    2456:	a0 91 f3 0b 	lds	r26, 0x0BF3
    245a:	b0 91 f4 0b 	lds	r27, 0x0BF4
    245e:	10 97       	sbiw	r26, 0x00	; 0
    2460:	09 f1       	breq	.+66     	; 0x24a4 <free+0x60>
    2462:	40 e0       	ldi	r20, 0x00	; 0
    2464:	50 e0       	ldi	r21, 0x00	; 0
    2466:	ac 17       	cp	r26, r28
    2468:	bd 07       	cpc	r27, r29
    246a:	08 f1       	brcs	.+66     	; 0x24ae <free+0x6a>
    246c:	bb 83       	std	Y+3, r27	; 0x03
    246e:	aa 83       	std	Y+2, r26	; 0x02
    2470:	fe 01       	movw	r30, r28
    2472:	21 91       	ld	r18, Z+
    2474:	31 91       	ld	r19, Z+
    2476:	e2 0f       	add	r30, r18
    2478:	f3 1f       	adc	r31, r19
    247a:	ae 17       	cp	r26, r30
    247c:	bf 07       	cpc	r27, r31
    247e:	79 f4       	brne	.+30     	; 0x249e <free+0x5a>
    2480:	8d 91       	ld	r24, X+
    2482:	9c 91       	ld	r25, X
    2484:	11 97       	sbiw	r26, 0x01	; 1
    2486:	28 0f       	add	r18, r24
    2488:	39 1f       	adc	r19, r25
    248a:	2e 5f       	subi	r18, 0xFE	; 254
    248c:	3f 4f       	sbci	r19, 0xFF	; 255
    248e:	39 83       	std	Y+1, r19	; 0x01
    2490:	28 83       	st	Y, r18
    2492:	12 96       	adiw	r26, 0x02	; 2
    2494:	8d 91       	ld	r24, X+
    2496:	9c 91       	ld	r25, X
    2498:	13 97       	sbiw	r26, 0x03	; 3
    249a:	9b 83       	std	Y+3, r25	; 0x03
    249c:	8a 83       	std	Y+2, r24	; 0x02
    249e:	41 15       	cp	r20, r1
    24a0:	51 05       	cpc	r21, r1
    24a2:	71 f4       	brne	.+28     	; 0x24c0 <free+0x7c>
    24a4:	d0 93 f4 0b 	sts	0x0BF4, r29
    24a8:	c0 93 f3 0b 	sts	0x0BF3, r28
    24ac:	20 c0       	rjmp	.+64     	; 0x24ee <free+0xaa>
    24ae:	12 96       	adiw	r26, 0x02	; 2
    24b0:	8d 91       	ld	r24, X+
    24b2:	9c 91       	ld	r25, X
    24b4:	13 97       	sbiw	r26, 0x03	; 3
    24b6:	ad 01       	movw	r20, r26
    24b8:	00 97       	sbiw	r24, 0x00	; 0
    24ba:	11 f0       	breq	.+4      	; 0x24c0 <free+0x7c>
    24bc:	dc 01       	movw	r26, r24
    24be:	d3 cf       	rjmp	.-90     	; 0x2466 <free+0x22>
    24c0:	fa 01       	movw	r30, r20
    24c2:	d3 83       	std	Z+3, r29	; 0x03
    24c4:	c2 83       	std	Z+2, r28	; 0x02
    24c6:	21 91       	ld	r18, Z+
    24c8:	31 91       	ld	r19, Z+
    24ca:	e2 0f       	add	r30, r18
    24cc:	f3 1f       	adc	r31, r19
    24ce:	ce 17       	cp	r28, r30
    24d0:	df 07       	cpc	r29, r31
    24d2:	69 f4       	brne	.+26     	; 0x24ee <free+0xaa>
    24d4:	88 81       	ld	r24, Y
    24d6:	99 81       	ldd	r25, Y+1	; 0x01
    24d8:	28 0f       	add	r18, r24
    24da:	39 1f       	adc	r19, r25
    24dc:	2e 5f       	subi	r18, 0xFE	; 254
    24de:	3f 4f       	sbci	r19, 0xFF	; 255
    24e0:	fa 01       	movw	r30, r20
    24e2:	31 83       	std	Z+1, r19	; 0x01
    24e4:	20 83       	st	Z, r18
    24e6:	8a 81       	ldd	r24, Y+2	; 0x02
    24e8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ea:	93 83       	std	Z+3, r25	; 0x03
    24ec:	82 83       	std	Z+2, r24	; 0x02
    24ee:	df 91       	pop	r29
    24f0:	cf 91       	pop	r28
    24f2:	08 95       	ret

000024f4 <strtol>:
    24f4:	2f 92       	push	r2
    24f6:	3f 92       	push	r3
    24f8:	5f 92       	push	r5
    24fa:	6f 92       	push	r6
    24fc:	7f 92       	push	r7
    24fe:	8f 92       	push	r8
    2500:	9f 92       	push	r9
    2502:	af 92       	push	r10
    2504:	bf 92       	push	r11
    2506:	cf 92       	push	r12
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	0f 93       	push	r16
    2510:	1f 93       	push	r17
    2512:	cf 93       	push	r28
    2514:	df 93       	push	r29
    2516:	8c 01       	movw	r16, r24
    2518:	1b 01       	movw	r2, r22
    251a:	ea 01       	movw	r28, r20
    251c:	61 15       	cp	r22, r1
    251e:	71 05       	cpc	r23, r1
    2520:	19 f0       	breq	.+6      	; 0x2528 <strtol+0x34>
    2522:	fb 01       	movw	r30, r22
    2524:	91 83       	std	Z+1, r25	; 0x01
    2526:	80 83       	st	Z, r24
    2528:	20 97       	sbiw	r28, 0x00	; 0
    252a:	49 f0       	breq	.+18     	; 0x253e <strtol+0x4a>
    252c:	ce 01       	movw	r24, r28
    252e:	02 97       	sbiw	r24, 0x02	; 2
    2530:	83 97       	sbiw	r24, 0x23	; 35
    2532:	28 f0       	brcs	.+10     	; 0x253e <strtol+0x4a>
    2534:	20 e0       	ldi	r18, 0x00	; 0
    2536:	30 e0       	ldi	r19, 0x00	; 0
    2538:	40 e0       	ldi	r20, 0x00	; 0
    253a:	50 e0       	ldi	r21, 0x00	; 0
    253c:	f6 c0       	rjmp	.+492    	; 0x272a <strtol+0x236>
    253e:	f8 01       	movw	r30, r16
    2540:	a1 90       	ld	r10, Z+
    2542:	8f 01       	movw	r16, r30
    2544:	8a 2d       	mov	r24, r10
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	0e 94 f0 6a 	call	0xd5e0	; 0xd5e0 <isspace>
    254c:	89 2b       	or	r24, r25
    254e:	b9 f7       	brne	.-18     	; 0x253e <strtol+0x4a>
    2550:	fd e2       	ldi	r31, 0x2D	; 45
    2552:	af 16       	cp	r10, r31
    2554:	31 f4       	brne	.+12     	; 0x2562 <strtol+0x6e>
    2556:	f8 01       	movw	r30, r16
    2558:	a1 90       	ld	r10, Z+
    255a:	8f 01       	movw	r16, r30
    255c:	55 24       	eor	r5, r5
    255e:	53 94       	inc	r5
    2560:	07 c0       	rjmp	.+14     	; 0x2570 <strtol+0x7c>
    2562:	fb e2       	ldi	r31, 0x2B	; 43
    2564:	af 16       	cp	r10, r31
    2566:	19 f4       	brne	.+6      	; 0x256e <strtol+0x7a>
    2568:	f8 01       	movw	r30, r16
    256a:	a1 90       	ld	r10, Z+
    256c:	8f 01       	movw	r16, r30
    256e:	55 24       	eor	r5, r5
    2570:	20 97       	sbiw	r28, 0x00	; 0
    2572:	19 f0       	breq	.+6      	; 0x257a <strtol+0x86>
    2574:	c0 31       	cpi	r28, 0x10	; 16
    2576:	d1 05       	cpc	r29, r1
    2578:	c1 f4       	brne	.+48     	; 0x25aa <strtol+0xb6>
    257a:	f0 e3       	ldi	r31, 0x30	; 48
    257c:	af 16       	cp	r10, r31
    257e:	79 f4       	brne	.+30     	; 0x259e <strtol+0xaa>
    2580:	f8 01       	movw	r30, r16
    2582:	80 81       	ld	r24, Z
    2584:	88 37       	cpi	r24, 0x78	; 120
    2586:	11 f0       	breq	.+4      	; 0x258c <strtol+0x98>
    2588:	88 35       	cpi	r24, 0x58	; 88
    258a:	49 f4       	brne	.+18     	; 0x259e <strtol+0xaa>
    258c:	f8 01       	movw	r30, r16
    258e:	a1 80       	ldd	r10, Z+1	; 0x01
    2590:	0e 5f       	subi	r16, 0xFE	; 254
    2592:	1f 4f       	sbci	r17, 0xFF	; 255
    2594:	f2 e0       	ldi	r31, 0x02	; 2
    2596:	5f 2a       	or	r5, r31
    2598:	c0 e1       	ldi	r28, 0x10	; 16
    259a:	d0 e0       	ldi	r29, 0x00	; 0
    259c:	06 c0       	rjmp	.+12     	; 0x25aa <strtol+0xb6>
    259e:	20 97       	sbiw	r28, 0x00	; 0
    25a0:	21 f4       	brne	.+8      	; 0x25aa <strtol+0xb6>
    25a2:	80 e3       	ldi	r24, 0x30	; 48
    25a4:	a8 16       	cp	r10, r24
    25a6:	e9 f4       	brne	.+58     	; 0x25e2 <strtol+0xee>
    25a8:	27 c0       	rjmp	.+78     	; 0x25f8 <strtol+0x104>
    25aa:	c8 30       	cpi	r28, 0x08	; 8
    25ac:	d1 05       	cpc	r29, r1
    25ae:	31 f1       	breq	.+76     	; 0x25fc <strtol+0x108>
    25b0:	c9 30       	cpi	r28, 0x09	; 9
    25b2:	d1 05       	cpc	r29, r1
    25b4:	24 f4       	brge	.+8      	; 0x25be <strtol+0xca>
    25b6:	c2 30       	cpi	r28, 0x02	; 2
    25b8:	d1 05       	cpc	r29, r1
    25ba:	31 f5       	brne	.+76     	; 0x2608 <strtol+0x114>
    25bc:	0c c0       	rjmp	.+24     	; 0x25d6 <strtol+0xe2>
    25be:	ca 30       	cpi	r28, 0x0A	; 10
    25c0:	d1 05       	cpc	r29, r1
    25c2:	89 f0       	breq	.+34     	; 0x25e6 <strtol+0xf2>
    25c4:	c0 31       	cpi	r28, 0x10	; 16
    25c6:	d1 05       	cpc	r29, r1
    25c8:	f9 f4       	brne	.+62     	; 0x2608 <strtol+0x114>
    25ca:	c1 2c       	mov	r12, r1
    25cc:	d1 2c       	mov	r13, r1
    25ce:	e1 2c       	mov	r14, r1
    25d0:	b8 e0       	ldi	r27, 0x08	; 8
    25d2:	fb 2e       	mov	r15, r27
    25d4:	28 c0       	rjmp	.+80     	; 0x2626 <strtol+0x132>
    25d6:	c1 2c       	mov	r12, r1
    25d8:	d1 2c       	mov	r13, r1
    25da:	e1 2c       	mov	r14, r1
    25dc:	a0 e4       	ldi	r26, 0x40	; 64
    25de:	fa 2e       	mov	r15, r26
    25e0:	22 c0       	rjmp	.+68     	; 0x2626 <strtol+0x132>
    25e2:	ca e0       	ldi	r28, 0x0A	; 10
    25e4:	d0 e0       	ldi	r29, 0x00	; 0
    25e6:	fc ec       	ldi	r31, 0xCC	; 204
    25e8:	cf 2e       	mov	r12, r31
    25ea:	fc ec       	ldi	r31, 0xCC	; 204
    25ec:	df 2e       	mov	r13, r31
    25ee:	fc ec       	ldi	r31, 0xCC	; 204
    25f0:	ef 2e       	mov	r14, r31
    25f2:	fc e0       	ldi	r31, 0x0C	; 12
    25f4:	ff 2e       	mov	r15, r31
    25f6:	17 c0       	rjmp	.+46     	; 0x2626 <strtol+0x132>
    25f8:	c8 e0       	ldi	r28, 0x08	; 8
    25fa:	d0 e0       	ldi	r29, 0x00	; 0
    25fc:	c1 2c       	mov	r12, r1
    25fe:	d1 2c       	mov	r13, r1
    2600:	e1 2c       	mov	r14, r1
    2602:	e0 e1       	ldi	r30, 0x10	; 16
    2604:	fe 2e       	mov	r15, r30
    2606:	0f c0       	rjmp	.+30     	; 0x2626 <strtol+0x132>
    2608:	9e 01       	movw	r18, r28
    260a:	44 27       	eor	r20, r20
    260c:	37 fd       	sbrc	r19, 7
    260e:	40 95       	com	r20
    2610:	54 2f       	mov	r21, r20
    2612:	60 e0       	ldi	r22, 0x00	; 0
    2614:	70 e0       	ldi	r23, 0x00	; 0
    2616:	80 e0       	ldi	r24, 0x00	; 0
    2618:	90 e8       	ldi	r25, 0x80	; 128
    261a:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    261e:	c9 01       	movw	r24, r18
    2620:	da 01       	movw	r26, r20
    2622:	6c 01       	movw	r12, r24
    2624:	7d 01       	movw	r14, r26
    2626:	20 e0       	ldi	r18, 0x00	; 0
    2628:	30 e0       	ldi	r19, 0x00	; 0
    262a:	40 e0       	ldi	r20, 0x00	; 0
    262c:	50 e0       	ldi	r21, 0x00	; 0
    262e:	60 e0       	ldi	r22, 0x00	; 0
    2630:	3e 01       	movw	r6, r28
    2632:	88 24       	eor	r8, r8
    2634:	77 fc       	sbrc	r7, 7
    2636:	80 94       	com	r8
    2638:	98 2c       	mov	r9, r8
    263a:	70 ed       	ldi	r23, 0xD0	; 208
    263c:	b7 2e       	mov	r11, r23
    263e:	ba 0c       	add	r11, r10
    2640:	e9 e0       	ldi	r30, 0x09	; 9
    2642:	eb 15       	cp	r30, r11
    2644:	70 f4       	brcc	.+28     	; 0x2662 <strtol+0x16e>
    2646:	8a 2d       	mov	r24, r10
    2648:	81 54       	subi	r24, 0x41	; 65
    264a:	8a 31       	cpi	r24, 0x1A	; 26
    264c:	18 f4       	brcc	.+6      	; 0x2654 <strtol+0x160>
    264e:	99 ec       	ldi	r25, 0xC9	; 201
    2650:	b9 2e       	mov	r11, r25
    2652:	06 c0       	rjmp	.+12     	; 0x2660 <strtol+0x16c>
    2654:	8a 2d       	mov	r24, r10
    2656:	81 56       	subi	r24, 0x61	; 97
    2658:	8a 31       	cpi	r24, 0x1A	; 26
    265a:	50 f5       	brcc	.+84     	; 0x26b0 <strtol+0x1bc>
    265c:	89 ea       	ldi	r24, 0xA9	; 169
    265e:	b8 2e       	mov	r11, r24
    2660:	ba 0c       	add	r11, r10
    2662:	8b 2d       	mov	r24, r11
    2664:	90 e0       	ldi	r25, 0x00	; 0
    2666:	8c 17       	cp	r24, r28
    2668:	9d 07       	cpc	r25, r29
    266a:	14 f5       	brge	.+68     	; 0x26b0 <strtol+0x1bc>
    266c:	6f 3f       	cpi	r22, 0xFF	; 255
    266e:	e1 f0       	breq	.+56     	; 0x26a8 <strtol+0x1b4>
    2670:	c2 16       	cp	r12, r18
    2672:	d3 06       	cpc	r13, r19
    2674:	e4 06       	cpc	r14, r20
    2676:	f5 06       	cpc	r15, r21
    2678:	b0 f0       	brcs	.+44     	; 0x26a6 <strtol+0x1b2>
    267a:	ca 01       	movw	r24, r20
    267c:	b9 01       	movw	r22, r18
    267e:	a4 01       	movw	r20, r8
    2680:	93 01       	movw	r18, r6
    2682:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    2686:	9b 01       	movw	r18, r22
    2688:	ac 01       	movw	r20, r24
    268a:	2b 0d       	add	r18, r11
    268c:	31 1d       	adc	r19, r1
    268e:	41 1d       	adc	r20, r1
    2690:	51 1d       	adc	r21, r1
    2692:	21 30       	cpi	r18, 0x01	; 1
    2694:	f0 e0       	ldi	r31, 0x00	; 0
    2696:	3f 07       	cpc	r19, r31
    2698:	f0 e0       	ldi	r31, 0x00	; 0
    269a:	4f 07       	cpc	r20, r31
    269c:	f0 e8       	ldi	r31, 0x80	; 128
    269e:	5f 07       	cpc	r21, r31
    26a0:	10 f4       	brcc	.+4      	; 0x26a6 <strtol+0x1b2>
    26a2:	61 e0       	ldi	r22, 0x01	; 1
    26a4:	01 c0       	rjmp	.+2      	; 0x26a8 <strtol+0x1b4>
    26a6:	6f ef       	ldi	r22, 0xFF	; 255
    26a8:	f8 01       	movw	r30, r16
    26aa:	a1 90       	ld	r10, Z+
    26ac:	8f 01       	movw	r16, r30
    26ae:	c5 cf       	rjmp	.-118    	; 0x263a <strtol+0x146>
    26b0:	21 14       	cp	r2, r1
    26b2:	31 04       	cpc	r3, r1
    26b4:	81 f0       	breq	.+32     	; 0x26d6 <strtol+0x1e2>
    26b6:	66 23       	and	r22, r22
    26b8:	31 f0       	breq	.+12     	; 0x26c6 <strtol+0x1d2>
    26ba:	01 50       	subi	r16, 0x01	; 1
    26bc:	10 40       	sbci	r17, 0x00	; 0
    26be:	f1 01       	movw	r30, r2
    26c0:	11 83       	std	Z+1, r17	; 0x01
    26c2:	00 83       	st	Z, r16
    26c4:	08 c0       	rjmp	.+16     	; 0x26d6 <strtol+0x1e2>
    26c6:	51 fe       	sbrs	r5, 1
    26c8:	1a c0       	rjmp	.+52     	; 0x26fe <strtol+0x20a>
    26ca:	02 50       	subi	r16, 0x02	; 2
    26cc:	10 40       	sbci	r17, 0x00	; 0
    26ce:	f1 01       	movw	r30, r2
    26d0:	11 83       	std	Z+1, r17	; 0x01
    26d2:	00 83       	st	Z, r16
    26d4:	14 c0       	rjmp	.+40     	; 0x26fe <strtol+0x20a>
    26d6:	67 ff       	sbrs	r22, 7
    26d8:	12 c0       	rjmp	.+36     	; 0x26fe <strtol+0x20a>
    26da:	50 fc       	sbrc	r5, 0
    26dc:	05 c0       	rjmp	.+10     	; 0x26e8 <strtol+0x1f4>
    26de:	2f ef       	ldi	r18, 0xFF	; 255
    26e0:	3f ef       	ldi	r19, 0xFF	; 255
    26e2:	4f ef       	ldi	r20, 0xFF	; 255
    26e4:	5f e7       	ldi	r21, 0x7F	; 127
    26e6:	04 c0       	rjmp	.+8      	; 0x26f0 <strtol+0x1fc>
    26e8:	20 e0       	ldi	r18, 0x00	; 0
    26ea:	30 e0       	ldi	r19, 0x00	; 0
    26ec:	40 e0       	ldi	r20, 0x00	; 0
    26ee:	50 e8       	ldi	r21, 0x80	; 128
    26f0:	82 e2       	ldi	r24, 0x22	; 34
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	90 93 fc 0b 	sts	0x0BFC, r25
    26f8:	80 93 fb 0b 	sts	0x0BFB, r24
    26fc:	16 c0       	rjmp	.+44     	; 0x272a <strtol+0x236>
    26fe:	50 fe       	sbrs	r5, 0
    2700:	08 c0       	rjmp	.+16     	; 0x2712 <strtol+0x21e>
    2702:	50 95       	com	r21
    2704:	40 95       	com	r20
    2706:	30 95       	com	r19
    2708:	21 95       	neg	r18
    270a:	3f 4f       	sbci	r19, 0xFF	; 255
    270c:	4f 4f       	sbci	r20, 0xFF	; 255
    270e:	5f 4f       	sbci	r21, 0xFF	; 255
    2710:	0c c0       	rjmp	.+24     	; 0x272a <strtol+0x236>
    2712:	57 ff       	sbrs	r21, 7
    2714:	0a c0       	rjmp	.+20     	; 0x272a <strtol+0x236>
    2716:	82 e2       	ldi	r24, 0x22	; 34
    2718:	90 e0       	ldi	r25, 0x00	; 0
    271a:	90 93 fc 0b 	sts	0x0BFC, r25
    271e:	80 93 fb 0b 	sts	0x0BFB, r24
    2722:	2f ef       	ldi	r18, 0xFF	; 255
    2724:	3f ef       	ldi	r19, 0xFF	; 255
    2726:	4f ef       	ldi	r20, 0xFF	; 255
    2728:	5f e7       	ldi	r21, 0x7F	; 127
    272a:	b9 01       	movw	r22, r18
    272c:	ca 01       	movw	r24, r20
    272e:	df 91       	pop	r29
    2730:	cf 91       	pop	r28
    2732:	1f 91       	pop	r17
    2734:	0f 91       	pop	r16
    2736:	ff 90       	pop	r15
    2738:	ef 90       	pop	r14
    273a:	df 90       	pop	r13
    273c:	cf 90       	pop	r12
    273e:	bf 90       	pop	r11
    2740:	af 90       	pop	r10
    2742:	9f 90       	pop	r9
    2744:	8f 90       	pop	r8
    2746:	7f 90       	pop	r7
    2748:	6f 90       	pop	r6
    274a:	5f 90       	pop	r5
    274c:	3f 90       	pop	r3
    274e:	2f 90       	pop	r2
    2750:	08 95       	ret

00002752 <atoi>:
    2752:	fc 01       	movw	r30, r24
    2754:	88 27       	eor	r24, r24
    2756:	99 27       	eor	r25, r25
    2758:	e8 94       	clt
    275a:	21 91       	ld	r18, Z+
    275c:	20 32       	cpi	r18, 0x20	; 32
    275e:	e9 f3       	breq	.-6      	; 0x275a <atoi+0x8>
    2760:	29 30       	cpi	r18, 0x09	; 9
    2762:	10 f0       	brcs	.+4      	; 0x2768 <atoi+0x16>
    2764:	2e 30       	cpi	r18, 0x0E	; 14
    2766:	c8 f3       	brcs	.-14     	; 0x275a <atoi+0x8>
    2768:	2b 32       	cpi	r18, 0x2B	; 43
    276a:	41 f0       	breq	.+16     	; 0x277c <atoi+0x2a>
    276c:	2d 32       	cpi	r18, 0x2D	; 45
    276e:	39 f4       	brne	.+14     	; 0x277e <atoi+0x2c>
    2770:	68 94       	set
    2772:	04 c0       	rjmp	.+8      	; 0x277c <atoi+0x2a>
    2774:	0e 94 9a 14 	call	0x2934	; 0x2934 <__mulhi_const_10>
    2778:	82 0f       	add	r24, r18
    277a:	91 1d       	adc	r25, r1
    277c:	21 91       	ld	r18, Z+
    277e:	20 53       	subi	r18, 0x30	; 48
    2780:	2a 30       	cpi	r18, 0x0A	; 10
    2782:	c0 f3       	brcs	.-16     	; 0x2774 <atoi+0x22>
    2784:	1e f4       	brtc	.+6      	; 0x278c <atoi+0x3a>
    2786:	90 95       	com	r25
    2788:	81 95       	neg	r24
    278a:	9f 4f       	sbci	r25, 0xFF	; 255
    278c:	08 95       	ret

0000278e <atol>:
    278e:	1f 93       	push	r17
    2790:	fc 01       	movw	r30, r24
    2792:	99 27       	eor	r25, r25
    2794:	88 27       	eor	r24, r24
    2796:	bc 01       	movw	r22, r24
    2798:	e8 94       	clt
    279a:	11 91       	ld	r17, Z+
    279c:	10 32       	cpi	r17, 0x20	; 32
    279e:	e9 f3       	breq	.-6      	; 0x279a <atol+0xc>
    27a0:	19 30       	cpi	r17, 0x09	; 9
    27a2:	10 f0       	brcs	.+4      	; 0x27a8 <atol+0x1a>
    27a4:	1e 30       	cpi	r17, 0x0E	; 14
    27a6:	c8 f3       	brcs	.-14     	; 0x279a <atol+0xc>
    27a8:	1b 32       	cpi	r17, 0x2B	; 43
    27aa:	51 f0       	breq	.+20     	; 0x27c0 <atol+0x32>
    27ac:	1d 32       	cpi	r17, 0x2D	; 45
    27ae:	49 f4       	brne	.+18     	; 0x27c2 <atol+0x34>
    27b0:	68 94       	set
    27b2:	06 c0       	rjmp	.+12     	; 0x27c0 <atol+0x32>
    27b4:	0e 94 85 14 	call	0x290a	; 0x290a <__mulsi_const_10>
    27b8:	61 0f       	add	r22, r17
    27ba:	71 1d       	adc	r23, r1
    27bc:	81 1d       	adc	r24, r1
    27be:	91 1d       	adc	r25, r1
    27c0:	11 91       	ld	r17, Z+
    27c2:	10 53       	subi	r17, 0x30	; 48
    27c4:	1a 30       	cpi	r17, 0x0A	; 10
    27c6:	b0 f3       	brcs	.-20     	; 0x27b4 <atol+0x26>
    27c8:	3e f4       	brtc	.+14     	; 0x27d8 <atol+0x4a>
    27ca:	90 95       	com	r25
    27cc:	80 95       	com	r24
    27ce:	70 95       	com	r23
    27d0:	61 95       	neg	r22
    27d2:	7f 4f       	sbci	r23, 0xFF	; 255
    27d4:	8f 4f       	sbci	r24, 0xFF	; 255
    27d6:	9f 4f       	sbci	r25, 0xFF	; 255
    27d8:	1f 91       	pop	r17
    27da:	08 95       	ret

000027dc <memcpy_P>:
    27dc:	fb 01       	movw	r30, r22
    27de:	dc 01       	movw	r26, r24
    27e0:	02 c0       	rjmp	.+4      	; 0x27e6 <memcpy_P+0xa>
    27e2:	05 90       	lpm	r0, Z+
    27e4:	0d 92       	st	X+, r0
    27e6:	41 50       	subi	r20, 0x01	; 1
    27e8:	50 40       	sbci	r21, 0x00	; 0
    27ea:	d8 f7       	brcc	.-10     	; 0x27e2 <memcpy_P+0x6>
    27ec:	08 95       	ret

000027ee <strcmp_P>:
    27ee:	fb 01       	movw	r30, r22
    27f0:	dc 01       	movw	r26, r24
    27f2:	8d 91       	ld	r24, X+
    27f4:	05 90       	lpm	r0, Z+
    27f6:	80 19       	sub	r24, r0
    27f8:	01 10       	cpse	r0, r1
    27fa:	d9 f3       	breq	.-10     	; 0x27f2 <strcmp_P+0x4>
    27fc:	99 0b       	sbc	r25, r25
    27fe:	08 95       	ret

00002800 <strcpy_P>:
    2800:	fb 01       	movw	r30, r22
    2802:	dc 01       	movw	r26, r24
    2804:	05 90       	lpm	r0, Z+
    2806:	0d 92       	st	X+, r0
    2808:	00 20       	and	r0, r0
    280a:	e1 f7       	brne	.-8      	; 0x2804 <strcpy_P+0x4>
    280c:	08 95       	ret

0000280e <strlen_P>:
    280e:	fc 01       	movw	r30, r24
    2810:	05 90       	lpm	r0, Z+
    2812:	00 20       	and	r0, r0
    2814:	e9 f7       	brne	.-6      	; 0x2810 <strlen_P+0x2>
    2816:	80 95       	com	r24
    2818:	90 95       	com	r25
    281a:	8e 0f       	add	r24, r30
    281c:	9f 1f       	adc	r25, r31
    281e:	08 95       	ret

00002820 <memcmp>:
    2820:	fb 01       	movw	r30, r22
    2822:	dc 01       	movw	r26, r24
    2824:	04 c0       	rjmp	.+8      	; 0x282e <memcmp+0xe>
    2826:	8d 91       	ld	r24, X+
    2828:	01 90       	ld	r0, Z+
    282a:	80 19       	sub	r24, r0
    282c:	21 f4       	brne	.+8      	; 0x2836 <memcmp+0x16>
    282e:	41 50       	subi	r20, 0x01	; 1
    2830:	50 40       	sbci	r21, 0x00	; 0
    2832:	c8 f7       	brcc	.-14     	; 0x2826 <memcmp+0x6>
    2834:	88 1b       	sub	r24, r24
    2836:	99 0b       	sbc	r25, r25
    2838:	08 95       	ret

0000283a <memcpy>:
    283a:	fb 01       	movw	r30, r22
    283c:	dc 01       	movw	r26, r24
    283e:	02 c0       	rjmp	.+4      	; 0x2844 <memcpy+0xa>
    2840:	01 90       	ld	r0, Z+
    2842:	0d 92       	st	X+, r0
    2844:	41 50       	subi	r20, 0x01	; 1
    2846:	50 40       	sbci	r21, 0x00	; 0
    2848:	d8 f7       	brcc	.-10     	; 0x2840 <memcpy+0x6>
    284a:	08 95       	ret

0000284c <memset>:
    284c:	dc 01       	movw	r26, r24
    284e:	01 c0       	rjmp	.+2      	; 0x2852 <memset+0x6>
    2850:	6d 93       	st	X+, r22
    2852:	41 50       	subi	r20, 0x01	; 1
    2854:	50 40       	sbci	r21, 0x00	; 0
    2856:	e0 f7       	brcc	.-8      	; 0x2850 <memset+0x4>
    2858:	08 95       	ret

0000285a <strchr>:
    285a:	fc 01       	movw	r30, r24
    285c:	81 91       	ld	r24, Z+
    285e:	86 17       	cp	r24, r22
    2860:	21 f0       	breq	.+8      	; 0x286a <strchr+0x10>
    2862:	88 23       	and	r24, r24
    2864:	d9 f7       	brne	.-10     	; 0x285c <strchr+0x2>
    2866:	99 27       	eor	r25, r25
    2868:	08 95       	ret
    286a:	31 97       	sbiw	r30, 0x01	; 1
    286c:	cf 01       	movw	r24, r30
    286e:	08 95       	ret

00002870 <strcmp>:
    2870:	fb 01       	movw	r30, r22
    2872:	dc 01       	movw	r26, r24
    2874:	8d 91       	ld	r24, X+
    2876:	01 90       	ld	r0, Z+
    2878:	80 19       	sub	r24, r0
    287a:	01 10       	cpse	r0, r1
    287c:	d9 f3       	breq	.-10     	; 0x2874 <strcmp+0x4>
    287e:	99 0b       	sbc	r25, r25
    2880:	08 95       	ret

00002882 <strncmp>:
    2882:	fb 01       	movw	r30, r22
    2884:	dc 01       	movw	r26, r24
    2886:	41 50       	subi	r20, 0x01	; 1
    2888:	50 40       	sbci	r21, 0x00	; 0
    288a:	30 f0       	brcs	.+12     	; 0x2898 <strncmp+0x16>
    288c:	8d 91       	ld	r24, X+
    288e:	01 90       	ld	r0, Z+
    2890:	80 19       	sub	r24, r0
    2892:	19 f4       	brne	.+6      	; 0x289a <strncmp+0x18>
    2894:	00 20       	and	r0, r0
    2896:	b9 f7       	brne	.-18     	; 0x2886 <strncmp+0x4>
    2898:	88 1b       	sub	r24, r24
    289a:	99 0b       	sbc	r25, r25
    289c:	08 95       	ret

0000289e <strncpy>:
    289e:	fb 01       	movw	r30, r22
    28a0:	dc 01       	movw	r26, r24
    28a2:	41 50       	subi	r20, 0x01	; 1
    28a4:	50 40       	sbci	r21, 0x00	; 0
    28a6:	48 f0       	brcs	.+18     	; 0x28ba <strncpy+0x1c>
    28a8:	01 90       	ld	r0, Z+
    28aa:	0d 92       	st	X+, r0
    28ac:	00 20       	and	r0, r0
    28ae:	c9 f7       	brne	.-14     	; 0x28a2 <strncpy+0x4>
    28b0:	01 c0       	rjmp	.+2      	; 0x28b4 <strncpy+0x16>
    28b2:	1d 92       	st	X+, r1
    28b4:	41 50       	subi	r20, 0x01	; 1
    28b6:	50 40       	sbci	r21, 0x00	; 0
    28b8:	e0 f7       	brcc	.-8      	; 0x28b2 <strncpy+0x14>
    28ba:	08 95       	ret

000028bc <strrchr>:
    28bc:	fc 01       	movw	r30, r24
    28be:	81 e0       	ldi	r24, 0x01	; 1
    28c0:	90 e0       	ldi	r25, 0x00	; 0
    28c2:	01 90       	ld	r0, Z+
    28c4:	06 16       	cp	r0, r22
    28c6:	09 f4       	brne	.+2      	; 0x28ca <strrchr+0xe>
    28c8:	cf 01       	movw	r24, r30
    28ca:	00 20       	and	r0, r0
    28cc:	d1 f7       	brne	.-12     	; 0x28c2 <strrchr+0x6>
    28ce:	01 97       	sbiw	r24, 0x01	; 1
    28d0:	08 95       	ret

000028d2 <__eerd_block>:
    28d2:	a0 e0       	ldi	r26, 0x00	; 0
    28d4:	b0 e0       	ldi	r27, 0x00	; 0
    28d6:	ef e6       	ldi	r30, 0x6F	; 111
    28d8:	f4 e1       	ldi	r31, 0x14	; 20
    28da:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    28de:	7c 01       	movw	r14, r24
    28e0:	eb 01       	movw	r28, r22
    28e2:	8a 01       	movw	r16, r20
    28e4:	69 01       	movw	r12, r18
    28e6:	09 c0       	rjmp	.+18     	; 0x28fa <__eerd_block+0x28>
    28e8:	ce 01       	movw	r24, r28
    28ea:	21 96       	adiw	r28, 0x01	; 1
    28ec:	f6 01       	movw	r30, r12
    28ee:	09 95       	icall
    28f0:	f7 01       	movw	r30, r14
    28f2:	81 93       	st	Z+, r24
    28f4:	7f 01       	movw	r14, r30
    28f6:	01 50       	subi	r16, 0x01	; 1
    28f8:	10 40       	sbci	r17, 0x00	; 0
    28fa:	01 15       	cp	r16, r1
    28fc:	11 05       	cpc	r17, r1
    28fe:	a1 f7       	brne	.-24     	; 0x28e8 <__eerd_block+0x16>
    2900:	cd b7       	in	r28, 0x3d	; 61
    2902:	de b7       	in	r29, 0x3e	; 62
    2904:	e8 e0       	ldi	r30, 0x08	; 8
    2906:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000290a <__mulsi_const_10>:
    290a:	59 2f       	mov	r21, r25
    290c:	48 2f       	mov	r20, r24
    290e:	37 2f       	mov	r19, r23
    2910:	26 2f       	mov	r18, r22
    2912:	66 0f       	add	r22, r22
    2914:	77 1f       	adc	r23, r23
    2916:	88 1f       	adc	r24, r24
    2918:	99 1f       	adc	r25, r25
    291a:	66 0f       	add	r22, r22
    291c:	77 1f       	adc	r23, r23
    291e:	88 1f       	adc	r24, r24
    2920:	99 1f       	adc	r25, r25
    2922:	62 0f       	add	r22, r18
    2924:	73 1f       	adc	r23, r19
    2926:	84 1f       	adc	r24, r20
    2928:	95 1f       	adc	r25, r21
    292a:	66 0f       	add	r22, r22
    292c:	77 1f       	adc	r23, r23
    292e:	88 1f       	adc	r24, r24
    2930:	99 1f       	adc	r25, r25
    2932:	08 95       	ret

00002934 <__mulhi_const_10>:
    2934:	7a e0       	ldi	r23, 0x0A	; 10
    2936:	97 9f       	mul	r25, r23
    2938:	90 2d       	mov	r25, r0
    293a:	87 9f       	mul	r24, r23
    293c:	80 2d       	mov	r24, r0
    293e:	91 0d       	add	r25, r1
    2940:	11 24       	eor	r1, r1
    2942:	08 95       	ret

00002944 <printf_P>:
    2944:	a0 e0       	ldi	r26, 0x00	; 0
    2946:	b0 e0       	ldi	r27, 0x00	; 0
    2948:	e8 ea       	ldi	r30, 0xA8	; 168
    294a:	f4 e1       	ldi	r31, 0x14	; 20
    294c:	0c 94 c9 6a 	jmp	0xd592	; 0xd592 <__prologue_saves__+0x20>
    2950:	fe 01       	movw	r30, r28
    2952:	35 96       	adiw	r30, 0x05	; 5
    2954:	61 91       	ld	r22, Z+
    2956:	71 91       	ld	r23, Z+
    2958:	a0 91 f7 0b 	lds	r26, 0x0BF7
    295c:	b0 91 f8 0b 	lds	r27, 0x0BF8
    2960:	13 96       	adiw	r26, 0x03	; 3
    2962:	8c 91       	ld	r24, X
    2964:	13 97       	sbiw	r26, 0x03	; 3
    2966:	88 60       	ori	r24, 0x08	; 8
    2968:	13 96       	adiw	r26, 0x03	; 3
    296a:	8c 93       	st	X, r24
    296c:	80 91 f7 0b 	lds	r24, 0x0BF7
    2970:	90 91 f8 0b 	lds	r25, 0x0BF8
    2974:	af 01       	movw	r20, r30
    2976:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <vfprintf>
    297a:	e0 91 f7 0b 	lds	r30, 0x0BF7
    297e:	f0 91 f8 0b 	lds	r31, 0x0BF8
    2982:	23 81       	ldd	r18, Z+3	; 0x03
    2984:	27 7f       	andi	r18, 0xF7	; 247
    2986:	23 83       	std	Z+3, r18	; 0x03
    2988:	20 96       	adiw	r28, 0x00	; 0
    298a:	e2 e0       	ldi	r30, 0x02	; 2
    298c:	0c 94 e5 6a 	jmp	0xd5ca	; 0xd5ca <__epilogue_restores__+0x20>

00002990 <sprintf_P>:
    2990:	ae e0       	ldi	r26, 0x0E	; 14
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	ee ec       	ldi	r30, 0xCE	; 206
    2996:	f4 e1       	ldi	r31, 0x14	; 20
    2998:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
    299c:	0d 89       	ldd	r16, Y+21	; 0x15
    299e:	1e 89       	ldd	r17, Y+22	; 0x16
    29a0:	8e e0       	ldi	r24, 0x0E	; 14
    29a2:	8c 83       	std	Y+4, r24	; 0x04
    29a4:	1a 83       	std	Y+2, r17	; 0x02
    29a6:	09 83       	std	Y+1, r16	; 0x01
    29a8:	8f ef       	ldi	r24, 0xFF	; 255
    29aa:	9f e7       	ldi	r25, 0x7F	; 127
    29ac:	9e 83       	std	Y+6, r25	; 0x06
    29ae:	8d 83       	std	Y+5, r24	; 0x05
    29b0:	9e 01       	movw	r18, r28
    29b2:	27 5e       	subi	r18, 0xE7	; 231
    29b4:	3f 4f       	sbci	r19, 0xFF	; 255
    29b6:	ce 01       	movw	r24, r28
    29b8:	01 96       	adiw	r24, 0x01	; 1
    29ba:	6f 89       	ldd	r22, Y+23	; 0x17
    29bc:	78 8d       	ldd	r23, Y+24	; 0x18
    29be:	a9 01       	movw	r20, r18
    29c0:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <vfprintf>
    29c4:	2f 81       	ldd	r18, Y+7	; 0x07
    29c6:	38 85       	ldd	r19, Y+8	; 0x08
    29c8:	02 0f       	add	r16, r18
    29ca:	13 1f       	adc	r17, r19
    29cc:	f8 01       	movw	r30, r16
    29ce:	10 82       	st	Z, r1
    29d0:	2e 96       	adiw	r28, 0x0e	; 14
    29d2:	e4 e0       	ldi	r30, 0x04	; 4
    29d4:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

000029d8 <vfprintf>:
    29d8:	ab e0       	ldi	r26, 0x0B	; 11
    29da:	b0 e0       	ldi	r27, 0x00	; 0
    29dc:	e2 ef       	ldi	r30, 0xF2	; 242
    29de:	f4 e1       	ldi	r31, 0x14	; 20
    29e0:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    29e4:	3c 01       	movw	r6, r24
    29e6:	2b 01       	movw	r4, r22
    29e8:	5a 01       	movw	r10, r20
    29ea:	fc 01       	movw	r30, r24
    29ec:	17 82       	std	Z+7, r1	; 0x07
    29ee:	16 82       	std	Z+6, r1	; 0x06
    29f0:	83 81       	ldd	r24, Z+3	; 0x03
    29f2:	81 fd       	sbrc	r24, 1
    29f4:	03 c0       	rjmp	.+6      	; 0x29fc <vfprintf+0x24>
    29f6:	6f ef       	ldi	r22, 0xFF	; 255
    29f8:	7f ef       	ldi	r23, 0xFF	; 255
    29fa:	c6 c1       	rjmp	.+908    	; 0x2d88 <vfprintf+0x3b0>
    29fc:	9a e0       	ldi	r25, 0x0A	; 10
    29fe:	89 2e       	mov	r8, r25
    2a00:	1e 01       	movw	r2, r28
    2a02:	08 94       	sec
    2a04:	21 1c       	adc	r2, r1
    2a06:	31 1c       	adc	r3, r1
    2a08:	f3 01       	movw	r30, r6
    2a0a:	23 81       	ldd	r18, Z+3	; 0x03
    2a0c:	f2 01       	movw	r30, r4
    2a0e:	23 fd       	sbrc	r18, 3
    2a10:	85 91       	lpm	r24, Z+
    2a12:	23 ff       	sbrs	r18, 3
    2a14:	81 91       	ld	r24, Z+
    2a16:	2f 01       	movw	r4, r30
    2a18:	88 23       	and	r24, r24
    2a1a:	09 f4       	brne	.+2      	; 0x2a1e <vfprintf+0x46>
    2a1c:	b2 c1       	rjmp	.+868    	; 0x2d82 <vfprintf+0x3aa>
    2a1e:	85 32       	cpi	r24, 0x25	; 37
    2a20:	39 f4       	brne	.+14     	; 0x2a30 <vfprintf+0x58>
    2a22:	23 fd       	sbrc	r18, 3
    2a24:	85 91       	lpm	r24, Z+
    2a26:	23 ff       	sbrs	r18, 3
    2a28:	81 91       	ld	r24, Z+
    2a2a:	2f 01       	movw	r4, r30
    2a2c:	85 32       	cpi	r24, 0x25	; 37
    2a2e:	29 f4       	brne	.+10     	; 0x2a3a <vfprintf+0x62>
    2a30:	90 e0       	ldi	r25, 0x00	; 0
    2a32:	b3 01       	movw	r22, r6
    2a34:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2a38:	e7 cf       	rjmp	.-50     	; 0x2a08 <vfprintf+0x30>
    2a3a:	98 2f       	mov	r25, r24
    2a3c:	ff 24       	eor	r15, r15
    2a3e:	ee 24       	eor	r14, r14
    2a40:	99 24       	eor	r9, r9
    2a42:	ff e1       	ldi	r31, 0x1F	; 31
    2a44:	ff 15       	cp	r31, r15
    2a46:	d0 f0       	brcs	.+52     	; 0x2a7c <vfprintf+0xa4>
    2a48:	9b 32       	cpi	r25, 0x2B	; 43
    2a4a:	69 f0       	breq	.+26     	; 0x2a66 <vfprintf+0x8e>
    2a4c:	9c 32       	cpi	r25, 0x2C	; 44
    2a4e:	28 f4       	brcc	.+10     	; 0x2a5a <vfprintf+0x82>
    2a50:	90 32       	cpi	r25, 0x20	; 32
    2a52:	59 f0       	breq	.+22     	; 0x2a6a <vfprintf+0x92>
    2a54:	93 32       	cpi	r25, 0x23	; 35
    2a56:	91 f4       	brne	.+36     	; 0x2a7c <vfprintf+0xa4>
    2a58:	0e c0       	rjmp	.+28     	; 0x2a76 <vfprintf+0x9e>
    2a5a:	9d 32       	cpi	r25, 0x2D	; 45
    2a5c:	49 f0       	breq	.+18     	; 0x2a70 <vfprintf+0x98>
    2a5e:	90 33       	cpi	r25, 0x30	; 48
    2a60:	69 f4       	brne	.+26     	; 0x2a7c <vfprintf+0xa4>
    2a62:	41 e0       	ldi	r20, 0x01	; 1
    2a64:	24 c0       	rjmp	.+72     	; 0x2aae <vfprintf+0xd6>
    2a66:	52 e0       	ldi	r21, 0x02	; 2
    2a68:	f5 2a       	or	r15, r21
    2a6a:	84 e0       	ldi	r24, 0x04	; 4
    2a6c:	f8 2a       	or	r15, r24
    2a6e:	28 c0       	rjmp	.+80     	; 0x2ac0 <vfprintf+0xe8>
    2a70:	98 e0       	ldi	r25, 0x08	; 8
    2a72:	f9 2a       	or	r15, r25
    2a74:	25 c0       	rjmp	.+74     	; 0x2ac0 <vfprintf+0xe8>
    2a76:	e0 e1       	ldi	r30, 0x10	; 16
    2a78:	fe 2a       	or	r15, r30
    2a7a:	22 c0       	rjmp	.+68     	; 0x2ac0 <vfprintf+0xe8>
    2a7c:	f7 fc       	sbrc	r15, 7
    2a7e:	29 c0       	rjmp	.+82     	; 0x2ad2 <vfprintf+0xfa>
    2a80:	89 2f       	mov	r24, r25
    2a82:	80 53       	subi	r24, 0x30	; 48
    2a84:	8a 30       	cpi	r24, 0x0A	; 10
    2a86:	70 f4       	brcc	.+28     	; 0x2aa4 <vfprintf+0xcc>
    2a88:	f6 fe       	sbrs	r15, 6
    2a8a:	05 c0       	rjmp	.+10     	; 0x2a96 <vfprintf+0xbe>
    2a8c:	98 9c       	mul	r9, r8
    2a8e:	90 2c       	mov	r9, r0
    2a90:	11 24       	eor	r1, r1
    2a92:	98 0e       	add	r9, r24
    2a94:	15 c0       	rjmp	.+42     	; 0x2ac0 <vfprintf+0xe8>
    2a96:	e8 9c       	mul	r14, r8
    2a98:	e0 2c       	mov	r14, r0
    2a9a:	11 24       	eor	r1, r1
    2a9c:	e8 0e       	add	r14, r24
    2a9e:	f0 e2       	ldi	r31, 0x20	; 32
    2aa0:	ff 2a       	or	r15, r31
    2aa2:	0e c0       	rjmp	.+28     	; 0x2ac0 <vfprintf+0xe8>
    2aa4:	9e 32       	cpi	r25, 0x2E	; 46
    2aa6:	29 f4       	brne	.+10     	; 0x2ab2 <vfprintf+0xda>
    2aa8:	f6 fc       	sbrc	r15, 6
    2aaa:	6b c1       	rjmp	.+726    	; 0x2d82 <vfprintf+0x3aa>
    2aac:	40 e4       	ldi	r20, 0x40	; 64
    2aae:	f4 2a       	or	r15, r20
    2ab0:	07 c0       	rjmp	.+14     	; 0x2ac0 <vfprintf+0xe8>
    2ab2:	9c 36       	cpi	r25, 0x6C	; 108
    2ab4:	19 f4       	brne	.+6      	; 0x2abc <vfprintf+0xe4>
    2ab6:	50 e8       	ldi	r21, 0x80	; 128
    2ab8:	f5 2a       	or	r15, r21
    2aba:	02 c0       	rjmp	.+4      	; 0x2ac0 <vfprintf+0xe8>
    2abc:	98 36       	cpi	r25, 0x68	; 104
    2abe:	49 f4       	brne	.+18     	; 0x2ad2 <vfprintf+0xfa>
    2ac0:	f2 01       	movw	r30, r4
    2ac2:	23 fd       	sbrc	r18, 3
    2ac4:	95 91       	lpm	r25, Z+
    2ac6:	23 ff       	sbrs	r18, 3
    2ac8:	91 91       	ld	r25, Z+
    2aca:	2f 01       	movw	r4, r30
    2acc:	99 23       	and	r25, r25
    2ace:	09 f0       	breq	.+2      	; 0x2ad2 <vfprintf+0xfa>
    2ad0:	b8 cf       	rjmp	.-144    	; 0x2a42 <vfprintf+0x6a>
    2ad2:	89 2f       	mov	r24, r25
    2ad4:	85 54       	subi	r24, 0x45	; 69
    2ad6:	83 30       	cpi	r24, 0x03	; 3
    2ad8:	18 f0       	brcs	.+6      	; 0x2ae0 <vfprintf+0x108>
    2ada:	80 52       	subi	r24, 0x20	; 32
    2adc:	83 30       	cpi	r24, 0x03	; 3
    2ade:	38 f4       	brcc	.+14     	; 0x2aee <vfprintf+0x116>
    2ae0:	44 e0       	ldi	r20, 0x04	; 4
    2ae2:	50 e0       	ldi	r21, 0x00	; 0
    2ae4:	a4 0e       	add	r10, r20
    2ae6:	b5 1e       	adc	r11, r21
    2ae8:	5f e3       	ldi	r21, 0x3F	; 63
    2aea:	59 83       	std	Y+1, r21	; 0x01
    2aec:	0f c0       	rjmp	.+30     	; 0x2b0c <vfprintf+0x134>
    2aee:	93 36       	cpi	r25, 0x63	; 99
    2af0:	31 f0       	breq	.+12     	; 0x2afe <vfprintf+0x126>
    2af2:	93 37       	cpi	r25, 0x73	; 115
    2af4:	79 f0       	breq	.+30     	; 0x2b14 <vfprintf+0x13c>
    2af6:	93 35       	cpi	r25, 0x53	; 83
    2af8:	09 f0       	breq	.+2      	; 0x2afc <vfprintf+0x124>
    2afa:	56 c0       	rjmp	.+172    	; 0x2ba8 <vfprintf+0x1d0>
    2afc:	20 c0       	rjmp	.+64     	; 0x2b3e <vfprintf+0x166>
    2afe:	f5 01       	movw	r30, r10
    2b00:	80 81       	ld	r24, Z
    2b02:	89 83       	std	Y+1, r24	; 0x01
    2b04:	42 e0       	ldi	r20, 0x02	; 2
    2b06:	50 e0       	ldi	r21, 0x00	; 0
    2b08:	a4 0e       	add	r10, r20
    2b0a:	b5 1e       	adc	r11, r21
    2b0c:	61 01       	movw	r12, r2
    2b0e:	01 e0       	ldi	r16, 0x01	; 1
    2b10:	10 e0       	ldi	r17, 0x00	; 0
    2b12:	12 c0       	rjmp	.+36     	; 0x2b38 <vfprintf+0x160>
    2b14:	f5 01       	movw	r30, r10
    2b16:	c0 80       	ld	r12, Z
    2b18:	d1 80       	ldd	r13, Z+1	; 0x01
    2b1a:	f6 fc       	sbrc	r15, 6
    2b1c:	03 c0       	rjmp	.+6      	; 0x2b24 <vfprintf+0x14c>
    2b1e:	6f ef       	ldi	r22, 0xFF	; 255
    2b20:	7f ef       	ldi	r23, 0xFF	; 255
    2b22:	02 c0       	rjmp	.+4      	; 0x2b28 <vfprintf+0x150>
    2b24:	69 2d       	mov	r22, r9
    2b26:	70 e0       	ldi	r23, 0x00	; 0
    2b28:	42 e0       	ldi	r20, 0x02	; 2
    2b2a:	50 e0       	ldi	r21, 0x00	; 0
    2b2c:	a4 0e       	add	r10, r20
    2b2e:	b5 1e       	adc	r11, r21
    2b30:	c6 01       	movw	r24, r12
    2b32:	0e 94 d4 16 	call	0x2da8	; 0x2da8 <strnlen>
    2b36:	8c 01       	movw	r16, r24
    2b38:	5f e7       	ldi	r21, 0x7F	; 127
    2b3a:	f5 22       	and	r15, r21
    2b3c:	14 c0       	rjmp	.+40     	; 0x2b66 <vfprintf+0x18e>
    2b3e:	f5 01       	movw	r30, r10
    2b40:	c0 80       	ld	r12, Z
    2b42:	d1 80       	ldd	r13, Z+1	; 0x01
    2b44:	f6 fc       	sbrc	r15, 6
    2b46:	03 c0       	rjmp	.+6      	; 0x2b4e <vfprintf+0x176>
    2b48:	6f ef       	ldi	r22, 0xFF	; 255
    2b4a:	7f ef       	ldi	r23, 0xFF	; 255
    2b4c:	02 c0       	rjmp	.+4      	; 0x2b52 <vfprintf+0x17a>
    2b4e:	69 2d       	mov	r22, r9
    2b50:	70 e0       	ldi	r23, 0x00	; 0
    2b52:	42 e0       	ldi	r20, 0x02	; 2
    2b54:	50 e0       	ldi	r21, 0x00	; 0
    2b56:	a4 0e       	add	r10, r20
    2b58:	b5 1e       	adc	r11, r21
    2b5a:	c6 01       	movw	r24, r12
    2b5c:	0e 94 c9 16 	call	0x2d92	; 0x2d92 <strnlen_P>
    2b60:	8c 01       	movw	r16, r24
    2b62:	50 e8       	ldi	r21, 0x80	; 128
    2b64:	f5 2a       	or	r15, r21
    2b66:	f3 fe       	sbrs	r15, 3
    2b68:	07 c0       	rjmp	.+14     	; 0x2b78 <vfprintf+0x1a0>
    2b6a:	1a c0       	rjmp	.+52     	; 0x2ba0 <vfprintf+0x1c8>
    2b6c:	80 e2       	ldi	r24, 0x20	; 32
    2b6e:	90 e0       	ldi	r25, 0x00	; 0
    2b70:	b3 01       	movw	r22, r6
    2b72:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2b76:	ea 94       	dec	r14
    2b78:	8e 2d       	mov	r24, r14
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	08 17       	cp	r16, r24
    2b7e:	19 07       	cpc	r17, r25
    2b80:	a8 f3       	brcs	.-22     	; 0x2b6c <vfprintf+0x194>
    2b82:	0e c0       	rjmp	.+28     	; 0x2ba0 <vfprintf+0x1c8>
    2b84:	f6 01       	movw	r30, r12
    2b86:	f7 fc       	sbrc	r15, 7
    2b88:	85 91       	lpm	r24, Z+
    2b8a:	f7 fe       	sbrs	r15, 7
    2b8c:	81 91       	ld	r24, Z+
    2b8e:	6f 01       	movw	r12, r30
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	b3 01       	movw	r22, r6
    2b94:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2b98:	e1 10       	cpse	r14, r1
    2b9a:	ea 94       	dec	r14
    2b9c:	01 50       	subi	r16, 0x01	; 1
    2b9e:	10 40       	sbci	r17, 0x00	; 0
    2ba0:	01 15       	cp	r16, r1
    2ba2:	11 05       	cpc	r17, r1
    2ba4:	79 f7       	brne	.-34     	; 0x2b84 <vfprintf+0x1ac>
    2ba6:	ea c0       	rjmp	.+468    	; 0x2d7c <vfprintf+0x3a4>
    2ba8:	94 36       	cpi	r25, 0x64	; 100
    2baa:	11 f0       	breq	.+4      	; 0x2bb0 <vfprintf+0x1d8>
    2bac:	99 36       	cpi	r25, 0x69	; 105
    2bae:	69 f5       	brne	.+90     	; 0x2c0a <vfprintf+0x232>
    2bb0:	f7 fe       	sbrs	r15, 7
    2bb2:	08 c0       	rjmp	.+16     	; 0x2bc4 <vfprintf+0x1ec>
    2bb4:	f5 01       	movw	r30, r10
    2bb6:	20 81       	ld	r18, Z
    2bb8:	31 81       	ldd	r19, Z+1	; 0x01
    2bba:	42 81       	ldd	r20, Z+2	; 0x02
    2bbc:	53 81       	ldd	r21, Z+3	; 0x03
    2bbe:	84 e0       	ldi	r24, 0x04	; 4
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	0a c0       	rjmp	.+20     	; 0x2bd8 <vfprintf+0x200>
    2bc4:	f5 01       	movw	r30, r10
    2bc6:	80 81       	ld	r24, Z
    2bc8:	91 81       	ldd	r25, Z+1	; 0x01
    2bca:	9c 01       	movw	r18, r24
    2bcc:	44 27       	eor	r20, r20
    2bce:	37 fd       	sbrc	r19, 7
    2bd0:	40 95       	com	r20
    2bd2:	54 2f       	mov	r21, r20
    2bd4:	82 e0       	ldi	r24, 0x02	; 2
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	a8 0e       	add	r10, r24
    2bda:	b9 1e       	adc	r11, r25
    2bdc:	9f e6       	ldi	r25, 0x6F	; 111
    2bde:	f9 22       	and	r15, r25
    2be0:	57 ff       	sbrs	r21, 7
    2be2:	09 c0       	rjmp	.+18     	; 0x2bf6 <vfprintf+0x21e>
    2be4:	50 95       	com	r21
    2be6:	40 95       	com	r20
    2be8:	30 95       	com	r19
    2bea:	21 95       	neg	r18
    2bec:	3f 4f       	sbci	r19, 0xFF	; 255
    2bee:	4f 4f       	sbci	r20, 0xFF	; 255
    2bf0:	5f 4f       	sbci	r21, 0xFF	; 255
    2bf2:	e0 e8       	ldi	r30, 0x80	; 128
    2bf4:	fe 2a       	or	r15, r30
    2bf6:	ca 01       	movw	r24, r20
    2bf8:	b9 01       	movw	r22, r18
    2bfa:	a1 01       	movw	r20, r2
    2bfc:	2a e0       	ldi	r18, 0x0A	; 10
    2bfe:	30 e0       	ldi	r19, 0x00	; 0
    2c00:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <__ultoa_invert>
    2c04:	d8 2e       	mov	r13, r24
    2c06:	d2 18       	sub	r13, r2
    2c08:	40 c0       	rjmp	.+128    	; 0x2c8a <vfprintf+0x2b2>
    2c0a:	95 37       	cpi	r25, 0x75	; 117
    2c0c:	29 f4       	brne	.+10     	; 0x2c18 <vfprintf+0x240>
    2c0e:	1f 2d       	mov	r17, r15
    2c10:	1f 7e       	andi	r17, 0xEF	; 239
    2c12:	2a e0       	ldi	r18, 0x0A	; 10
    2c14:	30 e0       	ldi	r19, 0x00	; 0
    2c16:	1d c0       	rjmp	.+58     	; 0x2c52 <vfprintf+0x27a>
    2c18:	1f 2d       	mov	r17, r15
    2c1a:	19 7f       	andi	r17, 0xF9	; 249
    2c1c:	9f 36       	cpi	r25, 0x6F	; 111
    2c1e:	61 f0       	breq	.+24     	; 0x2c38 <vfprintf+0x260>
    2c20:	90 37       	cpi	r25, 0x70	; 112
    2c22:	20 f4       	brcc	.+8      	; 0x2c2c <vfprintf+0x254>
    2c24:	98 35       	cpi	r25, 0x58	; 88
    2c26:	09 f0       	breq	.+2      	; 0x2c2a <vfprintf+0x252>
    2c28:	ac c0       	rjmp	.+344    	; 0x2d82 <vfprintf+0x3aa>
    2c2a:	0f c0       	rjmp	.+30     	; 0x2c4a <vfprintf+0x272>
    2c2c:	90 37       	cpi	r25, 0x70	; 112
    2c2e:	39 f0       	breq	.+14     	; 0x2c3e <vfprintf+0x266>
    2c30:	98 37       	cpi	r25, 0x78	; 120
    2c32:	09 f0       	breq	.+2      	; 0x2c36 <vfprintf+0x25e>
    2c34:	a6 c0       	rjmp	.+332    	; 0x2d82 <vfprintf+0x3aa>
    2c36:	04 c0       	rjmp	.+8      	; 0x2c40 <vfprintf+0x268>
    2c38:	28 e0       	ldi	r18, 0x08	; 8
    2c3a:	30 e0       	ldi	r19, 0x00	; 0
    2c3c:	0a c0       	rjmp	.+20     	; 0x2c52 <vfprintf+0x27a>
    2c3e:	10 61       	ori	r17, 0x10	; 16
    2c40:	14 fd       	sbrc	r17, 4
    2c42:	14 60       	ori	r17, 0x04	; 4
    2c44:	20 e1       	ldi	r18, 0x10	; 16
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	04 c0       	rjmp	.+8      	; 0x2c52 <vfprintf+0x27a>
    2c4a:	14 fd       	sbrc	r17, 4
    2c4c:	16 60       	ori	r17, 0x06	; 6
    2c4e:	20 e1       	ldi	r18, 0x10	; 16
    2c50:	32 e0       	ldi	r19, 0x02	; 2
    2c52:	17 ff       	sbrs	r17, 7
    2c54:	08 c0       	rjmp	.+16     	; 0x2c66 <vfprintf+0x28e>
    2c56:	f5 01       	movw	r30, r10
    2c58:	60 81       	ld	r22, Z
    2c5a:	71 81       	ldd	r23, Z+1	; 0x01
    2c5c:	82 81       	ldd	r24, Z+2	; 0x02
    2c5e:	93 81       	ldd	r25, Z+3	; 0x03
    2c60:	44 e0       	ldi	r20, 0x04	; 4
    2c62:	50 e0       	ldi	r21, 0x00	; 0
    2c64:	08 c0       	rjmp	.+16     	; 0x2c76 <vfprintf+0x29e>
    2c66:	f5 01       	movw	r30, r10
    2c68:	80 81       	ld	r24, Z
    2c6a:	91 81       	ldd	r25, Z+1	; 0x01
    2c6c:	bc 01       	movw	r22, r24
    2c6e:	80 e0       	ldi	r24, 0x00	; 0
    2c70:	90 e0       	ldi	r25, 0x00	; 0
    2c72:	42 e0       	ldi	r20, 0x02	; 2
    2c74:	50 e0       	ldi	r21, 0x00	; 0
    2c76:	a4 0e       	add	r10, r20
    2c78:	b5 1e       	adc	r11, r21
    2c7a:	a1 01       	movw	r20, r2
    2c7c:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <__ultoa_invert>
    2c80:	d8 2e       	mov	r13, r24
    2c82:	d2 18       	sub	r13, r2
    2c84:	8f e7       	ldi	r24, 0x7F	; 127
    2c86:	f8 2e       	mov	r15, r24
    2c88:	f1 22       	and	r15, r17
    2c8a:	f6 fe       	sbrs	r15, 6
    2c8c:	0b c0       	rjmp	.+22     	; 0x2ca4 <vfprintf+0x2cc>
    2c8e:	5e ef       	ldi	r21, 0xFE	; 254
    2c90:	f5 22       	and	r15, r21
    2c92:	d9 14       	cp	r13, r9
    2c94:	38 f4       	brcc	.+14     	; 0x2ca4 <vfprintf+0x2cc>
    2c96:	f4 fe       	sbrs	r15, 4
    2c98:	07 c0       	rjmp	.+14     	; 0x2ca8 <vfprintf+0x2d0>
    2c9a:	f2 fc       	sbrc	r15, 2
    2c9c:	05 c0       	rjmp	.+10     	; 0x2ca8 <vfprintf+0x2d0>
    2c9e:	8f ee       	ldi	r24, 0xEF	; 239
    2ca0:	f8 22       	and	r15, r24
    2ca2:	02 c0       	rjmp	.+4      	; 0x2ca8 <vfprintf+0x2d0>
    2ca4:	1d 2d       	mov	r17, r13
    2ca6:	01 c0       	rjmp	.+2      	; 0x2caa <vfprintf+0x2d2>
    2ca8:	19 2d       	mov	r17, r9
    2caa:	f4 fe       	sbrs	r15, 4
    2cac:	0d c0       	rjmp	.+26     	; 0x2cc8 <vfprintf+0x2f0>
    2cae:	fe 01       	movw	r30, r28
    2cb0:	ed 0d       	add	r30, r13
    2cb2:	f1 1d       	adc	r31, r1
    2cb4:	80 81       	ld	r24, Z
    2cb6:	80 33       	cpi	r24, 0x30	; 48
    2cb8:	19 f4       	brne	.+6      	; 0x2cc0 <vfprintf+0x2e8>
    2cba:	99 ee       	ldi	r25, 0xE9	; 233
    2cbc:	f9 22       	and	r15, r25
    2cbe:	08 c0       	rjmp	.+16     	; 0x2cd0 <vfprintf+0x2f8>
    2cc0:	1f 5f       	subi	r17, 0xFF	; 255
    2cc2:	f2 fe       	sbrs	r15, 2
    2cc4:	05 c0       	rjmp	.+10     	; 0x2cd0 <vfprintf+0x2f8>
    2cc6:	03 c0       	rjmp	.+6      	; 0x2cce <vfprintf+0x2f6>
    2cc8:	8f 2d       	mov	r24, r15
    2cca:	86 78       	andi	r24, 0x86	; 134
    2ccc:	09 f0       	breq	.+2      	; 0x2cd0 <vfprintf+0x2f8>
    2cce:	1f 5f       	subi	r17, 0xFF	; 255
    2cd0:	0f 2d       	mov	r16, r15
    2cd2:	f3 fc       	sbrc	r15, 3
    2cd4:	14 c0       	rjmp	.+40     	; 0x2cfe <vfprintf+0x326>
    2cd6:	f0 fe       	sbrs	r15, 0
    2cd8:	0f c0       	rjmp	.+30     	; 0x2cf8 <vfprintf+0x320>
    2cda:	1e 15       	cp	r17, r14
    2cdc:	10 f0       	brcs	.+4      	; 0x2ce2 <vfprintf+0x30a>
    2cde:	9d 2c       	mov	r9, r13
    2ce0:	0b c0       	rjmp	.+22     	; 0x2cf8 <vfprintf+0x320>
    2ce2:	9d 2c       	mov	r9, r13
    2ce4:	9e 0c       	add	r9, r14
    2ce6:	91 1a       	sub	r9, r17
    2ce8:	1e 2d       	mov	r17, r14
    2cea:	06 c0       	rjmp	.+12     	; 0x2cf8 <vfprintf+0x320>
    2cec:	80 e2       	ldi	r24, 0x20	; 32
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	b3 01       	movw	r22, r6
    2cf2:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2cf6:	1f 5f       	subi	r17, 0xFF	; 255
    2cf8:	1e 15       	cp	r17, r14
    2cfa:	c0 f3       	brcs	.-16     	; 0x2cec <vfprintf+0x314>
    2cfc:	04 c0       	rjmp	.+8      	; 0x2d06 <vfprintf+0x32e>
    2cfe:	1e 15       	cp	r17, r14
    2d00:	10 f4       	brcc	.+4      	; 0x2d06 <vfprintf+0x32e>
    2d02:	e1 1a       	sub	r14, r17
    2d04:	01 c0       	rjmp	.+2      	; 0x2d08 <vfprintf+0x330>
    2d06:	ee 24       	eor	r14, r14
    2d08:	04 ff       	sbrs	r16, 4
    2d0a:	0f c0       	rjmp	.+30     	; 0x2d2a <vfprintf+0x352>
    2d0c:	80 e3       	ldi	r24, 0x30	; 48
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	b3 01       	movw	r22, r6
    2d12:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2d16:	02 ff       	sbrs	r16, 2
    2d18:	1d c0       	rjmp	.+58     	; 0x2d54 <vfprintf+0x37c>
    2d1a:	01 fd       	sbrc	r16, 1
    2d1c:	03 c0       	rjmp	.+6      	; 0x2d24 <vfprintf+0x34c>
    2d1e:	88 e7       	ldi	r24, 0x78	; 120
    2d20:	90 e0       	ldi	r25, 0x00	; 0
    2d22:	0e c0       	rjmp	.+28     	; 0x2d40 <vfprintf+0x368>
    2d24:	88 e5       	ldi	r24, 0x58	; 88
    2d26:	90 e0       	ldi	r25, 0x00	; 0
    2d28:	0b c0       	rjmp	.+22     	; 0x2d40 <vfprintf+0x368>
    2d2a:	80 2f       	mov	r24, r16
    2d2c:	86 78       	andi	r24, 0x86	; 134
    2d2e:	91 f0       	breq	.+36     	; 0x2d54 <vfprintf+0x37c>
    2d30:	01 ff       	sbrs	r16, 1
    2d32:	02 c0       	rjmp	.+4      	; 0x2d38 <vfprintf+0x360>
    2d34:	8b e2       	ldi	r24, 0x2B	; 43
    2d36:	01 c0       	rjmp	.+2      	; 0x2d3a <vfprintf+0x362>
    2d38:	80 e2       	ldi	r24, 0x20	; 32
    2d3a:	f7 fc       	sbrc	r15, 7
    2d3c:	8d e2       	ldi	r24, 0x2D	; 45
    2d3e:	90 e0       	ldi	r25, 0x00	; 0
    2d40:	b3 01       	movw	r22, r6
    2d42:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2d46:	06 c0       	rjmp	.+12     	; 0x2d54 <vfprintf+0x37c>
    2d48:	80 e3       	ldi	r24, 0x30	; 48
    2d4a:	90 e0       	ldi	r25, 0x00	; 0
    2d4c:	b3 01       	movw	r22, r6
    2d4e:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2d52:	9a 94       	dec	r9
    2d54:	d9 14       	cp	r13, r9
    2d56:	c0 f3       	brcs	.-16     	; 0x2d48 <vfprintf+0x370>
    2d58:	da 94       	dec	r13
    2d5a:	f1 01       	movw	r30, r2
    2d5c:	ed 0d       	add	r30, r13
    2d5e:	f1 1d       	adc	r31, r1
    2d60:	80 81       	ld	r24, Z
    2d62:	90 e0       	ldi	r25, 0x00	; 0
    2d64:	b3 01       	movw	r22, r6
    2d66:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2d6a:	dd 20       	and	r13, r13
    2d6c:	a9 f7       	brne	.-22     	; 0x2d58 <vfprintf+0x380>
    2d6e:	06 c0       	rjmp	.+12     	; 0x2d7c <vfprintf+0x3a4>
    2d70:	80 e2       	ldi	r24, 0x20	; 32
    2d72:	90 e0       	ldi	r25, 0x00	; 0
    2d74:	b3 01       	movw	r22, r6
    2d76:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <fputc>
    2d7a:	ea 94       	dec	r14
    2d7c:	ee 20       	and	r14, r14
    2d7e:	c1 f7       	brne	.-16     	; 0x2d70 <vfprintf+0x398>
    2d80:	43 ce       	rjmp	.-890    	; 0x2a08 <vfprintf+0x30>
    2d82:	f3 01       	movw	r30, r6
    2d84:	66 81       	ldd	r22, Z+6	; 0x06
    2d86:	77 81       	ldd	r23, Z+7	; 0x07
    2d88:	cb 01       	movw	r24, r22
    2d8a:	2b 96       	adiw	r28, 0x0b	; 11
    2d8c:	e2 e1       	ldi	r30, 0x12	; 18
    2d8e:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

00002d92 <strnlen_P>:
    2d92:	fc 01       	movw	r30, r24
    2d94:	05 90       	lpm	r0, Z+
    2d96:	61 50       	subi	r22, 0x01	; 1
    2d98:	70 40       	sbci	r23, 0x00	; 0
    2d9a:	01 10       	cpse	r0, r1
    2d9c:	d8 f7       	brcc	.-10     	; 0x2d94 <strnlen_P+0x2>
    2d9e:	80 95       	com	r24
    2da0:	90 95       	com	r25
    2da2:	8e 0f       	add	r24, r30
    2da4:	9f 1f       	adc	r25, r31
    2da6:	08 95       	ret

00002da8 <strnlen>:
    2da8:	fc 01       	movw	r30, r24
    2daa:	61 50       	subi	r22, 0x01	; 1
    2dac:	70 40       	sbci	r23, 0x00	; 0
    2dae:	01 90       	ld	r0, Z+
    2db0:	01 10       	cpse	r0, r1
    2db2:	d8 f7       	brcc	.-10     	; 0x2daa <strnlen+0x2>
    2db4:	80 95       	com	r24
    2db6:	90 95       	com	r25
    2db8:	8e 0f       	add	r24, r30
    2dba:	9f 1f       	adc	r25, r31
    2dbc:	08 95       	ret

00002dbe <fputc>:
    2dbe:	0f 93       	push	r16
    2dc0:	1f 93       	push	r17
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	8c 01       	movw	r16, r24
    2dc8:	eb 01       	movw	r28, r22
    2dca:	8b 81       	ldd	r24, Y+3	; 0x03
    2dcc:	81 ff       	sbrs	r24, 1
    2dce:	1b c0       	rjmp	.+54     	; 0x2e06 <fputc+0x48>
    2dd0:	82 ff       	sbrs	r24, 2
    2dd2:	0d c0       	rjmp	.+26     	; 0x2dee <fputc+0x30>
    2dd4:	2e 81       	ldd	r18, Y+6	; 0x06
    2dd6:	3f 81       	ldd	r19, Y+7	; 0x07
    2dd8:	8c 81       	ldd	r24, Y+4	; 0x04
    2dda:	9d 81       	ldd	r25, Y+5	; 0x05
    2ddc:	28 17       	cp	r18, r24
    2dde:	39 07       	cpc	r19, r25
    2de0:	64 f4       	brge	.+24     	; 0x2dfa <fputc+0x3c>
    2de2:	e8 81       	ld	r30, Y
    2de4:	f9 81       	ldd	r31, Y+1	; 0x01
    2de6:	01 93       	st	Z+, r16
    2de8:	f9 83       	std	Y+1, r31	; 0x01
    2dea:	e8 83       	st	Y, r30
    2dec:	06 c0       	rjmp	.+12     	; 0x2dfa <fputc+0x3c>
    2dee:	e8 85       	ldd	r30, Y+8	; 0x08
    2df0:	f9 85       	ldd	r31, Y+9	; 0x09
    2df2:	80 2f       	mov	r24, r16
    2df4:	09 95       	icall
    2df6:	89 2b       	or	r24, r25
    2df8:	31 f4       	brne	.+12     	; 0x2e06 <fputc+0x48>
    2dfa:	8e 81       	ldd	r24, Y+6	; 0x06
    2dfc:	9f 81       	ldd	r25, Y+7	; 0x07
    2dfe:	01 96       	adiw	r24, 0x01	; 1
    2e00:	9f 83       	std	Y+7, r25	; 0x07
    2e02:	8e 83       	std	Y+6, r24	; 0x06
    2e04:	02 c0       	rjmp	.+4      	; 0x2e0a <fputc+0x4c>
    2e06:	0f ef       	ldi	r16, 0xFF	; 255
    2e08:	1f ef       	ldi	r17, 0xFF	; 255
    2e0a:	c8 01       	movw	r24, r16
    2e0c:	df 91       	pop	r29
    2e0e:	cf 91       	pop	r28
    2e10:	1f 91       	pop	r17
    2e12:	0f 91       	pop	r16
    2e14:	08 95       	ret

00002e16 <__ultoa_invert>:
    2e16:	fa 01       	movw	r30, r20
    2e18:	aa 27       	eor	r26, r26
    2e1a:	28 30       	cpi	r18, 0x08	; 8
    2e1c:	51 f1       	breq	.+84     	; 0x2e72 <__ultoa_invert+0x5c>
    2e1e:	20 31       	cpi	r18, 0x10	; 16
    2e20:	81 f1       	breq	.+96     	; 0x2e82 <__ultoa_invert+0x6c>
    2e22:	e8 94       	clt
    2e24:	6f 93       	push	r22
    2e26:	6e 7f       	andi	r22, 0xFE	; 254
    2e28:	6e 5f       	subi	r22, 0xFE	; 254
    2e2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e2c:	8f 4f       	sbci	r24, 0xFF	; 255
    2e2e:	9f 4f       	sbci	r25, 0xFF	; 255
    2e30:	af 4f       	sbci	r26, 0xFF	; 255
    2e32:	b1 e0       	ldi	r27, 0x01	; 1
    2e34:	3e d0       	rcall	.+124    	; 0x2eb2 <__ultoa_invert+0x9c>
    2e36:	b4 e0       	ldi	r27, 0x04	; 4
    2e38:	3c d0       	rcall	.+120    	; 0x2eb2 <__ultoa_invert+0x9c>
    2e3a:	67 0f       	add	r22, r23
    2e3c:	78 1f       	adc	r23, r24
    2e3e:	89 1f       	adc	r24, r25
    2e40:	9a 1f       	adc	r25, r26
    2e42:	a1 1d       	adc	r26, r1
    2e44:	68 0f       	add	r22, r24
    2e46:	79 1f       	adc	r23, r25
    2e48:	8a 1f       	adc	r24, r26
    2e4a:	91 1d       	adc	r25, r1
    2e4c:	a1 1d       	adc	r26, r1
    2e4e:	6a 0f       	add	r22, r26
    2e50:	71 1d       	adc	r23, r1
    2e52:	81 1d       	adc	r24, r1
    2e54:	91 1d       	adc	r25, r1
    2e56:	a1 1d       	adc	r26, r1
    2e58:	20 d0       	rcall	.+64     	; 0x2e9a <__ultoa_invert+0x84>
    2e5a:	09 f4       	brne	.+2      	; 0x2e5e <__ultoa_invert+0x48>
    2e5c:	68 94       	set
    2e5e:	3f 91       	pop	r19
    2e60:	2a e0       	ldi	r18, 0x0A	; 10
    2e62:	26 9f       	mul	r18, r22
    2e64:	11 24       	eor	r1, r1
    2e66:	30 19       	sub	r19, r0
    2e68:	30 5d       	subi	r19, 0xD0	; 208
    2e6a:	31 93       	st	Z+, r19
    2e6c:	de f6       	brtc	.-74     	; 0x2e24 <__ultoa_invert+0xe>
    2e6e:	cf 01       	movw	r24, r30
    2e70:	08 95       	ret
    2e72:	46 2f       	mov	r20, r22
    2e74:	47 70       	andi	r20, 0x07	; 7
    2e76:	40 5d       	subi	r20, 0xD0	; 208
    2e78:	41 93       	st	Z+, r20
    2e7a:	b3 e0       	ldi	r27, 0x03	; 3
    2e7c:	0f d0       	rcall	.+30     	; 0x2e9c <__ultoa_invert+0x86>
    2e7e:	c9 f7       	brne	.-14     	; 0x2e72 <__ultoa_invert+0x5c>
    2e80:	f6 cf       	rjmp	.-20     	; 0x2e6e <__ultoa_invert+0x58>
    2e82:	46 2f       	mov	r20, r22
    2e84:	4f 70       	andi	r20, 0x0F	; 15
    2e86:	40 5d       	subi	r20, 0xD0	; 208
    2e88:	4a 33       	cpi	r20, 0x3A	; 58
    2e8a:	18 f0       	brcs	.+6      	; 0x2e92 <__ultoa_invert+0x7c>
    2e8c:	49 5d       	subi	r20, 0xD9	; 217
    2e8e:	31 fd       	sbrc	r19, 1
    2e90:	40 52       	subi	r20, 0x20	; 32
    2e92:	41 93       	st	Z+, r20
    2e94:	02 d0       	rcall	.+4      	; 0x2e9a <__ultoa_invert+0x84>
    2e96:	a9 f7       	brne	.-22     	; 0x2e82 <__ultoa_invert+0x6c>
    2e98:	ea cf       	rjmp	.-44     	; 0x2e6e <__ultoa_invert+0x58>
    2e9a:	b4 e0       	ldi	r27, 0x04	; 4
    2e9c:	a6 95       	lsr	r26
    2e9e:	97 95       	ror	r25
    2ea0:	87 95       	ror	r24
    2ea2:	77 95       	ror	r23
    2ea4:	67 95       	ror	r22
    2ea6:	ba 95       	dec	r27
    2ea8:	c9 f7       	brne	.-14     	; 0x2e9c <__ultoa_invert+0x86>
    2eaa:	00 97       	sbiw	r24, 0x00	; 0
    2eac:	61 05       	cpc	r22, r1
    2eae:	71 05       	cpc	r23, r1
    2eb0:	08 95       	ret
    2eb2:	9b 01       	movw	r18, r22
    2eb4:	ac 01       	movw	r20, r24
    2eb6:	0a 2e       	mov	r0, r26
    2eb8:	06 94       	lsr	r0
    2eba:	57 95       	ror	r21
    2ebc:	47 95       	ror	r20
    2ebe:	37 95       	ror	r19
    2ec0:	27 95       	ror	r18
    2ec2:	ba 95       	dec	r27
    2ec4:	c9 f7       	brne	.-14     	; 0x2eb8 <__ultoa_invert+0xa2>
    2ec6:	62 0f       	add	r22, r18
    2ec8:	73 1f       	adc	r23, r19
    2eca:	84 1f       	adc	r24, r20
    2ecc:	95 1f       	adc	r25, r21
    2ece:	a0 1d       	adc	r26, r0
    2ed0:	08 95       	ret

00002ed2 <main>:
#include "apps/modul_init.h"

int main( void ) 
{
	// System initialisieren
	init();
    2ed2:	0e 94 ff 3e 	call	0x7dfe	; 0x7dfe <init>

	// Applikationen initialisieren (http, telnet, cron, .... )
	apps_init();
    2ed6:	0e 94 e4 4b 	call	0x97c8	; 0x97c8 <apps_init>

	// Module initialisieren ( cmd, cgi .... )
	modul_init();
    2eda:	0e 94 ef 4b 	call	0x97de	; 0x97de <modul_init>
	
	// die mainloop, hier wird alles abgearbeitet
	while(1)
	{
		THREAD_mainloop();
    2ede:	0e 94 f7 3f 	call	0x7fee	; 0x7fee <THREAD_mainloop>
    2ee2:	fd cf       	rjmp	.-6      	; 0x2ede <main+0xc>

00002ee4 <EXTINT_init>:

EXT_INT_CALLBACK_FUNC extint_CallBack_Table[ MAX_EXT_INT ];

void EXTINT_init( void )
{
	EICRA = 0;
    2ee4:	10 92 69 00 	sts	0x0069, r1
	#ifdef __AVR_ATmega2561__
		EICRB = 0;
	#endif
}
    2ee8:	08 95       	ret

00002eea <EXTINT_set>:
 * \param 	pFunc					Zeiger auf die Funktion, die bei einem Interrupt aufgerufen werden soll.
 * \retval  						Gibt ERROR_SENSEMODE, ERROR_INTERRUPTNUMBER oder OK zur체ck.
 */
/* -----------------------------------------------------------------------------------------------------------*/
unsigned char EXTINT_set ( unsigned char interrupt_number, unsigned char interrupt_sensemode, EXT_INT_CALLBACK_FUNC pFunc )
{
    2eea:	da 01       	movw	r26, r20
	// ist der der interrupt giltig ?
	if ( interrupt_number < MAX_EXT_INT )
    2eec:	83 30       	cpi	r24, 0x03	; 3
    2eee:	10 f0       	brcs	.+4      	; 0x2ef4 <EXTINT_set+0xa>
    2ef0:	8e ef       	ldi	r24, 0xFE	; 254
    2ef2:	08 95       	ret
	{
		// sensemode g체ltig ?
		if ( interrupt_sensemode < 4 )
    2ef4:	64 30       	cpi	r22, 0x04	; 4
    2ef6:	10 f0       	brcs	.+4      	; 0x2efc <EXTINT_set+0x12>
    2ef8:	8f ef       	ldi	r24, 0xFF	; 255
    2efa:	08 95       	ret
			#endif
			#ifdef __AVR_ATmega644P__
				if ( interrupt_number < 3 )
			#endif
			{
				EICRA &= ~( 3 << ( interrupt_number << 1 ) );
    2efc:	20 91 69 00 	lds	r18, 0x0069
    2f00:	48 2f       	mov	r20, r24
    2f02:	50 e0       	ldi	r21, 0x00	; 0
    2f04:	fa 01       	movw	r30, r20
    2f06:	ee 0f       	add	r30, r30
    2f08:	ff 1f       	adc	r31, r31
    2f0a:	83 e0       	ldi	r24, 0x03	; 3
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	0e 2e       	mov	r0, r30
    2f10:	02 c0       	rjmp	.+4      	; 0x2f16 <EXTINT_set+0x2c>
    2f12:	88 0f       	add	r24, r24
    2f14:	99 1f       	adc	r25, r25
    2f16:	0a 94       	dec	r0
    2f18:	e2 f7       	brpl	.-8      	; 0x2f12 <EXTINT_set+0x28>
    2f1a:	80 95       	com	r24
    2f1c:	82 23       	and	r24, r18
    2f1e:	80 93 69 00 	sts	0x0069, r24
				EICRA |= ( interrupt_sensemode << ( interrupt_number << 1 ) );
    2f22:	20 91 69 00 	lds	r18, 0x0069
    2f26:	86 2f       	mov	r24, r22
    2f28:	90 e0       	ldi	r25, 0x00	; 0
    2f2a:	0e 2e       	mov	r0, r30
    2f2c:	02 c0       	rjmp	.+4      	; 0x2f32 <EXTINT_set+0x48>
    2f2e:	88 0f       	add	r24, r24
    2f30:	99 1f       	adc	r25, r25
    2f32:	0a 94       	dec	r0
    2f34:	e2 f7       	brpl	.-8      	; 0x2f2e <EXTINT_set+0x44>
    2f36:	28 2b       	or	r18, r24
    2f38:	20 93 69 00 	sts	0x0069, r18
		{
			return( ERROR_SENSEMODE );
		}
		
		// CallbackFunc eintragen
		extint_CallBack_Table[ interrupt_number ] = pFunc ;
    2f3c:	e0 50       	subi	r30, 0x00	; 0
    2f3e:	f9 4f       	sbci	r31, 0xF9	; 249
    2f40:	b1 83       	std	Z+1, r27	; 0x01
    2f42:	a0 83       	st	Z, r26
 */
/* -----------------------------------------------------------------------------------------------------------*/
void EXTINT_free ( unsigned char interrupt_number )
{
	if ( interrupt_number < MAX_EXT_INT )
		EIMSK |= ( 1 << interrupt_number );
    2f44:	2d b3       	in	r18, 0x1d	; 29
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	02 c0       	rjmp	.+4      	; 0x2f50 <EXTINT_set+0x66>
    2f4c:	88 0f       	add	r24, r24
    2f4e:	99 1f       	adc	r25, r25
    2f50:	4a 95       	dec	r20
    2f52:	e2 f7       	brpl	.-8      	; 0x2f4c <EXTINT_set+0x62>
    2f54:	28 2b       	or	r18, r24
    2f56:	2d bb       	out	0x1d, r18	; 29
    2f58:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return( ERROR_INTERRUPTNUMBER );
	}
}
    2f5a:	08 95       	ret

00002f5c <EXTINT_free>:
 * \param 	interrupt_number		Nummer des externen Interrupts.
 * \retval	NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/
void EXTINT_free ( unsigned char interrupt_number )
{
    2f5c:	38 2f       	mov	r19, r24
	if ( interrupt_number < MAX_EXT_INT )
    2f5e:	83 30       	cpi	r24, 0x03	; 3
    2f60:	50 f4       	brcc	.+20     	; 0x2f76 <EXTINT_free+0x1a>
		EIMSK |= ( 1 << interrupt_number );
    2f62:	2d b3       	in	r18, 0x1d	; 29
    2f64:	81 e0       	ldi	r24, 0x01	; 1
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	02 c0       	rjmp	.+4      	; 0x2f6e <EXTINT_free+0x12>
    2f6a:	88 0f       	add	r24, r24
    2f6c:	99 1f       	adc	r25, r25
    2f6e:	3a 95       	dec	r19
    2f70:	e2 f7       	brpl	.-8      	; 0x2f6a <EXTINT_free+0xe>
    2f72:	28 2b       	or	r18, r24
    2f74:	2d bb       	out	0x1d, r18	; 29
    2f76:	08 95       	ret

00002f78 <EXTINT_block>:
 * \param 	interrupt_number		Nummer des externen Interrupts.
 * \retval	NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/
void EXTINT_block ( unsigned char interrupt_number )
{
    2f78:	38 2f       	mov	r19, r24
	if ( interrupt_number < MAX_EXT_INT )
    2f7a:	83 30       	cpi	r24, 0x03	; 3
    2f7c:	58 f4       	brcc	.+22     	; 0x2f94 <EXTINT_block+0x1c>
		EIMSK &= ~( 1 << interrupt_number );	
    2f7e:	2d b3       	in	r18, 0x1d	; 29
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	02 c0       	rjmp	.+4      	; 0x2f8a <EXTINT_block+0x12>
    2f86:	88 0f       	add	r24, r24
    2f88:	99 1f       	adc	r25, r25
    2f8a:	3a 95       	dec	r19
    2f8c:	e2 f7       	brpl	.-8      	; 0x2f86 <EXTINT_block+0xe>
    2f8e:	80 95       	com	r24
    2f90:	82 23       	and	r24, r18
    2f92:	8d bb       	out	0x1d, r24	; 29
    2f94:	08 95       	ret

00002f96 <__vector_1>:
}

ISR(INT0_vect)
{
    2f96:	1f 92       	push	r1
    2f98:	0f 92       	push	r0
    2f9a:	0f b6       	in	r0, 0x3f	; 63
    2f9c:	0f 92       	push	r0
    2f9e:	11 24       	eor	r1, r1
    2fa0:	2f 93       	push	r18
    2fa2:	3f 93       	push	r19
    2fa4:	4f 93       	push	r20
    2fa6:	5f 93       	push	r21
    2fa8:	6f 93       	push	r22
    2faa:	7f 93       	push	r23
    2fac:	8f 93       	push	r24
    2fae:	9f 93       	push	r25
    2fb0:	af 93       	push	r26
    2fb2:	bf 93       	push	r27
    2fb4:	ef 93       	push	r30
    2fb6:	ff 93       	push	r31
	extint_CallBack_Table[0]();
    2fb8:	e0 91 00 07 	lds	r30, 0x0700
    2fbc:	f0 91 01 07 	lds	r31, 0x0701
    2fc0:	09 95       	icall
}
    2fc2:	ff 91       	pop	r31
    2fc4:	ef 91       	pop	r30
    2fc6:	bf 91       	pop	r27
    2fc8:	af 91       	pop	r26
    2fca:	9f 91       	pop	r25
    2fcc:	8f 91       	pop	r24
    2fce:	7f 91       	pop	r23
    2fd0:	6f 91       	pop	r22
    2fd2:	5f 91       	pop	r21
    2fd4:	4f 91       	pop	r20
    2fd6:	3f 91       	pop	r19
    2fd8:	2f 91       	pop	r18
    2fda:	0f 90       	pop	r0
    2fdc:	0f be       	out	0x3f, r0	; 63
    2fde:	0f 90       	pop	r0
    2fe0:	1f 90       	pop	r1
    2fe2:	18 95       	reti

00002fe4 <__vector_2>:

ISR(INT1_vect)
{
    2fe4:	1f 92       	push	r1
    2fe6:	0f 92       	push	r0
    2fe8:	0f b6       	in	r0, 0x3f	; 63
    2fea:	0f 92       	push	r0
    2fec:	11 24       	eor	r1, r1
    2fee:	2f 93       	push	r18
    2ff0:	3f 93       	push	r19
    2ff2:	4f 93       	push	r20
    2ff4:	5f 93       	push	r21
    2ff6:	6f 93       	push	r22
    2ff8:	7f 93       	push	r23
    2ffa:	8f 93       	push	r24
    2ffc:	9f 93       	push	r25
    2ffe:	af 93       	push	r26
    3000:	bf 93       	push	r27
    3002:	ef 93       	push	r30
    3004:	ff 93       	push	r31
	extint_CallBack_Table[1]();
    3006:	e0 91 02 07 	lds	r30, 0x0702
    300a:	f0 91 03 07 	lds	r31, 0x0703
    300e:	09 95       	icall
}
    3010:	ff 91       	pop	r31
    3012:	ef 91       	pop	r30
    3014:	bf 91       	pop	r27
    3016:	af 91       	pop	r26
    3018:	9f 91       	pop	r25
    301a:	8f 91       	pop	r24
    301c:	7f 91       	pop	r23
    301e:	6f 91       	pop	r22
    3020:	5f 91       	pop	r21
    3022:	4f 91       	pop	r20
    3024:	3f 91       	pop	r19
    3026:	2f 91       	pop	r18
    3028:	0f 90       	pop	r0
    302a:	0f be       	out	0x3f, r0	; 63
    302c:	0f 90       	pop	r0
    302e:	1f 90       	pop	r1
    3030:	18 95       	reti

00003032 <__vector_3>:

ISR(INT2_vect)
{
    3032:	1f 92       	push	r1
    3034:	0f 92       	push	r0
    3036:	0f b6       	in	r0, 0x3f	; 63
    3038:	0f 92       	push	r0
    303a:	11 24       	eor	r1, r1
    303c:	2f 93       	push	r18
    303e:	3f 93       	push	r19
    3040:	4f 93       	push	r20
    3042:	5f 93       	push	r21
    3044:	6f 93       	push	r22
    3046:	7f 93       	push	r23
    3048:	8f 93       	push	r24
    304a:	9f 93       	push	r25
    304c:	af 93       	push	r26
    304e:	bf 93       	push	r27
    3050:	ef 93       	push	r30
    3052:	ff 93       	push	r31
	extint_CallBack_Table[2]();
    3054:	e0 91 04 07 	lds	r30, 0x0704
    3058:	f0 91 05 07 	lds	r31, 0x0705
    305c:	09 95       	icall
}
    305e:	ff 91       	pop	r31
    3060:	ef 91       	pop	r30
    3062:	bf 91       	pop	r27
    3064:	af 91       	pop	r26
    3066:	9f 91       	pop	r25
    3068:	8f 91       	pop	r24
    306a:	7f 91       	pop	r23
    306c:	6f 91       	pop	r22
    306e:	5f 91       	pop	r21
    3070:	4f 91       	pop	r20
    3072:	3f 91       	pop	r19
    3074:	2f 91       	pop	r18
    3076:	0f 90       	pop	r0
    3078:	0f be       	out	0x3f, r0	; 63
    307a:	0f 90       	pop	r0
    307c:	1f 90       	pop	r1
    307e:	18 95       	reti

00003080 <CLOCK_ReleaseCountdownTimer>:
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/	
void CLOCK_ReleaseCountdownTimer( int counter )
	{
		Counter_Table[ counter ].Resolution = NO_USE ;
    3080:	fc 01       	movw	r30, r24
    3082:	ee 0f       	add	r30, r30
    3084:	ff 1f       	adc	r31, r31
    3086:	ee 0f       	add	r30, r30
    3088:	ff 1f       	adc	r31, r31
    308a:	e8 0f       	add	r30, r24
    308c:	f9 1f       	adc	r31, r25
    308e:	ea 5f       	subi	r30, 0xFA	; 250
    3090:	f8 4f       	sbci	r31, 0xF8	; 248
    3092:	86 e0       	ldi	r24, 0x06	; 6
    3094:	84 83       	std	Z+4, r24	; 0x04
	}
    3096:	08 95       	ret

00003098 <CLOCK_decode_time>:
Beschreibung:    decode_time
decodes the time into the datetime_t struct
Return:        
*************************************************************************/
void CLOCK_decode_time( unsigned long ntp_time )
{
    3098:	a0 e0       	ldi	r26, 0x00	; 0
    309a:	b0 e0       	ldi	r27, 0x00	; 0
    309c:	e2 e5       	ldi	r30, 0x52	; 82
    309e:	f8 e1       	ldi	r31, 0x18	; 24
    30a0:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    30a4:	7b 01       	movw	r14, r22
    30a6:	8c 01       	movw	r16, r24
    unsigned long dayclock;
    unsigned int  dayno;
    unsigned char summertime;

	time.time = ntp_time;
    30a8:	60 93 83 07 	sts	0x0783, r22
    30ac:	70 93 84 07 	sts	0x0784, r23
    30b0:	80 93 85 07 	sts	0x0785, r24
    30b4:	90 93 86 07 	sts	0x0786, r25
	
    time.YY = EPOCH_YR; //=1970
    30b8:	8c e6       	ldi	r24, 0x6C	; 108
    30ba:	97 e0       	ldi	r25, 0x07	; 7
    30bc:	90 93 7e 07 	sts	0x077E, r25
    30c0:	80 93 7d 07 	sts	0x077D, r24
    dayclock = ( ntp_time ) % SECS_DAY;
    30c4:	c8 01       	movw	r24, r16
    30c6:	b7 01       	movw	r22, r14
    30c8:	20 e8       	ldi	r18, 0x80	; 128
    30ca:	31 e5       	ldi	r19, 0x51	; 81
    30cc:	41 e0       	ldi	r20, 0x01	; 1
    30ce:	50 e0       	ldi	r21, 0x00	; 0
    30d0:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    30d4:	d6 2e       	mov	r13, r22
    30d6:	c7 2e       	mov	r12, r23
    30d8:	b8 2e       	mov	r11, r24
    30da:	a9 2e       	mov	r10, r25
    dayno    = ( ntp_time ) / SECS_DAY;
    30dc:	c8 01       	movw	r24, r16
    30de:	b7 01       	movw	r22, r14
    30e0:	20 e8       	ldi	r18, 0x80	; 128
    30e2:	31 e5       	ldi	r19, 0x51	; 81
    30e4:	41 e0       	ldi	r20, 0x01	; 1
    30e6:	50 e0       	ldi	r21, 0x00	; 0
    30e8:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    30ec:	e9 01       	movw	r28, r18

    time.ss = dayclock % 60UL;
    30ee:	6d 2d       	mov	r22, r13
    30f0:	7c 2d       	mov	r23, r12
    30f2:	8b 2d       	mov	r24, r11
    30f4:	9a 2d       	mov	r25, r10
    30f6:	2c e3       	ldi	r18, 0x3C	; 60
    30f8:	30 e0       	ldi	r19, 0x00	; 0
    30fa:	40 e0       	ldi	r20, 0x00	; 0
    30fc:	50 e0       	ldi	r21, 0x00	; 0
    30fe:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    3102:	60 93 77 07 	sts	0x0777, r22
    time.mm = (dayclock % 3600UL) / 60;
    3106:	6d 2d       	mov	r22, r13
    3108:	7c 2d       	mov	r23, r12
    310a:	8b 2d       	mov	r24, r11
    310c:	9a 2d       	mov	r25, r10
    310e:	20 e1       	ldi	r18, 0x10	; 16
    3110:	3e e0       	ldi	r19, 0x0E	; 14
    3112:	40 e0       	ldi	r20, 0x00	; 0
    3114:	50 e0       	ldi	r21, 0x00	; 0
    3116:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    311a:	2c e3       	ldi	r18, 0x3C	; 60
    311c:	30 e0       	ldi	r19, 0x00	; 0
    311e:	40 e0       	ldi	r20, 0x00	; 0
    3120:	50 e0       	ldi	r21, 0x00	; 0
    3122:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    3126:	20 93 78 07 	sts	0x0778, r18
    time.hh   = dayclock / 3600UL;
    312a:	6d 2d       	mov	r22, r13
    312c:	7c 2d       	mov	r23, r12
    312e:	8b 2d       	mov	r24, r11
    3130:	9a 2d       	mov	r25, r10
    3132:	20 e1       	ldi	r18, 0x10	; 16
    3134:	3e e0       	ldi	r19, 0x0E	; 14
    3136:	40 e0       	ldi	r20, 0x00	; 0
    3138:	50 e0       	ldi	r21, 0x00	; 0
    313a:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    313e:	20 93 79 07 	sts	0x0779, r18
    time.WW   = (dayno + 4) % 7;      // day 0 was a thursday
    3142:	ce 01       	movw	r24, r28
    3144:	04 96       	adiw	r24, 0x04	; 4
    3146:	67 e0       	ldi	r22, 0x07	; 7
    3148:	70 e0       	ldi	r23, 0x00	; 0
    314a:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    314e:	80 93 7a 07 	sts	0x077A, r24
    3152:	2c c0       	rjmp	.+88     	; 0x31ac <CLOCK_decode_time+0x114>

    while (dayno >= YEARSIZE( time.YY ) )
    {
        dayno -= YEARSIZE( time.YY );
    3154:	80 91 7d 07 	lds	r24, 0x077D
    3158:	90 91 7e 07 	lds	r25, 0x077E
    315c:	83 70       	andi	r24, 0x03	; 3
    315e:	90 70       	andi	r25, 0x00	; 0
    3160:	89 2b       	or	r24, r25
    3162:	b9 f4       	brne	.+46     	; 0x3192 <CLOCK_decode_time+0xfa>
    3164:	80 91 7d 07 	lds	r24, 0x077D
    3168:	90 91 7e 07 	lds	r25, 0x077E
    316c:	64 e6       	ldi	r22, 0x64	; 100
    316e:	70 e0       	ldi	r23, 0x00	; 0
    3170:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    3174:	89 2b       	or	r24, r25
    3176:	51 f4       	brne	.+20     	; 0x318c <CLOCK_decode_time+0xf4>
    3178:	80 91 7d 07 	lds	r24, 0x077D
    317c:	90 91 7e 07 	lds	r25, 0x077E
    3180:	60 e9       	ldi	r22, 0x90	; 144
    3182:	71 e0       	ldi	r23, 0x01	; 1
    3184:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    3188:	89 2b       	or	r24, r25
    318a:	19 f4       	brne	.+6      	; 0x3192 <CLOCK_decode_time+0xfa>
    318c:	8e e6       	ldi	r24, 0x6E	; 110
    318e:	91 e0       	ldi	r25, 0x01	; 1
    3190:	02 c0       	rjmp	.+4      	; 0x3196 <CLOCK_decode_time+0xfe>
    3192:	8d e6       	ldi	r24, 0x6D	; 109
    3194:	91 e0       	ldi	r25, 0x01	; 1
    3196:	c8 1b       	sub	r28, r24
    3198:	d9 0b       	sbc	r29, r25
        time.YY++;
    319a:	80 91 7d 07 	lds	r24, 0x077D
    319e:	90 91 7e 07 	lds	r25, 0x077E
    31a2:	01 96       	adiw	r24, 0x01	; 1
    31a4:	90 93 7e 07 	sts	0x077E, r25
    31a8:	80 93 7d 07 	sts	0x077D, r24
    time.ss = dayclock % 60UL;
    time.mm = (dayclock % 3600UL) / 60;
    time.hh   = dayclock / 3600UL;
    time.WW   = (dayno + 4) % 7;      // day 0 was a thursday

    while (dayno >= YEARSIZE( time.YY ) )
    31ac:	80 91 7d 07 	lds	r24, 0x077D
    31b0:	90 91 7e 07 	lds	r25, 0x077E
    31b4:	83 70       	andi	r24, 0x03	; 3
    31b6:	90 70       	andi	r25, 0x00	; 0
    31b8:	89 2b       	or	r24, r25
    31ba:	b9 f4       	brne	.+46     	; 0x31ea <CLOCK_decode_time+0x152>
    31bc:	80 91 7d 07 	lds	r24, 0x077D
    31c0:	90 91 7e 07 	lds	r25, 0x077E
    31c4:	64 e6       	ldi	r22, 0x64	; 100
    31c6:	70 e0       	ldi	r23, 0x00	; 0
    31c8:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    31cc:	89 2b       	or	r24, r25
    31ce:	51 f4       	brne	.+20     	; 0x31e4 <CLOCK_decode_time+0x14c>
    31d0:	80 91 7d 07 	lds	r24, 0x077D
    31d4:	90 91 7e 07 	lds	r25, 0x077E
    31d8:	60 e9       	ldi	r22, 0x90	; 144
    31da:	71 e0       	ldi	r23, 0x01	; 1
    31dc:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    31e0:	89 2b       	or	r24, r25
    31e2:	19 f4       	brne	.+6      	; 0x31ea <CLOCK_decode_time+0x152>
    31e4:	8e e6       	ldi	r24, 0x6E	; 110
    31e6:	91 e0       	ldi	r25, 0x01	; 1
    31e8:	02 c0       	rjmp	.+4      	; 0x31ee <CLOCK_decode_time+0x156>
    31ea:	8d e6       	ldi	r24, 0x6D	; 109
    31ec:	91 e0       	ldi	r25, 0x01	; 1
    31ee:	c8 17       	cp	r28, r24
    31f0:	d9 07       	cpc	r29, r25
    31f2:	08 f0       	brcs	.+2      	; 0x31f6 <CLOCK_decode_time+0x15e>
    31f4:	af cf       	rjmp	.-162    	; 0x3154 <CLOCK_decode_time+0xbc>
    {
        dayno -= YEARSIZE( time.YY );
        time.YY++;
    }

    time.MM = 0;
    31f6:	10 92 7c 07 	sts	0x077C, r1
    31fa:	3c c0       	rjmp	.+120    	; 0x3274 <CLOCK_decode_time+0x1dc>
    while ( dayno >= CLOCK_monthlen( LEAPYEAR( time.YY ) , time.MM ) )
    {
        dayno -= CLOCK_monthlen(LEAPYEAR( time.YY ) , time.MM );
    31fc:	80 91 7d 07 	lds	r24, 0x077D
    3200:	90 91 7e 07 	lds	r25, 0x077E
    3204:	83 70       	andi	r24, 0x03	; 3
    3206:	90 70       	andi	r25, 0x00	; 0
    3208:	89 2b       	or	r24, r25
    320a:	19 f0       	breq	.+6      	; 0x3212 <CLOCK_decode_time+0x17a>
    320c:	80 e0       	ldi	r24, 0x00	; 0
    320e:	90 e0       	ldi	r25, 0x00	; 0
    3210:	1c c0       	rjmp	.+56     	; 0x324a <CLOCK_decode_time+0x1b2>
    3212:	80 91 7d 07 	lds	r24, 0x077D
    3216:	90 91 7e 07 	lds	r25, 0x077E
    321a:	64 e6       	ldi	r22, 0x64	; 100
    321c:	70 e0       	ldi	r23, 0x00	; 0
    321e:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    3222:	89 2b       	or	r24, r25
    3224:	19 f0       	breq	.+6      	; 0x322c <CLOCK_decode_time+0x194>
    3226:	81 e0       	ldi	r24, 0x01	; 1
    3228:	90 e0       	ldi	r25, 0x00	; 0
    322a:	0f c0       	rjmp	.+30     	; 0x324a <CLOCK_decode_time+0x1b2>
    322c:	80 91 7d 07 	lds	r24, 0x077D
    3230:	90 91 7e 07 	lds	r25, 0x077E
    3234:	20 e0       	ldi	r18, 0x00	; 0
    3236:	30 e0       	ldi	r19, 0x00	; 0
    3238:	60 e9       	ldi	r22, 0x90	; 144
    323a:	71 e0       	ldi	r23, 0x01	; 1
    323c:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    3240:	89 2b       	or	r24, r25
    3242:	11 f4       	brne	.+4      	; 0x3248 <CLOCK_decode_time+0x1b0>
    3244:	21 e0       	ldi	r18, 0x01	; 1
    3246:	30 e0       	ldi	r19, 0x00	; 0
    3248:	c9 01       	movw	r24, r18
    324a:	20 91 7c 07 	lds	r18, 0x077C
Inputs: isleapyear = 0-1, month=0-11
Return:  Number of days per month
*************************************************************************/
unsigned char CLOCK_monthlen(unsigned char isleapyear,unsigned char month)
{
    if (month == 1)
    324e:	21 30       	cpi	r18, 0x01	; 1
    3250:	11 f4       	brne	.+4      	; 0x3256 <CLOCK_decode_time+0x1be>
    {
        return (28+isleapyear);
    3252:	84 5e       	subi	r24, 0xE4	; 228
    3254:	08 c0       	rjmp	.+16     	; 0x3266 <CLOCK_decode_time+0x1ce>
    }

    if (month > 6)
    3256:	27 30       	cpi	r18, 0x07	; 7
    3258:	08 f0       	brcs	.+2      	; 0x325c <CLOCK_decode_time+0x1c4>
    {
        month--;
    325a:	21 50       	subi	r18, 0x01	; 1
    }

    if (month %2 == 1)
    325c:	20 fd       	sbrc	r18, 0
    325e:	02 c0       	rjmp	.+4      	; 0x3264 <CLOCK_decode_time+0x1cc>
    3260:	8f e1       	ldi	r24, 0x1F	; 31
    3262:	01 c0       	rjmp	.+2      	; 0x3266 <CLOCK_decode_time+0x1ce>
    3264:	8e e1       	ldi	r24, 0x1E	; 30
    }

    time.MM = 0;
    while ( dayno >= CLOCK_monthlen( LEAPYEAR( time.YY ) , time.MM ) )
    {
        dayno -= CLOCK_monthlen(LEAPYEAR( time.YY ) , time.MM );
    3266:	c8 1b       	sub	r28, r24
    3268:	d1 09       	sbc	r29, r1
        time.MM++;
    326a:	80 91 7c 07 	lds	r24, 0x077C
    326e:	8f 5f       	subi	r24, 0xFF	; 255
    3270:	80 93 7c 07 	sts	0x077C, r24
        dayno -= YEARSIZE( time.YY );
        time.YY++;
    }

    time.MM = 0;
    while ( dayno >= CLOCK_monthlen( LEAPYEAR( time.YY ) , time.MM ) )
    3274:	80 91 7d 07 	lds	r24, 0x077D
    3278:	90 91 7e 07 	lds	r25, 0x077E
    327c:	83 70       	andi	r24, 0x03	; 3
    327e:	90 70       	andi	r25, 0x00	; 0
    3280:	89 2b       	or	r24, r25
    3282:	19 f0       	breq	.+6      	; 0x328a <CLOCK_decode_time+0x1f2>
    3284:	80 e0       	ldi	r24, 0x00	; 0
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	1c c0       	rjmp	.+56     	; 0x32c2 <CLOCK_decode_time+0x22a>
    328a:	80 91 7d 07 	lds	r24, 0x077D
    328e:	90 91 7e 07 	lds	r25, 0x077E
    3292:	64 e6       	ldi	r22, 0x64	; 100
    3294:	70 e0       	ldi	r23, 0x00	; 0
    3296:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    329a:	89 2b       	or	r24, r25
    329c:	19 f0       	breq	.+6      	; 0x32a4 <CLOCK_decode_time+0x20c>
    329e:	81 e0       	ldi	r24, 0x01	; 1
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	0f c0       	rjmp	.+30     	; 0x32c2 <CLOCK_decode_time+0x22a>
    32a4:	80 91 7d 07 	lds	r24, 0x077D
    32a8:	90 91 7e 07 	lds	r25, 0x077E
    32ac:	20 e0       	ldi	r18, 0x00	; 0
    32ae:	30 e0       	ldi	r19, 0x00	; 0
    32b0:	60 e9       	ldi	r22, 0x90	; 144
    32b2:	71 e0       	ldi	r23, 0x01	; 1
    32b4:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    32b8:	89 2b       	or	r24, r25
    32ba:	11 f4       	brne	.+4      	; 0x32c0 <CLOCK_decode_time+0x228>
    32bc:	21 e0       	ldi	r18, 0x01	; 1
    32be:	30 e0       	ldi	r19, 0x00	; 0
    32c0:	c9 01       	movw	r24, r18
    32c2:	20 91 7c 07 	lds	r18, 0x077C
Inputs: isleapyear = 0-1, month=0-11
Return:  Number of days per month
*************************************************************************/
unsigned char CLOCK_monthlen(unsigned char isleapyear,unsigned char month)
{
    if (month == 1)
    32c6:	21 30       	cpi	r18, 0x01	; 1
    32c8:	11 f4       	brne	.+4      	; 0x32ce <CLOCK_decode_time+0x236>
    {
        return (28+isleapyear);
    32ca:	84 5e       	subi	r24, 0xE4	; 228
    32cc:	08 c0       	rjmp	.+16     	; 0x32de <CLOCK_decode_time+0x246>
    }

    if (month > 6)
    32ce:	27 30       	cpi	r18, 0x07	; 7
    32d0:	08 f0       	brcs	.+2      	; 0x32d4 <CLOCK_decode_time+0x23c>
    {
        month--;
    32d2:	21 50       	subi	r18, 0x01	; 1
    }

    if (month %2 == 1)
    32d4:	20 fd       	sbrc	r18, 0
    32d6:	02 c0       	rjmp	.+4      	; 0x32dc <CLOCK_decode_time+0x244>
    32d8:	8f e1       	ldi	r24, 0x1F	; 31
    32da:	01 c0       	rjmp	.+2      	; 0x32de <CLOCK_decode_time+0x246>
    32dc:	8e e1       	ldi	r24, 0x1E	; 30
        dayno -= YEARSIZE( time.YY );
        time.YY++;
    }

    time.MM = 0;
    while ( dayno >= CLOCK_monthlen( LEAPYEAR( time.YY ) , time.MM ) )
    32de:	90 e0       	ldi	r25, 0x00	; 0
    32e0:	c8 17       	cp	r28, r24
    32e2:	d9 07       	cpc	r29, r25
    32e4:	08 f0       	brcs	.+2      	; 0x32e8 <CLOCK_decode_time+0x250>
    32e6:	8a cf       	rjmp	.-236    	; 0x31fc <CLOCK_decode_time+0x164>
    {
        dayno -= CLOCK_monthlen(LEAPYEAR( time.YY ) , time.MM );
        time.MM++;
    }
    time.MM++;
    32e8:	80 91 7c 07 	lds	r24, 0x077C
    32ec:	8f 5f       	subi	r24, 0xFF	; 255
    32ee:	80 93 7c 07 	sts	0x077C, r24
    time.DD  = dayno+1;
    32f2:	9e 01       	movw	r18, r28
    32f4:	2f 5f       	subi	r18, 0xFF	; 255
    32f6:	20 93 7b 07 	sts	0x077B, r18

    // Summertime
    summertime = 1;
    if ( time.MM < 3 || time.MM > 10)     // month 1, 2, 11, 12
    32fa:	80 91 7c 07 	lds	r24, 0x077C
    32fe:	83 30       	cpi	r24, 0x03	; 3
    3300:	10 f4       	brcc	.+4      	; 0x3306 <CLOCK_decode_time+0x26e>
    3302:	30 e0       	ldi	r19, 0x00	; 0
    3304:	08 c0       	rjmp	.+16     	; 0x3316 <CLOCK_decode_time+0x27e>
    3306:	80 91 7c 07 	lds	r24, 0x077C
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	8b 30       	cpi	r24, 0x0B	; 11
    330e:	08 f0       	brcs	.+2      	; 0x3312 <CLOCK_decode_time+0x27a>
    3310:	31 e0       	ldi	r19, 0x01	; 1
    3312:	81 e0       	ldi	r24, 0x01	; 1
    3314:	38 27       	eor	r19, r24
    {
        summertime = 0;                          // -> Winter
    }

    if ( ( time.DD - time.WW >= 25 ) && ( time.WW || time.hh >= 2) )
    3316:	80 91 7b 07 	lds	r24, 0x077B
    331a:	20 91 7a 07 	lds	r18, 0x077A
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	82 1b       	sub	r24, r18
    3322:	91 09       	sbc	r25, r1
    3324:	49 97       	sbiw	r24, 0x19	; 25
    3326:	6c f0       	brlt	.+26     	; 0x3342 <CLOCK_decode_time+0x2aa>
    3328:	80 91 7a 07 	lds	r24, 0x077A
    332c:	88 23       	and	r24, r24
    332e:	21 f4       	brne	.+8      	; 0x3338 <CLOCK_decode_time+0x2a0>
    3330:	80 91 79 07 	lds	r24, 0x0779
    3334:	82 30       	cpi	r24, 0x02	; 2
    3336:	28 f0       	brcs	.+10     	; 0x3342 <CLOCK_decode_time+0x2aa>
    {                              // after last Sunday 2:00
        if ( time.MM == 10 )        // October -> Winter
    3338:	80 91 7c 07 	lds	r24, 0x077C
    333c:	8a 30       	cpi	r24, 0x0A	; 10
    333e:	31 f4       	brne	.+12     	; 0x334c <CLOCK_decode_time+0x2b4>
    3340:	64 c0       	rjmp	.+200    	; 0x340a <CLOCK_decode_time+0x372>
            summertime = 0;
        }
    }
    else
    {                              // before last Sunday 2:00
        if ( time.MM == 3)        // March -> Winter
    3342:	80 91 7c 07 	lds	r24, 0x077C
    3346:	83 30       	cpi	r24, 0x03	; 3
    3348:	09 f4       	brne	.+2      	; 0x334c <CLOCK_decode_time+0x2b4>
    334a:	5f c0       	rjmp	.+190    	; 0x340a <CLOCK_decode_time+0x372>
        {
            summertime = 0;
        }
    }

    if (summertime)
    334c:	33 23       	and	r19, r19
    334e:	09 f4       	brne	.+2      	; 0x3352 <CLOCK_decode_time+0x2ba>
    3350:	5c c0       	rjmp	.+184    	; 0x340a <CLOCK_decode_time+0x372>
    {
        time.hh++;              // add one hour
    3352:	80 91 79 07 	lds	r24, 0x0779
    3356:	8f 5f       	subi	r24, 0xFF	; 255
    3358:	80 93 79 07 	sts	0x0779, r24
        if ( time.hh == 24)
    335c:	80 91 79 07 	lds	r24, 0x0779
    3360:	88 31       	cpi	r24, 0x18	; 24
    3362:	09 f0       	breq	.+2      	; 0x3366 <CLOCK_decode_time+0x2ce>
    3364:	52 c0       	rjmp	.+164    	; 0x340a <CLOCK_decode_time+0x372>
        {                        // next day
            time.hh = 0;
    3366:	10 92 79 07 	sts	0x0779, r1
            time.WW++;            // next weekday
    336a:	80 91 7a 07 	lds	r24, 0x077A
    336e:	8f 5f       	subi	r24, 0xFF	; 255
    3370:	80 93 7a 07 	sts	0x077A, r24
            if ( time.WW == 7 )
    3374:	80 91 7a 07 	lds	r24, 0x077A
    3378:	87 30       	cpi	r24, 0x07	; 7
    337a:	11 f4       	brne	.+4      	; 0x3380 <CLOCK_decode_time+0x2e8>
            {
                time.WW = 0;
    337c:	10 92 7a 07 	sts	0x077A, r1
            }
            if ( time.DD == CLOCK_monthlen( LEAPYEAR( time.YY ) , time.MM ) )
    3380:	40 91 7b 07 	lds	r20, 0x077B
    3384:	80 91 7d 07 	lds	r24, 0x077D
    3388:	90 91 7e 07 	lds	r25, 0x077E
    338c:	83 70       	andi	r24, 0x03	; 3
    338e:	90 70       	andi	r25, 0x00	; 0
    3390:	89 2b       	or	r24, r25
    3392:	19 f0       	breq	.+6      	; 0x339a <CLOCK_decode_time+0x302>
    3394:	80 e0       	ldi	r24, 0x00	; 0
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	1c c0       	rjmp	.+56     	; 0x33d2 <CLOCK_decode_time+0x33a>
    339a:	80 91 7d 07 	lds	r24, 0x077D
    339e:	90 91 7e 07 	lds	r25, 0x077E
    33a2:	64 e6       	ldi	r22, 0x64	; 100
    33a4:	70 e0       	ldi	r23, 0x00	; 0
    33a6:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    33aa:	89 2b       	or	r24, r25
    33ac:	19 f0       	breq	.+6      	; 0x33b4 <CLOCK_decode_time+0x31c>
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	90 e0       	ldi	r25, 0x00	; 0
    33b2:	0f c0       	rjmp	.+30     	; 0x33d2 <CLOCK_decode_time+0x33a>
    33b4:	80 91 7d 07 	lds	r24, 0x077D
    33b8:	90 91 7e 07 	lds	r25, 0x077E
    33bc:	20 e0       	ldi	r18, 0x00	; 0
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	60 e9       	ldi	r22, 0x90	; 144
    33c2:	71 e0       	ldi	r23, 0x01	; 1
    33c4:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    33c8:	89 2b       	or	r24, r25
    33ca:	11 f4       	brne	.+4      	; 0x33d0 <CLOCK_decode_time+0x338>
    33cc:	21 e0       	ldi	r18, 0x01	; 1
    33ce:	30 e0       	ldi	r19, 0x00	; 0
    33d0:	c9 01       	movw	r24, r18
    33d2:	20 91 7c 07 	lds	r18, 0x077C
Inputs: isleapyear = 0-1, month=0-11
Return:  Number of days per month
*************************************************************************/
unsigned char CLOCK_monthlen(unsigned char isleapyear,unsigned char month)
{
    if (month == 1)
    33d6:	21 30       	cpi	r18, 0x01	; 1
    33d8:	11 f4       	brne	.+4      	; 0x33de <CLOCK_decode_time+0x346>
    {
        return (28+isleapyear);
    33da:	84 5e       	subi	r24, 0xE4	; 228
    33dc:	08 c0       	rjmp	.+16     	; 0x33ee <CLOCK_decode_time+0x356>
    }

    if (month > 6)
    33de:	27 30       	cpi	r18, 0x07	; 7
    33e0:	08 f0       	brcs	.+2      	; 0x33e4 <CLOCK_decode_time+0x34c>
    {
        month--;
    33e2:	21 50       	subi	r18, 0x01	; 1
    }

    if (month %2 == 1)
    33e4:	20 fd       	sbrc	r18, 0
    33e6:	02 c0       	rjmp	.+4      	; 0x33ec <CLOCK_decode_time+0x354>
    33e8:	8f e1       	ldi	r24, 0x1F	; 31
    33ea:	01 c0       	rjmp	.+2      	; 0x33ee <CLOCK_decode_time+0x356>
    33ec:	8e e1       	ldi	r24, 0x1E	; 30
            time.WW++;            // next weekday
            if ( time.WW == 7 )
            {
                time.WW = 0;
            }
            if ( time.DD == CLOCK_monthlen( LEAPYEAR( time.YY ) , time.MM ) )
    33ee:	48 17       	cp	r20, r24
    33f0:	39 f4       	brne	.+14     	; 0x3400 <CLOCK_decode_time+0x368>
            {                // next month
                time.DD = 0;
    33f2:	10 92 7b 07 	sts	0x077B, r1
                time.MM++;
    33f6:	80 91 7c 07 	lds	r24, 0x077C
    33fa:	8f 5f       	subi	r24, 0xFF	; 255
    33fc:	80 93 7c 07 	sts	0x077C, r24
            }
            time.DD++;
    3400:	80 91 7b 07 	lds	r24, 0x077B
    3404:	8f 5f       	subi	r24, 0xFF	; 255
    3406:	80 93 7b 07 	sts	0x077B, r24
        }
    }
}
    340a:	cd b7       	in	r28, 0x3d	; 61
    340c:	de b7       	in	r29, 0x3e	; 62
    340e:	ea e0       	ldi	r30, 0x0A	; 10
    3410:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00003414 <CLOCK_tick>:
/*-----------------------------------------------------------------------------------------------------------*/
/*! \brief Die ISR der Clock, hier werden die Uhrzeit und Callbackeintr채ge abgearbeitet
 */
/*------------------------------------------------------------------------------------------------------------*/
void CLOCK_tick( void )
	{			
    3414:	0f 93       	push	r16
    3416:	1f 93       	push	r17
    3418:	cf 93       	push	r28
    341a:	df 93       	push	r29
		unsigned char state;
		unsigned int i;
		time.ms++;
    341c:	80 91 76 07 	lds	r24, 0x0776
    3420:	8f 5f       	subi	r24, 0xFF	; 255
    3422:	80 93 76 07 	sts	0x0776, r24
		state = MSECOUND;
		if ( time.ms == 100 )
    3426:	80 91 76 07 	lds	r24, 0x0776
    342a:	84 36       	cpi	r24, 0x64	; 100
    342c:	11 f0       	breq	.+4      	; 0x3432 <CLOCK_tick+0x1e>
    342e:	11 e0       	ldi	r17, 0x01	; 1
    3430:	5a c0       	rjmp	.+180    	; 0x34e6 <CLOCK_tick+0xd2>
		{
			time.ms = 0;
    3432:	10 92 76 07 	sts	0x0776, r1
			time.ss++;
    3436:	80 91 77 07 	lds	r24, 0x0777
    343a:	8f 5f       	subi	r24, 0xFF	; 255
    343c:	80 93 77 07 	sts	0x0777, r24
			time.uptime++;
    3440:	80 91 7f 07 	lds	r24, 0x077F
    3444:	90 91 80 07 	lds	r25, 0x0780
    3448:	a0 91 81 07 	lds	r26, 0x0781
    344c:	b0 91 82 07 	lds	r27, 0x0782
    3450:	01 96       	adiw	r24, 0x01	; 1
    3452:	a1 1d       	adc	r26, r1
    3454:	b1 1d       	adc	r27, r1
    3456:	80 93 7f 07 	sts	0x077F, r24
    345a:	90 93 80 07 	sts	0x0780, r25
    345e:	a0 93 81 07 	sts	0x0781, r26
    3462:	b0 93 82 07 	sts	0x0782, r27
			time.time++;
    3466:	80 91 83 07 	lds	r24, 0x0783
    346a:	90 91 84 07 	lds	r25, 0x0784
    346e:	a0 91 85 07 	lds	r26, 0x0785
    3472:	b0 91 86 07 	lds	r27, 0x0786
    3476:	01 96       	adiw	r24, 0x01	; 1
    3478:	a1 1d       	adc	r26, r1
    347a:	b1 1d       	adc	r27, r1
    347c:	80 93 83 07 	sts	0x0783, r24
    3480:	90 93 84 07 	sts	0x0784, r25
    3484:	a0 93 85 07 	sts	0x0785, r26
    3488:	b0 93 86 07 	sts	0x0786, r27
			state = SECOUND;
			if ( time.ss == 60 )
    348c:	80 91 77 07 	lds	r24, 0x0777
    3490:	8c 33       	cpi	r24, 0x3C	; 60
    3492:	11 f0       	breq	.+4      	; 0x3498 <CLOCK_tick+0x84>
    3494:	12 e0       	ldi	r17, 0x02	; 2
    3496:	27 c0       	rjmp	.+78     	; 0x34e6 <CLOCK_tick+0xd2>
			{
				time.ss = 0;
    3498:	10 92 77 07 	sts	0x0777, r1
				time.mm++;
    349c:	80 91 78 07 	lds	r24, 0x0778
    34a0:	8f 5f       	subi	r24, 0xFF	; 255
    34a2:	80 93 78 07 	sts	0x0778, r24
				state = MINUTE;
				if ( time.mm == 60 )
    34a6:	80 91 78 07 	lds	r24, 0x0778
    34aa:	8c 33       	cpi	r24, 0x3C	; 60
    34ac:	11 f0       	breq	.+4      	; 0x34b2 <CLOCK_tick+0x9e>
    34ae:	13 e0       	ldi	r17, 0x03	; 3
    34b0:	1a c0       	rjmp	.+52     	; 0x34e6 <CLOCK_tick+0xd2>
				{
					time.mm = 0;
    34b2:	10 92 78 07 	sts	0x0778, r1
					time.hh++;
    34b6:	80 91 79 07 	lds	r24, 0x0779
    34ba:	8f 5f       	subi	r24, 0xFF	; 255
    34bc:	80 93 79 07 	sts	0x0779, r24
					state = HOUR;
					CLOCK_decode_time( time.time );
    34c0:	60 91 83 07 	lds	r22, 0x0783
    34c4:	70 91 84 07 	lds	r23, 0x0784
    34c8:	80 91 85 07 	lds	r24, 0x0785
    34cc:	90 91 86 07 	lds	r25, 0x0786
    34d0:	0e 94 4c 18 	call	0x3098	; 0x3098 <CLOCK_decode_time>

					if ( time.hh == 24 )
    34d4:	80 91 79 07 	lds	r24, 0x0779
    34d8:	88 31       	cpi	r24, 0x18	; 24
    34da:	11 f0       	breq	.+4      	; 0x34e0 <CLOCK_tick+0xcc>
    34dc:	14 e0       	ldi	r17, 0x04	; 4
    34de:	03 c0       	rjmp	.+6      	; 0x34e6 <CLOCK_tick+0xd2>
					{
						time.hh = 0;
    34e0:	10 92 79 07 	sts	0x0779, r1
    34e4:	15 e0       	ldi	r17, 0x05	; 5
    34e6:	c0 e0       	ldi	r28, 0x00	; 0
    34e8:	d0 e0       	ldi	r29, 0x00	; 0
		for ( i = 0; i < MAX_CLOCK_CALLBACKS ; i++ )
		{
			if ( Clock_CallBack_Table[i].Resolution <= state )
			{
				if ( state >= SECOUND )
					Clock_CallBack_Table[i].Execution = Executionbit;
    34ea:	01 e0       	ldi	r16, 0x01	; 1
		}
				
		// alle Callbacks durchgehen und alles was gr철er Resolution MSECOUND als Execution markieren f체r sp채tere ausf체hrung
		for ( i = 0; i < MAX_CLOCK_CALLBACKS ; i++ )
		{
			if ( Clock_CallBack_Table[i].Resolution <= state )
    34ec:	fe 01       	movw	r30, r28
    34ee:	ee 0f       	add	r30, r30
    34f0:	ff 1f       	adc	r31, r31
    34f2:	ee 0f       	add	r30, r30
    34f4:	ff 1f       	adc	r31, r31
    34f6:	e8 5a       	subi	r30, 0xA8	; 168
    34f8:	f8 4f       	sbci	r31, 0xF8	; 248
    34fa:	80 81       	ld	r24, Z
    34fc:	18 17       	cp	r17, r24
    34fe:	90 f0       	brcs	.+36     	; 0x3524 <CLOCK_tick+0x110>
    3500:	fe 01       	movw	r30, r28
    3502:	ee 0f       	add	r30, r30
    3504:	ff 1f       	adc	r31, r31
    3506:	ee 0f       	add	r30, r30
    3508:	ff 1f       	adc	r31, r31
			{
				if ( state >= SECOUND )
    350a:	12 30       	cpi	r17, 0x02	; 2
    350c:	20 f0       	brcs	.+8      	; 0x3516 <CLOCK_tick+0x102>
					Clock_CallBack_Table[i].Execution = Executionbit;
    350e:	ea 5a       	subi	r30, 0xAA	; 170
    3510:	f8 4f       	sbci	r31, 0xF8	; 248
    3512:	03 83       	std	Z+3, r16	; 0x03
    3514:	07 c0       	rjmp	.+14     	; 0x3524 <CLOCK_tick+0x110>
				else
				{
					Clock_CallBack_Table[i].Execution = NonExecutionbit;
    3516:	ea 5a       	subi	r30, 0xAA	; 170
    3518:	f8 4f       	sbci	r31, 0xF8	; 248
    351a:	13 82       	std	Z+3, r1	; 0x03
					Clock_CallBack_Table[i].CallbackFunc();
    351c:	01 90       	ld	r0, Z+
    351e:	f0 81       	ld	r31, Z
    3520:	e0 2d       	mov	r30, r0
    3522:	09 95       	icall
				}
			}
		}
				
		// alle Callbacks durchgehen und alles was gr철er Resolution MSECOUND als Execution markieren f체r sp채tere ausf체hrung
		for ( i = 0; i < MAX_CLOCK_CALLBACKS ; i++ )
    3524:	21 96       	adiw	r28, 0x01	; 1
    3526:	c8 30       	cpi	r28, 0x08	; 8
    3528:	d1 05       	cpc	r29, r1
    352a:	01 f7       	brne	.-64     	; 0x34ec <CLOCK_tick+0xd8>
    352c:	20 e0       	ldi	r18, 0x00	; 0
    352e:	30 e0       	ldi	r19, 0x00	; 0
		}

		// Hier werden die als Execution markierten Callbacks ausgef체hrt, je durchlauf einer
		for ( i = 0; i < MAX_CLOCK_CALLBACKS ; i++ )
		{
			if ( Clock_CallBack_Table[i].Execution == Executionbit )
    3530:	f9 01       	movw	r30, r18
    3532:	ee 0f       	add	r30, r30
    3534:	ff 1f       	adc	r31, r31
    3536:	ee 0f       	add	r30, r30
    3538:	ff 1f       	adc	r31, r31
    353a:	ea 5a       	subi	r30, 0xAA	; 170
    353c:	f8 4f       	sbci	r31, 0xF8	; 248
    353e:	df 01       	movw	r26, r30
    3540:	13 96       	adiw	r26, 0x03	; 3
    3542:	83 81       	ldd	r24, Z+3	; 0x03
    3544:	81 30       	cpi	r24, 0x01	; 1
    3546:	41 f4       	brne	.+16     	; 0x3558 <CLOCK_tick+0x144>
			{
				Clock_CallBack_Table[i].Execution = NonExecutionbit;
    3548:	1c 92       	st	X, r1
				Clock_CallBack_Table[i].CallbackFunc();
    354a:	01 90       	ld	r0, Z+
    354c:	f0 81       	ld	r31, Z
    354e:	e0 2d       	mov	r30, r0
    3550:	09 95       	icall
    3552:	20 e0       	ldi	r18, 0x00	; 0
    3554:	30 e0       	ldi	r19, 0x00	; 0
    3556:	06 c0       	rjmp	.+12     	; 0x3564 <CLOCK_tick+0x150>
				}
			}
		}

		// Hier werden die als Execution markierten Callbacks ausgef체hrt, je durchlauf einer
		for ( i = 0; i < MAX_CLOCK_CALLBACKS ; i++ )
    3558:	2f 5f       	subi	r18, 0xFF	; 255
    355a:	3f 4f       	sbci	r19, 0xFF	; 255
    355c:	28 30       	cpi	r18, 0x08	; 8
    355e:	31 05       	cpc	r19, r1
    3560:	39 f7       	brne	.-50     	; 0x3530 <CLOCK_tick+0x11c>
    3562:	f7 cf       	rjmp	.-18     	; 0x3552 <CLOCK_tick+0x13e>
			}
		}
		
		for ( i = 0 ; i < MAX_CLOCK_COUNTDOWNTIMER ; i++ )
		{
			if ( Counter_Table[i].Resolution <= state && Counter_Table[i].Counter != 0 )
    3564:	f9 01       	movw	r30, r18
    3566:	ee 0f       	add	r30, r30
    3568:	ff 1f       	adc	r31, r31
    356a:	ee 0f       	add	r30, r30
    356c:	ff 1f       	adc	r31, r31
    356e:	e2 0f       	add	r30, r18
    3570:	f3 1f       	adc	r31, r19
    3572:	ea 5f       	subi	r30, 0xFA	; 250
    3574:	f8 4f       	sbci	r31, 0xF8	; 248
    3576:	84 81       	ldd	r24, Z+4	; 0x04
    3578:	18 17       	cp	r17, r24
    357a:	98 f0       	brcs	.+38     	; 0x35a2 <CLOCK_tick+0x18e>
    357c:	80 81       	ld	r24, Z
    357e:	91 81       	ldd	r25, Z+1	; 0x01
    3580:	a2 81       	ldd	r26, Z+2	; 0x02
    3582:	b3 81       	ldd	r27, Z+3	; 0x03
    3584:	00 97       	sbiw	r24, 0x00	; 0
    3586:	a1 05       	cpc	r26, r1
    3588:	b1 05       	cpc	r27, r1
    358a:	59 f0       	breq	.+22     	; 0x35a2 <CLOCK_tick+0x18e>
			{
				Counter_Table[i].Counter--;
    358c:	80 81       	ld	r24, Z
    358e:	91 81       	ldd	r25, Z+1	; 0x01
    3590:	a2 81       	ldd	r26, Z+2	; 0x02
    3592:	b3 81       	ldd	r27, Z+3	; 0x03
    3594:	01 97       	sbiw	r24, 0x01	; 1
    3596:	a1 09       	sbc	r26, r1
    3598:	b1 09       	sbc	r27, r1
    359a:	80 83       	st	Z, r24
    359c:	91 83       	std	Z+1, r25	; 0x01
    359e:	a2 83       	std	Z+2, r26	; 0x02
    35a0:	b3 83       	std	Z+3, r27	; 0x03
				Clock_CallBack_Table[i].CallbackFunc();
				break;
			}
		}
		
		for ( i = 0 ; i < MAX_CLOCK_COUNTDOWNTIMER ; i++ )
    35a2:	2f 5f       	subi	r18, 0xFF	; 255
    35a4:	3f 4f       	sbci	r19, 0xFF	; 255
    35a6:	20 31       	cpi	r18, 0x10	; 16
    35a8:	31 05       	cpc	r19, r1
    35aa:	e1 f6       	brne	.-72     	; 0x3564 <CLOCK_tick+0x150>
			if ( Counter_Table[i].Resolution <= state && Counter_Table[i].Counter != 0 )
			{
				Counter_Table[i].Counter--;
			}
		}
	}
    35ac:	df 91       	pop	r29
    35ae:	cf 91       	pop	r28
    35b0:	1f 91       	pop	r17
    35b2:	0f 91       	pop	r16
    35b4:	08 95       	ret

000035b6 <CLOCK_GetTime>:
 * \param	Time		Pointer auf die Struct in der die Uhrzeit abgelegt werden soll.
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int CLOCK_GetTime( void * Time )
	{
    35b6:	0f 93       	push	r16
    35b8:	1f 93       	push	r17
		struct TIME * Timestruct;
		Timestruct = (struct TIME *) Time;
    35ba:	8c 01       	movw	r16, r24
		
		timer1_stop();
    35bc:	0e 94 3a 1c 	call	0x3874	; 0x3874 <timer1_stop>
		
		Timestruct->ms = time.ms;
    35c0:	80 91 76 07 	lds	r24, 0x0776
    35c4:	f8 01       	movw	r30, r16
    35c6:	80 83       	st	Z, r24
		Timestruct->ss = time.ss;
    35c8:	80 91 77 07 	lds	r24, 0x0777
    35cc:	81 83       	std	Z+1, r24	; 0x01
		Timestruct->mm = time.mm;
    35ce:	80 91 78 07 	lds	r24, 0x0778
    35d2:	82 83       	std	Z+2, r24	; 0x02
		Timestruct->hh = time.hh;
    35d4:	80 91 79 07 	lds	r24, 0x0779
    35d8:	83 83       	std	Z+3, r24	; 0x03
		Timestruct->WW = time.WW;
    35da:	80 91 7a 07 	lds	r24, 0x077A
    35de:	84 83       	std	Z+4, r24	; 0x04
		Timestruct->DD = time.DD;
    35e0:	80 91 7b 07 	lds	r24, 0x077B
    35e4:	85 83       	std	Z+5, r24	; 0x05
		Timestruct->MM = time.MM;
    35e6:	80 91 7c 07 	lds	r24, 0x077C
    35ea:	86 83       	std	Z+6, r24	; 0x06
		Timestruct->YY = time.YY;
    35ec:	80 91 7d 07 	lds	r24, 0x077D
    35f0:	90 91 7e 07 	lds	r25, 0x077E
    35f4:	90 87       	std	Z+8, r25	; 0x08
    35f6:	87 83       	std	Z+7, r24	; 0x07
		Timestruct->uptime = time.uptime;
    35f8:	80 91 7f 07 	lds	r24, 0x077F
    35fc:	90 91 80 07 	lds	r25, 0x0780
    3600:	a0 91 81 07 	lds	r26, 0x0781
    3604:	b0 91 82 07 	lds	r27, 0x0782
    3608:	81 87       	std	Z+9, r24	; 0x09
    360a:	92 87       	std	Z+10, r25	; 0x0a
    360c:	a3 87       	std	Z+11, r26	; 0x0b
    360e:	b4 87       	std	Z+12, r27	; 0x0c
		Timestruct->time = time.time;
    3610:	80 91 83 07 	lds	r24, 0x0783
    3614:	90 91 84 07 	lds	r25, 0x0784
    3618:	a0 91 85 07 	lds	r26, 0x0785
    361c:	b0 91 86 07 	lds	r27, 0x0786
    3620:	85 87       	std	Z+13, r24	; 0x0d
    3622:	96 87       	std	Z+14, r25	; 0x0e
    3624:	a7 87       	std	Z+15, r26	; 0x0f
    3626:	b0 8b       	std	Z+16, r27	; 0x10
		
		timer1_free();
    3628:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>
		
		return( 0 );
	}
    362c:	80 e0       	ldi	r24, 0x00	; 0
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	1f 91       	pop	r17
    3632:	0f 91       	pop	r16
    3634:	08 95       	ret

00003636 <CLOCK_GetCountdownTimer>:
 *						ermittelt worden sein.
 * \return	Value		Der Z채hlerstand
 */
/*------------------------------------------------------------------------------------------------------------*/
unsigned int CLOCK_GetCountdownTimer( int counter )
	{
    3636:	ef 92       	push	r14
    3638:	ff 92       	push	r15
    363a:	0f 93       	push	r16
    363c:	1f 93       	push	r17
    363e:	8c 01       	movw	r16, r24
		unsigned int value;

		timer1_stop();
    3640:	0e 94 3a 1c 	call	0x3874	; 0x3874 <timer1_stop>

		value = Counter_Table[ counter ].Counter;
    3644:	f8 01       	movw	r30, r16
    3646:	ee 0f       	add	r30, r30
    3648:	ff 1f       	adc	r31, r31
    364a:	ee 0f       	add	r30, r30
    364c:	ff 1f       	adc	r31, r31
    364e:	e0 0f       	add	r30, r16
    3650:	f1 1f       	adc	r31, r17
    3652:	ea 5f       	subi	r30, 0xFA	; 250
    3654:	f8 4f       	sbci	r31, 0xF8	; 248
    3656:	e0 80       	ld	r14, Z
    3658:	f1 80       	ldd	r15, Z+1	; 0x01
    365a:	02 81       	ldd	r16, Z+2	; 0x02
    365c:	13 81       	ldd	r17, Z+3	; 0x03

		timer1_free();
    365e:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>

		return ( value );
	}
    3662:	c7 01       	movw	r24, r14
    3664:	1f 91       	pop	r17
    3666:	0f 91       	pop	r16
    3668:	ff 90       	pop	r15
    366a:	ef 90       	pop	r14
    366c:	08 95       	ret

0000366e <CLOCK_SetCountdownTimer>:
 *						m철gliche Paramter: MSECOUND,SECOUND,MINUTE,HOUR und DAY
 * \return	Die Nummer des Countdowntimer oder FALSE
 */
/*------------------------------------------------------------------------------------------------------------*/
void CLOCK_SetCountdownTimer( int counter, unsigned int value, unsigned char Resolution )
	{
    366e:	bf 92       	push	r11
    3670:	cf 92       	push	r12
    3672:	df 92       	push	r13
    3674:	ef 92       	push	r14
    3676:	ff 92       	push	r15
    3678:	0f 93       	push	r16
    367a:	1f 93       	push	r17
    367c:	6c 01       	movw	r12, r24
    367e:	7b 01       	movw	r14, r22
    3680:	b4 2e       	mov	r11, r20
		timer1_stop();
    3682:	0e 94 3a 1c 	call	0x3874	; 0x3874 <timer1_stop>

		Counter_Table[ counter ].Counter = value;
    3686:	00 e0       	ldi	r16, 0x00	; 0
    3688:	10 e0       	ldi	r17, 0x00	; 0
    368a:	f6 01       	movw	r30, r12
    368c:	ee 0f       	add	r30, r30
    368e:	ff 1f       	adc	r31, r31
    3690:	ee 0f       	add	r30, r30
    3692:	ff 1f       	adc	r31, r31
    3694:	ec 0d       	add	r30, r12
    3696:	fd 1d       	adc	r31, r13
    3698:	ea 5f       	subi	r30, 0xFA	; 250
    369a:	f8 4f       	sbci	r31, 0xF8	; 248
    369c:	e0 82       	st	Z, r14
    369e:	f1 82       	std	Z+1, r15	; 0x01
    36a0:	02 83       	std	Z+2, r16	; 0x02
    36a2:	13 83       	std	Z+3, r17	; 0x03
		Counter_Table[ counter ].Resolution = Resolution;
    36a4:	b4 82       	std	Z+4, r11	; 0x04

		timer1_free();
    36a6:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>
	}
    36aa:	1f 91       	pop	r17
    36ac:	0f 91       	pop	r16
    36ae:	ff 90       	pop	r15
    36b0:	ef 90       	pop	r14
    36b2:	df 90       	pop	r13
    36b4:	cf 90       	pop	r12
    36b6:	bf 90       	pop	r11
    36b8:	08 95       	ret

000036ba <CLOCK_RegisterCoundowntimer>:
 * \endcode
 * \return	Die Nummer des Countdowntimer oder FALSE
 */
/*------------------------------------------------------------------------------------------------------------*/
int CLOCK_RegisterCoundowntimer( void )
	{
    36ba:	cf 93       	push	r28
    36bc:	df 93       	push	r29
		int counter ;
		
		timer1_stop();
    36be:	0e 94 3a 1c 	call	0x3874	; 0x3874 <timer1_stop>
    36c2:	c0 e0       	ldi	r28, 0x00	; 0
    36c4:	d0 e0       	ldi	r29, 0x00	; 0
		
		for ( counter = 0 ; counter < MAX_CLOCK_COUNTDOWNTIMER ; counter++ )
		{
			if ( Counter_Table[ counter ].Resolution == NO_USE )
    36c6:	fe 01       	movw	r30, r28
    36c8:	ee 0f       	add	r30, r30
    36ca:	ff 1f       	adc	r31, r31
    36cc:	ee 0f       	add	r30, r30
    36ce:	ff 1f       	adc	r31, r31
    36d0:	ec 0f       	add	r30, r28
    36d2:	fd 1f       	adc	r31, r29
    36d4:	ea 5f       	subi	r30, 0xFA	; 250
    36d6:	f8 4f       	sbci	r31, 0xF8	; 248
    36d8:	84 81       	ldd	r24, Z+4	; 0x04
    36da:	86 30       	cpi	r24, 0x06	; 6
    36dc:	39 f4       	brne	.+14     	; 0x36ec <CLOCK_RegisterCoundowntimer+0x32>
			{
				Counter_Table[ counter ].Counter = 0;
    36de:	10 82       	st	Z, r1
    36e0:	11 82       	std	Z+1, r1	; 0x01
    36e2:	12 82       	std	Z+2, r1	; 0x02
    36e4:	13 82       	std	Z+3, r1	; 0x03
				timer1_free();
    36e6:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>
    36ea:	08 c0       	rjmp	.+16     	; 0x36fc <CLOCK_RegisterCoundowntimer+0x42>
	{
		int counter ;
		
		timer1_stop();
		
		for ( counter = 0 ; counter < MAX_CLOCK_COUNTDOWNTIMER ; counter++ )
    36ec:	21 96       	adiw	r28, 0x01	; 1
    36ee:	c0 31       	cpi	r28, 0x10	; 16
    36f0:	d1 05       	cpc	r29, r1
    36f2:	49 f7       	brne	.-46     	; 0x36c6 <CLOCK_RegisterCoundowntimer+0xc>
				timer1_free();
				return ( counter ) ;
			}
		}

		timer1_free();
    36f4:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>
    36f8:	cf ef       	ldi	r28, 0xFF	; 255
    36fa:	df ef       	ldi	r29, 0xFF	; 255

		return( CLOCK_FAILED );		
	}
    36fc:	ce 01       	movw	r24, r28
    36fe:	df 91       	pop	r29
    3700:	cf 91       	pop	r28
    3702:	08 95       	ret

00003704 <CLOCK_RegisterCallbackFunction>:
 *						m철gliche Paramter: MSECOUND,SECOUND,MINUTE,HOUR und DAY
 * \return	TRUE oder FALSE
 */
/*------------------------------------------------------------------------------------------------------------*/
char CLOCK_RegisterCallbackFunction( CLOCK_CALLBACK_FUNC pFunc, unsigned char Resolution )
	{
    3704:	1f 93       	push	r17
    3706:	cf 93       	push	r28
    3708:	df 93       	push	r29
    370a:	ec 01       	movw	r28, r24
    370c:	16 2f       	mov	r17, r22
		unsigned char i;
		
		timer1_stop();
    370e:	0e 94 3a 1c 	call	0x3874	; 0x3874 <timer1_stop>
    3712:	20 e0       	ldi	r18, 0x00	; 0
    3714:	30 e0       	ldi	r19, 0x00	; 0

		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ ) 
		{
			if ( Clock_CallBack_Table[i].CallbackFunc == pFunc )
    3716:	f9 01       	movw	r30, r18
    3718:	ee 0f       	add	r30, r30
    371a:	ff 1f       	adc	r31, r31
    371c:	ee 0f       	add	r30, r30
    371e:	ff 1f       	adc	r31, r31
    3720:	ea 5a       	subi	r30, 0xAA	; 170
    3722:	f8 4f       	sbci	r31, 0xF8	; 248
    3724:	80 81       	ld	r24, Z
    3726:	91 81       	ldd	r25, Z+1	; 0x01
    3728:	8c 17       	cp	r24, r28
    372a:	9d 07       	cpc	r25, r29
    372c:	e9 f0       	breq	.+58     	; 0x3768 <CLOCK_RegisterCallbackFunction+0x64>
			{
				timer1_free();
				return CLOCK_OK;
    372e:	2f 5f       	subi	r18, 0xFF	; 255
    3730:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		unsigned char i;
		
		timer1_stop();

		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ ) 
    3732:	28 30       	cpi	r18, 0x08	; 8
    3734:	31 05       	cpc	r19, r1
    3736:	79 f7       	brne	.-34     	; 0x3716 <CLOCK_RegisterCallbackFunction+0x12>
    3738:	e0 e0       	ldi	r30, 0x00	; 0
    373a:	f0 e0       	ldi	r31, 0x00	; 0
			}
		}
		
		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ )
		{
			if ( Clock_CallBack_Table[i].CallbackFunc == NULL )
    373c:	df 01       	movw	r26, r30
    373e:	aa 0f       	add	r26, r26
    3740:	bb 1f       	adc	r27, r27
    3742:	aa 0f       	add	r26, r26
    3744:	bb 1f       	adc	r27, r27
    3746:	aa 5a       	subi	r26, 0xAA	; 170
    3748:	b8 4f       	sbci	r27, 0xF8	; 248
    374a:	8d 91       	ld	r24, X+
    374c:	9c 91       	ld	r25, X
    374e:	11 97       	sbiw	r26, 0x01	; 1
    3750:	89 2b       	or	r24, r25
    3752:	71 f4       	brne	.+28     	; 0x3770 <CLOCK_RegisterCallbackFunction+0x6c>
			{
				// zuerst Pointer zu Funktion setzen und Resolution setzen zum scharf machen
				// dies ist n철tig da der zugrif auf Resolution atomar ist
				Clock_CallBack_Table[i].CallbackFunc = pFunc;
    3754:	11 96       	adiw	r26, 0x01	; 1
    3756:	dc 93       	st	X, r29
    3758:	ce 93       	st	-X, r28
				Clock_CallBack_Table[i].Resolution = Resolution;
    375a:	ee 0f       	add	r30, r30
    375c:	ff 1f       	adc	r31, r31
    375e:	ee 0f       	add	r30, r30
    3760:	ff 1f       	adc	r31, r31
    3762:	e8 5a       	subi	r30, 0xA8	; 168
    3764:	f8 4f       	sbci	r31, 0xF8	; 248
    3766:	10 83       	st	Z, r17
				timer1_free();
    3768:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>
    376c:	80 e0       	ldi	r24, 0x00	; 0
    376e:	07 c0       	rjmp	.+14     	; 0x377e <CLOCK_RegisterCallbackFunction+0x7a>
				return CLOCK_OK;
    3770:	31 96       	adiw	r30, 0x01	; 1
				timer1_free();
				return CLOCK_OK;
			}
		}
		
		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ )
    3772:	e8 30       	cpi	r30, 0x08	; 8
    3774:	f1 05       	cpc	r31, r1
    3776:	11 f7       	brne	.-60     	; 0x373c <CLOCK_RegisterCallbackFunction+0x38>
				Clock_CallBack_Table[i].Resolution = Resolution;
				timer1_free();
				return CLOCK_OK;
			}
		}
		timer1_free();
    3778:	0e 94 40 1c 	call	0x3880	; 0x3880 <timer1_free>
    377c:	8f ef       	ldi	r24, 0xFF	; 255
		return CLOCK_FAILED;
	}
    377e:	df 91       	pop	r29
    3780:	cf 91       	pop	r28
    3782:	1f 91       	pop	r17
    3784:	08 95       	ret

00003786 <CLOCK_init>:
/*-----------------------------------------------------------------------------------------------------------*/
/*! \brief Initialisiert die System-Clock und registriert ihn auf Timer1 mit 1/100s als Callbackfunktion.
 */
/*------------------------------------------------------------------------------------------------------------*/
void CLOCK_init(void)
	{
    3786:	80 e0       	ldi	r24, 0x00	; 0
    3788:	90 e0       	ldi	r25, 0x00	; 0
		
		// Alle Callbackeintr채ge l철schen
		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ ) 
			{
				Clock_CallBack_Table[i].CallbackFunc = NULL;
				Clock_CallBack_Table[i].Resolution = NO_USE;
    378a:	26 e0       	ldi	r18, 0x06	; 6
		unsigned int i;
		
		// Alle Callbackeintr채ge l철schen
		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ ) 
			{
				Clock_CallBack_Table[i].CallbackFunc = NULL;
    378c:	fc 01       	movw	r30, r24
    378e:	ee 0f       	add	r30, r30
    3790:	ff 1f       	adc	r31, r31
    3792:	ee 0f       	add	r30, r30
    3794:	ff 1f       	adc	r31, r31
    3796:	ea 5a       	subi	r30, 0xAA	; 170
    3798:	f8 4f       	sbci	r31, 0xF8	; 248
    379a:	11 82       	std	Z+1, r1	; 0x01
    379c:	10 82       	st	Z, r1
				Clock_CallBack_Table[i].Resolution = NO_USE;
    379e:	fc 01       	movw	r30, r24
    37a0:	ee 0f       	add	r30, r30
    37a2:	ff 1f       	adc	r31, r31
    37a4:	ee 0f       	add	r30, r30
    37a6:	ff 1f       	adc	r31, r31
    37a8:	e8 5a       	subi	r30, 0xA8	; 168
    37aa:	f8 4f       	sbci	r31, 0xF8	; 248
    37ac:	20 83       	st	Z, r18
void CLOCK_init(void)
	{
		unsigned int i;
		
		// Alle Callbackeintr채ge l철schen
		for ( i = 0 ; i < MAX_CLOCK_CALLBACKS ; i++ ) 
    37ae:	01 96       	adiw	r24, 0x01	; 1
    37b0:	88 30       	cpi	r24, 0x08	; 8
    37b2:	91 05       	cpc	r25, r1
    37b4:	59 f7       	brne	.-42     	; 0x378c <CLOCK_init+0x6>
    37b6:	80 e0       	ldi	r24, 0x00	; 0
    37b8:	90 e0       	ldi	r25, 0x00	; 0
			}
			
		for ( i = 0 ; i < MAX_CLOCK_COUNTDOWNTIMER ; i++ ) 
			{
				Counter_Table[i].Counter = 0;
				Counter_Table[i].Resolution = NO_USE;
    37ba:	26 e0       	ldi	r18, 0x06	; 6
				Clock_CallBack_Table[i].Resolution = NO_USE;
			}
			
		for ( i = 0 ; i < MAX_CLOCK_COUNTDOWNTIMER ; i++ ) 
			{
				Counter_Table[i].Counter = 0;
    37bc:	fc 01       	movw	r30, r24
    37be:	ee 0f       	add	r30, r30
    37c0:	ff 1f       	adc	r31, r31
    37c2:	ee 0f       	add	r30, r30
    37c4:	ff 1f       	adc	r31, r31
    37c6:	e8 0f       	add	r30, r24
    37c8:	f9 1f       	adc	r31, r25
    37ca:	ea 5f       	subi	r30, 0xFA	; 250
    37cc:	f8 4f       	sbci	r31, 0xF8	; 248
    37ce:	10 82       	st	Z, r1
    37d0:	11 82       	std	Z+1, r1	; 0x01
    37d2:	12 82       	std	Z+2, r1	; 0x02
    37d4:	13 82       	std	Z+3, r1	; 0x03
				Counter_Table[i].Resolution = NO_USE;
    37d6:	24 83       	std	Z+4, r18	; 0x04
			{
				Clock_CallBack_Table[i].CallbackFunc = NULL;
				Clock_CallBack_Table[i].Resolution = NO_USE;
			}
			
		for ( i = 0 ; i < MAX_CLOCK_COUNTDOWNTIMER ; i++ ) 
    37d8:	01 96       	adiw	r24, 0x01	; 1
    37da:	80 31       	cpi	r24, 0x10	; 16
    37dc:	91 05       	cpc	r25, r1
    37de:	71 f7       	brne	.-36     	; 0x37bc <CLOCK_init+0x36>
			{
				Counter_Table[i].Counter = 0;
				Counter_Table[i].Resolution = NO_USE;
			}
			
		time.uptime=0;
    37e0:	10 92 7f 07 	sts	0x077F, r1
    37e4:	10 92 80 07 	sts	0x0780, r1
    37e8:	10 92 81 07 	sts	0x0781, r1
    37ec:	10 92 82 07 	sts	0x0782, r1
		time.time=0;
    37f0:	10 92 83 07 	sts	0x0783, r1
    37f4:	10 92 84 07 	sts	0x0784, r1
    37f8:	10 92 85 07 	sts	0x0785, r1
    37fc:	10 92 86 07 	sts	0x0786, r1

		CLOCK_decode_time( time.time );
    3800:	60 91 83 07 	lds	r22, 0x0783
    3804:	70 91 84 07 	lds	r23, 0x0784
    3808:	80 91 85 07 	lds	r24, 0x0785
    380c:	90 91 86 07 	lds	r25, 0x0786
    3810:	0e 94 4c 18 	call	0x3098	; 0x3098 <CLOCK_decode_time>
		
		// Clocksource init
		timer1_init( 100 , 0);
    3814:	84 e6       	ldi	r24, 0x64	; 100
    3816:	90 e0       	ldi	r25, 0x00	; 0
    3818:	60 e0       	ldi	r22, 0x00	; 0
    381a:	70 e0       	ldi	r23, 0x00	; 0
    381c:	0e 94 15 1c 	call	0x382a	; 0x382a <timer1_init>
		// clock_tick registrieren als Callbackfunktion
		timer1_RegisterCallbackFunction( CLOCK_tick );
    3820:	8a e0       	ldi	r24, 0x0A	; 10
    3822:	9a e1       	ldi	r25, 0x1A	; 26
    3824:	0e 94 6f 1c 	call	0x38de	; 0x38de <timer1_RegisterCallbackFunction>
		
	}
    3828:	08 95       	ret

0000382a <timer1_init>:
/*! \brief Initialisiert den Timer1 im CTC-Mode.
 * \param 	Hz		Die anzahl der aufrufe in der Sekunde.
 */
/* -----------------------------------------------------------------------------------------------------------*/ 
int timer1_init( unsigned int Hz, unsigned int timedrift )
{
    382a:	0f 93       	push	r16
    382c:	1f 93       	push	r17
    382e:	8b 01       	movw	r16, r22
	unsigned char i;
	
	// Alle Callbackeintr채ge l철schen
	for ( i = 0 ; i < MAX_TIMER1_CALLBACKS ; i++ ) TIMER1_CallbackFunc[i] = NULL;
    3830:	10 92 88 07 	sts	0x0788, r1
    3834:	10 92 87 07 	sts	0x0787, r1
		
	// Timer0 einstellungen setzen
	TCCR1B = ( 1<<WGM12 ) | ( 0<<CS12 ) | ( 1<<CS11 ) | ( 0<<CS10 ); // CTC mode setzen, Prescaler 1024
    3838:	2a e0       	ldi	r18, 0x0A	; 10
    383a:	20 93 81 00 	sts	0x0081, r18
	OCR1A  = ( F_CPU / ( 8 * Hz ) ) - timedrift ; // 100Hz bei 16MHz
    383e:	9c 01       	movw	r18, r24
    3840:	83 e0       	ldi	r24, 0x03	; 3
    3842:	22 0f       	add	r18, r18
    3844:	33 1f       	adc	r19, r19
    3846:	8a 95       	dec	r24
    3848:	e1 f7       	brne	.-8      	; 0x3842 <timer1_init+0x18>
    384a:	40 e0       	ldi	r20, 0x00	; 0
    384c:	50 e0       	ldi	r21, 0x00	; 0
    384e:	60 e0       	ldi	r22, 0x00	; 0
    3850:	74 e2       	ldi	r23, 0x24	; 36
    3852:	84 ef       	ldi	r24, 0xF4	; 244
    3854:	90 e0       	ldi	r25, 0x00	; 0
    3856:	0e 94 9e 6a 	call	0xd53c	; 0xd53c <__divmodsi4>
    385a:	20 1b       	sub	r18, r16
    385c:	31 0b       	sbc	r19, r17
    385e:	30 93 89 00 	sts	0x0089, r19
    3862:	20 93 88 00 	sts	0x0088, r18
	TIMSK1 = ( 1<<OCIE1A );  // Compare Match A Interupt freigegben
    3866:	82 e0       	ldi	r24, 0x02	; 2
    3868:	80 93 6f 00 	sts	0x006F, r24

	return( ( F_CPU / ( 8 * Hz ) ) - timedrift );
}
    386c:	c9 01       	movw	r24, r18
    386e:	1f 91       	pop	r17
    3870:	0f 91       	pop	r16
    3872:	08 95       	ret

00003874 <timer1_stop>:
 * \param	NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/
void timer1_stop(void)
	{
		TIMSK1 &= ~( 1<<OCIE1A );  // Compare Match A Interupt sperren		
    3874:	ef e6       	ldi	r30, 0x6F	; 111
    3876:	f0 e0       	ldi	r31, 0x00	; 0
    3878:	80 81       	ld	r24, Z
    387a:	8d 7f       	andi	r24, 0xFD	; 253
    387c:	80 83       	st	Z, r24
	}
    387e:	08 95       	ret

00003880 <timer1_free>:
 * \param	NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/ 
void timer1_free(void)
	{
		TIMSK1 |= ( 1<<OCIE1A );  // Compare Match A Interupt freigeben
    3880:	ef e6       	ldi	r30, 0x6F	; 111
    3882:	f0 e0       	ldi	r31, 0x00	; 0
    3884:	80 81       	ld	r24, Z
    3886:	82 60       	ori	r24, 0x02	; 2
    3888:	80 83       	st	Z, r24
	}
    388a:	08 95       	ret

0000388c <__vector_13>:


ISR( TIMER1_COMPA_vect )
	{
    388c:	1f 92       	push	r1
    388e:	0f 92       	push	r0
    3890:	0f b6       	in	r0, 0x3f	; 63
    3892:	0f 92       	push	r0
    3894:	11 24       	eor	r1, r1
    3896:	2f 93       	push	r18
    3898:	3f 93       	push	r19
    389a:	4f 93       	push	r20
    389c:	5f 93       	push	r21
    389e:	6f 93       	push	r22
    38a0:	7f 93       	push	r23
    38a2:	8f 93       	push	r24
    38a4:	9f 93       	push	r25
    38a6:	af 93       	push	r26
    38a8:	bf 93       	push	r27
    38aa:	ef 93       	push	r30
    38ac:	ff 93       	push	r31
		unsigned char i;
		for ( i = 0 ; i < MAX_TIMER1_CALLBACKS ; i++ ) if ( TIMER1_CallbackFunc[i] != NULL ) TIMER1_CallbackFunc[i]();
    38ae:	e0 91 87 07 	lds	r30, 0x0787
    38b2:	f0 91 88 07 	lds	r31, 0x0788
    38b6:	30 97       	sbiw	r30, 0x00	; 0
    38b8:	09 f0       	breq	.+2      	; 0x38bc <__vector_13+0x30>
    38ba:	09 95       	icall
	}
    38bc:	ff 91       	pop	r31
    38be:	ef 91       	pop	r30
    38c0:	bf 91       	pop	r27
    38c2:	af 91       	pop	r26
    38c4:	9f 91       	pop	r25
    38c6:	8f 91       	pop	r24
    38c8:	7f 91       	pop	r23
    38ca:	6f 91       	pop	r22
    38cc:	5f 91       	pop	r21
    38ce:	4f 91       	pop	r20
    38d0:	3f 91       	pop	r19
    38d2:	2f 91       	pop	r18
    38d4:	0f 90       	pop	r0
    38d6:	0f be       	out	0x3f, r0	; 63
    38d8:	0f 90       	pop	r0
    38da:	1f 90       	pop	r1
    38dc:	18 95       	reti

000038de <timer1_RegisterCallbackFunction>:
	{
		unsigned char i;
		
		for ( i = 0 ; i < MAX_TIMER1_CALLBACKS ; i++ ) 
		{
			if ( TIMER1_CallbackFunc[i] == pFunc )
    38de:	20 91 87 07 	lds	r18, 0x0787
    38e2:	30 91 88 07 	lds	r19, 0x0788
    38e6:	28 17       	cp	r18, r24
    38e8:	39 07       	cpc	r19, r25
    38ea:	11 f4       	brne	.+4      	; 0x38f0 <timer1_RegisterCallbackFunction+0x12>
    38ec:	80 e0       	ldi	r24, 0x00	; 0
    38ee:	08 95       	ret
				return TRUE;
		}
		
		for ( i = 0 ; i < MAX_TIMER1_CALLBACKS ; i++ )
		{
			if ( TIMER1_CallbackFunc[i] == NULL )
    38f0:	23 2b       	or	r18, r19
    38f2:	11 f0       	breq	.+4      	; 0x38f8 <timer1_RegisterCallbackFunction+0x1a>
    38f4:	8f ef       	ldi	r24, 0xFF	; 255
    38f6:	08 95       	ret
			{
				TIMER1_CallbackFunc[i] = pFunc;
    38f8:	90 93 88 07 	sts	0x0788, r25
    38fc:	80 93 87 07 	sts	0x0787, r24
    3900:	80 e0       	ldi	r24, 0x00	; 0
				return TRUE;
			}
		}
		return FALSE;
	}
    3902:	08 95       	ret

00003904 <SPI_init>:

void SPI_init( int SPI_ID )
{
	spi_bus[ SPI_ID ].INIT( );
    3904:	fc 01       	movw	r30, r24
    3906:	83 e0       	ldi	r24, 0x03	; 3
    3908:	ee 0f       	add	r30, r30
    390a:	ff 1f       	adc	r31, r31
    390c:	8a 95       	dec	r24
    390e:	e1 f7       	brne	.-8      	; 0x3908 <SPI_init+0x4>
    3910:	e7 59       	subi	r30, 0x97	; 151
    3912:	fe 4f       	sbci	r31, 0xFE	; 254
    3914:	01 90       	ld	r0, Z+
    3916:	f0 81       	ld	r31, Z
    3918:	e0 2d       	mov	r30, r0
    391a:	09 95       	icall
}
    391c:	08 95       	ret

0000391e <SPI_ReadWrite>:

char SPI_ReadWrite( int SPI_ID, char Data )
{
	return( spi_bus[ SPI_ID ].ReadWrite( Data ) );	
    391e:	fc 01       	movw	r30, r24
    3920:	93 e0       	ldi	r25, 0x03	; 3
    3922:	ee 0f       	add	r30, r30
    3924:	ff 1f       	adc	r31, r31
    3926:	9a 95       	dec	r25
    3928:	e1 f7       	brne	.-8      	; 0x3922 <SPI_ReadWrite+0x4>
    392a:	e5 59       	subi	r30, 0x95	; 149
    392c:	fe 4f       	sbci	r31, 0xFE	; 254
    392e:	01 90       	ld	r0, Z+
    3930:	f0 81       	ld	r31, Z
    3932:	e0 2d       	mov	r30, r0
    3934:	86 2f       	mov	r24, r22
    3936:	09 95       	icall
}
    3938:	08 95       	ret

0000393a <SPI_ReadBlock>:
	spi_bus[ SPI_ID ].WriteBlock( Block, len );	
}

void SPI_ReadBlock( int SPI_ID, char * Block, int len )
{
	spi_bus[ SPI_ID ].ReadBlock( Block, len );		
    393a:	fc 01       	movw	r30, r24
    393c:	33 e0       	ldi	r19, 0x03	; 3
    393e:	ee 0f       	add	r30, r30
    3940:	ff 1f       	adc	r31, r31
    3942:	3a 95       	dec	r19
    3944:	e1 f7       	brne	.-8      	; 0x393e <SPI_ReadBlock+0x4>
    3946:	e7 59       	subi	r30, 0x97	; 151
    3948:	fe 4f       	sbci	r31, 0xFE	; 254
    394a:	06 80       	ldd	r0, Z+6	; 0x06
    394c:	f7 81       	ldd	r31, Z+7	; 0x07
    394e:	e0 2d       	mov	r30, r0
    3950:	cb 01       	movw	r24, r22
    3952:	ba 01       	movw	r22, r20
    3954:	09 95       	icall
}
    3956:	08 95       	ret

00003958 <__vector_22>:
	ISR( USART0_TX_vect )
#endif
#ifdef __AVR_ATmega644P__
	ISR( USART0_TX_vect )
#endif
{
    3958:	1f 92       	push	r1
    395a:	0f 92       	push	r0
    395c:	0f b6       	in	r0, 0x3f	; 63
    395e:	0f 92       	push	r0
    3960:	11 24       	eor	r1, r1
    3962:	8f 93       	push	r24
    3964:	ef 93       	push	r30
    3966:	ff 93       	push	r31
	#ifdef __AVR_ATmega2561__
		UCSR1B &= ~( 1<<TXCIE1 );
		TX_state = TX_complete;
	#endif
	#ifdef __AVR_ATmega644__
		UCSR0B &= ~( 1<<TXCIE0 );
    3968:	e1 ec       	ldi	r30, 0xC1	; 193
    396a:	f0 e0       	ldi	r31, 0x00	; 0
    396c:	80 81       	ld	r24, Z
    396e:	8f 7b       	andi	r24, 0xBF	; 191
    3970:	80 83       	st	Z, r24
		TX_state = TX_complete;
    3972:	10 92 c6 01 	sts	0x01C6, r1
	#endif
	#ifdef __AVR_ATmega644P__
		UCSR0B &= ~( 1<<TXCIE0 );
		TX_state = TX_complete;
	#endif
}
    3976:	ff 91       	pop	r31
    3978:	ef 91       	pop	r30
    397a:	8f 91       	pop	r24
    397c:	0f 90       	pop	r0
    397e:	0f be       	out	0x3f, r0	; 63
    3980:	0f 90       	pop	r0
    3982:	1f 90       	pop	r1
    3984:	18 95       	reti

00003986 <__vector_21>:
	ISR( USART0_UDRE_vect )
#endif
#ifdef __AVR_ATmega644P__
	ISR( USART0_UDRE_vect )
#endif
{
    3986:	1f 92       	push	r1
    3988:	0f 92       	push	r0
    398a:	0f b6       	in	r0, 0x3f	; 63
    398c:	0f 92       	push	r0
    398e:	11 24       	eor	r1, r1
    3990:	2f 93       	push	r18
    3992:	3f 93       	push	r19
    3994:	4f 93       	push	r20
    3996:	5f 93       	push	r21
    3998:	6f 93       	push	r22
    399a:	7f 93       	push	r23
    399c:	8f 93       	push	r24
    399e:	9f 93       	push	r25
    39a0:	af 93       	push	r26
    39a2:	bf 93       	push	r27
    39a4:	ef 93       	push	r30
    39a6:	ff 93       	push	r31

	// checken ob noch bytes im Buffer sind
	if ( Get_Bytes_in_FIFO ( TX_fifo ) != 0 )
    39a8:	80 91 cb 07 	lds	r24, 0x07CB
    39ac:	90 91 cc 07 	lds	r25, 0x07CC
    39b0:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    39b4:	89 2b       	or	r24, r25
    39b6:	49 f0       	breq	.+18     	; 0x39ca <__vector_21+0x44>
	{
		#ifdef __AVR_ATmega2561__
			UDR1 = Get_Byte_from_FIFO ( TX_fifo );
		#endif
		#ifdef __AVR_ATmega644__
			UDR0 = Get_Byte_from_FIFO ( TX_fifo );
    39b8:	80 91 cb 07 	lds	r24, 0x07CB
    39bc:	90 91 cc 07 	lds	r25, 0x07CC
    39c0:	0e 94 fb 3d 	call	0x7bf6	; 0x7bf6 <Get_Byte_from_FIFO>
    39c4:	80 93 c6 00 	sts	0x00C6, r24
    39c8:	0a c0       	rjmp	.+20     	; 0x39de <__vector_21+0x58>
		#ifdef __AVR_ATmega2561__
			UCSR1B |= ( 1<<TXCIE1 );
			UCSR1B &= ~( 1<<UDRIE1 );
		#endif
		#ifdef __AVR_ATmega644__
			UCSR0B |= ( 1<<TXCIE0 );
    39ca:	80 91 c1 00 	lds	r24, 0x00C1
    39ce:	80 64       	ori	r24, 0x40	; 64
    39d0:	80 93 c1 00 	sts	0x00C1, r24
			UCSR0B &= ~( 1<<UDRIE0 );
    39d4:	80 91 c1 00 	lds	r24, 0x00C1
    39d8:	8f 7d       	andi	r24, 0xDF	; 223
    39da:	80 93 c1 00 	sts	0x00C1, r24
		#ifdef __AVR_ATmega644P__
			UCSR0B |= ( 1<<TXCIE0 );
			UCSR0B &= ~( 1<<UDRIE0 );
		#endif
	}
}
    39de:	ff 91       	pop	r31
    39e0:	ef 91       	pop	r30
    39e2:	bf 91       	pop	r27
    39e4:	af 91       	pop	r26
    39e6:	9f 91       	pop	r25
    39e8:	8f 91       	pop	r24
    39ea:	7f 91       	pop	r23
    39ec:	6f 91       	pop	r22
    39ee:	5f 91       	pop	r21
    39f0:	4f 91       	pop	r20
    39f2:	3f 91       	pop	r19
    39f4:	2f 91       	pop	r18
    39f6:	0f 90       	pop	r0
    39f8:	0f be       	out	0x3f, r0	; 63
    39fa:	0f 90       	pop	r0
    39fc:	1f 90       	pop	r1
    39fe:	18 95       	reti

00003a00 <UART_Send_Byte>:
 * \param	ein Byte vom typ unsigned char
 * \return  NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/
void UART_Send_Byte( unsigned char Byte )
{
    3a00:	1f 93       	push	r17
    3a02:	18 2f       	mov	r17, r24

	cli();
    3a04:	f8 94       	cli
	
	TX_Counter++;
    3a06:	80 91 c7 01 	lds	r24, 0x01C7
    3a0a:	90 91 c8 01 	lds	r25, 0x01C8
    3a0e:	a0 91 c9 01 	lds	r26, 0x01C9
    3a12:	b0 91 ca 01 	lds	r27, 0x01CA
    3a16:	01 96       	adiw	r24, 0x01	; 1
    3a18:	a1 1d       	adc	r26, r1
    3a1a:	b1 1d       	adc	r27, r1
    3a1c:	80 93 c7 01 	sts	0x01C7, r24
    3a20:	90 93 c8 01 	sts	0x01C8, r25
    3a24:	a0 93 c9 01 	sts	0x01C9, r26
    3a28:	b0 93 ca 01 	sts	0x01CA, r27
	
	if ( Get_Bytes_in_FIFO ( TX_fifo ) == 0 )
    3a2c:	80 91 cb 07 	lds	r24, 0x07CB
    3a30:	90 91 cc 07 	lds	r25, 0x07CC
    3a34:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    3a38:	89 2b       	or	r24, r25
    3a3a:	31 f5       	brne	.+76     	; 0x3a88 <UART_Send_Byte+0x88>
	{
		// Wenn Controller noch mit senden eines Byte besch채ftig, ab in den Puffer
		if ( TX_state == TX_sending )
    3a3c:	80 91 c6 01 	lds	r24, 0x01C6
    3a40:	81 30       	cpi	r24, 0x01	; 1
    3a42:	91 f4       	brne	.+36     	; 0x3a68 <UART_Send_Byte+0x68>
		{			
			// Byte in Buffer schreiben
			Put_Byte_in_FIFO ( TX_fifo, Byte );
    3a44:	80 91 cb 07 	lds	r24, 0x07CB
    3a48:	90 91 cc 07 	lds	r25, 0x07CC
    3a4c:	61 2f       	mov	r22, r17
    3a4e:	0e 94 a6 3d 	call	0x7b4c	; 0x7b4c <Put_Byte_in_FIFO>
			#ifdef __AVR_ATmega2561__
				UCSR1B &= ~( 1<<TXCIE1 );
				UCSR1B |= ( 1<<UDRIE1 );
			#endif
			#ifdef __AVR_ATmega644__
				UCSR0B &= ~( 1<<TXCIE0 );
    3a52:	80 91 c1 00 	lds	r24, 0x00C1
    3a56:	8f 7b       	andi	r24, 0xBF	; 191
    3a58:	80 93 c1 00 	sts	0x00C1, r24
				UCSR0B |= ( 1<<UDRIE0 );
    3a5c:	80 91 c1 00 	lds	r24, 0x00C1
    3a60:	80 62       	ori	r24, 0x20	; 32
    3a62:	80 93 c1 00 	sts	0x00C1, r24
    3a66:	22 c0       	rjmp	.+68     	; 0x3aac <UART_Send_Byte+0xac>
				// Buffer Emty sperren, TX_complete freigeben
				UCSR1B |= ( 1<<TXCIE1 );
				UCSR1B &= ~( 1<<UDRIE1 );
			#endif
			#ifdef __AVR_ATmega644__
				UDR0 = Byte;
    3a68:	10 93 c6 00 	sts	0x00C6, r17
			
				// Buffer Emty sperren, TX_complete freigeben
				UCSR0B |= ( 1<<TXCIE0 );
    3a6c:	80 91 c1 00 	lds	r24, 0x00C1
    3a70:	80 64       	ori	r24, 0x40	; 64
    3a72:	80 93 c1 00 	sts	0x00C1, r24
				UCSR0B &= ~( 1<<UDRIE0 );
    3a76:	80 91 c1 00 	lds	r24, 0x00C1
    3a7a:	8f 7d       	andi	r24, 0xDF	; 223
    3a7c:	80 93 c1 00 	sts	0x00C1, r24
				// Buffer Emty sperren, TX_complete freigeben
				UCSR0B |= ( 1<<TXCIE0 );
				UCSR0B &= ~( 1<<UDRIE0 );
			#endif
			
			TX_state = TX_sending;
    3a80:	81 e0       	ldi	r24, 0x01	; 1
    3a82:	80 93 c6 01 	sts	0x01C6, r24
    3a86:	12 c0       	rjmp	.+36     	; 0x3aac <UART_Send_Byte+0xac>
	else
	{	
		// Wenn Puffer voll, warten bis wieder was rein pat
		while ( 1 )
		{
			cli();
    3a88:	f8 94       	cli
			
			if ( Get_Bytes_in_FIFO ( TX_fifo ) < TX_Bufferlen ) break;
    3a8a:	80 91 cb 07 	lds	r24, 0x07CB
    3a8e:	90 91 cc 07 	lds	r25, 0x07CC
    3a92:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    3a96:	80 97       	sbiw	r24, 0x20	; 32
    3a98:	14 f0       	brlt	.+4      	; 0x3a9e <UART_Send_Byte+0x9e>
			
			sei();
    3a9a:	78 94       	sei
    3a9c:	f5 cf       	rjmp	.-22     	; 0x3a88 <UART_Send_Byte+0x88>
		}

		// Byte in Buffer schreiben
		Put_Byte_in_FIFO ( TX_fifo, Byte );
    3a9e:	80 91 cb 07 	lds	r24, 0x07CB
    3aa2:	90 91 cc 07 	lds	r25, 0x07CC
    3aa6:	61 2f       	mov	r22, r17
    3aa8:	0e 94 a6 3d 	call	0x7b4c	; 0x7b4c <Put_Byte_in_FIFO>
	}
	
	sei();
    3aac:	78 94       	sei
}
    3aae:	1f 91       	pop	r17
    3ab0:	08 95       	ret

00003ab2 <__vector_20>:
	ISR( USART0_RX_vect )
#endif
#ifdef __AVR_ATmega644P__
	ISR( USART0_RX_vect )
#endif
{
    3ab2:	1f 92       	push	r1
    3ab4:	0f 92       	push	r0
    3ab6:	0f b6       	in	r0, 0x3f	; 63
    3ab8:	0f 92       	push	r0
    3aba:	11 24       	eor	r1, r1
    3abc:	1f 93       	push	r17
    3abe:	2f 93       	push	r18
    3ac0:	3f 93       	push	r19
    3ac2:	4f 93       	push	r20
    3ac4:	5f 93       	push	r21
    3ac6:	6f 93       	push	r22
    3ac8:	7f 93       	push	r23
    3aca:	8f 93       	push	r24
    3acc:	9f 93       	push	r25
    3ace:	af 93       	push	r26
    3ad0:	bf 93       	push	r27
    3ad2:	ef 93       	push	r30
    3ad4:	ff 93       	push	r31
	unsigned char Byte;
	
	RX_Counter++;
    3ad6:	80 91 cb 01 	lds	r24, 0x01CB
    3ada:	90 91 cc 01 	lds	r25, 0x01CC
    3ade:	a0 91 cd 01 	lds	r26, 0x01CD
    3ae2:	b0 91 ce 01 	lds	r27, 0x01CE
    3ae6:	01 96       	adiw	r24, 0x01	; 1
    3ae8:	a1 1d       	adc	r26, r1
    3aea:	b1 1d       	adc	r27, r1
    3aec:	80 93 cb 01 	sts	0x01CB, r24
    3af0:	90 93 cc 01 	sts	0x01CC, r25
    3af4:	a0 93 cd 01 	sts	0x01CD, r26
    3af8:	b0 93 ce 01 	sts	0x01CE, r27
		
	#ifdef __AVR_ATmega2561__
		Byte = UDR1;
	#endif
	#ifdef __AVR_ATmega644__
		Byte = UDR0;
    3afc:	10 91 c6 00 	lds	r17, 0x00C6
	#endif
	#ifdef __AVR_ATmega644P__
		Byte = UDR0;
	#endif
	
	if ( Get_Bytes_in_FIFO ( RX_fifo ) < RX_Bufferlen )
    3b00:	80 91 c9 07 	lds	r24, 0x07C9
    3b04:	90 91 ca 07 	lds	r25, 0x07CA
    3b08:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    3b0c:	80 97       	sbiw	r24, 0x20	; 32
    3b0e:	3c f4       	brge	.+14     	; 0x3b1e <__vector_20+0x6c>
		Put_Byte_in_FIFO ( RX_fifo, Byte );
    3b10:	80 91 c9 07 	lds	r24, 0x07C9
    3b14:	90 91 ca 07 	lds	r25, 0x07CA
    3b18:	61 2f       	mov	r22, r17
    3b1a:	0e 94 a6 3d 	call	0x7b4c	; 0x7b4c <Put_Byte_in_FIFO>
}
    3b1e:	ff 91       	pop	r31
    3b20:	ef 91       	pop	r30
    3b22:	bf 91       	pop	r27
    3b24:	af 91       	pop	r26
    3b26:	9f 91       	pop	r25
    3b28:	8f 91       	pop	r24
    3b2a:	7f 91       	pop	r23
    3b2c:	6f 91       	pop	r22
    3b2e:	5f 91       	pop	r21
    3b30:	4f 91       	pop	r20
    3b32:	3f 91       	pop	r19
    3b34:	2f 91       	pop	r18
    3b36:	1f 91       	pop	r17
    3b38:	0f 90       	pop	r0
    3b3a:	0f be       	out	0x3f, r0	; 63
    3b3c:	0f 90       	pop	r0
    3b3e:	1f 90       	pop	r1
    3b40:	18 95       	reti

00003b42 <UART_init>:
 */
/* -----------------------------------------------------------------------------------------------------------*/
void UART_init( void )
{	
	// FIFO initialisieren wenn nicht schon passiert
	INIT_FIFO ();
    3b42:	0e 94 41 3d 	call	0x7a82	; 0x7a82 <INIT_FIFO>
		
	// FIFO reservieren f체r RX und TX
	RX_fifo = Get_FIFO( RX_Buffer, RX_Bufferlen );
    3b46:	89 e8       	ldi	r24, 0x89	; 137
    3b48:	97 e0       	ldi	r25, 0x07	; 7
    3b4a:	60 e2       	ldi	r22, 0x20	; 32
    3b4c:	70 e0       	ldi	r23, 0x00	; 0
    3b4e:	0e 94 61 3d 	call	0x7ac2	; 0x7ac2 <Get_FIFO>
    3b52:	90 93 ca 07 	sts	0x07CA, r25
    3b56:	80 93 c9 07 	sts	0x07C9, r24
	TX_fifo = Get_FIFO( TX_Buffer, TX_Bufferlen );
    3b5a:	89 ea       	ldi	r24, 0xA9	; 169
    3b5c:	97 e0       	ldi	r25, 0x07	; 7
    3b5e:	60 e2       	ldi	r22, 0x20	; 32
    3b60:	70 e0       	ldi	r23, 0x00	; 0
    3b62:	0e 94 61 3d 	call	0x7ac2	; 0x7ac2 <Get_FIFO>
    3b66:	90 93 cc 07 	sts	0x07CC, r25
    3b6a:	80 93 cb 07 	sts	0x07CB, r24

	// TX_state auf complete setzen, da ja nix gesendet wurde
	TX_state = TX_complete;
    3b6e:	10 92 c6 01 	sts	0x01C6, r1
		// Asynchron 8N1
		UCSR1C |= ( 1<< USBS1 ) | ( 1<<UCSZ11 ) ;    								 
	#endif
	#ifdef __AVR_ATmega644__
		// Bitrate einstellen
		UBRR0H = (unsigned char) ( UBRR_VAL>>8 );
    3b72:	10 92 c5 00 	sts	0x00C5, r1
		UBRR0L = (unsigned char) UBRR_VAL;									
    3b76:	80 e1       	ldi	r24, 0x10	; 16
    3b78:	80 93 c4 00 	sts	0x00C4, r24
	
		// UART Tx,Rx,RxINT einschalten, UDRIW und RXCIE werden erst w채rend der benutzung freigeben nach bedarf
		UCSR0B = ( 1<<TXEN0 ) | ( 1<<RXEN0 ) | ( 1<<RXCIE0 ) ; 
    3b7c:	88 e9       	ldi	r24, 0x98	; 152
    3b7e:	80 93 c1 00 	sts	0x00C1, r24
		// Asynchron 8N1
		UCSR0C = ( 1<< USBS0 ) | ( 1<<UCSZ01 ) | ( 1<<UCSZ00 ) ;    								 
    3b82:	8e e0       	ldi	r24, 0x0E	; 14
    3b84:	80 93 c2 00 	sts	0x00C2, r24
		// Asynchron 8N1
		UCSR0C = ( 1<< USBS0 ) | ( 1<<UCSZ01 ) | ( 1<<UCSZ00 ) ;    								 
	#endif
	
	return;
}
    3b88:	08 95       	ret

00003b8a <enc28j60WriteBuffer>:
//
// Buffer schreiben
//
//*********************************************************************************************************
void enc28j60WriteBuffer(unsigned int len, unsigned char * data)
{
    3b8a:	0f 93       	push	r16
    3b8c:	1f 93       	push	r17
    3b8e:	cf 93       	push	r28
    3b90:	df 93       	push	r29
    3b92:	ec 01       	movw	r28, r24
    3b94:	8b 01       	movw	r16, r22
	// assert CS
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
    3b96:	2c 98       	cbi	0x05, 4	; 5

	// issue write command
	SPI_ReadWrite( SPIBUS, ENC28J60_WRITE_BUF_MEM );
    3b98:	80 e0       	ldi	r24, 0x00	; 0
    3b9a:	90 e0       	ldi	r25, 0x00	; 0
    3b9c:	6a e7       	ldi	r22, 0x7A	; 122
    3b9e:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    3ba2:	08 c0       	rjmp	.+16     	; 0x3bb4 <enc28j60WriteBuffer+0x2a>

//	SPI1_FastMem2Write( data, len );
	while(len--)
	{
		// write data
		SPI_ReadWrite( SPIBUS, *data++ );
    3ba4:	f8 01       	movw	r30, r16
    3ba6:	61 91       	ld	r22, Z+
    3ba8:	8f 01       	movw	r16, r30
    3baa:	80 e0       	ldi	r24, 0x00	; 0
    3bac:	90 e0       	ldi	r25, 0x00	; 0
    3bae:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    3bb2:	21 97       	sbiw	r28, 0x01	; 1

	// issue write command
	SPI_ReadWrite( SPIBUS, ENC28J60_WRITE_BUF_MEM );

//	SPI1_FastMem2Write( data, len );
	while(len--)
    3bb4:	20 97       	sbiw	r28, 0x00	; 0
    3bb6:	b1 f7       	brne	.-20     	; 0x3ba4 <enc28j60WriteBuffer+0x1a>
	{
		// write data
		SPI_ReadWrite( SPIBUS, *data++ );
	}
	// release CS
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
    3bb8:	2c 9a       	sbi	0x05, 4	; 5
}
    3bba:	df 91       	pop	r29
    3bbc:	cf 91       	pop	r28
    3bbe:	1f 91       	pop	r17
    3bc0:	0f 91       	pop	r16
    3bc2:	08 95       	ret

00003bc4 <enc28j60WriteOp>:
//
// Sende Write Command
//
//*********************************************************************************************************
void enc28j60WriteOp( unsigned char op, unsigned char address,  unsigned char data)
{
    3bc4:	1f 93       	push	r17
    3bc6:	14 2f       	mov	r17, r20
	// CS aktive setzen
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
    3bc8:	2c 98       	cbi	0x05, 4	; 5
	// schreibcomando senden
	SPI_ReadWrite( SPIBUS, op | (address & ADDR_MASK) );
    3bca:	6f 71       	andi	r22, 0x1F	; 31
    3bcc:	68 2b       	or	r22, r24
    3bce:	80 e0       	ldi	r24, 0x00	; 0
    3bd0:	90 e0       	ldi	r25, 0x00	; 0
    3bd2:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	// daten senden
	SPI_ReadWrite( SPIBUS, data );
    3bd6:	80 e0       	ldi	r24, 0x00	; 0
    3bd8:	90 e0       	ldi	r25, 0x00	; 0
    3bda:	61 2f       	mov	r22, r17
    3bdc:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	// CS wieder freigeben
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
    3be0:	2c 9a       	sbi	0x05, 4	; 5
}
    3be2:	1f 91       	pop	r17
    3be4:	08 95       	ret

00003be6 <enc28j60SetBank>:
//
// 
//
//*********************************************************************************************************
void enc28j60SetBank(unsigned char address)
{
    3be6:	1f 93       	push	r17
    3be8:	cf 93       	push	r28
    3bea:	df 93       	push	r29
    3bec:	18 2f       	mov	r17, r24
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
    3bee:	c8 2f       	mov	r28, r24
    3bf0:	d0 e0       	ldi	r29, 0x00	; 0
    3bf2:	c0 76       	andi	r28, 0x60	; 96
    3bf4:	d0 70       	andi	r29, 0x00	; 0
    3bf6:	80 91 d0 07 	lds	r24, 0x07D0
    3bfa:	90 e0       	ldi	r25, 0x00	; 0
    3bfc:	c8 17       	cp	r28, r24
    3bfe:	d9 07       	cpc	r29, r25
    3c00:	91 f0       	breq	.+36     	; 0x3c26 <enc28j60SetBank+0x40>
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    3c02:	80 ea       	ldi	r24, 0xA0	; 160
    3c04:	6f e1       	ldi	r22, 0x1F	; 31
    3c06:	43 e0       	ldi	r20, 0x03	; 3
    3c08:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    3c0c:	85 e0       	ldi	r24, 0x05	; 5
    3c0e:	d5 95       	asr	r29
    3c10:	c7 95       	ror	r28
    3c12:	8a 95       	dec	r24
    3c14:	e1 f7       	brne	.-8      	; 0x3c0e <enc28j60SetBank+0x28>
    3c16:	80 e8       	ldi	r24, 0x80	; 128
    3c18:	6f e1       	ldi	r22, 0x1F	; 31
    3c1a:	4c 2f       	mov	r20, r28
    3c1c:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
		Enc28j60Bank = (address & BANK_MASK);
    3c20:	10 76       	andi	r17, 0x60	; 96
    3c22:	10 93 d0 07 	sts	0x07D0, r17
	}
}
    3c26:	df 91       	pop	r29
    3c28:	cf 91       	pop	r28
    3c2a:	1f 91       	pop	r17
    3c2c:	08 95       	ret

00003c2e <enc28j60Write>:
//
// 
//
//*********************************************************************************************************
void enc28j60Write(unsigned char address, unsigned char data)
{
    3c2e:	0f 93       	push	r16
    3c30:	1f 93       	push	r17
    3c32:	18 2f       	mov	r17, r24
    3c34:	06 2f       	mov	r16, r22
	// set the bank
	enc28j60SetBank(address);
    3c36:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <enc28j60SetBank>
	// do the write
	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    3c3a:	80 e4       	ldi	r24, 0x40	; 64
    3c3c:	61 2f       	mov	r22, r17
    3c3e:	40 2f       	mov	r20, r16
    3c40:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
}
    3c44:	1f 91       	pop	r17
    3c46:	0f 91       	pop	r16
    3c48:	08 95       	ret

00003c4a <nicSetMacAddress>:
//
// Setzt die MAC-Adressse im Enc28j60
//
//*********************************************************************************************************
void nicSetMacAddress( unsigned char * MAC)
{
    3c4a:	0f 93       	push	r16
    3c4c:	1f 93       	push	r17
    3c4e:	8c 01       	movw	r16, r24
	// write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
  	enc28j60Write(MAADR5, MAC[ 0 ] );
    3c50:	84 ee       	ldi	r24, 0xE4	; 228
    3c52:	f8 01       	movw	r30, r16
    3c54:	60 81       	ld	r22, Z
    3c56:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAADR4, MAC[ 1 ] );
    3c5a:	85 ee       	ldi	r24, 0xE5	; 229
    3c5c:	f8 01       	movw	r30, r16
    3c5e:	61 81       	ldd	r22, Z+1	; 0x01
    3c60:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAADR3, MAC[ 2 ] );
    3c64:	82 ee       	ldi	r24, 0xE2	; 226
    3c66:	f8 01       	movw	r30, r16
    3c68:	62 81       	ldd	r22, Z+2	; 0x02
    3c6a:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAADR2, MAC[ 3 ] );
    3c6e:	83 ee       	ldi	r24, 0xE3	; 227
    3c70:	f8 01       	movw	r30, r16
    3c72:	63 81       	ldd	r22, Z+3	; 0x03
    3c74:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAADR1, MAC[ 4 ] );
    3c78:	80 ee       	ldi	r24, 0xE0	; 224
    3c7a:	f8 01       	movw	r30, r16
    3c7c:	64 81       	ldd	r22, Z+4	; 0x04
    3c7e:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAADR0, MAC[ 5 ] );
    3c82:	81 ee       	ldi	r24, 0xE1	; 225
    3c84:	f8 01       	movw	r30, r16
    3c86:	65 81       	ldd	r22, Z+5	; 0x05
    3c88:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
}
    3c8c:	1f 91       	pop	r17
    3c8e:	0f 91       	pop	r16
    3c90:	08 95       	ret

00003c92 <enc28j60ReadOp>:
//
// Sende Rad Command
//
//*********************************************************************************************************
 unsigned char enc28j60ReadOp( unsigned char op,  unsigned char address)
{
    3c92:	1f 93       	push	r17
    3c94:	16 2f       	mov	r17, r22
	unsigned char data;
	// CS aktive setzen
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
    3c96:	2c 98       	cbi	0x05, 4	; 5
	// lesecomando schreiben
	data = SPI_ReadWrite( SPIBUS, op | (address & ADDR_MASK) );
    3c98:	6f 71       	andi	r22, 0x1F	; 31
    3c9a:	68 2b       	or	r22, r24
    3c9c:	80 e0       	ldi	r24, 0x00	; 0
    3c9e:	90 e0       	ldi	r25, 0x00	; 0
    3ca0:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	// dummy senden um ergebnis zu erhalten
	data = SPI_ReadWrite( SPIBUS, 0x00 );
    3ca4:	80 e0       	ldi	r24, 0x00	; 0
    3ca6:	90 e0       	ldi	r25, 0x00	; 0
    3ca8:	60 e0       	ldi	r22, 0x00	; 0
    3caa:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	// dummy read machen
	if ( address & 0x80 )
    3cae:	17 ff       	sbrs	r17, 7
    3cb0:	05 c0       	rjmp	.+10     	; 0x3cbc <enc28j60ReadOp+0x2a>
		data = SPI_ReadWrite( SPIBUS, 0x00 );
    3cb2:	80 e0       	ldi	r24, 0x00	; 0
    3cb4:	90 e0       	ldi	r25, 0x00	; 0
    3cb6:	60 e0       	ldi	r22, 0x00	; 0
    3cb8:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	// CS wieder freigeben
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
    3cbc:	2c 9a       	sbi	0x05, 4	; 5
	
	return data;
}
    3cbe:	1f 91       	pop	r17
    3cc0:	08 95       	ret

00003cc2 <enc28j60Read>:
//
// 
//
//*********************************************************************************************************
unsigned char enc28j60Read(unsigned char address)
{
    3cc2:	1f 93       	push	r17
    3cc4:	18 2f       	mov	r17, r24
	// set the bank
	enc28j60SetBank(address);
    3cc6:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <enc28j60SetBank>
	// do the read
	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    3cca:	80 e0       	ldi	r24, 0x00	; 0
    3ccc:	61 2f       	mov	r22, r17
    3cce:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
}
    3cd2:	1f 91       	pop	r17
    3cd4:	08 95       	ret

00003cd6 <enc28j60PacketSend>:
//
// Sendet ein Packet
//
//*********************************************************************************************************
void enc28j60PacketSend(unsigned int len, unsigned char* packet)
{
    3cd6:	ef 92       	push	r14
    3cd8:	ff 92       	push	r15
    3cda:	0f 93       	push	r16
    3cdc:	1f 93       	push	r17
    3cde:	8c 01       	movw	r16, r24
    3ce0:	7b 01       	movw	r14, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, ( unsigned char ) TXSTART_INIT );
    3ce2:	82 e0       	ldi	r24, 0x02	; 2
    3ce4:	60 e0       	ldi	r22, 0x00	; 0
    3ce6:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    3cea:	83 e0       	ldi	r24, 0x03	; 3
    3cec:	64 e1       	ldi	r22, 0x14	; 20
    3cee:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len));
    3cf2:	86 e0       	ldi	r24, 0x06	; 6
    3cf4:	60 2f       	mov	r22, r16
    3cf6:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    3cfa:	98 01       	movw	r18, r16
    3cfc:	20 50       	subi	r18, 0x00	; 0
    3cfe:	3c 4e       	sbci	r19, 0xEC	; 236
    3d00:	87 e0       	ldi	r24, 0x07	; 7
    3d02:	63 2f       	mov	r22, r19
    3d04:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>

	// write per-packet control byte
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    3d08:	8a e7       	ldi	r24, 0x7A	; 122
    3d0a:	60 e0       	ldi	r22, 0x00	; 0
    3d0c:	40 e0       	ldi	r20, 0x00	; 0
    3d0e:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>

	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
    3d12:	c8 01       	movw	r24, r16
    3d14:	b7 01       	movw	r22, r14
    3d16:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <enc28j60WriteBuffer>

	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    3d1a:	80 e8       	ldi	r24, 0x80	; 128
    3d1c:	6f e1       	ldi	r22, 0x1F	; 31
    3d1e:	48 e0       	ldi	r20, 0x08	; 8
    3d20:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>

	while ( (enc28j60Read(ECON1) & ECON1_TXRTS) != 0 );
    3d24:	8f e1       	ldi	r24, 0x1F	; 31
    3d26:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3d2a:	83 fd       	sbrc	r24, 3
    3d2c:	fb cf       	rjmp	.-10     	; 0x3d24 <enc28j60PacketSend+0x4e>

}
    3d2e:	1f 91       	pop	r17
    3d30:	0f 91       	pop	r16
    3d32:	ff 90       	pop	r15
    3d34:	ef 90       	pop	r14
    3d36:	08 95       	ret

00003d38 <enc28j60PhyWrite>:
//
// 
//
//*********************************************************************************************************
void enc28j60PhyWrite(unsigned char address, unsigned int data)
{
    3d38:	0f 93       	push	r16
    3d3a:	1f 93       	push	r17
    3d3c:	98 2f       	mov	r25, r24
    3d3e:	16 2f       	mov	r17, r22
    3d40:	07 2f       	mov	r16, r23
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
    3d42:	84 ed       	ldi	r24, 0xD4	; 212
    3d44:	69 2f       	mov	r22, r25
    3d46:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>

	// write the PHY data
	enc28j60Write(MIWRL, data);
    3d4a:	86 ed       	ldi	r24, 0xD6	; 214
    3d4c:	61 2f       	mov	r22, r17
    3d4e:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MIWRH, data>>8);
    3d52:	87 ed       	ldi	r24, 0xD7	; 215
    3d54:	60 2f       	mov	r22, r16
    3d56:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>

	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
    3d5a:	8a ee       	ldi	r24, 0xEA	; 234
    3d5c:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3d60:	80 fd       	sbrc	r24, 0
    3d62:	fb cf       	rjmp	.-10     	; 0x3d5a <enc28j60PhyWrite+0x22>
}
    3d64:	1f 91       	pop	r17
    3d66:	0f 91       	pop	r16
    3d68:	08 95       	ret

00003d6a <enc28j60Init>:

	// schau mal ob SPI schon laufen tut, wenn starten
	// if ( SPI_GetInitState() == SPI_NOT_INIT ) 
	// delay(10);
		
	SPI_init( SPIBUS );
    3d6a:	80 e0       	ldi	r24, 0x00	; 0
    3d6c:	90 e0       	ldi	r25, 0x00	; 0
    3d6e:	0e 94 82 1c 	call	0x3904	; 0x3904 <SPI_init>
			
	ENC28J60_CONTROL_DDR |= 1<<ENC28J60_CONTROL_CS;
    3d72:	24 9a       	sbi	0x04, 4	; 4
	ENC28J60_CONTROL_PORT |= 1<<ENC28J60_CONTROL_CS;
    3d74:	2c 9a       	sbi	0x05, 4	; 5
		#error "Hardwareplatform wird nicht unterst체tzt!"
	#endif
#endif
	
	// perform system reset
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
    3d76:	8f ef       	ldi	r24, 0xFF	; 255
    3d78:	60 e0       	ldi	r22, 0x00	; 0
    3d7a:	4f ef       	ldi	r20, 0xFF	; 255
    3d7c:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
	// check CLKRDY bit to see if reset is complete
	
	while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
    3d80:	8d e1       	ldi	r24, 0x1D	; 29
    3d82:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3d86:	80 ff       	sbrs	r24, 0
    3d88:	fb cf       	rjmp	.-10     	; 0x3d80 <enc28j60Init+0x16>
	// read die RevID
	REVID = enc28j60Read( EREVID );
    3d8a:	82 e7       	ldi	r24, 0x72	; 114
    3d8c:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3d90:	80 93 cf 07 	sts	0x07CF, r24
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	NextPacketPtr = RXSTART_INIT;
    3d94:	10 92 ce 07 	sts	0x07CE, r1
    3d98:	10 92 cd 07 	sts	0x07CD, r1
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
    3d9c:	88 e0       	ldi	r24, 0x08	; 8
    3d9e:	60 e0       	ldi	r22, 0x00	; 0
    3da0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
    3da4:	89 e0       	ldi	r24, 0x09	; 9
    3da6:	60 e0       	ldi	r22, 0x00	; 0
    3da8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
    3dac:	8c e0       	ldi	r24, 0x0C	; 12
    3dae:	60 e0       	ldi	r22, 0x00	; 0
    3db0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
    3db4:	8d e0       	ldi	r24, 0x0D	; 13
    3db6:	60 e0       	ldi	r22, 0x00	; 0
    3db8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// set receive buffer end
	// ERXND defaults to 0x1FFF (end of ram)
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
    3dbc:	8a e0       	ldi	r24, 0x0A	; 10
    3dbe:	6e ef       	ldi	r22, 0xFE	; 254
    3dc0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
    3dc4:	8b e0       	ldi	r24, 0x0B	; 11
    3dc6:	63 e1       	ldi	r22, 0x13	; 19
    3dc8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// set transmit buffer start
	// ETXST defaults to 0x0000 (beginnging of ram)
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
    3dcc:	84 e0       	ldi	r24, 0x04	; 4
    3dce:	60 e0       	ldi	r22, 0x00	; 0
    3dd0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
    3dd4:	85 e0       	ldi	r24, 0x05	; 5
    3dd6:	64 e1       	ldi	r22, 0x14	; 20
    3dd8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>

	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
    3ddc:	80 ec       	ldi	r24, 0xC0	; 192
    3dde:	6d e0       	ldi	r22, 0x0D	; 13
    3de0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
    3de4:	81 ec       	ldi	r24, 0xC1	; 193
    3de6:	60 e0       	ldi	r22, 0x00	; 0
    3de8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// bring MAC out of reset
	enc28j60Write(MACLCON1, 0x03);
    3dec:	88 ec       	ldi	r24, 0xC8	; 200
    3dee:	63 e0       	ldi	r22, 0x03	; 3
    3df0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// enable automatic padding and CRC operations
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
    3df4:	80 e8       	ldi	r24, 0x80	; 128
    3df6:	62 ec       	ldi	r22, 0xC2	; 194
    3df8:	42 e3       	ldi	r20, 0x32	; 50
    3dfa:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>

	// set inter-frame gap (non-back-to-back)
	enc28j60Write(MAIPGL, 0x12);
    3dfe:	86 ec       	ldi	r24, 0xC6	; 198
    3e00:	62 e1       	ldi	r22, 0x12	; 18
    3e02:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
    3e06:	87 ec       	ldi	r24, 0xC7	; 199
    3e08:	6c e0       	ldi	r22, 0x0C	; 12
    3e0a:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
    3e0e:	84 ec       	ldi	r24, 0xC4	; 196
    3e10:	62 e1       	ldi	r22, 0x12	; 18
    3e12:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// Set the maximum packet size which the controller will accept
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);
    3e16:	8a ec       	ldi	r24, 0xCA	; 202
    3e18:	60 e0       	ldi	r22, 0x00	; 0
    3e1a:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
    3e1e:	8b ec       	ldi	r24, 0xCB	; 203
    3e20:	62 e0       	ldi	r22, 0x02	; 2
    3e22:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>

	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
    3e26:	80 e1       	ldi	r24, 0x10	; 16
    3e28:	60 e0       	ldi	r22, 0x00	; 0
    3e2a:	71 e0       	ldi	r23, 0x01	; 1
    3e2c:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <enc28j60PhyWrite>

	// switch to bank 0
	enc28j60SetBank(ECON1);
    3e30:	8f e1       	ldi	r24, 0x1F	; 31
    3e32:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <enc28j60SetBank>
	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
    3e36:	80 e8       	ldi	r24, 0x80	; 128
    3e38:	6b e1       	ldi	r22, 0x1B	; 27
    3e3a:	40 ec       	ldi	r20, 0xC0	; 192
    3e3c:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    3e40:	80 e8       	ldi	r24, 0x80	; 128
    3e42:	6f e1       	ldi	r22, 0x1F	; 31
    3e44:	44 e0       	ldi	r20, 0x04	; 4
    3e46:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
	// LED initialization
	enc28j60PhyWrite(PHLCON, 0x0476);
    3e4a:	84 e1       	ldi	r24, 0x14	; 20
    3e4c:	66 e7       	ldi	r22, 0x76	; 118
    3e4e:	74 e0       	ldi	r23, 0x04	; 4
    3e50:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <enc28j60PhyWrite>
    
}
    3e54:	08 95       	ret

00003e56 <enc28j60PhyRead>:
//
// 
//
//*********************************************************************************************************
unsigned int enc28j60PhyRead(unsigned char address)
{
    3e56:	0f 93       	push	r16
    3e58:	1f 93       	push	r17
    3e5a:	68 2f       	mov	r22, r24
     unsigned int data;
 
     // Set the right address and start the register read operation
     enc28j60Write(MIREGADR, address);
    3e5c:	84 ed       	ldi	r24, 0xD4	; 212
    3e5e:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
     enc28j60Write(MICMD, MICMD_MIIRD);
    3e62:	82 ed       	ldi	r24, 0xD2	; 210
    3e64:	61 e0       	ldi	r22, 0x01	; 1
    3e66:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
 
    // wait until the PHY read completes
     while(enc28j60Read(MISTAT) & MISTAT_BUSY);
    3e6a:	8a ee       	ldi	r24, 0xEA	; 234
    3e6c:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3e70:	80 fd       	sbrc	r24, 0
    3e72:	fb cf       	rjmp	.-10     	; 0x3e6a <enc28j60PhyRead+0x14>
 
     // quit reading
     enc28j60Write(MICMD, 0x00);
    3e74:	82 ed       	ldi	r24, 0xD2	; 210
    3e76:	60 e0       	ldi	r22, 0x00	; 0
    3e78:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
     
     // get data value
     data  = enc28j60Read(MIRDL);
    3e7c:	88 ed       	ldi	r24, 0xD8	; 216
    3e7e:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3e82:	08 2f       	mov	r16, r24
    3e84:	10 e0       	ldi	r17, 0x00	; 0
     data |= enc28j60Read(MIRDH)<<8;
    3e86:	89 ed       	ldi	r24, 0xD9	; 217
    3e88:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3e8c:	38 2f       	mov	r19, r24
    3e8e:	20 e0       	ldi	r18, 0x00	; 0
    3e90:	20 2b       	or	r18, r16
    3e92:	31 2b       	or	r19, r17
     // return the data
     return data;
}
    3e94:	c9 01       	movw	r24, r18
    3e96:	1f 91       	pop	r17
    3e98:	0f 91       	pop	r16
    3e9a:	08 95       	ret

00003e9c <enc28j60Linkcheck>:
	return len;
}

unsigned char enc28j60Linkcheck(void)                                              //
{                                                                           //
    if(enc28j60PhyRead(0x01) & PHSTAT1_LLSTAT)                              // Pr체fe ob Netzwerk Link vorhanden
    3e9c:	81 e0       	ldi	r24, 0x01	; 1
    3e9e:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <enc28j60PhyRead>
    3ea2:	96 95       	lsr	r25
    3ea4:	87 95       	ror	r24
    3ea6:	96 95       	lsr	r25
    3ea8:	87 95       	ror	r24
    3eaa:	80 95       	com	r24
    }                                                                       //
    else                                                                    // Wenn nicht dann
    {                                                                       //
        return ( LINK_DOWN );                                               //
    }                                                                       //
}
    3eac:	81 70       	andi	r24, 0x01	; 1
    3eae:	08 95       	ret

00003eb0 <enc28j60EnableFullDuplex>:

void enc28j60EnableFullDuplex( void )
{
    // setup duplex ----------------------
    // Disable receive logic and abort any packets currently being transmitted
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS|ECON1_RXEN);
    3eb0:	80 ea       	ldi	r24, 0xA0	; 160
    3eb2:	6f e1       	ldi	r22, 0x1F	; 31
    3eb4:	4c e0       	ldi	r20, 0x0C	; 12
    3eb6:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
     
    unsigned int temp;
    // Set the PHY to the proper duplex mode
    temp = enc28j60PhyRead(PHCON1);
    3eba:	80 e0       	ldi	r24, 0x00	; 0
    3ebc:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <enc28j60PhyRead>
    temp &= ~PHCON1_PDPXMD;
    enc28j60PhyWrite(PHCON1, temp);
    3ec0:	bc 01       	movw	r22, r24
    3ec2:	7e 7f       	andi	r23, 0xFE	; 254
    3ec4:	80 e0       	ldi	r24, 0x00	; 0
    3ec6:	0e 94 9c 1e 	call	0x3d38	; 0x3d38 <enc28j60PhyWrite>
    // Set the MAC to the proper duplex mode
    temp = enc28j60Read(MACON3);
    3eca:	82 ec       	ldi	r24, 0xC2	; 194
    3ecc:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3ed0:	68 2f       	mov	r22, r24
    3ed2:	70 e0       	ldi	r23, 0x00	; 0
    temp &= ~MACON3_FULDPX;
    enc28j60Write(MACON3, temp);
    3ed4:	6e 7f       	andi	r22, 0xFE	; 254
    3ed6:	82 ec       	ldi	r24, 0xC2	; 194
    3ed8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
    // state, so it must be updated in this function.
    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex
    // enc28j60Write(MABBIPG, DuplexState ? 0x15 : 0x12);    
    
    // Reenable receive logic
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    3edc:	80 e8       	ldi	r24, 0x80	; 128
    3ede:	6f e1       	ldi	r22, 0x1F	; 31
    3ee0:	44 e0       	ldi	r20, 0x04	; 4
    3ee2:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>

	return;
}
    3ee6:	08 95       	ret

00003ee8 <enc28j60ReadBuffer>:
//
// Buffer einlesen
//
//*********************************************************************************************************
void enc28j60ReadBuffer(unsigned int len, unsigned char * data)
{
    3ee8:	ef 92       	push	r14
    3eea:	ff 92       	push	r15
    3eec:	0f 93       	push	r16
    3eee:	1f 93       	push	r17
    3ef0:	7c 01       	movw	r14, r24
    3ef2:	8b 01       	movw	r16, r22
	// assert CS
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
    3ef4:	2c 98       	cbi	0x05, 4	; 5
	
	// issue read command
	SPI_ReadWrite( SPIBUS, ENC28J60_READ_BUF_MEM );
    3ef6:	80 e0       	ldi	r24, 0x00	; 0
    3ef8:	90 e0       	ldi	r25, 0x00	; 0
    3efa:	6a e3       	ldi	r22, 0x3A	; 58
    3efc:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>

	SPI_ReadBlock( SPIBUS, data, len);
    3f00:	80 e0       	ldi	r24, 0x00	; 0
    3f02:	90 e0       	ldi	r25, 0x00	; 0
    3f04:	b8 01       	movw	r22, r16
    3f06:	a7 01       	movw	r20, r14
    3f08:	0e 94 9d 1c 	call	0x393a	; 0x393a <SPI_ReadBlock>
		*data++ = SPI1_ReadWrite( 0x00 );
	} */

	// release CS

	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
    3f0c:	2c 9a       	sbi	0x05, 4	; 5
}
    3f0e:	1f 91       	pop	r17
    3f10:	0f 91       	pop	r16
    3f12:	ff 90       	pop	r15
    3f14:	ef 90       	pop	r14
    3f16:	08 95       	ret

00003f18 <enc28j60PacketReceive>:
//
// Hole ein empfangendes Packet
//
//*********************************************************************************************************
unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
{
    3f18:	a0 e0       	ldi	r26, 0x00	; 0
    3f1a:	b0 e0       	ldi	r27, 0x00	; 0
    3f1c:	e2 e9       	ldi	r30, 0x92	; 146
    3f1e:	ff e1       	ldi	r31, 0x1F	; 31
    3f20:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    3f24:	ec 01       	movw	r28, r24
    3f26:	7b 01       	movw	r14, r22
	unsigned int rxstat, rs,re;;
	unsigned int len;

	// check if a packet has been received and buffered
	if( !(enc28j60Read(EIR) & EIR_PKTIF) )
    3f28:	8c e1       	ldi	r24, 0x1C	; 28
    3f2a:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3f2e:	86 fd       	sbrc	r24, 6
    3f30:	06 c0       	rjmp	.+12     	; 0x3f3e <enc28j60PacketReceive+0x26>
		if (enc28j60Read(EPKTCNT) == 0)
    3f32:	89 e3       	ldi	r24, 0x39	; 57
    3f34:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3f38:	88 23       	and	r24, r24
    3f3a:	09 f4       	brne	.+2      	; 0x3f3e <enc28j60PacketReceive+0x26>
    3f3c:	48 c0       	rjmp	.+144    	; 0x3fce <enc28j60PacketReceive+0xb6>
	// Make absolutely certain that any previous packet was discarded	
	//if( WasDiscarded == FALSE)
	//	MACDiscardRx();

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
    3f3e:	80 e0       	ldi	r24, 0x00	; 0
    3f40:	60 91 cd 07 	lds	r22, 0x07CD
    3f44:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
    3f48:	60 91 ce 07 	lds	r22, 0x07CE
    3f4c:	81 e0       	ldi	r24, 0x01	; 1
    3f4e:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    3f52:	8a e3       	ldi	r24, 0x3A	; 58
    3f54:	60 e0       	ldi	r22, 0x00	; 0
    3f56:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
    3f5a:	08 2f       	mov	r16, r24
    3f5c:	10 e0       	ldi	r17, 0x00	; 0
    3f5e:	10 93 ce 07 	sts	0x07CE, r17
    3f62:	00 93 cd 07 	sts	0x07CD, r16
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    3f66:	8a e3       	ldi	r24, 0x3A	; 58
    3f68:	60 e0       	ldi	r22, 0x00	; 0
    3f6a:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
    3f6e:	38 2f       	mov	r19, r24
    3f70:	20 e0       	ldi	r18, 0x00	; 0
    3f72:	20 2b       	or	r18, r16
    3f74:	31 2b       	or	r19, r17
    3f76:	30 93 ce 07 	sts	0x07CE, r19
    3f7a:	20 93 cd 07 	sts	0x07CD, r18
	
	// read the packet length
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    3f7e:	8a e3       	ldi	r24, 0x3A	; 58
    3f80:	60 e0       	ldi	r22, 0x00	; 0
    3f82:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
    3f86:	a8 2e       	mov	r10, r24
    3f88:	bb 24       	eor	r11, r11
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    3f8a:	8a e3       	ldi	r24, 0x3A	; 58
    3f8c:	60 e0       	ldi	r22, 0x00	; 0
    3f8e:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
    3f92:	38 2f       	mov	r19, r24
    3f94:	20 e0       	ldi	r18, 0x00	; 0
    3f96:	a2 2a       	or	r10, r18
    3f98:	b3 2a       	or	r11, r19
	
	// read the receive status
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    3f9a:	8a e3       	ldi	r24, 0x3A	; 58
    3f9c:	60 e0       	ldi	r22, 0x00	; 0
    3f9e:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
	rxstat |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    3fa2:	8a e3       	ldi	r24, 0x3A	; 58
    3fa4:	60 e0       	ldi	r22, 0x00	; 0
    3fa6:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <enc28j60ReadOp>
	
	// limit retrieve length
	// len = MIN(len, maxlen);
	// When len bigger than maxlen, ignore the packet und read next packetptr
	if ( len > maxlen ) 
    3faa:	ca 15       	cp	r28, r10
    3fac:	db 05       	cpc	r29, r11
    3fae:	90 f4       	brcc	.+36     	; 0x3fd4 <enc28j60PacketReceive+0xbc>
	{
		enc28j60Write(ERXRDPTL, (NextPacketPtr));
    3fb0:	8c e0       	ldi	r24, 0x0C	; 12
    3fb2:	60 91 cd 07 	lds	r22, 0x07CD
    3fb6:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
		enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
    3fba:	60 91 ce 07 	lds	r22, 0x07CE
    3fbe:	8d e0       	ldi	r24, 0x0D	; 13
    3fc0:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    3fc4:	80 e8       	ldi	r24, 0x80	; 128
    3fc6:	6e e1       	ldi	r22, 0x1E	; 30
    3fc8:	40 e4       	ldi	r20, 0x40	; 64
    3fca:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>
    3fce:	aa 24       	eor	r10, r10
    3fd0:	bb 24       	eor	r11, r11
    3fd2:	42 c0       	rjmp	.+132    	; 0x4058 <enc28j60PacketReceive+0x140>
		return(0);
	}
	// copy the packet from the receive buffer
	enc28j60ReadBuffer(len, packet);
    3fd4:	c5 01       	movw	r24, r10
    3fd6:	b7 01       	movw	r22, r14
    3fd8:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <enc28j60ReadBuffer>
	
	// an implementation of Errata B1 Section #13
    rs = enc28j60Read(ERXSTH);
    3fdc:	89 e0       	ldi	r24, 0x09	; 9
    3fde:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    rs <<= 8;
    3fe2:	18 2f       	mov	r17, r24
    3fe4:	00 e0       	ldi	r16, 0x00	; 0
    rs |= enc28j60Read(ERXSTL);
    3fe6:	88 e0       	ldi	r24, 0x08	; 8
    3fe8:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3fec:	c8 2e       	mov	r12, r24
    re = enc28j60Read(ERXNDH);
    3fee:	8b e0       	ldi	r24, 0x0B	; 11
    3ff0:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    re <<= 8;
    3ff4:	f8 2e       	mov	r15, r24
    3ff6:	ee 24       	eor	r14, r14
    re |= enc28j60Read(ERXNDL);
    3ff8:	8a e0       	ldi	r24, 0x0A	; 10
    3ffa:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    3ffe:	c8 2f       	mov	r28, r24
    4000:	d0 e0       	ldi	r29, 0x00	; 0
    4002:	ce 29       	or	r28, r14
    4004:	df 29       	or	r29, r15
    if (NextPacketPtr - 1 < rs || NextPacketPtr - 1 > re)
    4006:	60 91 cd 07 	lds	r22, 0x07CD
    400a:	70 91 ce 07 	lds	r23, 0x07CE
    400e:	cb 01       	movw	r24, r22
    4010:	01 97       	sbiw	r24, 0x01	; 1
    4012:	dd 24       	eor	r13, r13
    4014:	0c 29       	or	r16, r12
    4016:	1d 29       	or	r17, r13
    4018:	80 17       	cp	r24, r16
    401a:	91 07       	cpc	r25, r17
    401c:	18 f0       	brcs	.+6      	; 0x4024 <enc28j60PacketReceive+0x10c>
    401e:	c8 17       	cp	r28, r24
    4020:	d9 07       	cpc	r29, r25
    4022:	38 f4       	brcc	.+14     	; 0x4032 <enc28j60PacketReceive+0x11a>
    {
        enc28j60Write(ERXRDPTL, (re));
    4024:	8c e0       	ldi	r24, 0x0C	; 12
    4026:	6c 2f       	mov	r22, r28
    4028:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
        enc28j60Write(ERXRDPTH, (re)>>8);
    402c:	8d e0       	ldi	r24, 0x0D	; 13
    402e:	6d 2f       	mov	r22, r29
    4030:	0c c0       	rjmp	.+24     	; 0x404a <enc28j60PacketReceive+0x132>
    }
    else
    {
        enc28j60Write(ERXRDPTL, (NextPacketPtr-1));
    4032:	61 50       	subi	r22, 0x01	; 1
    4034:	8c e0       	ldi	r24, 0x0C	; 12
    4036:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
        enc28j60Write(ERXRDPTH, (NextPacketPtr-1)>>8);
    403a:	20 91 cd 07 	lds	r18, 0x07CD
    403e:	30 91 ce 07 	lds	r19, 0x07CE
    4042:	21 50       	subi	r18, 0x01	; 1
    4044:	30 40       	sbci	r19, 0x00	; 0
    4046:	8d e0       	ldi	r24, 0x0D	; 13
    4048:	63 2f       	mov	r22, r19
    404a:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <enc28j60Write>
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8); */
	
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    404e:	80 e8       	ldi	r24, 0x80	; 128
    4050:	6e e1       	ldi	r22, 0x1E	; 30
    4052:	40 e4       	ldi	r20, 0x40	; 64
    4054:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <enc28j60WriteOp>

	return len;
}
    4058:	c5 01       	movw	r24, r10
    405a:	cd b7       	in	r28, 0x3d	; 61
    405c:	de b7       	in	r29, 0x3e	; 62
    405e:	ea e0       	ldi	r30, 0x0A	; 10
    4060:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00004064 <PCINT_init>:
void PCINT_init ( void )
{
	int i;

	char sreg_tmp;
	sreg_tmp = SREG;    /* Sichern */
    4064:	8f b7       	in	r24, 0x3f	; 63
	cli();
    4066:	f8 94       	cli

	for ( i = 0 ; i < 4 ; i++ )
		PCINT_table[ i ].FUNCTION = NULL;
    4068:	10 92 d2 07 	sts	0x07D2, r1
    406c:	10 92 d1 07 	sts	0x07D1, r1
    4070:	10 92 d4 07 	sts	0x07D4, r1
    4074:	10 92 d3 07 	sts	0x07D3, r1
    4078:	10 92 d6 07 	sts	0x07D6, r1
    407c:	10 92 d5 07 	sts	0x07D5, r1
    4080:	10 92 d8 07 	sts	0x07D8, r1
    4084:	10 92 d7 07 	sts	0x07D7, r1

	SREG = sreg_tmp;
    4088:	8f bf       	out	0x3f, r24	; 63
}
    408a:	08 95       	ret

0000408c <PCINT_set>:
 * \param		NONE
 * \return		NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int PCINT_set ( unsigned char PCINT, PCINT_CALLBACK_FUNC pFunc )
{
    408c:	e8 2f       	mov	r30, r24
	char sreg_tmp;

	sreg_tmp = SREG;    /* Sichern */
    408e:	8f b7       	in	r24, 0x3f	; 63
	cli();
    4090:	f8 94       	cli

	// CallbackFunc eintragen
	PCINT_table[ PCINT ].FUNCTION = pFunc ;
    4092:	f0 e0       	ldi	r31, 0x00	; 0
    4094:	ee 0f       	add	r30, r30
    4096:	ff 1f       	adc	r31, r31
    4098:	ef 52       	subi	r30, 0x2F	; 47
    409a:	f8 4f       	sbci	r31, 0xF8	; 248
    409c:	71 83       	std	Z+1, r23	; 0x01
    409e:	60 83       	st	Z, r22

	SREG = sreg_tmp;
    40a0:	8f bf       	out	0x3f, r24	; 63
	
	return( 0 );
}
    40a2:	80 e0       	ldi	r24, 0x00	; 0
    40a4:	90 e0       	ldi	r25, 0x00	; 0
    40a6:	08 95       	ret

000040a8 <PCINT_enablePCINT>:
 * \return		NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int PCINT_enablePCINT( unsigned char PCINT )
{
	PCICR |= ( 1<<PCINT );
    40a8:	e8 e6       	ldi	r30, 0x68	; 104
    40aa:	f0 e0       	ldi	r31, 0x00	; 0
    40ac:	90 81       	ld	r25, Z
    40ae:	21 e0       	ldi	r18, 0x01	; 1
    40b0:	30 e0       	ldi	r19, 0x00	; 0
    40b2:	02 c0       	rjmp	.+4      	; 0x40b8 <PCINT_enablePCINT+0x10>
    40b4:	22 0f       	add	r18, r18
    40b6:	33 1f       	adc	r19, r19
    40b8:	8a 95       	dec	r24
    40ba:	e2 f7       	brpl	.-8      	; 0x40b4 <PCINT_enablePCINT+0xc>
    40bc:	92 2b       	or	r25, r18
    40be:	90 83       	st	Z, r25
	return( 0 );
}
    40c0:	80 e0       	ldi	r24, 0x00	; 0
    40c2:	90 e0       	ldi	r25, 0x00	; 0
    40c4:	08 95       	ret

000040c6 <PCINT_enablePIN>:
 * \param		NONE
 * \return		NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int PCINT_enablePIN( unsigned char PIN, unsigned char PCINT )
{
    40c6:	38 2f       	mov	r19, r24
	PCICR |= ( 1<<PCINT );
    40c8:	20 91 68 00 	lds	r18, 0x0068
    40cc:	41 e0       	ldi	r20, 0x01	; 1
    40ce:	50 e0       	ldi	r21, 0x00	; 0
    40d0:	ca 01       	movw	r24, r20
    40d2:	06 2e       	mov	r0, r22
    40d4:	02 c0       	rjmp	.+4      	; 0x40da <PCINT_enablePIN+0x14>
    40d6:	88 0f       	add	r24, r24
    40d8:	99 1f       	adc	r25, r25
    40da:	0a 94       	dec	r0
    40dc:	e2 f7       	brpl	.-8      	; 0x40d6 <PCINT_enablePIN+0x10>
    40de:	28 2b       	or	r18, r24
    40e0:	20 93 68 00 	sts	0x0068, r18

	switch( PCINT )
    40e4:	61 30       	cpi	r22, 0x01	; 1
    40e6:	91 f0       	breq	.+36     	; 0x410c <PCINT_enablePIN+0x46>
    40e8:	61 30       	cpi	r22, 0x01	; 1
    40ea:	28 f0       	brcs	.+10     	; 0x40f6 <PCINT_enablePIN+0x30>
    40ec:	62 30       	cpi	r22, 0x02	; 2
    40ee:	c9 f0       	breq	.+50     	; 0x4122 <PCINT_enablePIN+0x5c>
    40f0:	63 30       	cpi	r22, 0x03	; 3
    40f2:	61 f5       	brne	.+88     	; 0x414c <PCINT_enablePIN+0x86>
    40f4:	21 c0       	rjmp	.+66     	; 0x4138 <PCINT_enablePIN+0x72>
	{
		case 0:			PCMSK0 |= ( 1<<PIN );
    40f6:	80 91 6b 00 	lds	r24, 0x006B
    40fa:	02 c0       	rjmp	.+4      	; 0x4100 <PCINT_enablePIN+0x3a>
    40fc:	44 0f       	add	r20, r20
    40fe:	55 1f       	adc	r21, r21
    4100:	3a 95       	dec	r19
    4102:	e2 f7       	brpl	.-8      	; 0x40fc <PCINT_enablePIN+0x36>
    4104:	84 2b       	or	r24, r20
    4106:	80 93 6b 00 	sts	0x006B, r24
    410a:	20 c0       	rjmp	.+64     	; 0x414c <PCINT_enablePIN+0x86>
						break;
		case 1:			PCMSK1 |= ( 1<<PIN );
    410c:	80 91 6c 00 	lds	r24, 0x006C
    4110:	02 c0       	rjmp	.+4      	; 0x4116 <PCINT_enablePIN+0x50>
    4112:	44 0f       	add	r20, r20
    4114:	55 1f       	adc	r21, r21
    4116:	3a 95       	dec	r19
    4118:	e2 f7       	brpl	.-8      	; 0x4112 <PCINT_enablePIN+0x4c>
    411a:	84 2b       	or	r24, r20
    411c:	80 93 6c 00 	sts	0x006C, r24
    4120:	15 c0       	rjmp	.+42     	; 0x414c <PCINT_enablePIN+0x86>
						break;
		case 2:			PCMSK2 |= ( 1<<PIN );
    4122:	80 91 6d 00 	lds	r24, 0x006D
    4126:	02 c0       	rjmp	.+4      	; 0x412c <PCINT_enablePIN+0x66>
    4128:	44 0f       	add	r20, r20
    412a:	55 1f       	adc	r21, r21
    412c:	3a 95       	dec	r19
    412e:	e2 f7       	brpl	.-8      	; 0x4128 <PCINT_enablePIN+0x62>
    4130:	84 2b       	or	r24, r20
    4132:	80 93 6d 00 	sts	0x006D, r24
    4136:	0a c0       	rjmp	.+20     	; 0x414c <PCINT_enablePIN+0x86>
						break;
		case 3:			PCMSK3 |= ( 1<<PIN );
    4138:	80 91 73 00 	lds	r24, 0x0073
    413c:	02 c0       	rjmp	.+4      	; 0x4142 <PCINT_enablePIN+0x7c>
    413e:	44 0f       	add	r20, r20
    4140:	55 1f       	adc	r21, r21
    4142:	3a 95       	dec	r19
    4144:	e2 f7       	brpl	.-8      	; 0x413e <PCINT_enablePIN+0x78>
    4146:	84 2b       	or	r24, r20
    4148:	80 93 73 00 	sts	0x0073, r24
						break;
	}

	return( 0 );
}
    414c:	80 e0       	ldi	r24, 0x00	; 0
    414e:	90 e0       	ldi	r25, 0x00	; 0
    4150:	08 95       	ret

00004152 <__vector_4>:
 * \param		NONE
 * \return		NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
ISR(PCINT0_vect)
{
    4152:	1f 92       	push	r1
    4154:	0f 92       	push	r0
    4156:	0f b6       	in	r0, 0x3f	; 63
    4158:	0f 92       	push	r0
    415a:	11 24       	eor	r1, r1
    415c:	2f 93       	push	r18
    415e:	3f 93       	push	r19
    4160:	4f 93       	push	r20
    4162:	5f 93       	push	r21
    4164:	6f 93       	push	r22
    4166:	7f 93       	push	r23
    4168:	8f 93       	push	r24
    416a:	9f 93       	push	r25
    416c:	af 93       	push	r26
    416e:	bf 93       	push	r27
    4170:	ef 93       	push	r30
    4172:	ff 93       	push	r31
	PCIFR |= ( 1<<0 );
    4174:	d8 9a       	sbi	0x1b, 0	; 27
	if ( PCINT_table[ 0 ].FUNCTION != NULL )
    4176:	80 91 d1 07 	lds	r24, 0x07D1
    417a:	90 91 d2 07 	lds	r25, 0x07D2
    417e:	89 2b       	or	r24, r25
    4180:	29 f0       	breq	.+10     	; 0x418c <__vector_4+0x3a>
		PCINT_table[ 0 ].FUNCTION();
    4182:	e0 91 d1 07 	lds	r30, 0x07D1
    4186:	f0 91 d2 07 	lds	r31, 0x07D2
    418a:	09 95       	icall
}
    418c:	ff 91       	pop	r31
    418e:	ef 91       	pop	r30
    4190:	bf 91       	pop	r27
    4192:	af 91       	pop	r26
    4194:	9f 91       	pop	r25
    4196:	8f 91       	pop	r24
    4198:	7f 91       	pop	r23
    419a:	6f 91       	pop	r22
    419c:	5f 91       	pop	r21
    419e:	4f 91       	pop	r20
    41a0:	3f 91       	pop	r19
    41a2:	2f 91       	pop	r18
    41a4:	0f 90       	pop	r0
    41a6:	0f be       	out	0x3f, r0	; 63
    41a8:	0f 90       	pop	r0
    41aa:	1f 90       	pop	r1
    41ac:	18 95       	reti

000041ae <__vector_5>:

ISR(PCINT1_vect)
{
    41ae:	1f 92       	push	r1
    41b0:	0f 92       	push	r0
    41b2:	0f b6       	in	r0, 0x3f	; 63
    41b4:	0f 92       	push	r0
    41b6:	11 24       	eor	r1, r1
    41b8:	2f 93       	push	r18
    41ba:	3f 93       	push	r19
    41bc:	4f 93       	push	r20
    41be:	5f 93       	push	r21
    41c0:	6f 93       	push	r22
    41c2:	7f 93       	push	r23
    41c4:	8f 93       	push	r24
    41c6:	9f 93       	push	r25
    41c8:	af 93       	push	r26
    41ca:	bf 93       	push	r27
    41cc:	ef 93       	push	r30
    41ce:	ff 93       	push	r31
	PCIFR |= ( 1<<1 );
    41d0:	d9 9a       	sbi	0x1b, 1	; 27
	if ( PCINT_table[ 1 ].FUNCTION != NULL )
    41d2:	80 91 d3 07 	lds	r24, 0x07D3
    41d6:	90 91 d4 07 	lds	r25, 0x07D4
    41da:	89 2b       	or	r24, r25
    41dc:	29 f0       	breq	.+10     	; 0x41e8 <__vector_5+0x3a>
		PCINT_table[ 1 ].FUNCTION();
    41de:	e0 91 d3 07 	lds	r30, 0x07D3
    41e2:	f0 91 d4 07 	lds	r31, 0x07D4
    41e6:	09 95       	icall
}
    41e8:	ff 91       	pop	r31
    41ea:	ef 91       	pop	r30
    41ec:	bf 91       	pop	r27
    41ee:	af 91       	pop	r26
    41f0:	9f 91       	pop	r25
    41f2:	8f 91       	pop	r24
    41f4:	7f 91       	pop	r23
    41f6:	6f 91       	pop	r22
    41f8:	5f 91       	pop	r21
    41fa:	4f 91       	pop	r20
    41fc:	3f 91       	pop	r19
    41fe:	2f 91       	pop	r18
    4200:	0f 90       	pop	r0
    4202:	0f be       	out	0x3f, r0	; 63
    4204:	0f 90       	pop	r0
    4206:	1f 90       	pop	r1
    4208:	18 95       	reti

0000420a <__vector_6>:

ISR(PCINT2_vect)
{
    420a:	1f 92       	push	r1
    420c:	0f 92       	push	r0
    420e:	0f b6       	in	r0, 0x3f	; 63
    4210:	0f 92       	push	r0
    4212:	11 24       	eor	r1, r1
    4214:	2f 93       	push	r18
    4216:	3f 93       	push	r19
    4218:	4f 93       	push	r20
    421a:	5f 93       	push	r21
    421c:	6f 93       	push	r22
    421e:	7f 93       	push	r23
    4220:	8f 93       	push	r24
    4222:	9f 93       	push	r25
    4224:	af 93       	push	r26
    4226:	bf 93       	push	r27
    4228:	ef 93       	push	r30
    422a:	ff 93       	push	r31
	PCIFR |= ( 1<<2 );
    422c:	da 9a       	sbi	0x1b, 2	; 27
	if ( PCINT_table[ 2 ].FUNCTION != NULL )
    422e:	80 91 d5 07 	lds	r24, 0x07D5
    4232:	90 91 d6 07 	lds	r25, 0x07D6
    4236:	89 2b       	or	r24, r25
    4238:	29 f0       	breq	.+10     	; 0x4244 <__vector_6+0x3a>
		PCINT_table[ 2 ].FUNCTION();
    423a:	e0 91 d5 07 	lds	r30, 0x07D5
    423e:	f0 91 d6 07 	lds	r31, 0x07D6
    4242:	09 95       	icall
}
    4244:	ff 91       	pop	r31
    4246:	ef 91       	pop	r30
    4248:	bf 91       	pop	r27
    424a:	af 91       	pop	r26
    424c:	9f 91       	pop	r25
    424e:	8f 91       	pop	r24
    4250:	7f 91       	pop	r23
    4252:	6f 91       	pop	r22
    4254:	5f 91       	pop	r21
    4256:	4f 91       	pop	r20
    4258:	3f 91       	pop	r19
    425a:	2f 91       	pop	r18
    425c:	0f 90       	pop	r0
    425e:	0f be       	out	0x3f, r0	; 63
    4260:	0f 90       	pop	r0
    4262:	1f 90       	pop	r1
    4264:	18 95       	reti

00004266 <__vector_7>:

ISR(PCINT3_vect)
{
    4266:	1f 92       	push	r1
    4268:	0f 92       	push	r0
    426a:	0f b6       	in	r0, 0x3f	; 63
    426c:	0f 92       	push	r0
    426e:	11 24       	eor	r1, r1
    4270:	2f 93       	push	r18
    4272:	3f 93       	push	r19
    4274:	4f 93       	push	r20
    4276:	5f 93       	push	r21
    4278:	6f 93       	push	r22
    427a:	7f 93       	push	r23
    427c:	8f 93       	push	r24
    427e:	9f 93       	push	r25
    4280:	af 93       	push	r26
    4282:	bf 93       	push	r27
    4284:	ef 93       	push	r30
    4286:	ff 93       	push	r31
	PCIFR |= ( 1<<3 );
    4288:	db 9a       	sbi	0x1b, 3	; 27
	if ( PCINT_table[ 3 ].FUNCTION != NULL )
    428a:	80 91 d7 07 	lds	r24, 0x07D7
    428e:	90 91 d8 07 	lds	r25, 0x07D8
    4292:	89 2b       	or	r24, r25
    4294:	29 f0       	breq	.+10     	; 0x42a0 <__vector_7+0x3a>
		PCINT_table[ 3 ].FUNCTION();
    4296:	e0 91 d7 07 	lds	r30, 0x07D7
    429a:	f0 91 d8 07 	lds	r31, 0x07D8
    429e:	09 95       	icall
}
    42a0:	ff 91       	pop	r31
    42a2:	ef 91       	pop	r30
    42a4:	bf 91       	pop	r27
    42a6:	af 91       	pop	r26
    42a8:	9f 91       	pop	r25
    42aa:	8f 91       	pop	r24
    42ac:	7f 91       	pop	r23
    42ae:	6f 91       	pop	r22
    42b0:	5f 91       	pop	r21
    42b2:	4f 91       	pop	r20
    42b4:	3f 91       	pop	r19
    42b6:	2f 91       	pop	r18
    42b8:	0f 90       	pop	r0
    42ba:	0f be       	out	0x3f, r0	; 63
    42bc:	0f 90       	pop	r0
    42be:	1f 90       	pop	r1
    42c0:	18 95       	reti

000042c2 <SPI0_init>:
/* -----------------------------------------------------------------------------------------------------------*/
void SPI0_init( void )
{

	// SCK auf Hi setzen
	SPI0_PORT |= 1<<SCK;
    42c2:	2f 9a       	sbi	0x05, 7	; 5
	// MOSI, SCK, SS als Output
	SPI0_DDR  |= 1<<MOSI | 1<<SCK ; // mosi, sck output
    42c4:	84 b1       	in	r24, 0x04	; 4
    42c6:	80 6a       	ori	r24, 0xA0	; 160
    42c8:	84 b9       	out	0x04, r24	; 4
	// MISO als Input
	SPI0_DDR  &= ~( 1<<MISO ); // miso input
    42ca:	26 98       	cbi	0x04, 6	; 4

	// Master mode
	SPCR = 1<<MSTR | 1<<SPE ;
    42cc:	80 e5       	ldi	r24, 0x50	; 80
    42ce:	8c bd       	out	0x2c, r24	; 44
	
	SPSR = 1<<SPI2X;
    42d0:	81 e0       	ldi	r24, 0x01	; 1
    42d2:	8d bd       	out	0x2d, r24	; 45
	
}
    42d4:	08 95       	ret

000042d6 <SPI0_ReadWrite>:
 */
/* -----------------------------------------------------------------------------------------------------------*/
char SPI0_ReadWrite( char Data )
{
	// daten senden
	SPDR = Data;
    42d6:	8e bd       	out	0x2e, r24	; 46
	// auf fertig warten
	while(!(SPSR & (1<<SPIF)));
    42d8:	0d b4       	in	r0, 0x2d	; 45
    42da:	07 fe       	sbrs	r0, 7
    42dc:	fd cf       	rjmp	.-6      	; 0x42d8 <SPI0_ReadWrite+0x2>
	// empfangende daten einlesen
	Data = SPDR;
    42de:	8e b5       	in	r24, 0x2e	; 46
	// daten zurueckgeben
	return( Data );
}
    42e0:	08 95       	ret

000042e2 <SPI0_FastMem2Write>:
 * \param	buffer		Zeiger auf den Puffer der gesendet werden soll.
 * \param	Datalenght	Anzahl der Bytes die gesedet werden soll.
 */
/* -----------------------------------------------------------------------------------------------------------*/
void SPI0_FastMem2Write( char * buffer, int Datalenght )
{
    42e2:	dc 01       	movw	r26, r24
	unsigned int Counter = 0;
	unsigned char data;
	
	// erten Wert senden
	SPDR = buffer[ Counter++ ];
    42e4:	8c 91       	ld	r24, X
    42e6:	8e bd       	out	0x2e, r24	; 46
    42e8:	81 e0       	ldi	r24, 0x01	; 1
    42ea:	90 e0       	ldi	r25, 0x00	; 0
    42ec:	09 c0       	rjmp	.+18     	; 0x4300 <SPI0_FastMem2Write+0x1e>
	while( Counter < Datalenght )
	{
		// Wert schon mal in Register holen, schneller da der Wert jetzt in einem Register steht und nicht mehr aus dem RAM geholt werden muss
		// nachdem das senden des vorherigen Wertes fertig ist,
		data = buffer[ Counter ];
    42ee:	fd 01       	movw	r30, r26
    42f0:	e8 0f       	add	r30, r24
    42f2:	f9 1f       	adc	r31, r25
    42f4:	e0 81       	ld	r30, Z
		// warten auf fertig
		while(!(SPSR & (1<<SPIF)));
    42f6:	0d b4       	in	r0, 0x2d	; 45
    42f8:	07 fe       	sbrs	r0, 7
    42fa:	fd cf       	rjmp	.-6      	; 0x42f6 <SPI0_FastMem2Write+0x14>
		// Wert aus Register senden
		SPDR = data;
    42fc:	ee bd       	out	0x2e, r30	; 46
		Counter++;
    42fe:	01 96       	adiw	r24, 0x01	; 1
	unsigned int Counter = 0;
	unsigned char data;
	
	// erten Wert senden
	SPDR = buffer[ Counter++ ];
	while( Counter < Datalenght )
    4300:	86 17       	cp	r24, r22
    4302:	97 07       	cpc	r25, r23
    4304:	a0 f3       	brcs	.-24     	; 0x42ee <SPI0_FastMem2Write+0xc>
		while(!(SPSR & (1<<SPIF)));
		// Wert aus Register senden
		SPDR = data;
		Counter++;
	}
	while(!(SPSR & (1<<SPIF)));
    4306:	0d b4       	in	r0, 0x2d	; 45
    4308:	07 fe       	sbrs	r0, 7
    430a:	fd cf       	rjmp	.-6      	; 0x4306 <SPI0_FastMem2Write+0x24>
	return;
}
    430c:	08 95       	ret

0000430e <SPI0_FastRead2Mem>:
 * \param	buffer		Zeiger auf den Puffer wohin die Daten geschrieben werden sollen.
 * \param	Datalenght	Anzahl der Bytes die empfangen werden sollen.
 */
/* -----------------------------------------------------------------------------------------------------------*/
void SPI0_FastRead2Mem( char * buffer, int Datalenght )
{
    430e:	ac 01       	movw	r20, r24
	unsigned int Counter = 0;
	unsigned char data;
	
	// dummywrite
	SPDR = 0x00;
    4310:	1e bc       	out	0x2e, r1	; 46
    4312:	20 e0       	ldi	r18, 0x00	; 0
    4314:	30 e0       	ldi	r19, 0x00	; 0
    4316:	0b c0       	rjmp	.+22     	; 0x432e <SPI0_FastRead2Mem+0x20>

	while( Counter < Datalenght )
	{
		// warten auf fertig
		while(!(SPSR & (1<<SPIF)));
    4318:	0d b4       	in	r0, 0x2d	; 45
    431a:	07 fe       	sbrs	r0, 7
    431c:	fd cf       	rjmp	.-6      	; 0x4318 <SPI0_FastRead2Mem+0xa>
		// dummy-write
		SPDR = 0x00;		
*/
		// bessere Optimierung, aber nicht auf jeden controller
		// dummy-write
		SPDR = 0x00;		
    431e:	1e bc       	out	0x2e, r1	; 46
		// Daten einlesen
		data = SPDR;
    4320:	8e b5       	in	r24, 0x2e	; 46

		// speichern
		buffer[ Counter++ ] = data;
    4322:	fa 01       	movw	r30, r20
    4324:	e2 0f       	add	r30, r18
    4326:	f3 1f       	adc	r31, r19
    4328:	80 83       	st	Z, r24
    432a:	2f 5f       	subi	r18, 0xFF	; 255
    432c:	3f 4f       	sbci	r19, 0xFF	; 255
	unsigned char data;
	
	// dummywrite
	SPDR = 0x00;

	while( Counter < Datalenght )
    432e:	26 17       	cp	r18, r22
    4330:	37 07       	cpc	r19, r23
    4332:	90 f3       	brcs	.-28     	; 0x4318 <SPI0_FastRead2Mem+0xa>
		data = SPDR;

		// speichern
		buffer[ Counter++ ] = data;
	}
	while(!(SPSR & (1<<SPIF)));
    4334:	0d b4       	in	r0, 0x2d	; 45
    4336:	07 fe       	sbrs	r0, 7
    4338:	fd cf       	rjmp	.-6      	; 0x4334 <SPI0_FastRead2Mem+0x26>
	return;
}
    433a:	08 95       	ret

0000433c <SPI2_init>:
/* -----------------------------------------------------------------------------------------------------------*/
void SPI2_init( void )
{

	// SCK auf Low setzen
	SPI2_PORT &= ~( 1<<SCK2 );
    433c:	5d 98       	cbi	0x0b, 5	; 11
	// MOSI, SCK, SS als Output
	SPI2_DDR  |= 1<<MOSI2 | 1<<SCK2; // mosi, sck, ss output
    433e:	8a b1       	in	r24, 0x0a	; 10
    4340:	84 62       	ori	r24, 0x24	; 36
    4342:	8a b9       	out	0x0a, r24	; 10
	// MISO als Input
	SPI2_DDR  &= ~( 1<<MISO2 ); // miso input
    4344:	54 98       	cbi	0x0a, 4	; 10
}
    4346:	08 95       	ret

00004348 <SPI2_ReadWrite>:
 * \param 	Data	Der Wert der uebertragen werden soll.
 * \retval  Data	Der wert der gleichzeit empfangen wurde.
 */
/* -----------------------------------------------------------------------------------------------------------*/
char SPI2_ReadWrite( char Data )
{
    4348:	28 2f       	mov	r18, r24
    434a:	90 e0       	ldi	r25, 0x00	; 0
    434c:	80 e0       	ldi	r24, 0x00	; 0
	unsigned char i, InData = 0;
		
	for( i = 0 ; i < 8 ; i++ )
	{
		// InDaten shiften;
		InData = InData<<1;
    434e:	88 0f       	add	r24, r24
		
		// Kieck mal ob MSB 1 ist
		if ( ( Data & 0x80 ) > 0 )
    4350:	27 ff       	sbrs	r18, 7
    4352:	02 c0       	rjmp	.+4      	; 0x4358 <SPI2_ReadWrite+0x10>
			SPI2_PORT |= ( 1<<MOSI2 );
    4354:	5a 9a       	sbi	0x0b, 2	; 11
    4356:	01 c0       	rjmp	.+2      	; 0x435a <SPI2_ReadWrite+0x12>
		else
			SPI2_PORT &= ~( 1<<MOSI2 );
    4358:	5a 98       	cbi	0x0b, 2	; 11
		
		// SCK auf High setzen
		SPI2_PORT |= ( 1<<SCK2 );
    435a:	5d 9a       	sbi	0x0b, 5	; 11
				
		// MISO einlesen
		if ( bit_is_set( SPI2_PIN, MISO2 ) > 0 )
    435c:	4c 99       	sbic	0x09, 4	; 9
			InData |= 1;
    435e:	81 60       	ori	r24, 0x01	; 1
		
		// SCK auf Low setzen
		SPI2_PORT &= ~( 1<<SCK2 );
    4360:	5d 98       	cbi	0x0b, 5	; 11
/* -----------------------------------------------------------------------------------------------------------*/
char SPI2_ReadWrite( char Data )
{
	unsigned char i, InData = 0;
		
	for( i = 0 ; i < 8 ; i++ )
    4362:	9f 5f       	subi	r25, 0xFF	; 255
    4364:	98 30       	cpi	r25, 0x08	; 8
    4366:	11 f0       	breq	.+4      	; 0x436c <SPI2_ReadWrite+0x24>
			InData |= 1;
		
		// SCK auf Low setzen
		SPI2_PORT &= ~( 1<<SCK2 );
		
		Data <<= 1;
    4368:	22 0f       	add	r18, r18
    436a:	f1 cf       	rjmp	.-30     	; 0x434e <SPI2_ReadWrite+0x6>
	}
	
	return( InData );
}
    436c:	08 95       	ret

0000436e <SPI2_FastMem2Write>:
 * \param	buffer		Zeiger auf den Puffer der gesendet werden soll.
 * \param	Datalenght	Anzahl der Bytes die gesedet werden soll.
 */
/* -----------------------------------------------------------------------------------------------------------*/
void SPI2_FastMem2Write( char * buffer, int Datalenght )
{
    436e:	20 e0       	ldi	r18, 0x00	; 0
    4370:	30 e0       	ldi	r19, 0x00	; 0
    4372:	13 c0       	rjmp	.+38     	; 0x439a <SPI2_FastMem2Write+0x2c>
	unsigned int Counter = 0;
	unsigned char data,i;
	
	while( Counter < Datalenght )
	{
		data = buffer[ Counter ];
    4374:	fc 01       	movw	r30, r24
    4376:	e2 0f       	add	r30, r18
    4378:	f3 1f       	adc	r31, r19
    437a:	e0 81       	ld	r30, Z
    437c:	40 e0       	ldi	r20, 0x00	; 0
		
		for( i = 0 ; i < 8 ; i++ )
		{
			// Kieck mal ob MSB 1 ist
			if ( ( data & 0x80 ) > 0 )
    437e:	e7 ff       	sbrs	r30, 7
    4380:	02 c0       	rjmp	.+4      	; 0x4386 <SPI2_FastMem2Write+0x18>
				SPI2_PORT |= ( 1<<MOSI2 );
    4382:	5a 9a       	sbi	0x0b, 2	; 11
    4384:	01 c0       	rjmp	.+2      	; 0x4388 <SPI2_FastMem2Write+0x1a>
			else
				SPI2_PORT &= ~( 1<<MOSI2 );
    4386:	5a 98       	cbi	0x0b, 2	; 11
			
			// SCK auf High setzen
			SPI2_PORT |= ( 1<<SCK2 );
    4388:	5d 9a       	sbi	0x0b, 5	; 11
			
			data <<= 1;

			// SCK auf Low setzen
			SPI2_PORT &= ~( 1<<SCK2 );
    438a:	5d 98       	cbi	0x0b, 5	; 11
	
	while( Counter < Datalenght )
	{
		data = buffer[ Counter ];
		
		for( i = 0 ; i < 8 ; i++ )
    438c:	4f 5f       	subi	r20, 0xFF	; 255
    438e:	48 30       	cpi	r20, 0x08	; 8
    4390:	11 f0       	breq	.+4      	; 0x4396 <SPI2_FastMem2Write+0x28>
				SPI2_PORT &= ~( 1<<MOSI2 );
			
			// SCK auf High setzen
			SPI2_PORT |= ( 1<<SCK2 );
			
			data <<= 1;
    4392:	ee 0f       	add	r30, r30
    4394:	f4 cf       	rjmp	.-24     	; 0x437e <SPI2_FastMem2Write+0x10>
			// SCK auf Low setzen
			SPI2_PORT &= ~( 1<<SCK2 );

		}
		
		Counter++;
    4396:	2f 5f       	subi	r18, 0xFF	; 255
    4398:	3f 4f       	sbci	r19, 0xFF	; 255
void SPI2_FastMem2Write( char * buffer, int Datalenght )
{
	unsigned int Counter = 0;
	unsigned char data,i;
	
	while( Counter < Datalenght )
    439a:	26 17       	cp	r18, r22
    439c:	37 07       	cpc	r19, r23
    439e:	50 f3       	brcs	.-44     	; 0x4374 <SPI2_FastMem2Write+0x6>
		
		Counter++;
		
	}
	return;
}
    43a0:	08 95       	ret

000043a2 <SPI2_FastRead2Mem>:
 * \param	buffer		Zeiger auf den Puffer wohin die Daten geschrieben werden sollen.
 * \param	Datalenght	Anzahl der Bytes die empfangen werden sollen.
 */
/* -----------------------------------------------------------------------------------------------------------*/
void SPI2_FastRead2Mem( char * buffer, int Datalenght )
{
    43a2:	fc 01       	movw	r30, r24
	unsigned int Counter = 0;
	unsigned char InData = 0,i;
	
	SPI2_PORT &= ~( 1<<MOSI2 );
    43a4:	5a 98       	cbi	0x0b, 2	; 11
    43a6:	80 e0       	ldi	r24, 0x00	; 0
    43a8:	90 e0       	ldi	r25, 0x00	; 0
    43aa:	30 e0       	ldi	r19, 0x00	; 0
    43ac:	0b c0       	rjmp	.+22     	; 0x43c4 <SPI2_FastRead2Mem+0x22>

	while( Counter < Datalenght )
    43ae:	20 e0       	ldi	r18, 0x00	; 0
	{
		for( i = 0 ; i < 8 ; i++ )
		{
			// InDaten shiften;
			InData = InData<<1;
    43b0:	33 0f       	add	r19, r19
			
			// SCK auf High setzen
			SPI2_PORT |= ( 1<<SCK2 );
    43b2:	5d 9a       	sbi	0x0b, 5	; 11
			
			// MISO einlesen
			if ( bit_is_set( PINB,MISO2 ) > 0 )
    43b4:	1c 99       	sbic	0x03, 4	; 3
				InData |= 1;
    43b6:	31 60       	ori	r19, 0x01	; 1
		
			// SCK auf Low setzen
			SPI2_PORT &= ~( 1<<SCK2 );
    43b8:	5d 98       	cbi	0x0b, 5	; 11
	
	SPI2_PORT &= ~( 1<<MOSI2 );

	while( Counter < Datalenght )
	{
		for( i = 0 ; i < 8 ; i++ )
    43ba:	2f 5f       	subi	r18, 0xFF	; 255
    43bc:	28 30       	cpi	r18, 0x08	; 8
    43be:	c1 f7       	brne	.-16     	; 0x43b0 <SPI2_FastRead2Mem+0xe>
				InData |= 1;
		
			// SCK auf Low setzen
			SPI2_PORT &= ~( 1<<SCK2 );
		}
		*buffer++ = InData;
    43c0:	31 93       	st	Z+, r19
		Counter++;
    43c2:	01 96       	adiw	r24, 0x01	; 1
	unsigned int Counter = 0;
	unsigned char InData = 0,i;
	
	SPI2_PORT &= ~( 1<<MOSI2 );

	while( Counter < Datalenght )
    43c4:	86 17       	cp	r24, r22
    43c6:	97 07       	cpc	r25, r23
    43c8:	90 f3       	brcs	.-28     	; 0x43ae <SPI2_FastRead2Mem+0xc>
		}
		*buffer++ = InData;
		Counter++;
	}
	return;
}
    43ca:	08 95       	ret

000043cc <__vector_16>:


ISR( TIMER0_COMPA_vect )
{
    43cc:	1f 92       	push	r1
    43ce:	0f 92       	push	r0
    43d0:	0f b6       	in	r0, 0x3f	; 63
    43d2:	0f 92       	push	r0
    43d4:	11 24       	eor	r1, r1
    43d6:	2f 93       	push	r18
    43d8:	3f 93       	push	r19
    43da:	4f 93       	push	r20
    43dc:	5f 93       	push	r21
    43de:	6f 93       	push	r22
    43e0:	7f 93       	push	r23
    43e2:	8f 93       	push	r24
    43e4:	9f 93       	push	r25
    43e6:	af 93       	push	r26
    43e8:	bf 93       	push	r27
    43ea:	ef 93       	push	r30
    43ec:	ff 93       	push	r31
	unsigned char i;
	for ( i = 0 ; i < MAX_TIMER0_CALLBACKS ; i++ ) if ( TIMER0_CallbackFunc[i] != NULL ) TIMER0_CallbackFunc[i]();
    43ee:	e0 91 d9 07 	lds	r30, 0x07D9
    43f2:	f0 91 da 07 	lds	r31, 0x07DA
    43f6:	30 97       	sbiw	r30, 0x00	; 0
    43f8:	09 f0       	breq	.+2      	; 0x43fc <__vector_16+0x30>
    43fa:	09 95       	icall
}
    43fc:	ff 91       	pop	r31
    43fe:	ef 91       	pop	r30
    4400:	bf 91       	pop	r27
    4402:	af 91       	pop	r26
    4404:	9f 91       	pop	r25
    4406:	8f 91       	pop	r24
    4408:	7f 91       	pop	r23
    440a:	6f 91       	pop	r22
    440c:	5f 91       	pop	r21
    440e:	4f 91       	pop	r20
    4410:	3f 91       	pop	r19
    4412:	2f 91       	pop	r18
    4414:	0f 90       	pop	r0
    4416:	0f be       	out	0x3f, r0	; 63
    4418:	0f 90       	pop	r0
    441a:	1f 90       	pop	r1
    441c:	18 95       	reti

0000441e <icmp>:
#include "system/math/math.h"

static char ICMP_Replaystate = ICMP_Unknow;

void icmp( unsigned int packet_lenght, unsigned char *buffer)
	{
    441e:	a0 e0       	ldi	r26, 0x00	; 0
    4420:	b0 e0       	ldi	r27, 0x00	; 0
    4422:	e5 e1       	ldi	r30, 0x15	; 21
    4424:	f2 e2       	ldi	r31, 0x22	; 34
    4426:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    442a:	6c 01       	movw	r12, r24
    442c:	7b 01       	movw	r14, r22
		unsigned char i;
		unsigned int checksum;
		
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *)&buffer[0];
    442e:	b6 2e       	mov	r11, r22
    4430:	af 2c       	mov	r10, r15
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *)&buffer[ETHERNET_HEADER_LENGTH];
    4432:	8b 01       	movw	r16, r22
    4434:	02 5f       	subi	r16, 0xF2	; 242
    4436:	1f 4f       	sbci	r17, 0xFF	; 255
		struct ICMP_header *ICMP_packet;	// ICMP_struct anlegen
		ICMP_packet = ( struct ICMP_header *)&buffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    4438:	fb 01       	movw	r30, r22
    443a:	86 85       	ldd	r24, Z+14	; 0x0e
    443c:	68 2f       	mov	r22, r24
    443e:	70 e0       	ldi	r23, 0x00	; 0
    4440:	6f 70       	andi	r22, 0x0F	; 15
    4442:	70 70       	andi	r23, 0x00	; 0
    4444:	66 0f       	add	r22, r22
    4446:	77 1f       	adc	r23, r23
    4448:	66 0f       	add	r22, r22
    444a:	77 1f       	adc	r23, r23
    444c:	62 5f       	subi	r22, 0xF2	; 242
    444e:	7f 4f       	sbci	r23, 0xFF	; 255
    4450:	e7 01       	movw	r28, r14
    4452:	c6 0f       	add	r28, r22
    4454:	d7 1f       	adc	r29, r23
    4456:	6e 50       	subi	r22, 0x0E	; 14
    4458:	70 40       	sbci	r23, 0x00	; 0

		switch ( ICMP_packet->ICMP_type )
    445a:	88 81       	ld	r24, Y
    445c:	88 23       	and	r24, r24
    445e:	09 f4       	brne	.+2      	; 0x4462 <icmp+0x44>
    4460:	41 c0       	rjmp	.+130    	; 0x44e4 <icmp+0xc6>
    4462:	88 30       	cpi	r24, 0x08	; 8
    4464:	09 f0       	breq	.+2      	; 0x4468 <icmp+0x4a>
    4466:	4a c0       	rjmp	.+148    	; 0x44fc <icmp+0xde>
			{
				case ICMP_EchoRequest:			//IP_header unbauen zum versenden 
												IP_packet->IP_DestinationIP = IP_packet->IP_SourceIP;
    4468:	f8 01       	movw	r30, r16
    446a:	84 85       	ldd	r24, Z+12	; 0x0c
    446c:	95 85       	ldd	r25, Z+13	; 0x0d
    446e:	a6 85       	ldd	r26, Z+14	; 0x0e
    4470:	b7 85       	ldd	r27, Z+15	; 0x0f
    4472:	80 8b       	std	Z+16, r24	; 0x10
    4474:	91 8b       	std	Z+17, r25	; 0x11
    4476:	a2 8b       	std	Z+18, r26	; 0x12
    4478:	b3 8b       	std	Z+19, r27	; 0x13
												IP_packet->IP_SourceIP = myIP;
    447a:	80 91 41 01 	lds	r24, 0x0141
    447e:	90 91 42 01 	lds	r25, 0x0142
    4482:	a0 91 43 01 	lds	r26, 0x0143
    4486:	b0 91 44 01 	lds	r27, 0x0144
    448a:	84 87       	std	Z+12, r24	; 0x0c
    448c:	95 87       	std	Z+13, r25	; 0x0d
    448e:	a6 87       	std	Z+14, r26	; 0x0e
    4490:	b7 87       	std	Z+15, r27	; 0x0f
												//IP_header checksummer ausrechnen
												IP_packet->IP_Headerchecksum = 0x0;
    4492:	13 86       	std	Z+11, r1	; 0x0b
    4494:	12 86       	std	Z+10, r1	; 0x0a
												checksum = Checksum_16( &buffer[14], ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 ) );
    4496:	c8 01       	movw	r24, r16
    4498:	0e 94 dd 37 	call	0x6fba	; 0x6fba <Checksum_16>
												IP_packet->IP_Headerchecksum = ChangeEndian16bit( checksum );
    449c:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    44a0:	f8 01       	movw	r30, r16
    44a2:	93 87       	std	Z+11, r25	; 0x0b
    44a4:	82 87       	std	Z+10, r24	; 0x0a
												ICMP_packet->ICMP_type = ICMP_EchoReplay; // auf reply einstellen
    44a6:	18 82       	st	Y, r1
												ICMP_packet->ICMP_code = 0x00; 
    44a8:	19 82       	std	Y+1, r1	; 0x01
												//Simple ICMP Checksummenbildung, die Idee stammt von
												//Simon, siehe http://avr.auctionant.de/
												if(ICMP_packet->ICMP_checksumByteOne >  0xFF-0x08)ICMP_packet->ICMP_checksumByteTwo++;
    44aa:	8a 81       	ldd	r24, Y+2	; 0x02
    44ac:	88 3f       	cpi	r24, 0xF8	; 248
    44ae:	18 f0       	brcs	.+6      	; 0x44b6 <icmp+0x98>
    44b0:	8b 81       	ldd	r24, Y+3	; 0x03
    44b2:	8f 5f       	subi	r24, 0xFF	; 255
    44b4:	8b 83       	std	Y+3, r24	; 0x03
												ICMP_packet->ICMP_checksumByteOne+=0x08;
    44b6:	8a 81       	ldd	r24, Y+2	; 0x02
    44b8:	88 5f       	subi	r24, 0xF8	; 248
    44ba:	8a 83       	std	Y+2, r24	; 0x02
    44bc:	2b 2d       	mov	r18, r11
    44be:	3a 2d       	mov	r19, r10
    44c0:	c9 01       	movw	r24, r18
    44c2:	fc 01       	movw	r30, r24
    44c4:	ab e3       	ldi	r26, 0x3B	; 59
    44c6:	b1 e0       	ldi	r27, 0x01	; 1
												// Ethernetframe bauen
												for(i = 0; i < 6 ; i++ ){	
													ETH_packet->ETH_destMac[i] = ETH_packet->ETH_sourceMac[i];	
    44c8:	86 81       	ldd	r24, Z+6	; 0x06
    44ca:	80 83       	st	Z, r24
													ETH_packet->ETH_sourceMac[i] = mymac[i]; }
    44cc:	8d 91       	ld	r24, X+
    44ce:	86 83       	std	Z+6, r24	; 0x06
    44d0:	31 96       	adiw	r30, 0x01	; 1
												//Simple ICMP Checksummenbildung, die Idee stammt von
												//Simon, siehe http://avr.auctionant.de/
												if(ICMP_packet->ICMP_checksumByteOne >  0xFF-0x08)ICMP_packet->ICMP_checksumByteTwo++;
												ICMP_packet->ICMP_checksumByteOne+=0x08;
												// Ethernetframe bauen
												for(i = 0; i < 6 ; i++ ){	
    44d2:	21 e0       	ldi	r18, 0x01	; 1
    44d4:	a1 34       	cpi	r26, 0x41	; 65
    44d6:	b2 07       	cpc	r27, r18
    44d8:	b9 f7       	brne	.-18     	; 0x44c8 <icmp+0xaa>
													ETH_packet->ETH_destMac[i] = ETH_packet->ETH_sourceMac[i];	
													ETH_packet->ETH_sourceMac[i] = mymac[i]; }
												// und ab die post
												sendEthernetframe( packet_lenght, buffer); // packet_lenght - 4 weil der Controller die checksumme selber berechnet
    44da:	c6 01       	movw	r24, r12
    44dc:	b7 01       	movw	r22, r14
    44de:	0e 94 4d 30 	call	0x609a	; 0x609a <sendEthernetframe>
    44e2:	0c c0       	rjmp	.+24     	; 0x44fc <icmp+0xde>
												break;

				case ICMP_EchoReplay:			if ( ICMP_packet->ICMP_Identifierer == 0xac1d && ICMP_Replaystate == ICMP_WaitForReplay )
    44e4:	8c 81       	ldd	r24, Y+4	; 0x04
    44e6:	9d 81       	ldd	r25, Y+5	; 0x05
    44e8:	8d 51       	subi	r24, 0x1D	; 29
    44ea:	9c 4a       	sbci	r25, 0xAC	; 172
    44ec:	39 f4       	brne	.+14     	; 0x44fc <icmp+0xde>
    44ee:	80 91 39 01 	lds	r24, 0x0139
    44f2:	81 30       	cpi	r24, 0x01	; 1
    44f4:	19 f4       	brne	.+6      	; 0x44fc <icmp+0xde>
													ICMP_Replaystate = ICMP_ReplayOkay;
    44f6:	82 e0       	ldi	r24, 0x02	; 2
    44f8:	80 93 39 01 	sts	0x0139, r24
												break;
			}
	}
    44fc:	cd b7       	in	r28, 0x3d	; 61
    44fe:	de b7       	in	r29, 0x3e	; 62
    4500:	ea e0       	ldi	r30, 0x0A	; 10
    4502:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00004506 <UDP_init>:
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_CloseSocket( int SOCKET )
	{
		if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
			
		if ( UDP_sockettable[SOCKET].Socketstate == UDP_SOCKET_NOT_USE ) return( UDP_SOCKET_ERROR );
    4506:	80 91 db 07 	lds	r24, 0x07DB
    450a:	88 23       	and	r24, r24
    450c:	11 f0       	breq	.+4      	; 0x4512 <UDP_init+0xc>
			
		UDP_sockettable[SOCKET].Socketstate = UDP_SOCKET_NOT_USE;
    450e:	10 92 db 07 	sts	0x07DB, r1
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_CloseSocket( int SOCKET )
	{
		if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
			
		if ( UDP_sockettable[SOCKET].Socketstate == UDP_SOCKET_NOT_USE ) return( UDP_SOCKET_ERROR );
    4512:	80 91 f1 07 	lds	r24, 0x07F1
    4516:	88 23       	and	r24, r24
    4518:	11 f0       	breq	.+4      	; 0x451e <UDP_init+0x18>
			
		UDP_sockettable[SOCKET].Socketstate = UDP_SOCKET_NOT_USE;
    451a:	10 92 f1 07 	sts	0x07F1, r1
    451e:	08 95       	ret

00004520 <UDP_GetSocketState>:
 * \param	SOCKET	Die Socketnummer vom abzufragen Socket.
 * \return  Den Socketstatus.
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_GetSocketState( int SOCKET )
	{
    4520:	9c 01       	movw	r18, r24
		if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
    4522:	82 30       	cpi	r24, 0x02	; 2
    4524:	91 05       	cpc	r25, r1
    4526:	1c f0       	brlt	.+6      	; 0x452e <UDP_GetSocketState+0xe>
    4528:	2f ef       	ldi	r18, 0xFF	; 255
    452a:	3f ef       	ldi	r19, 0xFF	; 255
    452c:	0e c0       	rjmp	.+28     	; 0x454a <UDP_GetSocketState+0x2a>
		return( UDP_sockettable[ SOCKET ].Socketstate );
    452e:	86 e1       	ldi	r24, 0x16	; 22
    4530:	90 e0       	ldi	r25, 0x00	; 0
    4532:	28 9f       	mul	r18, r24
    4534:	f0 01       	movw	r30, r0
    4536:	29 9f       	mul	r18, r25
    4538:	f0 0d       	add	r31, r0
    453a:	38 9f       	mul	r19, r24
    453c:	f0 0d       	add	r31, r0
    453e:	11 24       	eor	r1, r1
    4540:	e5 52       	subi	r30, 0x25	; 37
    4542:	f8 4f       	sbci	r31, 0xF8	; 248
    4544:	80 81       	ld	r24, Z
    4546:	28 2f       	mov	r18, r24
    4548:	30 e0       	ldi	r19, 0x00	; 0
	}
    454a:	c9 01       	movw	r24, r18
    454c:	08 95       	ret

0000454e <UDP_GetByteInBuffer>:
 * \return  Anzahl der Byte im Puffer.
 *\sa UDP_GetSocketState, UDP_FreeBuffer
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_GetByteInBuffer( int SOCKET )
	{
    454e:	9c 01       	movw	r18, r24
		if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
    4550:	82 30       	cpi	r24, 0x02	; 2
    4552:	91 05       	cpc	r25, r1
    4554:	1c f0       	brlt	.+6      	; 0x455c <UDP_GetByteInBuffer+0xe>
    4556:	2f ef       	ldi	r18, 0xFF	; 255
    4558:	3f ef       	ldi	r19, 0xFF	; 255
    455a:	0d c0       	rjmp	.+26     	; 0x4576 <UDP_GetByteInBuffer+0x28>
		return ( UDP_sockettable[ SOCKET ].Bufferfill );
    455c:	86 e1       	ldi	r24, 0x16	; 22
    455e:	90 e0       	ldi	r25, 0x00	; 0
    4560:	28 9f       	mul	r18, r24
    4562:	f0 01       	movw	r30, r0
    4564:	29 9f       	mul	r18, r25
    4566:	f0 0d       	add	r31, r0
    4568:	38 9f       	mul	r19, r24
    456a:	f0 0d       	add	r31, r0
    456c:	11 24       	eor	r1, r1
    456e:	e5 52       	subi	r30, 0x25	; 37
    4570:	f8 4f       	sbci	r31, 0xF8	; 248
    4572:	21 89       	ldd	r18, Z+17	; 0x11
    4574:	32 89       	ldd	r19, Z+18	; 0x12
	}
    4576:	c9 01       	movw	r24, r18
    4578:	08 95       	ret

0000457a <UDP_FreeBuffer>:
 * \param	SOCKET		Die Socketnummer die freigegeben werden soll.
 * \return	NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_FreeBuffer( int SOCKET )
	{
    457a:	9c 01       	movw	r18, r24
		if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
    457c:	82 30       	cpi	r24, 0x02	; 2
    457e:	91 05       	cpc	r25, r1
    4580:	1c f0       	brlt	.+6      	; 0x4588 <UDP_FreeBuffer+0xe>
    4582:	2f ef       	ldi	r18, 0xFF	; 255
    4584:	3f ef       	ldi	r19, 0xFF	; 255
    4586:	11 c0       	rjmp	.+34     	; 0x45aa <UDP_FreeBuffer+0x30>

		UDP_sockettable[ SOCKET ].Bufferfill = 0;
    4588:	86 e1       	ldi	r24, 0x16	; 22
    458a:	90 e0       	ldi	r25, 0x00	; 0
    458c:	28 9f       	mul	r18, r24
    458e:	f0 01       	movw	r30, r0
    4590:	29 9f       	mul	r18, r25
    4592:	f0 0d       	add	r31, r0
    4594:	38 9f       	mul	r19, r24
    4596:	f0 0d       	add	r31, r0
    4598:	11 24       	eor	r1, r1
    459a:	e5 52       	subi	r30, 0x25	; 37
    459c:	f8 4f       	sbci	r31, 0xF8	; 248
    459e:	12 8a       	std	Z+18, r1	; 0x12
    45a0:	11 8a       	std	Z+17, r1	; 0x11

		UDP_sockettable[ SOCKET ].Socketstate = UDP_SOCKET_READY;
    45a2:	80 e1       	ldi	r24, 0x10	; 16
    45a4:	80 83       	st	Z, r24
    45a6:	20 e0       	ldi	r18, 0x00	; 0
    45a8:	30 e0       	ldi	r19, 0x00	; 0
		return( 0 );
	}
    45aa:	c9 01       	movw	r24, r18
    45ac:	08 95       	ret

000045ae <UDP_CloseSocket>:
 * \param	SOCKET		Die Socketnummer die geschlossen werden soll.
 * \return	Es wird beim erfolgreichen schliessen der Socket 0 zurueck gegeben, sonst 0xffff.
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_CloseSocket( int SOCKET )
	{
    45ae:	9c 01       	movw	r18, r24
		if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
    45b0:	82 30       	cpi	r24, 0x02	; 2
    45b2:	91 05       	cpc	r25, r1
    45b4:	94 f4       	brge	.+36     	; 0x45da <UDP_CloseSocket+0x2c>
			
		if ( UDP_sockettable[SOCKET].Socketstate == UDP_SOCKET_NOT_USE ) return( UDP_SOCKET_ERROR );
    45b6:	86 e1       	ldi	r24, 0x16	; 22
    45b8:	90 e0       	ldi	r25, 0x00	; 0
    45ba:	28 9f       	mul	r18, r24
    45bc:	f0 01       	movw	r30, r0
    45be:	29 9f       	mul	r18, r25
    45c0:	f0 0d       	add	r31, r0
    45c2:	38 9f       	mul	r19, r24
    45c4:	f0 0d       	add	r31, r0
    45c6:	11 24       	eor	r1, r1
    45c8:	e5 52       	subi	r30, 0x25	; 37
    45ca:	f8 4f       	sbci	r31, 0xF8	; 248
    45cc:	80 81       	ld	r24, Z
    45ce:	88 23       	and	r24, r24
    45d0:	21 f0       	breq	.+8      	; 0x45da <UDP_CloseSocket+0x2c>
			
		UDP_sockettable[SOCKET].Socketstate = UDP_SOCKET_NOT_USE;
    45d2:	10 82       	st	Z, r1
    45d4:	20 e0       	ldi	r18, 0x00	; 0
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	02 c0       	rjmp	.+4      	; 0x45de <UDP_CloseSocket+0x30>
		
		return( 0 );
    45da:	2f ef       	ldi	r18, 0xFF	; 255
    45dc:	3f ef       	ldi	r19, 0xFF	; 255
	}
    45de:	c9 01       	movw	r24, r18
    45e0:	08 95       	ret

000045e2 <UDP_GetSocket>:

/* -----------------------------------------------------------------------------------------------------------
w채hlt den richtigen Socketeintrag setzt TCP_socket auf diesen eintrag
------------------------------------------------------------------------------------------------------------*/
int UDP_GetSocket( unsigned char * ethernetbuffer )
	{
    45e2:	a0 e0       	ldi	r26, 0x00	; 0
    45e4:	b0 e0       	ldi	r27, 0x00	; 0
    45e6:	e7 ef       	ldi	r30, 0xF7	; 247
    45e8:	f2 e2       	ldi	r31, 0x22	; 34
    45ea:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    45ee:	ac 01       	movw	r20, r24
		struct ETH_header * ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header * IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    45f0:	9e e0       	ldi	r25, 0x0E	; 14
    45f2:	a9 2e       	mov	r10, r25
    45f4:	b1 2c       	mov	r11, r1
    45f6:	a4 0e       	add	r10, r20
    45f8:	b5 1e       	adc	r11, r21
		struct UDP_header * UDP_packet;		// TCP_struct anlegen
		UDP_packet = ( struct UDP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    45fa:	da 01       	movw	r26, r20
    45fc:	1e 96       	adiw	r26, 0x0e	; 14
    45fe:	8c 91       	ld	r24, X
    4600:	c8 2f       	mov	r28, r24
    4602:	d0 e0       	ldi	r29, 0x00	; 0
    4604:	cf 70       	andi	r28, 0x0F	; 15
    4606:	d0 70       	andi	r29, 0x00	; 0
    4608:	cc 0f       	add	r28, r28
    460a:	dd 1f       	adc	r29, r29
    460c:	cc 0f       	add	r28, r28
    460e:	dd 1f       	adc	r29, r29
    4610:	2e 96       	adiw	r28, 0x0e	; 14
    4612:	c4 0f       	add	r28, r20
    4614:	d5 1f       	adc	r29, r21
				CAN_SendBuffer[5] = UDP_sockettable[Socket].SourcePort ;
		
				UDP_SendPacket (CAN_Socket,10,CAN_SendBuffer) ; */

				//Normal zuordnung
				if ( UDP_sockettable[ Socket ].DestinationPort == UDP_packet->UDP_SourcePort
    4616:	88 80       	ld	r8, Y
    4618:	99 80       	ldd	r9, Y+1	; 0x01
						&& UDP_sockettable[ Socket ].DestinationIP == IP_packet->IP_SourceIP ) return( Socket );
				// BootP sonderstellung einr채umen
				if ( UDP_sockettable[ Socket ].DestinationPort == UDP_packet->UDP_SourcePort
					 	&& UDP_sockettable[ Socket ].SourcePort == UDP_packet->UDP_DestinationPort ) return( Socket );
				// Sonderstellung auf Broadcast
				if ( IP_packet->IP_DestinationIP == myBroadcast
    461a:	c0 90 45 01 	lds	r12, 0x0145
    461e:	d0 90 46 01 	lds	r13, 0x0146
    4622:	e0 90 47 01 	lds	r14, 0x0147
    4626:	f0 90 48 01 	lds	r15, 0x0148
    462a:	ec ed       	ldi	r30, 0xDC	; 220
    462c:	f7 e0       	ldi	r31, 0x07	; 7
    462e:	60 e0       	ldi	r22, 0x00	; 0
    4630:	70 e0       	ldi	r23, 0x00	; 0
				CAN_SendBuffer[5] = UDP_sockettable[Socket].SourcePort ;
		
				UDP_SendPacket (CAN_Socket,10,CAN_SendBuffer) ; */

				//Normal zuordnung
				if ( UDP_sockettable[ Socket ].DestinationPort == UDP_packet->UDP_SourcePort
    4632:	06 81       	ldd	r16, Z+6	; 0x06
    4634:	17 81       	ldd	r17, Z+7	; 0x07
    4636:	08 15       	cp	r16, r8
    4638:	19 05       	cpc	r17, r9
    463a:	41 f4       	brne	.+16     	; 0x464c <UDP_GetSocket+0x6a>
    463c:	24 81       	ldd	r18, Z+4	; 0x04
    463e:	35 81       	ldd	r19, Z+5	; 0x05
    4640:	8a 81       	ldd	r24, Y+2	; 0x02
    4642:	9b 81       	ldd	r25, Y+3	; 0x03
    4644:	28 17       	cp	r18, r24
    4646:	39 07       	cpc	r19, r25
    4648:	09 f4       	brne	.+2      	; 0x464c <UDP_GetSocket+0x6a>
    464a:	59 c0       	rjmp	.+178    	; 0x46fe <UDP_GetSocket+0x11c>
						&& UDP_sockettable[ Socket ].DestinationIP == IP_packet->IP_SourceIP ) return( Socket );
				// BootP sonderstellung einr채umen
				if ( UDP_sockettable[ Socket ].DestinationPort == UDP_packet->UDP_SourcePort
					 	&& UDP_sockettable[ Socket ].SourcePort == UDP_packet->UDP_DestinationPort ) return( Socket );
				// Sonderstellung auf Broadcast
				if ( IP_packet->IP_DestinationIP == myBroadcast
    464c:	d5 01       	movw	r26, r10
    464e:	50 96       	adiw	r26, 0x10	; 16
    4650:	4d 90       	ld	r4, X+
    4652:	5d 90       	ld	r5, X+
    4654:	6d 90       	ld	r6, X+
    4656:	7c 90       	ld	r7, X
    4658:	53 97       	sbiw	r26, 0x13	; 19
    465a:	4c 14       	cp	r4, r12
    465c:	5d 04       	cpc	r5, r13
    465e:	6e 04       	cpc	r6, r14
    4660:	7f 04       	cpc	r7, r15
    4662:	41 f4       	brne	.+16     	; 0x4674 <UDP_GetSocket+0x92>
    4664:	24 81       	ldd	r18, Z+4	; 0x04
    4666:	35 81       	ldd	r19, Z+5	; 0x05
    4668:	8a 81       	ldd	r24, Y+2	; 0x02
    466a:	9b 81       	ldd	r25, Y+3	; 0x03
    466c:	28 17       	cp	r18, r24
    466e:	39 07       	cpc	r19, r25
    4670:	09 f4       	brne	.+2      	; 0x4674 <UDP_GetSocket+0x92>
    4672:	45 c0       	rjmp	.+138    	; 0x46fe <UDP_GetSocket+0x11c>
					 	&& UDP_sockettable[ Socket ].SourcePort == UDP_packet->UDP_DestinationPort ) return( Socket );		
				// Ist Packet auf einen Listen-socket eingetroffen ?	
				if ( UDP_sockettable[ Socket ].SourcePort == UDP_packet->UDP_DestinationPort
    4674:	24 81       	ldd	r18, Z+4	; 0x04
    4676:	35 81       	ldd	r19, Z+5	; 0x05
    4678:	8a 81       	ldd	r24, Y+2	; 0x02
    467a:	9b 81       	ldd	r25, Y+3	; 0x03
    467c:	28 17       	cp	r18, r24
    467e:	39 07       	cpc	r19, r25
    4680:	09 f0       	breq	.+2      	; 0x4684 <UDP_GetSocket+0xa2>
    4682:	3f c0       	rjmp	.+126    	; 0x4702 <UDP_GetSocket+0x120>
    4684:	01 15       	cp	r16, r1
    4686:	11 05       	cpc	r17, r1
    4688:	e1 f5       	brne	.+120    	; 0x4702 <UDP_GetSocket+0x120>
    468a:	80 81       	ld	r24, Z
    468c:	91 81       	ldd	r25, Z+1	; 0x01
    468e:	a2 81       	ldd	r26, Z+2	; 0x02
    4690:	b3 81       	ldd	r27, Z+3	; 0x03
    4692:	00 97       	sbiw	r24, 0x00	; 0
    4694:	a1 05       	cpc	r26, r1
    4696:	b1 05       	cpc	r27, r1
    4698:	a1 f5       	brne	.+104    	; 0x4702 <UDP_GetSocket+0x120>
						&& UDP_sockettable[ Socket ].DestinationPort == 0
						&& UDP_sockettable[ Socket ].DestinationIP == 0 )
							{
								// Socket komplettieren
								UDP_sockettable[ Socket ].DestinationIP = IP_packet->IP_SourceIP;
    469a:	86 e1       	ldi	r24, 0x16	; 22
    469c:	90 e0       	ldi	r25, 0x00	; 0
    469e:	68 9f       	mul	r22, r24
    46a0:	f0 01       	movw	r30, r0
    46a2:	69 9f       	mul	r22, r25
    46a4:	f0 0d       	add	r31, r0
    46a6:	78 9f       	mul	r23, r24
    46a8:	f0 0d       	add	r31, r0
    46aa:	11 24       	eor	r1, r1
    46ac:	e5 52       	subi	r30, 0x25	; 37
    46ae:	f8 4f       	sbci	r31, 0xF8	; 248
    46b0:	d5 01       	movw	r26, r10
    46b2:	1c 96       	adiw	r26, 0x0c	; 12
    46b4:	0d 91       	ld	r16, X+
    46b6:	1d 91       	ld	r17, X+
    46b8:	2d 91       	ld	r18, X+
    46ba:	3c 91       	ld	r19, X
    46bc:	1f 97       	sbiw	r26, 0x0f	; 15
    46be:	01 83       	std	Z+1, r16	; 0x01
    46c0:	12 83       	std	Z+2, r17	; 0x02
    46c2:	23 83       	std	Z+3, r18	; 0x03
    46c4:	34 83       	std	Z+4, r19	; 0x04
								UDP_sockettable[ Socket ].DestinationPort = UDP_packet->UDP_SourcePort;
    46c6:	88 81       	ld	r24, Y
    46c8:	99 81       	ldd	r25, Y+1	; 0x01
    46ca:	90 87       	std	Z+8, r25	; 0x08
    46cc:	87 83       	std	Z+7, r24	; 0x07
								for( i = 0 ; i < 6 ; i++ ) UDP_sockettable[ Socket ].MACadress[ i ] = ETH_packet->ETH_sourceMac[ i ] ;
    46ce:	da 01       	movw	r26, r20
    46d0:	16 96       	adiw	r26, 0x06	; 6
    46d2:	8c 91       	ld	r24, X
    46d4:	16 97       	sbiw	r26, 0x06	; 6
    46d6:	81 87       	std	Z+9, r24	; 0x09
    46d8:	17 96       	adiw	r26, 0x07	; 7
    46da:	8c 91       	ld	r24, X
    46dc:	17 97       	sbiw	r26, 0x07	; 7
    46de:	82 87       	std	Z+10, r24	; 0x0a
    46e0:	18 96       	adiw	r26, 0x08	; 8
    46e2:	8c 91       	ld	r24, X
    46e4:	18 97       	sbiw	r26, 0x08	; 8
    46e6:	83 87       	std	Z+11, r24	; 0x0b
    46e8:	19 96       	adiw	r26, 0x09	; 9
    46ea:	8c 91       	ld	r24, X
    46ec:	19 97       	sbiw	r26, 0x09	; 9
    46ee:	84 87       	std	Z+12, r24	; 0x0c
    46f0:	1a 96       	adiw	r26, 0x0a	; 10
    46f2:	8c 91       	ld	r24, X
    46f4:	1a 97       	sbiw	r26, 0x0a	; 10
    46f6:	85 87       	std	Z+13, r24	; 0x0d
    46f8:	1b 96       	adiw	r26, 0x0b	; 11
    46fa:	8c 91       	ld	r24, X
    46fc:	86 87       	std	Z+14, r24	; 0x0e
								return( Socket );
    46fe:	fb 01       	movw	r30, r22
    4700:	09 c0       	rjmp	.+18     	; 0x4714 <UDP_GetSocket+0x132>
		struct UDP_header * UDP_packet;		// TCP_struct anlegen
		UDP_packet = ( struct UDP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];

		unsigned int Socket,i;
		
		for ( Socket = 0 ; Socket < MAX_UDP_CONNECTIONS ; Socket++ ) 
    4702:	6f 5f       	subi	r22, 0xFF	; 255
    4704:	7f 4f       	sbci	r23, 0xFF	; 255
    4706:	76 96       	adiw	r30, 0x16	; 22
    4708:	62 30       	cpi	r22, 0x02	; 2
    470a:	71 05       	cpc	r23, r1
    470c:	09 f0       	breq	.+2      	; 0x4710 <UDP_GetSocket+0x12e>
    470e:	91 cf       	rjmp	.-222    	; 0x4632 <UDP_GetSocket+0x50>
    4710:	ef ef       	ldi	r30, 0xFF	; 255
    4712:	ff ef       	ldi	r31, 0xFF	; 255
								return( Socket );
							}
			}

		return( UDP_SOCKET_ERROR );
	}
    4714:	cf 01       	movw	r24, r30
    4716:	cd b7       	in	r28, 0x3d	; 61
    4718:	de b7       	in	r29, 0x3e	; 62
    471a:	e0 e1       	ldi	r30, 0x10	; 16
    471c:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

00004720 <MakeUDPheader>:
	
/* -----------------------------------------------------------------------------------------------------------
Bastelt den UDP-header
------------------------------------------------------------------------------------------------------------*/
int MakeUDPheader( int SOCKET, unsigned int Datalenght, unsigned char * ethernetbuffer )
{
    4720:	0f 93       	push	r16
    4722:	1f 93       	push	r17
    4724:	cf 93       	push	r28
    4726:	df 93       	push	r29
    4728:	9c 01       	movw	r18, r24
    472a:	fa 01       	movw	r30, r20
	if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
    472c:	82 30       	cpi	r24, 0x02	; 2
    472e:	91 05       	cpc	r25, r1
    4730:	1c f0       	brlt	.+6      	; 0x4738 <MakeUDPheader+0x18>
    4732:	2f ef       	ldi	r18, 0xFF	; 255
    4734:	3f ef       	ldi	r19, 0xFF	; 255
    4736:	2d c0       	rjmp	.+90     	; 0x4792 <MakeUDPheader+0x72>
	struct ETH_header * ETH_packet; 		// ETH_struct anlegen
	ETH_packet = (struct ETH_header *) ethernetbuffer;
	struct IP_header * IP_packet;		// IP_struct anlegen
	IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
	struct UDP_header * UDP_packet;		// TCP_struct anlegen
	UDP_packet = ( struct UDP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];		
    4738:	86 85       	ldd	r24, Z+14	; 0x0e
    473a:	c8 2f       	mov	r28, r24
    473c:	d0 e0       	ldi	r29, 0x00	; 0
    473e:	cf 70       	andi	r28, 0x0F	; 15
    4740:	d0 70       	andi	r29, 0x00	; 0
    4742:	cc 0f       	add	r28, r28
    4744:	dd 1f       	adc	r29, r29
    4746:	cc 0f       	add	r28, r28
    4748:	dd 1f       	adc	r29, r29
    474a:	2e 96       	adiw	r28, 0x0e	; 14
    474c:	ce 0f       	add	r28, r30
    474e:	df 1f       	adc	r29, r31
		
	UDP_packet->UDP_DestinationPort = UDP_sockettable[SOCKET].DestinationPort;
    4750:	86 e1       	ldi	r24, 0x16	; 22
    4752:	90 e0       	ldi	r25, 0x00	; 0
    4754:	28 9f       	mul	r18, r24
    4756:	80 01       	movw	r16, r0
    4758:	29 9f       	mul	r18, r25
    475a:	10 0d       	add	r17, r0
    475c:	38 9f       	mul	r19, r24
    475e:	10 0d       	add	r17, r0
    4760:	11 24       	eor	r1, r1
    4762:	05 52       	subi	r16, 0x25	; 37
    4764:	18 4f       	sbci	r17, 0xF8	; 248
    4766:	f8 01       	movw	r30, r16
    4768:	87 81       	ldd	r24, Z+7	; 0x07
    476a:	90 85       	ldd	r25, Z+8	; 0x08
    476c:	9b 83       	std	Y+3, r25	; 0x03
    476e:	8a 83       	std	Y+2, r24	; 0x02
	UDP_packet->UDP_SourcePort = UDP_sockettable[SOCKET].SourcePort;
    4770:	85 81       	ldd	r24, Z+5	; 0x05
    4772:	96 81       	ldd	r25, Z+6	; 0x06
    4774:	99 83       	std	Y+1, r25	; 0x01
    4776:	88 83       	st	Y, r24
	UDP_packet->UDP_Checksum = 0;
    4778:	1f 82       	std	Y+7, r1	; 0x07
    477a:	1e 82       	std	Y+6, r1	; 0x06
	UDP_packet->UDP_Datalenght = ChangeEndian16bit( 8 + Datalenght );
    477c:	cb 01       	movw	r24, r22
    477e:	08 96       	adiw	r24, 0x08	; 8
    4780:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    4784:	9d 83       	std	Y+5, r25	; 0x05
    4786:	8c 83       	std	Y+4, r24	; 0x04
	
	UDP_sockettable[SOCKET].ttl = UDP_Default_ttl;
    4788:	8e e1       	ldi	r24, 0x1E	; 30
    478a:	f8 01       	movw	r30, r16
    478c:	85 8b       	std	Z+21, r24	; 0x15
    478e:	20 e0       	ldi	r18, 0x00	; 0
    4790:	30 e0       	ldi	r19, 0x00	; 0
	
	return(0);
}
    4792:	c9 01       	movw	r24, r18
    4794:	df 91       	pop	r29
    4796:	cf 91       	pop	r28
    4798:	1f 91       	pop	r17
    479a:	0f 91       	pop	r16
    479c:	08 95       	ret

0000479e <udp>:
 * \param	ethernetbuffer	Zeiger auf das Packet.
 * \return  NONE
 */
/* -----------------------------------------------------------------------------------------------------------*/
void udp( unsigned int packet_lenght, unsigned char * ethernetbuffer )
{
    479e:	a0 e0       	ldi	r26, 0x00	; 0
    47a0:	b0 e0       	ldi	r27, 0x00	; 0
    47a2:	e5 ed       	ldi	r30, 0xD5	; 213
    47a4:	f3 e2       	ldi	r31, 0x23	; 35
    47a6:	0c 94 c2 6a 	jmp	0xd584	; 0xd584 <__prologue_saves__+0x12>
    47aa:	6b 01       	movw	r12, r22
		struct ETH_header * ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header * IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
		struct UDP_header * UDP_packet;		// TCP_struct anlegen
		UDP_packet = ( struct UDP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    47ac:	db 01       	movw	r26, r22
    47ae:	1e 96       	adiw	r26, 0x0e	; 14
    47b0:	bc 90       	ld	r11, X
			
		#ifdef _DEBUG_
			printf_P( PSTR("UDP-Packet empfangen") , packet_lenght );
		#endif

		SOCKET = UDP_GetSocket( ethernetbuffer );
    47b2:	cb 01       	movw	r24, r22
    47b4:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <UDP_GetSocket>
    47b8:	7c 01       	movw	r14, r24
	
		// Socket zugeordnet ?
		if ( SOCKET == UDP_SOCKET_ERROR ) return;
    47ba:	bf ef       	ldi	r27, 0xFF	; 255
    47bc:	8f 3f       	cpi	r24, 0xFF	; 255
    47be:	9b 07       	cpc	r25, r27
    47c0:	09 f4       	brne	.+2      	; 0x47c4 <udp+0x26>
    47c2:	67 c0       	rjmp	.+206    	; 0x4892 <udp+0xf4>
			
		// Socket schon mit daten belegt ?
		if ( UDP_sockettable[ SOCKET ].Socketstate == UDP_SOCKET_BUSY ) return ;
    47c4:	86 e1       	ldi	r24, 0x16	; 22
    47c6:	90 e0       	ldi	r25, 0x00	; 0
    47c8:	e8 9e       	mul	r14, r24
    47ca:	80 01       	movw	r16, r0
    47cc:	e9 9e       	mul	r14, r25
    47ce:	10 0d       	add	r17, r0
    47d0:	f8 9e       	mul	r15, r24
    47d2:	10 0d       	add	r17, r0
    47d4:	11 24       	eor	r1, r1
    47d6:	05 52       	subi	r16, 0x25	; 37
    47d8:	18 4f       	sbci	r17, 0xF8	; 248
    47da:	f8 01       	movw	r30, r16
    47dc:	80 81       	ld	r24, Z
    47de:	80 32       	cpi	r24, 0x20	; 32
    47e0:	09 f4       	brne	.+2      	; 0x47e4 <udp+0x46>
    47e2:	57 c0       	rjmp	.+174    	; 0x4892 <udp+0xf4>
		struct ETH_header * ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header * IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
		struct UDP_header * UDP_packet;		// TCP_struct anlegen
		UDP_packet = ( struct UDP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    47e4:	cb 2d       	mov	r28, r11
    47e6:	d0 e0       	ldi	r29, 0x00	; 0
    47e8:	cf 70       	andi	r28, 0x0F	; 15
    47ea:	d0 70       	andi	r29, 0x00	; 0
    47ec:	cc 0f       	add	r28, r28
    47ee:	dd 1f       	adc	r29, r29
    47f0:	cc 0f       	add	r28, r28
    47f2:	dd 1f       	adc	r29, r29
    47f4:	2e 96       	adiw	r28, 0x0e	; 14
    47f6:	cc 0d       	add	r28, r12
    47f8:	dd 1d       	adc	r29, r13
		if ( SOCKET == UDP_SOCKET_ERROR ) return;
			
		// Socket schon mit daten belegt ?
		if ( UDP_sockettable[ SOCKET ].Socketstate == UDP_SOCKET_BUSY ) return ;
		// Hat Socket Daten ?
		if ( ( ChangeEndian16bit( UDP_packet->UDP_Datalenght ) - UDP_HEADER_LENGHT ) == 0 ) return ;
    47fa:	8c 81       	ldd	r24, Y+4	; 0x04
    47fc:	9d 81       	ldd	r25, Y+5	; 0x05
    47fe:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    4802:	08 97       	sbiw	r24, 0x08	; 8
    4804:	09 f4       	brne	.+2      	; 0x4808 <udp+0x6a>
    4806:	45 c0       	rjmp	.+138    	; 0x4892 <udp+0xf4>
		// Gr철e der Daten limitieren auf Puffergr철e
		i = MIN( ChangeEndian16bit( UDP_packet->UDP_Datalenght) - UDP_HEADER_LENGHT , UDP_sockettable[ SOCKET ].Bufferlenght );
    4808:	8c 81       	ldd	r24, Y+4	; 0x04
    480a:	9d 81       	ldd	r25, Y+5	; 0x05
    480c:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    4810:	d8 01       	movw	r26, r16
    4812:	1f 96       	adiw	r26, 0x0f	; 15
    4814:	2d 91       	ld	r18, X+
    4816:	3c 91       	ld	r19, X
    4818:	50 97       	sbiw	r26, 0x10	; 16
    481a:	08 97       	sbiw	r24, 0x08	; 8
    481c:	82 17       	cp	r24, r18
    481e:	93 07       	cpc	r25, r19
    4820:	38 f4       	brcc	.+14     	; 0x4830 <udp+0x92>
    4822:	8c 81       	ldd	r24, Y+4	; 0x04
    4824:	9d 81       	ldd	r25, Y+5	; 0x05
    4826:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    482a:	9c 01       	movw	r18, r24
    482c:	28 50       	subi	r18, 0x08	; 8
    482e:	30 40       	sbci	r19, 0x00	; 0
		
		// Gr철e der Daten eintragen
		UDP_sockettable[ SOCKET ].Bufferfill = i;
    4830:	86 e1       	ldi	r24, 0x16	; 22
    4832:	90 e0       	ldi	r25, 0x00	; 0
    4834:	e8 9e       	mul	r14, r24
    4836:	f0 01       	movw	r30, r0
    4838:	e9 9e       	mul	r14, r25
    483a:	f0 0d       	add	r31, r0
    483c:	f8 9e       	mul	r15, r24
    483e:	f0 0d       	add	r31, r0
    4840:	11 24       	eor	r1, r1
    4842:	e5 52       	subi	r30, 0x25	; 37
    4844:	f8 4f       	sbci	r31, 0xF8	; 248
    4846:	32 8b       	std	Z+18, r19	; 0x12
    4848:	21 8b       	std	Z+17, r18	; 0x11
		// Socket als belegt melden
		UDP_sockettable[ SOCKET ].Socketstate = UDP_SOCKET_BUSY;
    484a:	80 e2       	ldi	r24, 0x20	; 32
    484c:	80 83       	st	Z, r24
		// ttl wieder richtig setzen
		UDP_sockettable[SOCKET].ttl = UDP_Default_ttl;
    484e:	8e e1       	ldi	r24, 0x1E	; 30
    4850:	85 8b       	std	Z+21, r24	; 0x15
    4852:	d6 01       	movw	r26, r12
    4854:	1e 96       	adiw	r26, 0x0e	; 14
    4856:	8c 91       	ld	r24, X
    4858:	a8 2f       	mov	r26, r24
    485a:	b0 e0       	ldi	r27, 0x00	; 0
    485c:	af 70       	andi	r26, 0x0F	; 15
    485e:	b0 70       	andi	r27, 0x00	; 0
    4860:	aa 0f       	add	r26, r26
    4862:	bb 1f       	adc	r27, r27
    4864:	aa 0f       	add	r26, r26
    4866:	bb 1f       	adc	r27, r27
    4868:	a2 0f       	add	r26, r18
    486a:	b3 1f       	adc	r27, r19
    486c:	ac 0d       	add	r26, r12
    486e:	bd 1d       	adc	r27, r13
		Offset = ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 ) + UDP_HEADER_LENGHT;
		
		// Daten kopieren
		while ( i-- )
			{
				UDP_sockettable[ SOCKET ].Recivebuffer[i] = ethernetbuffer[ Offset + i ];
    4870:	ef 01       	movw	r28, r30
    4872:	63 96       	adiw	r28, 0x13	; 19
    4874:	0a c0       	rjmp	.+20     	; 0x488a <udp+0xec>
		
		// Offset f체r UDP-Daten im Ethernetfrane berechnen
		Offset = ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 ) + UDP_HEADER_LENGHT;
		
		// Daten kopieren
		while ( i-- )
    4876:	21 50       	subi	r18, 0x01	; 1
    4878:	30 40       	sbci	r19, 0x00	; 0
			{
				UDP_sockettable[ SOCKET ].Recivebuffer[i] = ethernetbuffer[ Offset + i ];
    487a:	e8 81       	ld	r30, Y
    487c:	f9 81       	ldd	r31, Y+1	; 0x01
    487e:	e2 0f       	add	r30, r18
    4880:	f3 1f       	adc	r31, r19
    4882:	56 96       	adiw	r26, 0x16	; 22
    4884:	8c 91       	ld	r24, X
    4886:	56 97       	sbiw	r26, 0x16	; 22
    4888:	80 83       	st	Z, r24
    488a:	11 97       	sbiw	r26, 0x01	; 1
		
		// Offset f체r UDP-Daten im Ethernetfrane berechnen
		Offset = ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 ) + UDP_HEADER_LENGHT;
		
		// Daten kopieren
		while ( i-- )
    488c:	21 15       	cp	r18, r1
    488e:	31 05       	cpc	r19, r1
    4890:	91 f7       	brne	.-28     	; 0x4876 <udp+0xd8>
			{
				UDP_sockettable[ SOCKET ].Recivebuffer[i] = ethernetbuffer[ Offset + i ];
			}
		return;
}
    4892:	cd b7       	in	r28, 0x3d	; 61
    4894:	de b7       	in	r29, 0x3e	; 62
    4896:	e9 e0       	ldi	r30, 0x09	; 9
    4898:	0c 94 de 6a 	jmp	0xd5bc	; 0xd5bc <__epilogue_restores__+0x12>

0000489c <UDP_SendPacket>:
 * \return  Bei einem Fehler beim versenden wird ungleich 0 zurueckgegeben, sonst 0.
 * \sa UDP_RegisterSocket , UDP_GetSocketState
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_SendPacket( int SOCKET, unsigned int Datalenght, unsigned char * UDP_Databuffer )
{
    489c:	a0 e0       	ldi	r26, 0x00	; 0
    489e:	b0 e0       	ldi	r27, 0x00	; 0
    48a0:	e4 e5       	ldi	r30, 0x54	; 84
    48a2:	f4 e2       	ldi	r31, 0x24	; 36
    48a4:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    48a8:	4c 01       	movw	r8, r24
    48aa:	5b 01       	movw	r10, r22
    48ac:	8a 01       	movw	r16, r20
	sendEthernetframe( ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + UDP_HEADER_LENGHT + Datalenght, ethernetbuffer);

	FreeEthernet();
	
	return(0);
}
    48ae:	4d b6       	in	r4, 0x3d	; 61
    48b0:	5e b6       	in	r5, 0x3e	; 62
 * \sa UDP_RegisterSocket , UDP_GetSocketState
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_SendPacket( int SOCKET, unsigned int Datalenght, unsigned char * UDP_Databuffer )
{
	if ( SOCKET >= MAX_UDP_CONNECTIONS ) return( UDP_SOCKET_ERROR );
    48b2:	82 e0       	ldi	r24, 0x02	; 2
    48b4:	88 16       	cp	r8, r24
    48b6:	91 04       	cpc	r9, r1
    48b8:	1c f0       	brlt	.+6      	; 0x48c0 <UDP_SendPacket+0x24>
    48ba:	2f ef       	ldi	r18, 0xFF	; 255
    48bc:	3f ef       	ldi	r19, 0xFF	; 255
    48be:	52 c0       	rjmp	.+164    	; 0x4964 <UDP_SendPacket+0xc8>
		
	LockEthernet();
    48c0:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
	
	unsigned char * ethernetbuffer;
	ethernetbuffer = (unsigned char*) __builtin_alloca (( size_t ) ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + UDP_HEADER_LENGHT + Datalenght );
    48c4:	7a e2       	ldi	r23, 0x2A	; 42
    48c6:	67 2e       	mov	r6, r23
    48c8:	71 2c       	mov	r7, r1
    48ca:	6a 0c       	add	r6, r10
    48cc:	7b 1c       	adc	r7, r11
    48ce:	ed b7       	in	r30, 0x3d	; 61
    48d0:	fe b7       	in	r31, 0x3e	; 62
    48d2:	e6 19       	sub	r30, r6
    48d4:	f7 09       	sbc	r31, r7
    48d6:	0f b6       	in	r0, 0x3f	; 63
    48d8:	f8 94       	cli
    48da:	fe bf       	out	0x3e, r31	; 62
    48dc:	0f be       	out	0x3f, r0	; 63
    48de:	ed bf       	out	0x3d, r30	; 61
    48e0:	cd b6       	in	r12, 0x3d	; 61
    48e2:	de b6       	in	r13, 0x3e	; 62
    48e4:	08 94       	sec
    48e6:	c1 1c       	adc	r12, r1
    48e8:	d1 1c       	adc	r13, r1

	struct ETH_header * ETH_packet; 		// ETH_struct anlegen
	ETH_packet = (struct ETH_header *) ethernetbuffer;
	struct IP_header * IP_packet;		// IP_struct anlegen
	IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
	IP_packet->IP_Version_Headerlen = 0x45; // Standart IPv4 und Headerlenght 20byte
    48ea:	85 e4       	ldi	r24, 0x45	; 69
    48ec:	f6 01       	movw	r30, r12
    48ee:	86 87       	std	Z+14, r24	; 0x0e
    48f0:	ad b7       	in	r26, 0x3d	; 61
    48f2:	be b7       	in	r27, 0x3e	; 62
    48f4:	9b 96       	adiw	r26, 0x2b	; 43
    48f6:	20 e0       	ldi	r18, 0x00	; 0
    48f8:	30 e0       	ldi	r19, 0x00	; 0
    48fa:	07 c0       	rjmp	.+14     	; 0x490a <UDP_SendPacket+0x6e>
	UDP_packet = ( struct UDP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
		
	unsigned int i;
	unsigned int offset = ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 ) + UDP_HEADER_LENGHT;

	for ( i = 0 ; i < Datalenght ; i++ ) ethernetbuffer[ offset + i ] = UDP_Databuffer[ i ];
    48fc:	f8 01       	movw	r30, r16
    48fe:	e2 0f       	add	r30, r18
    4900:	f3 1f       	adc	r31, r19
    4902:	80 81       	ld	r24, Z
    4904:	8d 93       	st	X+, r24
    4906:	2f 5f       	subi	r18, 0xFF	; 255
    4908:	3f 4f       	sbci	r19, 0xFF	; 255
    490a:	2a 15       	cp	r18, r10
    490c:	3b 05       	cpc	r19, r11
    490e:	b0 f3       	brcs	.-20     	; 0x48fc <UDP_SendPacket+0x60>
	
	MakeIPheader( UDP_sockettable[SOCKET].DestinationIP, PROTO_UDP, UDP_HEADER_LENGHT + Datalenght , ethernetbuffer );
    4910:	86 e1       	ldi	r24, 0x16	; 22
    4912:	90 e0       	ldi	r25, 0x00	; 0
    4914:	88 9e       	mul	r8, r24
    4916:	70 01       	movw	r14, r0
    4918:	89 9e       	mul	r8, r25
    491a:	f0 0c       	add	r15, r0
    491c:	98 9e       	mul	r9, r24
    491e:	f0 0c       	add	r15, r0
    4920:	11 24       	eor	r1, r1
    4922:	f7 01       	movw	r30, r14
    4924:	e5 52       	subi	r30, 0x25	; 37
    4926:	f8 4f       	sbci	r31, 0xF8	; 248
    4928:	61 81       	ldd	r22, Z+1	; 0x01
    492a:	72 81       	ldd	r23, Z+2	; 0x02
    492c:	83 81       	ldd	r24, Z+3	; 0x03
    492e:	94 81       	ldd	r25, Z+4	; 0x04
    4930:	95 01       	movw	r18, r10
    4932:	28 5f       	subi	r18, 0xF8	; 248
    4934:	3f 4f       	sbci	r19, 0xFF	; 255
    4936:	41 e1       	ldi	r20, 0x11	; 17
    4938:	86 01       	movw	r16, r12
    493a:	0e 94 8b 33 	call	0x6716	; 0x6716 <MakeIPheader>
	MakeUDPheader( SOCKET, Datalenght, ethernetbuffer );
    493e:	c4 01       	movw	r24, r8
    4940:	b5 01       	movw	r22, r10
    4942:	a6 01       	movw	r20, r12
    4944:	0e 94 90 23 	call	0x4720	; 0x4720 <MakeUDPheader>
	MakeETHheader( UDP_sockettable[SOCKET].MACadress, ethernetbuffer );
    4948:	c7 01       	movw	r24, r14
    494a:	8c 51       	subi	r24, 0x1C	; 28
    494c:	98 4f       	sbci	r25, 0xF8	; 248
    494e:	b6 01       	movw	r22, r12
    4950:	0e 94 26 30 	call	0x604c	; 0x604c <MakeETHheader>
	sendEthernetframe( ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + UDP_HEADER_LENGHT + Datalenght, ethernetbuffer);
    4954:	c3 01       	movw	r24, r6
    4956:	b6 01       	movw	r22, r12
    4958:	0e 94 4d 30 	call	0x609a	; 0x609a <sendEthernetframe>

	FreeEthernet();
    495c:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
    4960:	20 e0       	ldi	r18, 0x00	; 0
    4962:	30 e0       	ldi	r19, 0x00	; 0
	
	return(0);
}
    4964:	c9 01       	movw	r24, r18
    4966:	0f b6       	in	r0, 0x3f	; 63
    4968:	f8 94       	cli
    496a:	5e be       	out	0x3e, r5	; 62
    496c:	0f be       	out	0x3f, r0	; 63
    496e:	4d be       	out	0x3d, r4	; 61
    4970:	20 96       	adiw	r28, 0x00	; 0
    4972:	e0 e1       	ldi	r30, 0x10	; 16
    4974:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

00004978 <UDP_RegisterSocket>:
 * \param	UDP_Recivebuffer	Zieger auf den Puffer der vom Benutzer bereitgestellt wird.
 * \return  Beim erfolgreichen anlegen eines Socket wird die Socketnummer zurueck gegeben. Im Fehlerfall 0xffff.
 */
/* -----------------------------------------------------------------------------------------------------------*/
int UDP_RegisterSocket( unsigned long IP, unsigned int DestinationPort, unsigned int Bufferlenght, unsigned char * UDP_Recivebuffer)
{
    4978:	a0 e0       	ldi	r26, 0x00	; 0
    497a:	b0 e0       	ldi	r27, 0x00	; 0
    497c:	e2 ec       	ldi	r30, 0xC2	; 194
    497e:	f4 e2       	ldi	r31, 0x24	; 36
    4980:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    4984:	5b 01       	movw	r10, r22
    4986:	6c 01       	movw	r12, r24
    4988:	7a 01       	movw	r14, r20
    498a:	39 01       	movw	r6, r18
    498c:	28 01       	movw	r4, r16
int UDP_Getfreesocket( void )
	{
		unsigned int Socket;
		for ( Socket = 0 ; Socket < MAX_UDP_CONNECTIONS ; Socket++ ) 
			{
				if ( UDP_sockettable[ Socket ].Socketstate == UDP_SOCKET_NOT_USE ) return( Socket );
    498e:	80 91 db 07 	lds	r24, 0x07DB
    4992:	88 23       	and	r24, r24
    4994:	19 f4       	brne	.+6      	; 0x499c <UDP_RegisterSocket+0x24>
    4996:	00 e0       	ldi	r16, 0x00	; 0
    4998:	10 e0       	ldi	r17, 0x00	; 0
    499a:	0a c0       	rjmp	.+20     	; 0x49b0 <UDP_RegisterSocket+0x38>
    499c:	80 91 f1 07 	lds	r24, 0x07F1
    49a0:	88 23       	and	r24, r24
    49a2:	21 f0       	breq	.+8      	; 0x49ac <UDP_RegisterSocket+0x34>
    49a4:	88 24       	eor	r8, r8
    49a6:	8a 94       	dec	r8
    49a8:	98 2c       	mov	r9, r8
    49aa:	93 c0       	rjmp	.+294    	; 0x4ad2 <UDP_RegisterSocket+0x15a>
    49ac:	01 e0       	ldi	r16, 0x01	; 1
    49ae:	10 e0       	ldi	r17, 0x00	; 0
    49b0:	48 01       	movw	r8, r16
	
	SOCKET = UDP_Getfreesocket();
	
	if ( SOCKET == UDP_SOCKET_ERROR ) return( UDP_SOCKET_ERROR );
	
	UDP_sockettable[SOCKET].Socketstate = UDP_SOCKET_READY;
    49b2:	86 e1       	ldi	r24, 0x16	; 22
    49b4:	90 e0       	ldi	r25, 0x00	; 0
    49b6:	08 9f       	mul	r16, r24
    49b8:	e0 01       	movw	r28, r0
    49ba:	09 9f       	mul	r16, r25
    49bc:	d0 0d       	add	r29, r0
    49be:	18 9f       	mul	r17, r24
    49c0:	d0 0d       	add	r29, r0
    49c2:	11 24       	eor	r1, r1
    49c4:	c5 52       	subi	r28, 0x25	; 37
    49c6:	d8 4f       	sbci	r29, 0xF8	; 248
    49c8:	80 e1       	ldi	r24, 0x10	; 16
    49ca:	88 83       	st	Y, r24
	UDP_sockettable[SOCKET].DestinationPort = ChangeEndian16bit( DestinationPort );
    49cc:	c7 01       	movw	r24, r14
    49ce:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    49d2:	98 87       	std	Y+8, r25	; 0x08
    49d4:	8f 83       	std	Y+7, r24	; 0x07
	// wenn Zielport Bootps(67) dann Sourceport auf Bootpc(68) setzen um kommunikation mit DHCP-Server zu erm철glichen
	if ( DestinationPort == 67 ) {
    49d6:	83 e4       	ldi	r24, 0x43	; 67
    49d8:	e8 16       	cp	r14, r24
    49da:	f1 04       	cpc	r15, r1
    49dc:	19 f4       	brne	.+6      	; 0x49e4 <UDP_RegisterSocket+0x6c>
		UDP_sockettable[SOCKET].SourcePort = ChangeEndian16bit( 68 );
    49de:	84 e4       	ldi	r24, 0x44	; 68
    49e0:	90 e0       	ldi	r25, 0x00	; 0
    49e2:	07 c0       	rjmp	.+14     	; 0x49f2 <UDP_RegisterSocket+0x7a>
	} else if (DestinationPort  == CAN_RELAY_PORT) {
    49e4:	8f eb       	ldi	r24, 0xBF	; 191
    49e6:	e8 16       	cp	r14, r24
    49e8:	83 e3       	ldi	r24, 0x33	; 51
    49ea:	f8 06       	cpc	r15, r24
    49ec:	39 f4       	brne	.+14     	; 0x49fc <UDP_RegisterSocket+0x84>
		// CAN UDP werden auf dem gleichen Socket empfangen wie gesendet.
		UDP_sockettable[SOCKET].SourcePort = ChangeEndian16bit( CAN_RELAY_PORT );
    49ee:	8f eb       	ldi	r24, 0xBF	; 191
    49f0:	93 e3       	ldi	r25, 0x33	; 51
    49f2:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    49f6:	9e 83       	std	Y+6, r25	; 0x06
    49f8:	8d 83       	std	Y+5, r24	; 0x05
    49fa:	04 c0       	rjmp	.+8      	; 0x4a04 <UDP_RegisterSocket+0x8c>
	} else {
		UDP_sockettable[SOCKET].SourcePort =~ DestinationPort;
    49fc:	e0 94       	com	r14
    49fe:	f0 94       	com	r15
    4a00:	fe 82       	std	Y+6, r15	; 0x06
    4a02:	ed 82       	std	Y+5, r14	; 0x05
	} ;
	
	UDP_sockettable[SOCKET].DestinationIP = IP;
    4a04:	86 e1       	ldi	r24, 0x16	; 22
    4a06:	90 e0       	ldi	r25, 0x00	; 0
    4a08:	08 9f       	mul	r16, r24
    4a0a:	e0 01       	movw	r28, r0
    4a0c:	09 9f       	mul	r16, r25
    4a0e:	d0 0d       	add	r29, r0
    4a10:	18 9f       	mul	r17, r24
    4a12:	d0 0d       	add	r29, r0
    4a14:	11 24       	eor	r1, r1
    4a16:	fe 01       	movw	r30, r28
    4a18:	e5 52       	subi	r30, 0x25	; 37
    4a1a:	f8 4f       	sbci	r31, 0xF8	; 248
    4a1c:	a1 82       	std	Z+1, r10	; 0x01
    4a1e:	b2 82       	std	Z+2, r11	; 0x02
    4a20:	c3 82       	std	Z+3, r12	; 0x03
    4a22:	d4 82       	std	Z+4, r13	; 0x04
	UDP_sockettable[SOCKET].Bufferfill = 0;
    4a24:	12 8a       	std	Z+18, r1	; 0x12
    4a26:	11 8a       	std	Z+17, r1	; 0x11
	UDP_sockettable[SOCKET].Bufferlenght = Bufferlenght;
    4a28:	70 8a       	std	Z+16, r7	; 0x10
    4a2a:	67 86       	std	Z+15, r6	; 0x0f
	UDP_sockettable[SOCKET].Recivebuffer = UDP_Recivebuffer;
    4a2c:	54 8a       	std	Z+20, r5	; 0x14
    4a2e:	43 8a       	std	Z+19, r4	; 0x13
	UDP_sockettable[SOCKET].ttl = UDP_Default_ttl;
    4a30:	8e e1       	ldi	r24, 0x1E	; 30
    4a32:	85 8b       	std	Z+21, r24	; 0x15
		
	if ( IP == 0xffffffff ) 
    4a34:	8f ef       	ldi	r24, 0xFF	; 255
    4a36:	a8 16       	cp	r10, r24
    4a38:	8f ef       	ldi	r24, 0xFF	; 255
    4a3a:	b8 06       	cpc	r11, r24
    4a3c:	8f ef       	ldi	r24, 0xFF	; 255
    4a3e:	c8 06       	cpc	r12, r24
    4a40:	8f ef       	ldi	r24, 0xFF	; 255
    4a42:	d8 06       	cpc	r13, r24
    4a44:	59 f1       	breq	.+86     	; 0x4a9c <UDP_RegisterSocket+0x124>
	{
		for( unsigned char i = 0 ; i < 6 ; i++ ) UDP_sockettable[SOCKET].MACadress[i] = 0xff;
		return( SOCKET );
	}
	if ( IS_ADDR_IN_MY_SUBNET( IP, Netmask ) )
    4a46:	20 91 49 01 	lds	r18, 0x0149
    4a4a:	30 91 4a 01 	lds	r19, 0x014A
    4a4e:	40 91 4b 01 	lds	r20, 0x014B
    4a52:	50 91 4c 01 	lds	r21, 0x014C
    4a56:	80 91 41 01 	lds	r24, 0x0141
    4a5a:	90 91 42 01 	lds	r25, 0x0142
    4a5e:	a0 91 43 01 	lds	r26, 0x0143
    4a62:	b0 91 44 01 	lds	r27, 0x0144
    4a66:	8a 25       	eor	r24, r10
    4a68:	9b 25       	eor	r25, r11
    4a6a:	ac 25       	eor	r26, r12
    4a6c:	bd 25       	eor	r27, r13
    4a6e:	82 23       	and	r24, r18
    4a70:	93 23       	and	r25, r19
    4a72:	a4 23       	and	r26, r20
    4a74:	b5 23       	and	r27, r21
    4a76:	00 97       	sbiw	r24, 0x00	; 0
    4a78:	a1 05       	cpc	r26, r1
    4a7a:	b1 05       	cpc	r27, r1
    4a7c:	e9 f4       	brne	.+58     	; 0x4ab8 <UDP_RegisterSocket+0x140>
		if ( IS_BROADCAST_ADDR( IP, Netmask ) ) for( unsigned char i = 0 ; i < 6 ; i++ ) UDP_sockettable[SOCKET].MACadress[i] = 0xff;
    4a7e:	20 95       	com	r18
    4a80:	30 95       	com	r19
    4a82:	40 95       	com	r20
    4a84:	50 95       	com	r21
    4a86:	d6 01       	movw	r26, r12
    4a88:	c5 01       	movw	r24, r10
    4a8a:	82 23       	and	r24, r18
    4a8c:	93 23       	and	r25, r19
    4a8e:	a4 23       	and	r26, r20
    4a90:	b5 23       	and	r27, r21
    4a92:	82 17       	cp	r24, r18
    4a94:	93 07       	cpc	r25, r19
    4a96:	a4 07       	cpc	r26, r20
    4a98:	b5 07       	cpc	r27, r21
    4a9a:	41 f4       	brne	.+16     	; 0x4aac <UDP_RegisterSocket+0x134>
    4a9c:	8f ef       	ldi	r24, 0xFF	; 255
    4a9e:	81 87       	std	Z+9, r24	; 0x09
    4aa0:	82 87       	std	Z+10, r24	; 0x0a
    4aa2:	83 87       	std	Z+11, r24	; 0x0b
    4aa4:	84 87       	std	Z+12, r24	; 0x0c
    4aa6:	85 87       	std	Z+13, r24	; 0x0d
    4aa8:	86 87       	std	Z+14, r24	; 0x0e
    4aaa:	13 c0       	rjmp	.+38     	; 0x4ad2 <UDP_RegisterSocket+0x15a>
		else GetIP2MAC( IP, UDP_sockettable[SOCKET].MACadress );
    4aac:	ae 01       	movw	r20, r28
    4aae:	4c 51       	subi	r20, 0x1C	; 28
    4ab0:	58 4f       	sbci	r21, 0xF8	; 248
    4ab2:	c6 01       	movw	r24, r12
    4ab4:	b5 01       	movw	r22, r10
    4ab6:	0b c0       	rjmp	.+22     	; 0x4ace <UDP_RegisterSocket+0x156>
	else GetIP2MAC( Gateway, UDP_sockettable[SOCKET].MACadress );
    4ab8:	60 91 4d 01 	lds	r22, 0x014D
    4abc:	70 91 4e 01 	lds	r23, 0x014E
    4ac0:	80 91 4f 01 	lds	r24, 0x014F
    4ac4:	90 91 50 01 	lds	r25, 0x0150
    4ac8:	ae 01       	movw	r20, r28
    4aca:	4c 51       	subi	r20, 0x1C	; 28
    4acc:	58 4f       	sbci	r21, 0xF8	; 248
    4ace:	0e 94 d0 31 	call	0x63a0	; 0x63a0 <GetIP2MAC>

	return( SOCKET );
}
    4ad2:	c4 01       	movw	r24, r8
    4ad4:	cd b7       	in	r28, 0x3d	; 61
    4ad6:	de b7       	in	r29, 0x3e	; 62
    4ad8:	e0 e1       	ldi	r30, 0x10	; 16
    4ada:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

00004ade <LockTCP>:
/*-----------------------------------------------------------------------------------------------------------*/
/*!\brief Sperrt den TCP-Timeouthandler
/*------------------------------------------------------------------------------------------------------------*/
void LockTCP()
{
	TCP_LOCK = Lock;
    4ade:	10 92 3a 01 	sts	0x013A, r1
}
    4ae2:	08 95       	ret

00004ae4 <FreeTCP>:
/*-----------------------------------------------------------------------------------------------------------*/
/*!\brief Gibt den TCP-Timeouthandler frei
/*------------------------------------------------------------------------------------------------------------*/
void FreeTCP()
{
	TCP_LOCK = Unlock;
    4ae4:	81 e0       	ldi	r24, 0x01	; 1
    4ae6:	80 93 3a 01 	sts	0x013A, r24
}
    4aea:	08 95       	ret

00004aec <GetSocket>:
 * \param	ethernetbuffer	Zeiger auf den Ethernetpuffer.
 * \retval	Socket	Im Erfolgsfall die Socketnummer, im Fehlerfall 0xffff
 */
/*------------------------------------------------------------------------------------------------------------*/
int GetSocket( unsigned char * ethernetbuffer )
	{
    4aec:	a0 e0       	ldi	r26, 0x00	; 0
    4aee:	b0 e0       	ldi	r27, 0x00	; 0
    4af0:	ec e7       	ldi	r30, 0x7C	; 124
    4af2:	f5 e2       	ldi	r31, 0x25	; 37
    4af4:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    4af8:	fc 01       	movw	r30, r24
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    4afa:	8c 01       	movw	r16, r24
    4afc:	02 5f       	subi	r16, 0xF2	; 242
    4afe:	1f 4f       	sbci	r17, 0xFF	; 255
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    4b00:	86 85       	ldd	r24, Z+14	; 0x0e
    4b02:	c8 2f       	mov	r28, r24
    4b04:	d0 e0       	ldi	r29, 0x00	; 0
    4b06:	cf 70       	andi	r28, 0x0F	; 15
    4b08:	d0 70       	andi	r29, 0x00	; 0
    4b0a:	cc 0f       	add	r28, r28
    4b0c:	dd 1f       	adc	r29, r29
    4b0e:	cc 0f       	add	r28, r28
    4b10:	dd 1f       	adc	r29, r29
    4b12:	2e 96       	adiw	r28, 0x0e	; 14
    4b14:	ce 0f       	add	r28, r30
    4b16:	df 1f       	adc	r29, r31
    4b18:	60 e0       	ldi	r22, 0x00	; 0
    4b1a:	70 e0       	ldi	r23, 0x00	; 0

		int Socket;
		
		for ( Socket = 0 ; Socket < MAX_TCP_CONNECTIONS ; Socket++ ) 
			{
				if ( 	TCP_sockettable[ Socket ].ConnectionState != SOCKET_NOT_USE 
    4b1c:	40 ea       	ldi	r20, 0xA0	; 160
    4b1e:	a4 2e       	mov	r10, r20
    4b20:	b1 2c       	mov	r11, r1
    4b22:	30 e5       	ldi	r19, 0x50	; 80
    4b24:	c3 2e       	mov	r12, r19
    4b26:	d1 2c       	mov	r13, r1
    4b28:	28 e2       	ldi	r18, 0x28	; 40
    4b2a:	e2 2e       	mov	r14, r18
    4b2c:	f1 2c       	mov	r15, r1
    4b2e:	6a 9d       	mul	r22, r10
    4b30:	d0 01       	movw	r26, r0
    4b32:	6b 9d       	mul	r22, r11
    4b34:	b0 0d       	add	r27, r0
    4b36:	7a 9d       	mul	r23, r10
    4b38:	b0 0d       	add	r27, r0
    4b3a:	11 24       	eor	r1, r1
    4b3c:	a7 5f       	subi	r26, 0xF7	; 247
    4b3e:	b7 4f       	sbci	r27, 0xF7	; 247
    4b40:	8c 91       	ld	r24, X
    4b42:	88 23       	and	r24, r24
    4b44:	b1 f1       	breq	.+108    	; 0x4bb2 <GetSocket+0xc6>
    4b46:	6c 9d       	mul	r22, r12
    4b48:	f0 01       	movw	r30, r0
    4b4a:	6d 9d       	mul	r22, r13
    4b4c:	f0 0d       	add	r31, r0
    4b4e:	7c 9d       	mul	r23, r12
    4b50:	f0 0d       	add	r31, r0
    4b52:	11 24       	eor	r1, r1
    4b54:	ee 0f       	add	r30, r30
    4b56:	ff 1f       	adc	r31, r31
    4b58:	e5 5f       	subi	r30, 0xF5	; 245
    4b5a:	f7 4f       	sbci	r31, 0xF7	; 247
    4b5c:	20 81       	ld	r18, Z
    4b5e:	31 81       	ldd	r19, Z+1	; 0x01
    4b60:	88 81       	ld	r24, Y
    4b62:	99 81       	ldd	r25, Y+1	; 0x01
    4b64:	28 17       	cp	r18, r24
    4b66:	39 07       	cpc	r19, r25
    4b68:	21 f5       	brne	.+72     	; 0x4bb2 <GetSocket+0xc6>
    4b6a:	6e 9d       	mul	r22, r14
    4b6c:	f0 01       	movw	r30, r0
    4b6e:	6f 9d       	mul	r22, r15
    4b70:	f0 0d       	add	r31, r0
    4b72:	7e 9d       	mul	r23, r14
    4b74:	f0 0d       	add	r31, r0
    4b76:	11 24       	eor	r1, r1
    4b78:	ee 0f       	add	r30, r30
    4b7a:	ff 1f       	adc	r31, r31
    4b7c:	ee 0f       	add	r30, r30
    4b7e:	ff 1f       	adc	r31, r31
    4b80:	e3 5f       	subi	r30, 0xF3	; 243
    4b82:	f7 4f       	sbci	r31, 0xF7	; 247
    4b84:	20 81       	ld	r18, Z
    4b86:	31 81       	ldd	r19, Z+1	; 0x01
    4b88:	8a 81       	ldd	r24, Y+2	; 0x02
    4b8a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b8c:	28 17       	cp	r18, r24
    4b8e:	39 07       	cpc	r19, r25
    4b90:	81 f4       	brne	.+32     	; 0x4bb2 <GetSocket+0xc6>
    4b92:	16 96       	adiw	r26, 0x06	; 6
    4b94:	2d 91       	ld	r18, X+
    4b96:	3d 91       	ld	r19, X+
    4b98:	4d 91       	ld	r20, X+
    4b9a:	5c 91       	ld	r21, X
    4b9c:	19 97       	sbiw	r26, 0x09	; 9
    4b9e:	f8 01       	movw	r30, r16
    4ba0:	84 85       	ldd	r24, Z+12	; 0x0c
    4ba2:	95 85       	ldd	r25, Z+13	; 0x0d
    4ba4:	a6 85       	ldd	r26, Z+14	; 0x0e
    4ba6:	b7 85       	ldd	r27, Z+15	; 0x0f
    4ba8:	28 17       	cp	r18, r24
    4baa:	39 07       	cpc	r19, r25
    4bac:	4a 07       	cpc	r20, r26
    4bae:	5b 07       	cpc	r21, r27
    4bb0:	41 f0       	breq	.+16     	; 0x4bc2 <GetSocket+0xd6>
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];

		int Socket;
		
		for ( Socket = 0 ; Socket < MAX_TCP_CONNECTIONS ; Socket++ ) 
    4bb2:	6f 5f       	subi	r22, 0xFF	; 255
    4bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    4bb6:	63 30       	cpi	r22, 0x03	; 3
    4bb8:	71 05       	cpc	r23, r1
    4bba:	09 f0       	breq	.+2      	; 0x4bbe <GetSocket+0xd2>
    4bbc:	b8 cf       	rjmp	.-144    	; 0x4b2e <GetSocket+0x42>
    4bbe:	6f ef       	ldi	r22, 0xFF	; 255
    4bc0:	7f ef       	ldi	r23, 0xFF	; 255
						&& TCP_sockettable[ Socket ].SourcePort == TCP_packet->TCP_SourcePort 
						&& TCP_sockettable[ Socket ].DestinationPort == TCP_packet->TCP_DestinationPort 
						&& TCP_sockettable[ Socket ].SourceIP == IP_packet->IP_SourceIP ) return( Socket );
			}
		return( SOCKET_ERROR );
	}		
    4bc2:	cb 01       	movw	r24, r22
    4bc4:	cd b7       	in	r28, 0x3d	; 61
    4bc6:	de b7       	in	r29, 0x3e	; 62
    4bc8:	ea e0       	ldi	r30, 0x0A	; 10
    4bca:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00004bce <RegisterTCPPort>:
 * \param	Port	Der Port auf den Gelauscht werden soll
 * \retval	Im Erfolgsfall 0, im Fehlerfall 0xffff
 */
/*------------------------------------------------------------------------------------------------------------*/
int RegisterTCPPort( unsigned int Port )
	{
    4bce:	ac 01       	movw	r20, r24
    4bd0:	20 e0       	ldi	r18, 0x00	; 0
    4bd2:	30 e0       	ldi	r19, 0x00	; 0
		int i;
		
		for ( i = 0 ; i < MAX_LISTEN_PORTS ; i ++ ) 
			{
				if ( TCP_porttable[i].TCP_Port == TCP_Port_not_use ) 
    4bd4:	f9 01       	movw	r30, r18
    4bd6:	ee 0f       	add	r30, r30
    4bd8:	ff 1f       	adc	r31, r31
    4bda:	e7 51       	subi	r30, 0x17	; 23
    4bdc:	f6 4f       	sbci	r31, 0xF6	; 246
    4bde:	80 81       	ld	r24, Z
    4be0:	91 81       	ldd	r25, Z+1	; 0x01
    4be2:	89 2b       	or	r24, r25
    4be4:	29 f4       	brne	.+10     	; 0x4bf0 <RegisterTCPPort+0x22>
				{
					TCP_porttable[i].TCP_Port = Port;
    4be6:	51 83       	std	Z+1, r21	; 0x01
    4be8:	40 83       	st	Z, r20
    4bea:	20 e0       	ldi	r18, 0x00	; 0
    4bec:	30 e0       	ldi	r19, 0x00	; 0
    4bee:	07 c0       	rjmp	.+14     	; 0x4bfe <RegisterTCPPort+0x30>
/*------------------------------------------------------------------------------------------------------------*/
int RegisterTCPPort( unsigned int Port )
	{
		int i;
		
		for ( i = 0 ; i < MAX_LISTEN_PORTS ; i ++ ) 
    4bf0:	2f 5f       	subi	r18, 0xFF	; 255
    4bf2:	3f 4f       	sbci	r19, 0xFF	; 255
    4bf4:	24 30       	cpi	r18, 0x04	; 4
    4bf6:	31 05       	cpc	r19, r1
    4bf8:	69 f7       	brne	.-38     	; 0x4bd4 <RegisterTCPPort+0x6>
    4bfa:	2f ef       	ldi	r18, 0xFF	; 255
    4bfc:	3f ef       	ldi	r19, 0xFF	; 255
					TCP_porttable[i].TCP_Port = Port;
					return(0);
				}
			}
		return( SOCKET_ERROR );
	}
    4bfe:	c9 01       	movw	r24, r18
    4c00:	08 95       	ret

00004c02 <CheckSocketState>:
 * \param	Socket		Die Socketnummer vom dem der Status zurueckgegeben werden soll.
 * \return	Der Socketstate
 */
/*------------------------------------------------------------------------------------------------------------*/	
char CheckSocketState( int Socket )
	{
    4c02:	9c 01       	movw	r18, r24
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS ) return( SOCKET_ERROR );
    4c04:	83 30       	cpi	r24, 0x03	; 3
    4c06:	91 05       	cpc	r25, r1
    4c08:	10 f0       	brcs	.+4      	; 0x4c0e <CheckSocketState+0xc>
    4c0a:	8f ef       	ldi	r24, 0xFF	; 255
    4c0c:	08 95       	ret
		return( TCP_sockettable[ Socket ].ConnectionState );
    4c0e:	80 ea       	ldi	r24, 0xA0	; 160
    4c10:	90 e0       	ldi	r25, 0x00	; 0
    4c12:	28 9f       	mul	r18, r24
    4c14:	f0 01       	movw	r30, r0
    4c16:	29 9f       	mul	r18, r25
    4c18:	f0 0d       	add	r31, r0
    4c1a:	38 9f       	mul	r19, r24
    4c1c:	f0 0d       	add	r31, r0
    4c1e:	11 24       	eor	r1, r1
    4c20:	e7 5f       	subi	r30, 0xF7	; 247
    4c22:	f7 4f       	sbci	r31, 0xF7	; 247
    4c24:	80 81       	ld	r24, Z
	}
    4c26:	08 95       	ret

00004c28 <CheckPortRequest>:
 * \param	Port	Der Port der abgefragt wird.
 * \return	Im Erfolgsfall die Socketnummer, im Fehlerfall 0xffff
 */
/*------------------------------------------------------------------------------------------------------------*/	
int CheckPortRequest( unsigned int Port )
	{
    4c28:	a0 e0       	ldi	r26, 0x00	; 0
    4c2a:	b0 e0       	ldi	r27, 0x00	; 0
    4c2c:	ea e1       	ldi	r30, 0x1A	; 26
    4c2e:	f6 e2       	ldi	r31, 0x26	; 38
    4c30:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    4c34:	7c 01       	movw	r14, r24
    4c36:	c0 e0       	ldi	r28, 0x00	; 0
    4c38:	d0 e0       	ldi	r29, 0x00	; 0
		int i;
		
		for ( i = 0 ; i < MAX_TCP_CONNECTIONS ; i ++ ) 
			{
				if ( TCP_sockettable[i].DestinationPort == ChangeEndian16bit( Port ) && TCP_sockettable[i].ConnectionState == SOCKET_READY2USE ) 
    4c3a:	18 e2       	ldi	r17, 0x28	; 40
    4c3c:	a1 2e       	mov	r10, r17
    4c3e:	b1 2c       	mov	r11, r1
    4c40:	b0 ea       	ldi	r27, 0xA0	; 160
    4c42:	cb 2e       	mov	r12, r27
    4c44:	d1 2c       	mov	r13, r1
    4c46:	ca 9d       	mul	r28, r10
    4c48:	f0 01       	movw	r30, r0
    4c4a:	cb 9d       	mul	r28, r11
    4c4c:	f0 0d       	add	r31, r0
    4c4e:	da 9d       	mul	r29, r10
    4c50:	f0 0d       	add	r31, r0
    4c52:	11 24       	eor	r1, r1
    4c54:	ee 0f       	add	r30, r30
    4c56:	ff 1f       	adc	r31, r31
    4c58:	ee 0f       	add	r30, r30
    4c5a:	ff 1f       	adc	r31, r31
    4c5c:	e3 5f       	subi	r30, 0xF3	; 243
    4c5e:	f7 4f       	sbci	r31, 0xF7	; 247
    4c60:	00 81       	ld	r16, Z
    4c62:	11 81       	ldd	r17, Z+1	; 0x01
    4c64:	c7 01       	movw	r24, r14
    4c66:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    4c6a:	08 17       	cp	r16, r24
    4c6c:	19 07       	cpc	r17, r25
    4c6e:	79 f4       	brne	.+30     	; 0x4c8e <CheckPortRequest+0x66>
    4c70:	cc 9d       	mul	r28, r12
    4c72:	f0 01       	movw	r30, r0
    4c74:	cd 9d       	mul	r28, r13
    4c76:	f0 0d       	add	r31, r0
    4c78:	dc 9d       	mul	r29, r12
    4c7a:	f0 0d       	add	r31, r0
    4c7c:	11 24       	eor	r1, r1
    4c7e:	e7 5f       	subi	r30, 0xF7	; 247
    4c80:	f7 4f       	sbci	r31, 0xF7	; 247
    4c82:	80 81       	ld	r24, Z
    4c84:	8f 30       	cpi	r24, 0x0F	; 15
    4c86:	19 f4       	brne	.+6      	; 0x4c8e <CheckPortRequest+0x66>
				{
					TCP_sockettable[i].ConnectionState = SOCKET_READY;
    4c88:	80 e1       	ldi	r24, 0x10	; 16
    4c8a:	80 83       	st	Z, r24
    4c8c:	06 c0       	rjmp	.+12     	; 0x4c9a <CheckPortRequest+0x72>
/*------------------------------------------------------------------------------------------------------------*/	
int CheckPortRequest( unsigned int Port )
	{
		int i;
		
		for ( i = 0 ; i < MAX_TCP_CONNECTIONS ; i ++ ) 
    4c8e:	21 96       	adiw	r28, 0x01	; 1
    4c90:	c3 30       	cpi	r28, 0x03	; 3
    4c92:	d1 05       	cpc	r29, r1
    4c94:	c1 f6       	brne	.-80     	; 0x4c46 <CheckPortRequest+0x1e>
    4c96:	cf ef       	ldi	r28, 0xFF	; 255
    4c98:	df ef       	ldi	r29, 0xFF	; 255
					TCP_sockettable[i].ConnectionState = SOCKET_READY;
					return(i);
				}
			}
		return( SOCKET_ERROR );
	}
    4c9a:	ce 01       	movw	r24, r28
    4c9c:	cd b7       	in	r28, 0x3d	; 61
    4c9e:	de b7       	in	r29, 0x3e	; 62
    4ca0:	ea e0       	ldi	r30, 0x0A	; 10
    4ca2:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00004ca6 <FlushSocketData>:
 * \param	Socket		Socketnummer von welchen der Puffer gel철scht werden soll.
 * \retval	Die Anzahl der kopierten Bytes.
 */
/*------------------------------------------------------------------------------------------------------------*/	
int FlushSocketData( int Socket )
	{
    4ca6:	9c 01       	movw	r18, r24
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS || TCP_sockettable[Socket].ConnectionState == SOCKET_NOT_USE ) return( SOCKET_ERROR );
    4ca8:	83 30       	cpi	r24, 0x03	; 3
    4caa:	91 05       	cpc	r25, r1
    4cac:	a0 f4       	brcc	.+40     	; 0x4cd6 <FlushSocketData+0x30>
    4cae:	80 ea       	ldi	r24, 0xA0	; 160
    4cb0:	90 e0       	ldi	r25, 0x00	; 0
    4cb2:	28 9f       	mul	r18, r24
    4cb4:	f0 01       	movw	r30, r0
    4cb6:	29 9f       	mul	r18, r25
    4cb8:	f0 0d       	add	r31, r0
    4cba:	38 9f       	mul	r19, r24
    4cbc:	f0 0d       	add	r31, r0
    4cbe:	11 24       	eor	r1, r1
    4cc0:	e7 5f       	subi	r30, 0xF7	; 247
    4cc2:	f7 4f       	sbci	r31, 0xF7	; 247
    4cc4:	80 81       	ld	r24, Z
    4cc6:	88 23       	and	r24, r24
    4cc8:	31 f0       	breq	.+12     	; 0x4cd6 <FlushSocketData+0x30>
		
		return( Flush_FIFO( TCP_sockettable[ Socket ].fifo ) );
    4cca:	86 8d       	ldd	r24, Z+30	; 0x1e
    4ccc:	97 8d       	ldd	r25, Z+31	; 0x1f
    4cce:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <Flush_FIFO>
    4cd2:	9c 01       	movw	r18, r24
    4cd4:	02 c0       	rjmp	.+4      	; 0x4cda <FlushSocketData+0x34>
    4cd6:	2f ef       	ldi	r18, 0xFF	; 255
    4cd8:	3f ef       	ldi	r19, 0xFF	; 255
	}
    4cda:	c9 01       	movw	r24, r18
    4cdc:	08 95       	ret

00004cde <GetBytesInSocketData>:
 * \param	Socket		Die Socketnummer die zum versnden benutzt werden soll.
 * \retval	Datalenght	Die Anzahl der kopierten Bytes.
 */
/*------------------------------------------------------------------------------------------------------------*/	
int GetBytesInSocketData( int Socket )
	{
    4cde:	9c 01       	movw	r18, r24
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS || TCP_sockettable[Socket].ConnectionState == SOCKET_NOT_USE ) return( SOCKET_ERROR );
    4ce0:	83 30       	cpi	r24, 0x03	; 3
    4ce2:	91 05       	cpc	r25, r1
    4ce4:	a0 f4       	brcc	.+40     	; 0x4d0e <GetBytesInSocketData+0x30>
    4ce6:	80 ea       	ldi	r24, 0xA0	; 160
    4ce8:	90 e0       	ldi	r25, 0x00	; 0
    4cea:	28 9f       	mul	r18, r24
    4cec:	f0 01       	movw	r30, r0
    4cee:	29 9f       	mul	r18, r25
    4cf0:	f0 0d       	add	r31, r0
    4cf2:	38 9f       	mul	r19, r24
    4cf4:	f0 0d       	add	r31, r0
    4cf6:	11 24       	eor	r1, r1
    4cf8:	e7 5f       	subi	r30, 0xF7	; 247
    4cfa:	f7 4f       	sbci	r31, 0xF7	; 247
    4cfc:	80 81       	ld	r24, Z
    4cfe:	88 23       	and	r24, r24
    4d00:	31 f0       	breq	.+12     	; 0x4d0e <GetBytesInSocketData+0x30>
		
		return( Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) );
    4d02:	86 8d       	ldd	r24, Z+30	; 0x1e
    4d04:	97 8d       	ldd	r25, Z+31	; 0x1f
    4d06:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    4d0a:	9c 01       	movw	r18, r24
    4d0c:	02 c0       	rjmp	.+4      	; 0x4d12 <GetBytesInSocketData+0x34>
    4d0e:	2f ef       	ldi	r18, 0xFF	; 255
    4d10:	3f ef       	ldi	r19, 0xFF	; 255
	}
    4d12:	c9 01       	movw	r24, r18
    4d14:	08 95       	ret

00004d16 <CopyTCPdata2socketbuffer>:
 * \param	ethernetbuffer		Zeiger auf den Speicher wo die Daten hin kopiert werden soll.
 * \retval	0
 */
/*------------------------------------------------------------------------------------------------------------*/	
int CopyTCPdata2socketbuffer( int Socket, unsigned int Datalenght , unsigned char *ethernetbuffer )
	{
    4d16:	af 92       	push	r10
    4d18:	bf 92       	push	r11
    4d1a:	cf 92       	push	r12
    4d1c:	df 92       	push	r13
    4d1e:	ff 92       	push	r15
    4d20:	0f 93       	push	r16
    4d22:	1f 93       	push	r17
    4d24:	cf 93       	push	r28
    4d26:	df 93       	push	r29
    4d28:	ec 01       	movw	r28, r24
    4d2a:	5b 01       	movw	r10, r22
    4d2c:	6a 01       	movw	r12, r20
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    4d2e:	fa 01       	movw	r30, r20
    4d30:	06 85       	ldd	r16, Z+14	; 0x0e
			
		// Abbrechen wenn die Datem nicht mehr in den buffer passen
		if ( ( Get_FIFOrestsize ( TCP_sockettable[ Socket ].fifo ) ) < Datalenght ) return( SOCKET_ERROR );
    4d32:	80 ea       	ldi	r24, 0xA0	; 160
    4d34:	90 e0       	ldi	r25, 0x00	; 0
    4d36:	c8 9f       	mul	r28, r24
    4d38:	f0 01       	movw	r30, r0
    4d3a:	c9 9f       	mul	r28, r25
    4d3c:	f0 0d       	add	r31, r0
    4d3e:	d8 9f       	mul	r29, r24
    4d40:	f0 0d       	add	r31, r0
    4d42:	11 24       	eor	r1, r1
    4d44:	e7 5f       	subi	r30, 0xF7	; 247
    4d46:	f7 4f       	sbci	r31, 0xF7	; 247
    4d48:	86 8d       	ldd	r24, Z+30	; 0x1e
    4d4a:	97 8d       	ldd	r25, Z+31	; 0x1f
    4d4c:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <Get_FIFOrestsize>
    4d50:	8a 15       	cp	r24, r10
    4d52:	9b 05       	cpc	r25, r11
    4d54:	18 f4       	brcc	.+6      	; 0x4d5c <CopyTCPdata2socketbuffer+0x46>
    4d56:	cf ef       	ldi	r28, 0xFF	; 255
    4d58:	df ef       	ldi	r29, 0xFF	; 255
    4d5a:	3b c0       	rjmp	.+118    	; 0x4dd2 <CopyTCPdata2socketbuffer+0xbc>
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    4d5c:	e0 2f       	mov	r30, r16
    4d5e:	f0 e0       	ldi	r31, 0x00	; 0
    4d60:	ef 70       	andi	r30, 0x0F	; 15
    4d62:	f0 70       	andi	r31, 0x00	; 0
    4d64:	ee 0f       	add	r30, r30
    4d66:	ff 1f       	adc	r31, r31
    4d68:	ee 0f       	add	r30, r30
    4d6a:	ff 1f       	adc	r31, r31
    4d6c:	3e 96       	adiw	r30, 0x0e	; 14
    4d6e:	ec 0d       	add	r30, r12
    4d70:	fd 1d       	adc	r31, r13
			
		// Abbrechen wenn die Datem nicht mehr in den buffer passen
		if ( ( Get_FIFOrestsize ( TCP_sockettable[ Socket ].fifo ) ) < Datalenght ) return( SOCKET_ERROR );
		
		Offset = ETHERNET_HEADER_LENGTH + ( IP_packet->IP_Version_Headerlen & 0x0f ) * 4 + ( ( TCP_packet->TCP_DataOffset & 0xf0 ) >> 2 ) ;
    4d72:	84 85       	ldd	r24, Z+12	; 0x0c
    4d74:	f6 01       	movw	r30, r12
    4d76:	06 85       	ldd	r16, Z+14	; 0x0e
    4d78:	10 e0       	ldi	r17, 0x00	; 0
    4d7a:	0f 70       	andi	r16, 0x0F	; 15
    4d7c:	10 70       	andi	r17, 0x00	; 0
    4d7e:	00 0f       	add	r16, r16
    4d80:	11 1f       	adc	r17, r17
    4d82:	00 0f       	add	r16, r16
    4d84:	11 1f       	adc	r17, r17
    4d86:	90 e0       	ldi	r25, 0x00	; 0
    4d88:	80 7f       	andi	r24, 0xF0	; 240
    4d8a:	90 70       	andi	r25, 0x00	; 0
    4d8c:	95 95       	asr	r25
    4d8e:	87 95       	ror	r24
    4d90:	95 95       	asr	r25
    4d92:	87 95       	ror	r24
    4d94:	08 0f       	add	r16, r24
    4d96:	19 1f       	adc	r17, r25
    4d98:	02 5f       	subi	r16, 0xF2	; 242
    4d9a:	1f 4f       	sbci	r17, 0xFF	; 255

		// gibt mal interrupts im interrupt frei auer den netzwerkinterrupt, da das kopieren der daten manchmal zu lange dauert und sonst
		// die Clock hinterher hinkt :-(
		LockEthernet();
    4d9c:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
   		sreg_tmp = SREG;    /* Sichern */
    4da0:	ff b6       	in	r15, 0x3f	; 63
		sei();
    4da2:	78 94       	sei
		Put_Block_in_FIFO ( TCP_sockettable[ Socket ].fifo, Datalenght, &ethernetbuffer[ Offset ] );
    4da4:	80 ea       	ldi	r24, 0xA0	; 160
    4da6:	90 e0       	ldi	r25, 0x00	; 0
    4da8:	c8 9f       	mul	r28, r24
    4daa:	f0 01       	movw	r30, r0
    4dac:	c9 9f       	mul	r28, r25
    4dae:	f0 0d       	add	r31, r0
    4db0:	d8 9f       	mul	r29, r24
    4db2:	f0 0d       	add	r31, r0
    4db4:	11 24       	eor	r1, r1
    4db6:	e7 5f       	subi	r30, 0xF7	; 247
    4db8:	f7 4f       	sbci	r31, 0xF7	; 247
    4dba:	86 8d       	ldd	r24, Z+30	; 0x1e
    4dbc:	97 8d       	ldd	r25, Z+31	; 0x1f
    4dbe:	e5 01       	movw	r28, r10
    4dc0:	0c 0d       	add	r16, r12
    4dc2:	1d 1d       	adc	r17, r13
    4dc4:	b5 01       	movw	r22, r10
    4dc6:	a8 01       	movw	r20, r16
    4dc8:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <Put_Block_in_FIFO>
		SREG = sreg_tmp;
    4dcc:	ff be       	out	0x3f, r15	; 63
		FreeEthernet();
    4dce:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

		return( Datalenght );
	}		
    4dd2:	ce 01       	movw	r24, r28
    4dd4:	df 91       	pop	r29
    4dd6:	cf 91       	pop	r28
    4dd8:	1f 91       	pop	r17
    4dda:	0f 91       	pop	r16
    4ddc:	ff 90       	pop	r15
    4dde:	df 90       	pop	r13
    4de0:	cf 90       	pop	r12
    4de2:	bf 90       	pop	r11
    4de4:	af 90       	pop	r10
    4de6:	08 95       	ret

00004de8 <RegisterSocket>:
 * \param	ethernetbuffer	Zeiger auf den Ethernetpuffer.
 * \retval	Socket			Im Erfolgsfall die Socketnummer, im Fehlerfall 0xffff
 */
/*------------------------------------------------------------------------------------------------------------*/
 int RegisterSocket( unsigned char *ethernetbuffer)
	{
    4de8:	a0 e0       	ldi	r26, 0x00	; 0
    4dea:	b0 e0       	ldi	r27, 0x00	; 0
    4dec:	ea ef       	ldi	r30, 0xFA	; 250
    4dee:	f6 e2       	ldi	r31, 0x26	; 38
    4df0:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    4df4:	ec 01       	movw	r28, r24
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    4df6:	dc 01       	movw	r26, r24
    4df8:	1e 96       	adiw	r26, 0x0e	; 14
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    4dfa:	ee 84       	ldd	r14, Y+14	; 0x0e
int Getfreesocket( void )
	{
		int Socket;
		for ( Socket = 0 ; Socket < MAX_TCP_CONNECTIONS ; Socket++ )
			{
				if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_NOT_USE && TCP_sockettable[ Socket ].Timeoutcounter == 0 ) return( Socket );
    4dfc:	80 91 09 08 	lds	r24, 0x0809
    4e00:	88 23       	and	r24, r24
    4e02:	59 f4       	brne	.+22     	; 0x4e1a <RegisterSocket+0x32>
    4e04:	80 91 1f 08 	lds	r24, 0x081F
    4e08:	90 91 20 08 	lds	r25, 0x0820
    4e0c:	89 2b       	or	r24, r25
    4e0e:	29 f4       	brne	.+10     	; 0x4e1a <RegisterSocket+0x32>
    4e10:	60 e0       	ldi	r22, 0x00	; 0
    4e12:	70 e0       	ldi	r23, 0x00	; 0
    4e14:	cc 24       	eor	r12, r12
    4e16:	dd 24       	eor	r13, r13
    4e18:	21 c0       	rjmp	.+66     	; 0x4e5c <RegisterSocket+0x74>
    4e1a:	80 91 a9 08 	lds	r24, 0x08A9
    4e1e:	88 23       	and	r24, r24
    4e20:	61 f4       	brne	.+24     	; 0x4e3a <RegisterSocket+0x52>
    4e22:	80 91 bf 08 	lds	r24, 0x08BF
    4e26:	90 91 c0 08 	lds	r25, 0x08C0
    4e2a:	89 2b       	or	r24, r25
    4e2c:	31 f4       	brne	.+12     	; 0x4e3a <RegisterSocket+0x52>
    4e2e:	61 e0       	ldi	r22, 0x01	; 1
    4e30:	70 e0       	ldi	r23, 0x00	; 0
    4e32:	91 e0       	ldi	r25, 0x01	; 1
    4e34:	c9 2e       	mov	r12, r25
    4e36:	d1 2c       	mov	r13, r1
    4e38:	11 c0       	rjmp	.+34     	; 0x4e5c <RegisterSocket+0x74>
    4e3a:	80 91 49 09 	lds	r24, 0x0949
    4e3e:	88 23       	and	r24, r24
    4e40:	09 f0       	breq	.+2      	; 0x4e44 <RegisterSocket+0x5c>
    4e42:	90 c0       	rjmp	.+288    	; 0x4f64 <RegisterSocket+0x17c>
    4e44:	80 91 5f 09 	lds	r24, 0x095F
    4e48:	90 91 60 09 	lds	r25, 0x0960
    4e4c:	89 2b       	or	r24, r25
    4e4e:	09 f0       	breq	.+2      	; 0x4e52 <RegisterSocket+0x6a>
    4e50:	89 c0       	rjmp	.+274    	; 0x4f64 <RegisterSocket+0x17c>
    4e52:	62 e0       	ldi	r22, 0x02	; 2
    4e54:	70 e0       	ldi	r23, 0x00	; 0
    4e56:	82 e0       	ldi	r24, 0x02	; 2
    4e58:	c8 2e       	mov	r12, r24
    4e5a:	d1 2c       	mov	r13, r1
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    4e5c:	ff 24       	eor	r15, r15
    4e5e:	8f e0       	ldi	r24, 0x0F	; 15
    4e60:	e8 22       	and	r14, r24
    4e62:	ff 24       	eor	r15, r15
    4e64:	ee 0c       	add	r14, r14
    4e66:	ff 1c       	adc	r15, r15
    4e68:	ee 0c       	add	r14, r14
    4e6a:	ff 1c       	adc	r15, r15
    4e6c:	ee e0       	ldi	r30, 0x0E	; 14
    4e6e:	f0 e0       	ldi	r31, 0x00	; 0
    4e70:	ee 0e       	add	r14, r30
    4e72:	ff 1e       	adc	r15, r31
    4e74:	ec 0e       	add	r14, r28
    4e76:	fd 1e       	adc	r15, r29
		
		Socket = Getfreesocket();
		if ( Socket == SOCKET_ERROR ) return( SOCKET_ERROR );
		
		// Registert das SOCKET
		TCP_sockettable[ Socket ].SourcePort = TCP_packet->TCP_SourcePort;
    4e78:	f7 01       	movw	r30, r14
    4e7a:	20 81       	ld	r18, Z
    4e7c:	31 81       	ldd	r19, Z+1	; 0x01
    4e7e:	80 e5       	ldi	r24, 0x50	; 80
    4e80:	90 e0       	ldi	r25, 0x00	; 0
    4e82:	68 9f       	mul	r22, r24
    4e84:	f0 01       	movw	r30, r0
    4e86:	69 9f       	mul	r22, r25
    4e88:	f0 0d       	add	r31, r0
    4e8a:	78 9f       	mul	r23, r24
    4e8c:	f0 0d       	add	r31, r0
    4e8e:	11 24       	eor	r1, r1
    4e90:	ee 0f       	add	r30, r30
    4e92:	ff 1f       	adc	r31, r31
    4e94:	e5 5f       	subi	r30, 0xF5	; 245
    4e96:	f7 4f       	sbci	r31, 0xF7	; 247
    4e98:	31 83       	std	Z+1, r19	; 0x01
    4e9a:	20 83       	st	Z, r18
		TCP_sockettable[ Socket ].DestinationPort = TCP_packet->TCP_DestinationPort;
    4e9c:	f7 01       	movw	r30, r14
    4e9e:	22 81       	ldd	r18, Z+2	; 0x02
    4ea0:	33 81       	ldd	r19, Z+3	; 0x03
    4ea2:	88 e2       	ldi	r24, 0x28	; 40
    4ea4:	90 e0       	ldi	r25, 0x00	; 0
    4ea6:	68 9f       	mul	r22, r24
    4ea8:	f0 01       	movw	r30, r0
    4eaa:	69 9f       	mul	r22, r25
    4eac:	f0 0d       	add	r31, r0
    4eae:	78 9f       	mul	r23, r24
    4eb0:	f0 0d       	add	r31, r0
    4eb2:	11 24       	eor	r1, r1
    4eb4:	ee 0f       	add	r30, r30
    4eb6:	ff 1f       	adc	r31, r31
    4eb8:	ee 0f       	add	r30, r30
    4eba:	ff 1f       	adc	r31, r31
    4ebc:	e3 5f       	subi	r30, 0xF3	; 243
    4ebe:	f7 4f       	sbci	r31, 0xF7	; 247
    4ec0:	31 83       	std	Z+1, r19	; 0x01
    4ec2:	20 83       	st	Z, r18
		TCP_sockettable[ Socket ].SourceIP = IP_packet->IP_SourceIP;
    4ec4:	1c 96       	adiw	r26, 0x0c	; 12
    4ec6:	2d 91       	ld	r18, X+
    4ec8:	3d 91       	ld	r19, X+
    4eca:	4d 91       	ld	r20, X+
    4ecc:	5c 91       	ld	r21, X
    4ece:	1f 97       	sbiw	r26, 0x0f	; 15
    4ed0:	80 ea       	ldi	r24, 0xA0	; 160
    4ed2:	90 e0       	ldi	r25, 0x00	; 0
    4ed4:	68 9f       	mul	r22, r24
    4ed6:	80 01       	movw	r16, r0
    4ed8:	69 9f       	mul	r22, r25
    4eda:	10 0d       	add	r17, r0
    4edc:	78 9f       	mul	r23, r24
    4ede:	10 0d       	add	r17, r0
    4ee0:	11 24       	eor	r1, r1
    4ee2:	07 5f       	subi	r16, 0xF7	; 247
    4ee4:	17 4f       	sbci	r17, 0xF7	; 247
    4ee6:	f8 01       	movw	r30, r16
    4ee8:	26 83       	std	Z+6, r18	; 0x06
    4eea:	37 83       	std	Z+7, r19	; 0x07
    4eec:	40 87       	std	Z+8, r20	; 0x08
    4eee:	51 87       	std	Z+9, r21	; 0x09
		TCP_sockettable[ Socket ].SequenceNumber =~ ChangeEndian32bit( TCP_packet->TCP_SequenceNumber );
    4ef0:	f7 01       	movw	r30, r14
    4ef2:	64 81       	ldd	r22, Z+4	; 0x04
    4ef4:	75 81       	ldd	r23, Z+5	; 0x05
    4ef6:	86 81       	ldd	r24, Z+6	; 0x06
    4ef8:	97 81       	ldd	r25, Z+7	; 0x07
    4efa:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    4efe:	60 95       	com	r22
    4f00:	70 95       	com	r23
    4f02:	80 95       	com	r24
    4f04:	90 95       	com	r25
    4f06:	f8 01       	movw	r30, r16
    4f08:	62 87       	std	Z+10, r22	; 0x0a
    4f0a:	73 87       	std	Z+11, r23	; 0x0b
    4f0c:	84 87       	std	Z+12, r24	; 0x0c
    4f0e:	95 87       	std	Z+13, r25	; 0x0d
		TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit( TCP_packet->TCP_SequenceNumber );
    4f10:	f7 01       	movw	r30, r14
    4f12:	64 81       	ldd	r22, Z+4	; 0x04
    4f14:	75 81       	ldd	r23, Z+5	; 0x05
    4f16:	86 81       	ldd	r24, Z+6	; 0x06
    4f18:	97 81       	ldd	r25, Z+7	; 0x07
    4f1a:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    4f1e:	f8 01       	movw	r30, r16
    4f20:	66 87       	std	Z+14, r22	; 0x0e
    4f22:	77 87       	std	Z+15, r23	; 0x0f
    4f24:	80 8b       	std	Z+16, r24	; 0x10
    4f26:	91 8b       	std	Z+17, r25	; 0x11
		TCP_sockettable[ Socket ].SendState = SOCKET_READY2SEND;
    4f28:	11 82       	std	Z+1, r1	; 0x01
		TCP_sockettable[ Socket ].Timeoutcounter = 10;
    4f2a:	8a e0       	ldi	r24, 0x0A	; 10
    4f2c:	90 e0       	ldi	r25, 0x00	; 0
    4f2e:	97 8b       	std	Z+23, r25	; 0x17
    4f30:	86 8b       	std	Z+22, r24	; 0x16
		Flush_FIFO ( TCP_sockettable[ Socket ].fifo );
    4f32:	86 8d       	ldd	r24, Z+30	; 0x1e
    4f34:	97 8d       	ldd	r25, Z+31	; 0x1f
    4f36:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <Flush_FIFO>
		TCP_sockettable[ Socket ].Windowsize = TCP_packet->TCP_Window ;
    4f3a:	f7 01       	movw	r30, r14
    4f3c:	86 85       	ldd	r24, Z+14	; 0x0e
    4f3e:	97 85       	ldd	r25, Z+15	; 0x0f
    4f40:	f8 01       	movw	r30, r16
    4f42:	93 8b       	std	Z+19, r25	; 0x13
    4f44:	82 8b       	std	Z+18, r24	; 0x12
		TCP_sockettable[ Socket ].SendetBytes = 0;
    4f46:	15 8a       	std	Z+21, r1	; 0x15
    4f48:	14 8a       	std	Z+20, r1	; 0x14
		
		for ( int i = 0 ; i < 6 ; i++ ) TCP_sockettable[ Socket ].MACadress[i] = ETH_packet->ETH_sourceMac[i];
    4f4a:	8e 81       	ldd	r24, Y+6	; 0x06
    4f4c:	80 8f       	std	Z+24, r24	; 0x18
    4f4e:	8f 81       	ldd	r24, Y+7	; 0x07
    4f50:	81 8f       	std	Z+25, r24	; 0x19
    4f52:	88 85       	ldd	r24, Y+8	; 0x08
    4f54:	82 8f       	std	Z+26, r24	; 0x1a
    4f56:	89 85       	ldd	r24, Y+9	; 0x09
    4f58:	83 8f       	std	Z+27, r24	; 0x1b
    4f5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f5c:	84 8f       	std	Z+28, r24	; 0x1c
    4f5e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4f60:	85 8f       	std	Z+29, r24	; 0x1d
    4f62:	03 c0       	rjmp	.+6      	; 0x4f6a <RegisterSocket+0x182>
    4f64:	cc 24       	eor	r12, r12
    4f66:	ca 94       	dec	r12
    4f68:	dc 2c       	mov	r13, r12
		
		return( Socket );
	}
    4f6a:	c6 01       	movw	r24, r12
    4f6c:	cd b7       	in	r28, 0x3d	; 61
    4f6e:	de b7       	in	r29, 0x3e	; 62
    4f70:	e8 e0       	ldi	r30, 0x08	; 8
    4f72:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

00004f76 <MakeTCPheader>:
 * \param	ethernetbuffer	Zeiger auf den Ethernetpuffer.
 * \retval	void
 */
/*------------------------------------------------------------------------------------------------------------*/
void MakeTCPheader( int Socket, unsigned char TCP_flags, unsigned int Datalenght, unsigned int Windowsize, unsigned char * ethernetbuffer )
	{
    4f76:	2f 92       	push	r2
    4f78:	3f 92       	push	r3
    4f7a:	4f 92       	push	r4
    4f7c:	5f 92       	push	r5
    4f7e:	6f 92       	push	r6
    4f80:	7f 92       	push	r7
    4f82:	8f 92       	push	r8
    4f84:	9f 92       	push	r9
    4f86:	bf 92       	push	r11
    4f88:	cf 92       	push	r12
    4f8a:	df 92       	push	r13
    4f8c:	ef 92       	push	r14
    4f8e:	ff 92       	push	r15
    4f90:	0f 93       	push	r16
    4f92:	1f 93       	push	r17
    4f94:	cf 93       	push	r28
    4f96:	df 93       	push	r29
    4f98:	2c 01       	movw	r4, r24
    4f9a:	b6 2e       	mov	r11, r22
    4f9c:	3a 01       	movw	r6, r20
    4f9e:	69 01       	movw	r12, r18
    4fa0:	48 01       	movw	r8, r16
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT ];
    4fa2:	e8 01       	movw	r28, r16
    4fa4:	a2 96       	adiw	r28, 0x22	; 34

		struct IP_Pseudoheader *IP_pseudopacket;
		IP_pseudopacket = ( struct IP_Pseudoheader *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT - IP_PSEUDOHEADER_LENGHT ];
    4fa6:	0a 5e       	subi	r16, 0xEA	; 234
    4fa8:	1f 4f       	sbci	r17, 0xFF	; 255

		// Bastel mal den Pseudoheader
		IP_pseudopacket->IP_SourceIP = TCP_sockettable[ Socket ].SourceIP;
    4faa:	80 ea       	ldi	r24, 0xA0	; 160
    4fac:	90 e0       	ldi	r25, 0x00	; 0
    4fae:	48 9e       	mul	r4, r24
    4fb0:	70 01       	movw	r14, r0
    4fb2:	49 9e       	mul	r4, r25
    4fb4:	f0 0c       	add	r15, r0
    4fb6:	58 9e       	mul	r5, r24
    4fb8:	f0 0c       	add	r15, r0
    4fba:	11 24       	eor	r1, r1
    4fbc:	89 e0       	ldi	r24, 0x09	; 9
    4fbe:	98 e0       	ldi	r25, 0x08	; 8
    4fc0:	e8 0e       	add	r14, r24
    4fc2:	f9 1e       	adc	r15, r25
    4fc4:	f7 01       	movw	r30, r14
    4fc6:	86 81       	ldd	r24, Z+6	; 0x06
    4fc8:	97 81       	ldd	r25, Z+7	; 0x07
    4fca:	a0 85       	ldd	r26, Z+8	; 0x08
    4fcc:	b1 85       	ldd	r27, Z+9	; 0x09
    4fce:	f4 01       	movw	r30, r8
    4fd0:	86 8b       	std	Z+22, r24	; 0x16
    4fd2:	97 8b       	std	Z+23, r25	; 0x17
    4fd4:	a0 8f       	std	Z+24, r26	; 0x18
    4fd6:	b1 8f       	std	Z+25, r27	; 0x19
		IP_pseudopacket->IP_DestinationIP = myIP;
    4fd8:	80 91 41 01 	lds	r24, 0x0141
    4fdc:	90 91 42 01 	lds	r25, 0x0142
    4fe0:	a0 91 43 01 	lds	r26, 0x0143
    4fe4:	b0 91 44 01 	lds	r27, 0x0144
    4fe8:	f8 01       	movw	r30, r16
    4fea:	84 83       	std	Z+4, r24	; 0x04
    4fec:	95 83       	std	Z+5, r25	; 0x05
    4fee:	a6 83       	std	Z+6, r26	; 0x06
    4ff0:	b7 83       	std	Z+7, r27	; 0x07
		IP_pseudopacket->IP_ZERO = 0x0;
    4ff2:	10 86       	std	Z+8, r1	; 0x08
		IP_pseudopacket->IP_Protokoll = 0x6;
    4ff4:	86 e0       	ldi	r24, 0x06	; 6
    4ff6:	81 87       	std	Z+9, r24	; 0x09
		IP_pseudopacket->IP_TCP_lenght = ChangeEndian16bit( TCP_HEADER_LENGHT + Datalenght );										
    4ff8:	40 e2       	ldi	r20, 0x20	; 32
    4ffa:	24 2e       	mov	r2, r20
    4ffc:	31 2c       	mov	r3, r1
    4ffe:	26 0c       	add	r2, r6
    5000:	37 1c       	adc	r3, r7
    5002:	c1 01       	movw	r24, r2
    5004:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    5008:	f8 01       	movw	r30, r16
    500a:	93 87       	std	Z+11, r25	; 0x0b
    500c:	82 87       	std	Z+10, r24	; 0x0a
			
		// TCP_header basteln
		TCP_packet->TCP_SourcePort = TCP_sockettable[ Socket ].DestinationPort;
    500e:	88 e2       	ldi	r24, 0x28	; 40
    5010:	90 e0       	ldi	r25, 0x00	; 0
    5012:	48 9e       	mul	r4, r24
    5014:	f0 01       	movw	r30, r0
    5016:	49 9e       	mul	r4, r25
    5018:	f0 0d       	add	r31, r0
    501a:	58 9e       	mul	r5, r24
    501c:	f0 0d       	add	r31, r0
    501e:	11 24       	eor	r1, r1
    5020:	ee 0f       	add	r30, r30
    5022:	ff 1f       	adc	r31, r31
    5024:	ee 0f       	add	r30, r30
    5026:	ff 1f       	adc	r31, r31
    5028:	e3 5f       	subi	r30, 0xF3	; 243
    502a:	f7 4f       	sbci	r31, 0xF7	; 247
    502c:	80 81       	ld	r24, Z
    502e:	91 81       	ldd	r25, Z+1	; 0x01
    5030:	f4 01       	movw	r30, r8
    5032:	93 a3       	std	Z+35, r25	; 0x23
    5034:	82 a3       	std	Z+34, r24	; 0x22
		TCP_packet->TCP_DestinationPort = TCP_sockettable[ Socket ].SourcePort;
    5036:	80 e5       	ldi	r24, 0x50	; 80
    5038:	90 e0       	ldi	r25, 0x00	; 0
    503a:	48 9e       	mul	r4, r24
    503c:	f0 01       	movw	r30, r0
    503e:	49 9e       	mul	r4, r25
    5040:	f0 0d       	add	r31, r0
    5042:	58 9e       	mul	r5, r24
    5044:	f0 0d       	add	r31, r0
    5046:	11 24       	eor	r1, r1
    5048:	ee 0f       	add	r30, r30
    504a:	ff 1f       	adc	r31, r31
    504c:	e5 5f       	subi	r30, 0xF5	; 245
    504e:	f7 4f       	sbci	r31, 0xF7	; 247
    5050:	80 81       	ld	r24, Z
    5052:	91 81       	ldd	r25, Z+1	; 0x01
    5054:	9b 83       	std	Y+3, r25	; 0x03
    5056:	8a 83       	std	Y+2, r24	; 0x02
		TCP_packet->TCP_SequenceNumber = ChangeEndian32bit( TCP_sockettable[ Socket ].SequenceNumber );
    5058:	f7 01       	movw	r30, r14
    505a:	62 85       	ldd	r22, Z+10	; 0x0a
    505c:	73 85       	ldd	r23, Z+11	; 0x0b
    505e:	84 85       	ldd	r24, Z+12	; 0x0c
    5060:	95 85       	ldd	r25, Z+13	; 0x0d
    5062:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5066:	6c 83       	std	Y+4, r22	; 0x04
    5068:	7d 83       	std	Y+5, r23	; 0x05
    506a:	8e 83       	std	Y+6, r24	; 0x06
    506c:	9f 83       	std	Y+7, r25	; 0x07
		TCP_packet->TCP_AcknowledgeNumber = ChangeEndian32bit( TCP_sockettable[ Socket ].AcknowledgeNumber );
    506e:	f7 01       	movw	r30, r14
    5070:	66 85       	ldd	r22, Z+14	; 0x0e
    5072:	77 85       	ldd	r23, Z+15	; 0x0f
    5074:	80 89       	ldd	r24, Z+16	; 0x10
    5076:	91 89       	ldd	r25, Z+17	; 0x11
    5078:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    507c:	68 87       	std	Y+8, r22	; 0x08
    507e:	79 87       	std	Y+9, r23	; 0x09
    5080:	8a 87       	std	Y+10, r24	; 0x0a
    5082:	9b 87       	std	Y+11, r25	; 0x0b
		TCP_packet->TCP_DataOffset = ( ( TCP_HEADER_LENGHT << 2 ) & 0xf0 ) ;
    5084:	80 e8       	ldi	r24, 0x80	; 128
    5086:	8c 87       	std	Y+12, r24	; 0x0c
		TCP_packet->TCP_ControllFlags = TCP_flags ;
    5088:	bd 86       	std	Y+13, r11	; 0x0d
		TCP_packet->TCP_Window = ChangeEndian16bit( Windowsize );
    508a:	c6 01       	movw	r24, r12
    508c:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    5090:	9f 87       	std	Y+15, r25	; 0x0f
    5092:	8e 87       	std	Y+14, r24	; 0x0e
		TCP_packet->TCP_Checksum = 0x0;
    5094:	19 8a       	std	Y+17, r1	; 0x11
    5096:	18 8a       	std	Y+16, r1	; 0x10
		TCP_packet->TCP_UrgentPointer = 0x0;
    5098:	1b 8a       	std	Y+19, r1	; 0x13
    509a:	1a 8a       	std	Y+18, r1	; 0x12
		
		if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_SYNINIT )
    509c:	f7 01       	movw	r30, r14
    509e:	80 81       	ld	r24, Z
    50a0:	81 30       	cpi	r24, 0x01	; 1
    50a2:	69 f4       	brne	.+26     	; 0x50be <MakeTCPheader+0x148>
		{
			// beschreibe das Optionfeld mit MSS = MAX_TCP_Datalenght wenn der SYN ausgehandelt wird
			TCP_packet->TCP_Options[0] = 0x02;
    50a4:	82 e0       	ldi	r24, 0x02	; 2
    50a6:	8c 8b       	std	Y+20, r24	; 0x14
			TCP_packet->TCP_Options[1] = 0x04;
    50a8:	84 e0       	ldi	r24, 0x04	; 4
    50aa:	8d 8b       	std	Y+21, r24	; 0x15
			TCP_packet->TCP_Options[2] = ( MAX_TCP_Datalenght >> 8 ) & 0x00ff ;
    50ac:	1e 8a       	std	Y+22, r1	; 0x16
			TCP_packet->TCP_Options[3] = MAX_TCP_Datalenght & 0x00ff ;
    50ae:	80 e4       	ldi	r24, 0x40	; 64
    50b0:	8f 8b       	std	Y+23, r24	; 0x17
			TCP_packet->TCP_Options[4] = 0;
    50b2:	18 8e       	std	Y+24, r1	; 0x18
			TCP_packet->TCP_Options[5] = 0;
    50b4:	19 8e       	std	Y+25, r1	; 0x19
			TCP_packet->TCP_Options[6] = 0;
    50b6:	1a 8e       	std	Y+26, r1	; 0x1a
			TCP_packet->TCP_Options[7] = 0;
    50b8:	1b 8e       	std	Y+27, r1	; 0x1b
			TCP_packet->TCP_Options[8] = 0;
    50ba:	1c 8e       	std	Y+28, r1	; 0x1c
    50bc:	10 c0       	rjmp	.+32     	; 0x50de <MakeTCPheader+0x168>
		}
		else
		{
			// lasse Optionfeld leer wenn kein SYN
			TCP_packet->TCP_Options[0] = 0;
    50be:	1c 8a       	std	Y+20, r1	; 0x14
			TCP_packet->TCP_Options[1] = 'H';
    50c0:	88 e4       	ldi	r24, 0x48	; 72
    50c2:	8d 8b       	std	Y+21, r24	; 0x15
			TCP_packet->TCP_Options[2] = 'u';
    50c4:	85 e7       	ldi	r24, 0x75	; 117
    50c6:	8e 8b       	std	Y+22, r24	; 0x16
			TCP_packet->TCP_Options[3] = 'r';
    50c8:	82 e7       	ldi	r24, 0x72	; 114
    50ca:	8f 8b       	std	Y+23, r24	; 0x17
			TCP_packet->TCP_Options[4] = 'r';
    50cc:	88 8f       	std	Y+24, r24	; 0x18
			TCP_packet->TCP_Options[5] = 'i';
    50ce:	89 e6       	ldi	r24, 0x69	; 105
    50d0:	89 8f       	std	Y+25, r24	; 0x19
			TCP_packet->TCP_Options[6] = 'c';
    50d2:	83 e6       	ldi	r24, 0x63	; 99
    50d4:	8a 8f       	std	Y+26, r24	; 0x1a
			TCP_packet->TCP_Options[7] = 'a';
    50d6:	81 e6       	ldi	r24, 0x61	; 97
    50d8:	8b 8f       	std	Y+27, r24	; 0x1b
			TCP_packet->TCP_Options[8] = 'n';
    50da:	8e e6       	ldi	r24, 0x6E	; 110
    50dc:	8c 8f       	std	Y+28, r24	; 0x1c
		}
			
		TCP_packet->TCP_Checksum = ChangeEndian16bit( Checksum_16( 	&ethernetbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT - IP_PSEUDOHEADER_LENGHT ],
    50de:	8c e2       	ldi	r24, 0x2C	; 44
    50e0:	90 e0       	ldi	r25, 0x00	; 0
    50e2:	68 0e       	add	r6, r24
    50e4:	79 1e       	adc	r7, r25
    50e6:	c4 01       	movw	r24, r8
    50e8:	46 96       	adiw	r24, 0x16	; 22
    50ea:	b3 01       	movw	r22, r6
    50ec:	0e 94 dd 37 	call	0x6fba	; 0x6fba <Checksum_16>
    50f0:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    50f4:	99 8b       	std	Y+17, r25	; 0x11
    50f6:	88 8b       	std	Y+16, r24	; 0x10
																	TCP_HEADER_LENGHT + IP_PSEUDOHEADER_LENGHT  + Datalenght ) ) ;
		MakeIPheader( TCP_sockettable[ Socket ].SourceIP, PROTO_TCP, TCP_HEADER_LENGHT + Datalenght , ethernetbuffer );
    50f8:	80 ea       	ldi	r24, 0xA0	; 160
    50fa:	90 e0       	ldi	r25, 0x00	; 0
    50fc:	48 9e       	mul	r4, r24
    50fe:	70 01       	movw	r14, r0
    5100:	49 9e       	mul	r4, r25
    5102:	f0 0c       	add	r15, r0
    5104:	58 9e       	mul	r5, r24
    5106:	f0 0c       	add	r15, r0
    5108:	11 24       	eor	r1, r1
    510a:	f7 01       	movw	r30, r14
    510c:	e7 5f       	subi	r30, 0xF7	; 247
    510e:	f7 4f       	sbci	r31, 0xF7	; 247
    5110:	66 81       	ldd	r22, Z+6	; 0x06
    5112:	77 81       	ldd	r23, Z+7	; 0x07
    5114:	80 85       	ldd	r24, Z+8	; 0x08
    5116:	91 85       	ldd	r25, Z+9	; 0x09
    5118:	46 e0       	ldi	r20, 0x06	; 6
    511a:	91 01       	movw	r18, r2
    511c:	84 01       	movw	r16, r8
    511e:	0e 94 8b 33 	call	0x6716	; 0x6716 <MakeIPheader>
		MakeETHheader( TCP_sockettable[ Socket ].MACadress, ethernetbuffer );
    5122:	c7 01       	movw	r24, r14
    5124:	8f 5d       	subi	r24, 0xDF	; 223
    5126:	97 4f       	sbci	r25, 0xF7	; 247
    5128:	b4 01       	movw	r22, r8
    512a:	0e 94 26 30 	call	0x604c	; 0x604c <MakeETHheader>
		sendEthernetframe( ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT + Datalenght, ethernetbuffer );
    512e:	c3 01       	movw	r24, r6
    5130:	46 96       	adiw	r24, 0x16	; 22
    5132:	b4 01       	movw	r22, r8
    5134:	0e 94 4d 30 	call	0x609a	; 0x609a <sendEthernetframe>
		
		return;
	}
    5138:	df 91       	pop	r29
    513a:	cf 91       	pop	r28
    513c:	1f 91       	pop	r17
    513e:	0f 91       	pop	r16
    5140:	ff 90       	pop	r15
    5142:	ef 90       	pop	r14
    5144:	df 90       	pop	r13
    5146:	cf 90       	pop	r12
    5148:	bf 90       	pop	r11
    514a:	9f 90       	pop	r9
    514c:	8f 90       	pop	r8
    514e:	7f 90       	pop	r7
    5150:	6f 90       	pop	r6
    5152:	5f 90       	pop	r5
    5154:	4f 90       	pop	r4
    5156:	3f 90       	pop	r3
    5158:	2f 90       	pop	r2
    515a:	08 95       	ret

0000515c <GetByteFromSocketData>:
 * \param	Socket		Die Socketnummer die zum versnden benutzt werden soll.
 * \retval	char		Die Anzahl der kopierten Bytes.
 */
/*------------------------------------------------------------------------------------------------------------*/	
char GetByteFromSocketData( int Socket )
	{
    515c:	a2 e4       	ldi	r26, 0x42	; 66
    515e:	b0 e0       	ldi	r27, 0x00	; 0
    5160:	e4 eb       	ldi	r30, 0xB4	; 180
    5162:	f8 e2       	ldi	r31, 0x28	; 40
    5164:	0c 94 c4 6a 	jmp	0xd588	; 0xd588 <__prologue_saves__+0x16>
    5168:	7c 01       	movw	r14, r24
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS || TCP_sockettable[Socket].ConnectionState == SOCKET_NOT_USE) return( 0 );
    516a:	83 e0       	ldi	r24, 0x03	; 3
    516c:	e8 16       	cp	r14, r24
    516e:	f1 04       	cpc	r15, r1
    5170:	c8 f5       	brcc	.+114    	; 0x51e4 <GetByteFromSocketData+0x88>
    5172:	80 ea       	ldi	r24, 0xA0	; 160
    5174:	90 e0       	ldi	r25, 0x00	; 0
    5176:	e8 9e       	mul	r14, r24
    5178:	80 01       	movw	r16, r0
    517a:	e9 9e       	mul	r14, r25
    517c:	10 0d       	add	r17, r0
    517e:	f8 9e       	mul	r15, r24
    5180:	10 0d       	add	r17, r0
    5182:	11 24       	eor	r1, r1
    5184:	07 5f       	subi	r16, 0xF7	; 247
    5186:	17 4f       	sbci	r17, 0xF7	; 247
    5188:	f8 01       	movw	r30, r16
    518a:	80 81       	ld	r24, Z
    518c:	88 23       	and	r24, r24
    518e:	51 f1       	breq	.+84     	; 0x51e4 <GetByteFromSocketData+0x88>
		if ( Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) == 0 ) return ( 0 );
    5190:	86 8d       	ldd	r24, Z+30	; 0x1e
    5192:	97 8d       	ldd	r25, Z+31	; 0x1f
    5194:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5198:	89 2b       	or	r24, r25
    519a:	21 f1       	breq	.+72     	; 0x51e4 <GetByteFromSocketData+0x88>
		
		char Data;
		
		LockEthernet();
    519c:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
		
		Data = Get_Byte_from_FIFO ( TCP_sockettable[ Socket ].fifo );
    51a0:	f8 01       	movw	r30, r16
    51a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    51a4:	97 8d       	ldd	r25, Z+31	; 0x1f
    51a6:	0e 94 fb 3d 	call	0x7bf6	; 0x7bf6 <Get_Byte_from_FIFO>
    51aa:	d8 2e       	mov	r13, r24

		// Sendet ein Update wenn Buffer leer
		if ( Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) == 0 )
    51ac:	f8 01       	movw	r30, r16
    51ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    51b0:	97 8d       	ldd	r25, Z+31	; 0x1f
    51b2:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    51b6:	89 2b       	or	r24, r25
    51b8:	91 f4       	brne	.+36     	; 0x51de <GetByteFromSocketData+0x82>
			unsigned char ackbuffer[ ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ];

			struct TCP_header *TCP_packet;		// TCP_struct anlegen
			TCP_packet = ( struct TCP_header *)&ackbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT ];							

			MakeTCPheader( Socket, TCP_ACK_FLAG , 0 , MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) , ackbuffer );
    51ba:	f8 01       	movw	r30, r16
    51bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    51be:	97 8d       	ldd	r25, Z+31	; 0x1f
    51c0:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    51c4:	20 e8       	ldi	r18, 0x80	; 128
    51c6:	30 e0       	ldi	r19, 0x00	; 0
    51c8:	28 1b       	sub	r18, r24
    51ca:	39 0b       	sbc	r19, r25
    51cc:	c7 01       	movw	r24, r14
    51ce:	60 e1       	ldi	r22, 0x10	; 16
    51d0:	40 e0       	ldi	r20, 0x00	; 0
    51d2:	50 e0       	ldi	r21, 0x00	; 0
    51d4:	8e 01       	movw	r16, r28
    51d6:	0f 5f       	subi	r16, 0xFF	; 255
    51d8:	1f 4f       	sbci	r17, 0xFF	; 255
    51da:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
		}
		
		FreeEthernet();
    51de:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
    51e2:	01 c0       	rjmp	.+2      	; 0x51e6 <GetByteFromSocketData+0x8a>

		return( Data );
    51e4:	dd 24       	eor	r13, r13
	}
    51e6:	8d 2d       	mov	r24, r13
    51e8:	ce 5b       	subi	r28, 0xBE	; 190
    51ea:	df 4f       	sbci	r29, 0xFF	; 255
    51ec:	e7 e0       	ldi	r30, 0x07	; 7
    51ee:	0c 94 e0 6a 	jmp	0xd5c0	; 0xd5c0 <__epilogue_restores__+0x16>

000051f2 <SendData_RPE>:
 * \param	RetransmissionCounter		Anzahl der bereits erfolgten Retransmissions.
 * \return	Datalenght	Anzahl der gesendet Bytes.
 */
/*------------------------------------------------------------------------------------------------------------*/	
int SendData_RPE( int Socket, unsigned int Datalenght, unsigned char * Sendbuffer, unsigned char Mode, int RetransmissionCounter )	
	{
    51f2:	a2 e8       	ldi	r26, 0x82	; 130
    51f4:	b0 e0       	ldi	r27, 0x00	; 0
    51f6:	ef ef       	ldi	r30, 0xFF	; 255
    51f8:	f8 e2       	ldi	r31, 0x28	; 40
    51fa:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    51fe:	2c 01       	movw	r4, r24
    5200:	3b 01       	movw	r6, r22
    5202:	18 01       	movw	r2, r16
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS || TCP_sockettable[Socket].ConnectionState == SOCKET_NOT_USE ) return( SOCKET_ERROR );
    5204:	83 e0       	ldi	r24, 0x03	; 3
    5206:	48 16       	cp	r4, r24
    5208:	51 04       	cpc	r5, r1
    520a:	08 f0       	brcs	.+2      	; 0x520e <SendData_RPE+0x1c>
    520c:	01 c1       	rjmp	.+514    	; 0x5410 <SendData_RPE+0x21e>
    520e:	80 ea       	ldi	r24, 0xA0	; 160
    5210:	90 e0       	ldi	r25, 0x00	; 0
    5212:	48 9e       	mul	r4, r24
    5214:	f0 01       	movw	r30, r0
    5216:	49 9e       	mul	r4, r25
    5218:	f0 0d       	add	r31, r0
    521a:	58 9e       	mul	r5, r24
    521c:	f0 0d       	add	r31, r0
    521e:	11 24       	eor	r1, r1
    5220:	e7 5f       	subi	r30, 0xF7	; 247
    5222:	f7 4f       	sbci	r31, 0xF7	; 247
    5224:	80 81       	ld	r24, Z
    5226:	88 23       	and	r24, r24
    5228:	09 f4       	brne	.+2      	; 0x522c <SendData_RPE+0x3a>
    522a:	f2 c0       	rjmp	.+484    	; 0x5410 <SendData_RPE+0x21e>
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT ];	

		unsigned int Offset = ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ;
		unsigned int i;

		switch ( Mode )
    522c:	22 23       	and	r18, r18
    522e:	69 f0       	breq	.+26     	; 0x524a <SendData_RPE+0x58>
    5230:	21 30       	cpi	r18, 0x01	; 1
    5232:	09 f0       	breq	.+2      	; 0x5236 <SendData_RPE+0x44>
    5234:	ed c0       	rjmp	.+474    	; 0x5410 <SendData_RPE+0x21e>
    5236:	fa 01       	movw	r30, r20
    5238:	de 01       	movw	r26, r28
    523a:	ad 5b       	subi	r26, 0xBD	; 189
    523c:	bf 4f       	sbci	r27, 0xFF	; 255
		{
			case RAM:	for ( i = 0 ; i < Datalenght ; i++ )
								ethernetbuffer[ Offset + i ] = Sendbuffer[ i ]; // kopiere die daten in den Sendebiffer
						break;
			case FLASH:	for ( i = 0 ; i < Datalenght ; i++ )
    523e:	9e 01       	movw	r18, r28
    5240:	26 0f       	add	r18, r22
    5242:	37 1f       	adc	r19, r23
    5244:	2d 5b       	subi	r18, 0xBD	; 189
    5246:	3f 4f       	sbci	r19, 0xFF	; 255
    5248:	13 c0       	rjmp	.+38     	; 0x5270 <SendData_RPE+0x7e>
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT ];	

		unsigned int Offset = ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ;
		unsigned int i;

		switch ( Mode )
    524a:	da 01       	movw	r26, r20
    524c:	fe 01       	movw	r30, r28
    524e:	ed 5b       	subi	r30, 0xBD	; 189
    5250:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			case RAM:	for ( i = 0 ; i < Datalenght ; i++ )
    5252:	9e 01       	movw	r18, r28
    5254:	26 0f       	add	r18, r22
    5256:	37 1f       	adc	r19, r23
    5258:	2d 5b       	subi	r18, 0xBD	; 189
    525a:	3f 4f       	sbci	r19, 0xFF	; 255
    525c:	02 c0       	rjmp	.+4      	; 0x5262 <SendData_RPE+0x70>
								ethernetbuffer[ Offset + i ] = Sendbuffer[ i ]; // kopiere die daten in den Sendebiffer
    525e:	8d 91       	ld	r24, X+
    5260:	81 93       	st	Z+, r24
		unsigned int Offset = ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ;
		unsigned int i;

		switch ( Mode )
		{
			case RAM:	for ( i = 0 ; i < Datalenght ; i++ )
    5262:	e2 17       	cp	r30, r18
    5264:	f3 07       	cpc	r31, r19
    5266:	d9 f7       	brne	.-10     	; 0x525e <SendData_RPE+0x6c>
    5268:	06 c0       	rjmp	.+12     	; 0x5276 <SendData_RPE+0x84>
								ethernetbuffer[ Offset + i ] = Sendbuffer[ i ]; // kopiere die daten in den Sendebiffer
						break;
			case FLASH:	for ( i = 0 ; i < Datalenght ; i++ )
								ethernetbuffer[ Offset + i ] = pgm_read_byte ( Sendbuffer + i ) ;
    526a:	84 91       	lpm	r24, Z+
    526c:	8d 93       	st	X+, r24
    526e:	31 96       	adiw	r30, 0x01	; 1
		switch ( Mode )
		{
			case RAM:	for ( i = 0 ; i < Datalenght ; i++ )
								ethernetbuffer[ Offset + i ] = Sendbuffer[ i ]; // kopiere die daten in den Sendebiffer
						break;
			case FLASH:	for ( i = 0 ; i < Datalenght ; i++ )
    5270:	a2 17       	cp	r26, r18
    5272:	b3 07       	cpc	r27, r19
    5274:	d1 f7       	brne	.-12     	; 0x526a <SendData_RPE+0x78>
								ethernetbuffer[ Offset + i ] = pgm_read_byte ( Sendbuffer + i ) ;
						break;
			default:	return( SOCKET_ERROR );
		}

		LockEthernet();
    5276:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
		
		MakeTCPheader( Socket, TCP_PSH_FLAG | TCP_ACK_FLAG , Datalenght, MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) , ethernetbuffer );
    527a:	80 ea       	ldi	r24, 0xA0	; 160
    527c:	90 e0       	ldi	r25, 0x00	; 0
    527e:	48 9e       	mul	r4, r24
    5280:	70 01       	movw	r14, r0
    5282:	49 9e       	mul	r4, r25
    5284:	f0 0c       	add	r15, r0
    5286:	58 9e       	mul	r5, r24
    5288:	f0 0c       	add	r15, r0
    528a:	11 24       	eor	r1, r1
    528c:	e9 e0       	ldi	r30, 0x09	; 9
    528e:	f8 e0       	ldi	r31, 0x08	; 8
    5290:	ee 0e       	add	r14, r30
    5292:	ff 1e       	adc	r15, r31
    5294:	f7 01       	movw	r30, r14
    5296:	86 8d       	ldd	r24, Z+30	; 0x1e
    5298:	97 8d       	ldd	r25, Z+31	; 0x1f
    529a:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    529e:	20 e8       	ldi	r18, 0x80	; 128
    52a0:	30 e0       	ldi	r19, 0x00	; 0
    52a2:	28 1b       	sub	r18, r24
    52a4:	39 0b       	sbc	r19, r25
    52a6:	c2 01       	movw	r24, r4
    52a8:	68 e1       	ldi	r22, 0x18	; 24
    52aa:	a3 01       	movw	r20, r6
    52ac:	8e 01       	movw	r16, r28
    52ae:	0f 5f       	subi	r16, 0xFF	; 255
    52b0:	1f 4f       	sbci	r17, 0xFF	; 255
    52b2:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
		TCP_sockettable[ Socket ].SequenceNumber = TCP_sockettable[ Socket ].SequenceNumber + i;
    52b6:	f7 01       	movw	r30, r14
    52b8:	82 85       	ldd	r24, Z+10	; 0x0a
    52ba:	93 85       	ldd	r25, Z+11	; 0x0b
    52bc:	a4 85       	ldd	r26, Z+12	; 0x0c
    52be:	b5 85       	ldd	r27, Z+13	; 0x0d
    52c0:	53 01       	movw	r10, r6
    52c2:	cc 24       	eor	r12, r12
    52c4:	dd 24       	eor	r13, r13
    52c6:	8a 0d       	add	r24, r10
    52c8:	9b 1d       	adc	r25, r11
    52ca:	ac 1d       	adc	r26, r12
    52cc:	bd 1d       	adc	r27, r13
    52ce:	82 87       	std	Z+10, r24	; 0x0a
    52d0:	93 87       	std	Z+11, r25	; 0x0b
    52d2:	a4 87       	std	Z+12, r26	; 0x0c
    52d4:	b5 87       	std	Z+13, r27	; 0x0d
		TCP_sockettable[ Socket ].SendetBytes = Datalenght ;
    52d6:	75 8a       	std	Z+21, r7	; 0x15
    52d8:	64 8a       	std	Z+20, r6	; 0x14

		FreeEthernet();
    52da:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
		
		timer = CLOCK_RegisterCoundowntimer();
    52de:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <CLOCK_RegisterCoundowntimer>
    52e2:	4c 01       	movw	r8, r24
		if( timer == CLOCK_FAILED ) return( SOCKET_ERROR );
    52e4:	ff ef       	ldi	r31, 0xFF	; 255
    52e6:	8f 3f       	cpi	r24, 0xFF	; 255
    52e8:	9f 07       	cpc	r25, r31
    52ea:	09 f4       	brne	.+2      	; 0x52ee <SendData_RPE+0xfc>
    52ec:	91 c0       	rjmp	.+290    	; 0x5410 <SendData_RPE+0x21e>

		
		if ( RetransmissionCounter < 1 )
    52ee:	12 14       	cp	r1, r2
    52f0:	13 04       	cpc	r1, r3
    52f2:	1c f0       	brlt	.+6      	; 0x52fa <SendData_RPE+0x108>
			CLOCK_SetCountdownTimer( timer , RETRANSMISSIONTIMEOUT/16 , MSECOUND );
    52f4:	6c e0       	ldi	r22, 0x0C	; 12
    52f6:	70 e0       	ldi	r23, 0x00	; 0
    52f8:	07 c0       	rjmp	.+14     	; 0x5308 <SendData_RPE+0x116>
		else if ( RetransmissionCounter < MAX_TCP_RETRANSMISSIONS/4 )
			CLOCK_SetCountdownTimer( timer , RETRANSMISSIONTIMEOUT/4 , MSECOUND );
		else if ( RetransmissionCounter < MAX_TCP_RETRANSMISSIONS/2 )
			CLOCK_SetCountdownTimer( timer , RETRANSMISSIONTIMEOUT , MSECOUND );
		else if ( RetransmissionCounter < MAX_TCP_RETRANSMISSIONS )
    52fa:	83 e0       	ldi	r24, 0x03	; 3
    52fc:	28 16       	cp	r2, r24
    52fe:	31 04       	cpc	r3, r1
    5300:	34 f4       	brge	.+12     	; 0x530e <SendData_RPE+0x11c>
			CLOCK_SetCountdownTimer( timer , RETRANSMISSIONTIMEOUT , MSECOUND );
    5302:	c4 01       	movw	r24, r8
    5304:	68 ec       	ldi	r22, 0xC8	; 200
    5306:	70 e0       	ldi	r23, 0x00	; 0
    5308:	41 e0       	ldi	r20, 0x01	; 1
    530a:	0e 94 37 1b 	call	0x366e	; 0x366e <CLOCK_SetCountdownTimer>

		#ifdef TCP_delayed_ack
			LockEthernet();
    530e:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
		
			TCP_sockettable[ Socket ].SequenceNumber = TCP_sockettable[ Socket ].SequenceNumber - i;
    5312:	80 ea       	ldi	r24, 0xA0	; 160
    5314:	90 e0       	ldi	r25, 0x00	; 0
    5316:	48 9e       	mul	r4, r24
    5318:	70 01       	movw	r14, r0
    531a:	49 9e       	mul	r4, r25
    531c:	f0 0c       	add	r15, r0
    531e:	58 9e       	mul	r5, r24
    5320:	f0 0c       	add	r15, r0
    5322:	11 24       	eor	r1, r1
    5324:	e9 e0       	ldi	r30, 0x09	; 9
    5326:	f8 e0       	ldi	r31, 0x08	; 8
    5328:	ee 0e       	add	r14, r30
    532a:	ff 1e       	adc	r15, r31
    532c:	f7 01       	movw	r30, r14
    532e:	82 85       	ldd	r24, Z+10	; 0x0a
    5330:	93 85       	ldd	r25, Z+11	; 0x0b
    5332:	a4 85       	ldd	r26, Z+12	; 0x0c
    5334:	b5 85       	ldd	r27, Z+13	; 0x0d
    5336:	8a 19       	sub	r24, r10
    5338:	9b 09       	sbc	r25, r11
    533a:	ac 09       	sbc	r26, r12
    533c:	bd 09       	sbc	r27, r13
    533e:	82 87       	std	Z+10, r24	; 0x0a
    5340:	93 87       	std	Z+11, r25	; 0x0b
    5342:	a4 87       	std	Z+12, r26	; 0x0c
    5344:	b5 87       	std	Z+13, r27	; 0x0d
			TCP_sockettable[ Socket ].SendetBytes = Datalenght ;
    5346:	75 8a       	std	Z+21, r7	; 0x15
    5348:	64 8a       	std	Z+20, r6	; 0x14
			MakeTCPheader( Socket, TCP_ACK_FLAG , 0, MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) , ethernetbuffer );
    534a:	86 8d       	ldd	r24, Z+30	; 0x1e
    534c:	97 8d       	ldd	r25, Z+31	; 0x1f
    534e:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5352:	20 e8       	ldi	r18, 0x80	; 128
    5354:	30 e0       	ldi	r19, 0x00	; 0
    5356:	28 1b       	sub	r18, r24
    5358:	39 0b       	sbc	r19, r25
    535a:	c2 01       	movw	r24, r4
    535c:	60 e1       	ldi	r22, 0x10	; 16
    535e:	40 e0       	ldi	r20, 0x00	; 0
    5360:	50 e0       	ldi	r21, 0x00	; 0
    5362:	8e 01       	movw	r16, r28
    5364:	0f 5f       	subi	r16, 0xFF	; 255
    5366:	1f 4f       	sbci	r17, 0xFF	; 255
    5368:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
			TCP_sockettable[ Socket ].SequenceNumber = TCP_sockettable[ Socket ].SequenceNumber + i;
    536c:	f7 01       	movw	r30, r14
    536e:	82 85       	ldd	r24, Z+10	; 0x0a
    5370:	93 85       	ldd	r25, Z+11	; 0x0b
    5372:	a4 85       	ldd	r26, Z+12	; 0x0c
    5374:	b5 85       	ldd	r27, Z+13	; 0x0d
    5376:	8a 0d       	add	r24, r10
    5378:	9b 1d       	adc	r25, r11
    537a:	ac 1d       	adc	r26, r12
    537c:	bd 1d       	adc	r27, r13
    537e:	82 87       	std	Z+10, r24	; 0x0a
    5380:	93 87       	std	Z+11, r25	; 0x0b
    5382:	a4 87       	std	Z+12, r26	; 0x0c
    5384:	b5 87       	std	Z+13, r27	; 0x0d
			TCP_sockettable[ Socket ].SendetBytes = Datalenght ;
    5386:	75 8a       	std	Z+21, r7	; 0x15
    5388:	64 8a       	std	Z+20, r6	; 0x14

			FreeEthernet();
    538a:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

		#ifdef TCP_delayed_ack
			LockEthernet();
		
			TCP_sockettable[ Socket ].SequenceNumber = TCP_sockettable[ Socket ].SequenceNumber - i;
			TCP_sockettable[ Socket ].SendetBytes = Datalenght ;
    538e:	84 e1       	ldi	r24, 0x14	; 20
    5390:	90 e0       	ldi	r25, 0x00	; 0
    5392:	e8 0e       	add	r14, r24
    5394:	f9 1e       	adc	r15, r25
				TXErrorCounter++;
				return( SOCKET_ERROR );
			}
			else
			{
				if ( TCP_sockettable[ Socket ].SendetBytes == 0 )
    5396:	87 01       	movw	r16, r14
			FreeEthernet();
		#endif

		while(1)
		{
			LockEthernet();
    5398:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
			if( CLOCK_GetCountdownTimer( timer ) == 0 )
    539c:	c4 01       	movw	r24, r8
    539e:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    53a2:	89 2b       	or	r24, r25
    53a4:	31 f5       	brne	.+76     	; 0x53f2 <SendData_RPE+0x200>
			{
				CLOCK_ReleaseCountdownTimer ( timer );
    53a6:	c4 01       	movw	r24, r8
    53a8:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
				TCP_sockettable[ Socket ].SequenceNumber = TCP_sockettable[ Socket ].SequenceNumber - i ;
    53ac:	80 ea       	ldi	r24, 0xA0	; 160
    53ae:	90 e0       	ldi	r25, 0x00	; 0
    53b0:	48 9e       	mul	r4, r24
    53b2:	f0 01       	movw	r30, r0
    53b4:	49 9e       	mul	r4, r25
    53b6:	f0 0d       	add	r31, r0
    53b8:	58 9e       	mul	r5, r24
    53ba:	f0 0d       	add	r31, r0
    53bc:	11 24       	eor	r1, r1
    53be:	e7 5f       	subi	r30, 0xF7	; 247
    53c0:	f7 4f       	sbci	r31, 0xF7	; 247
    53c2:	82 85       	ldd	r24, Z+10	; 0x0a
    53c4:	93 85       	ldd	r25, Z+11	; 0x0b
    53c6:	a4 85       	ldd	r26, Z+12	; 0x0c
    53c8:	b5 85       	ldd	r27, Z+13	; 0x0d
    53ca:	8a 19       	sub	r24, r10
    53cc:	9b 09       	sbc	r25, r11
    53ce:	ac 09       	sbc	r26, r12
    53d0:	bd 09       	sbc	r27, r13
    53d2:	82 87       	std	Z+10, r24	; 0x0a
    53d4:	93 87       	std	Z+11, r25	; 0x0b
    53d6:	a4 87       	std	Z+12, r26	; 0x0c
    53d8:	b5 87       	std	Z+13, r27	; 0x0d
				FreeEthernet();
    53da:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
				TXErrorCounter++;
    53de:	80 91 cf 01 	lds	r24, 0x01CF
    53e2:	90 91 d0 01 	lds	r25, 0x01D0
    53e6:	01 96       	adiw	r24, 0x01	; 1
    53e8:	90 93 d0 01 	sts	0x01D0, r25
    53ec:	80 93 cf 01 	sts	0x01CF, r24
    53f0:	0f c0       	rjmp	.+30     	; 0x5410 <SendData_RPE+0x21e>
				return( SOCKET_ERROR );
			}
			else
			{
				if ( TCP_sockettable[ Socket ].SendetBytes == 0 )
    53f2:	f8 01       	movw	r30, r16
    53f4:	80 81       	ld	r24, Z
    53f6:	91 81       	ldd	r25, Z+1	; 0x01
    53f8:	89 2b       	or	r24, r25
    53fa:	39 f4       	brne	.+14     	; 0x540a <SendData_RPE+0x218>
				{
					CLOCK_ReleaseCountdownTimer ( timer );
    53fc:	c4 01       	movw	r24, r8
    53fe:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
					FreeEthernet();
    5402:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
					return( Datalenght );
    5406:	a3 01       	movw	r20, r6
    5408:	05 c0       	rjmp	.+10     	; 0x5414 <SendData_RPE+0x222>
				}
			}
			FreeEthernet();
    540a:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
    540e:	c4 cf       	rjmp	.-120    	; 0x5398 <SendData_RPE+0x1a6>
		}
    5410:	4f ef       	ldi	r20, 0xFF	; 255
    5412:	5f ef       	ldi	r21, 0xFF	; 255
	}
    5414:	ca 01       	movw	r24, r20
    5416:	ce 57       	subi	r28, 0x7E	; 126
    5418:	df 4f       	sbci	r29, 0xFF	; 255
    541a:	e2 e1       	ldi	r30, 0x12	; 18
    541c:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

00005420 <CloseTCPSocket>:
/*!\brief Schliesst ein Socket und Beendet die TCP-Verbindung.
 * \param	Socket		Die Socketnummer die geschlossen werden soll.
 */
/*------------------------------------------------------------------------------------------------------------*/		
void CloseTCPSocket( int Socket)
	{
    5420:	a2 e4       	ldi	r26, 0x42	; 66
    5422:	b0 e0       	ldi	r27, 0x00	; 0
    5424:	e6 e1       	ldi	r30, 0x16	; 22
    5426:	fa e2       	ldi	r31, 0x2A	; 42
    5428:	0c 94 bd 6a 	jmp	0xd57a	; 0xd57a <__prologue_saves__+0x8>
    542c:	4c 01       	movw	r8, r24
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS  || TCP_sockettable[Socket].ConnectionState == SOCKET_NOT_USE ) return;
    542e:	83 e0       	ldi	r24, 0x03	; 3
    5430:	88 16       	cp	r8, r24
    5432:	91 04       	cpc	r9, r1
    5434:	08 f0       	brcs	.+2      	; 0x5438 <CloseTCPSocket+0x18>
    5436:	b9 c0       	rjmp	.+370    	; 0x55aa <CloseTCPSocket+0x18a>
    5438:	80 ea       	ldi	r24, 0xA0	; 160
    543a:	90 e0       	ldi	r25, 0x00	; 0
    543c:	88 9e       	mul	r8, r24
    543e:	70 01       	movw	r14, r0
    5440:	89 9e       	mul	r8, r25
    5442:	f0 0c       	add	r15, r0
    5444:	98 9e       	mul	r9, r24
    5446:	f0 0c       	add	r15, r0
    5448:	11 24       	eor	r1, r1
    544a:	e9 e0       	ldi	r30, 0x09	; 9
    544c:	f8 e0       	ldi	r31, 0x08	; 8
    544e:	ee 0e       	add	r14, r30
    5450:	ff 1e       	adc	r15, r31
    5452:	f7 01       	movw	r30, r14
    5454:	80 81       	ld	r24, Z
    5456:	88 23       	and	r24, r24
    5458:	09 f4       	brne	.+2      	; 0x545c <CloseTCPSocket+0x3c>
    545a:	a7 c0       	rjmp	.+334    	; 0x55aa <CloseTCPSocket+0x18a>
					
		int timer;
		
		timer = CLOCK_RegisterCoundowntimer();
    545c:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <CLOCK_RegisterCoundowntimer>
    5460:	8c 01       	movw	r16, r24
		if( timer == CLOCK_FAILED ) return;
    5462:	ff ef       	ldi	r31, 0xFF	; 255
    5464:	8f 3f       	cpi	r24, 0xFF	; 255
    5466:	9f 07       	cpc	r25, r31
    5468:	09 f4       	brne	.+2      	; 0x546c <CloseTCPSocket+0x4c>
    546a:	9f c0       	rjmp	.+318    	; 0x55aa <CloseTCPSocket+0x18a>
		
		CLOCK_SetCountdownTimer( timer , CLOSETIMEOUT, MSECOUND );
    546c:	68 ec       	ldi	r22, 0xC8	; 200
    546e:	70 e0       	ldi	r23, 0x00	; 0
    5470:	41 e0       	ldi	r20, 0x01	; 1
    5472:	0e 94 37 1b 	call	0x366e	; 0x366e <CLOCK_SetCountdownTimer>

		while ( 1 )
		{
			if ( ( TCP_sockettable[ Socket ].SendState == SOCKET_READY2SEND ) && ( CLOCK_GetCountdownTimer( timer ) != 0 ) )
    5476:	67 01       	movw	r12, r14
    5478:	08 94       	sec
    547a:	c1 1c       	adc	r12, r1
    547c:	d1 1c       	adc	r13, r1
    547e:	f6 01       	movw	r30, r12
    5480:	80 81       	ld	r24, Z
    5482:	88 23       	and	r24, r24
    5484:	69 f5       	brne	.+90     	; 0x54e0 <CloseTCPSocket+0xc0>
    5486:	c8 01       	movw	r24, r16
    5488:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    548c:	89 2b       	or	r24, r25
    548e:	41 f1       	breq	.+80     	; 0x54e0 <CloseTCPSocket+0xc0>
			{
				CLOCK_ReleaseCountdownTimer( timer );
    5490:	c8 01       	movw	r24, r16
    5492:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
				CLOCK_ReleaseCountdownTimer( timer );
				return;
			}
		}
		
		LockEthernet();
    5496:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
		unsigned char ethernetbuffer[ ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ];
		
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT ];

		MakeTCPheader( Socket, TCP_FIN_FLAG | TCP_ACK_FLAG , 0, ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    549a:	f7 01       	movw	r30, r14
    549c:	86 8d       	ldd	r24, Z+30	; 0x1e
    549e:	97 8d       	ldd	r25, Z+31	; 0x1f
    54a0:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    54a4:	10 e8       	ldi	r17, 0x80	; 128
    54a6:	c1 2e       	mov	r12, r17
    54a8:	d1 2c       	mov	r13, r1
    54aa:	96 01       	movw	r18, r12
    54ac:	28 1b       	sub	r18, r24
    54ae:	39 0b       	sbc	r19, r25
    54b0:	c4 01       	movw	r24, r8
    54b2:	61 e1       	ldi	r22, 0x11	; 17
    54b4:	40 e0       	ldi	r20, 0x00	; 0
    54b6:	50 e0       	ldi	r21, 0x00	; 0
    54b8:	3e 01       	movw	r6, r28
    54ba:	08 94       	sec
    54bc:	61 1c       	adc	r6, r1
    54be:	71 1c       	adc	r7, r1
    54c0:	83 01       	movw	r16, r6
    54c2:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
		
		TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FINACK;
    54c6:	81 e7       	ldi	r24, 0x71	; 113
    54c8:	f7 01       	movw	r30, r14
    54ca:	80 83       	st	Z, r24
	
		FreeEthernet();		
    54cc:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

		timer = CLOCK_RegisterCoundowntimer();
    54d0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <CLOCK_RegisterCoundowntimer>
    54d4:	5c 01       	movw	r10, r24
		if( timer == CLOCK_FAILED ) return;
    54d6:	ff ef       	ldi	r31, 0xFF	; 255
    54d8:	8f 3f       	cpi	r24, 0xFF	; 255
    54da:	9f 07       	cpc	r25, r31
    54dc:	b1 f4       	brne	.+44     	; 0x550a <CloseTCPSocket+0xea>
    54de:	65 c0       	rjmp	.+202    	; 0x55aa <CloseTCPSocket+0x18a>
			if ( ( TCP_sockettable[ Socket ].SendState == SOCKET_READY2SEND ) && ( CLOCK_GetCountdownTimer( timer ) != 0 ) )
			{
				CLOCK_ReleaseCountdownTimer( timer );
				break;
			}
			if ( CLOCK_GetCountdownTimer( timer ) == 0 ) 
    54e0:	c8 01       	movw	r24, r16
    54e2:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    54e6:	89 2b       	or	r24, r25
    54e8:	51 f6       	brne	.-108    	; 0x547e <CloseTCPSocket+0x5e>
				#ifdef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = CloseTimeout ;
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
				#endif
				#ifndef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = 0 ;
    54ea:	80 ea       	ldi	r24, 0xA0	; 160
    54ec:	90 e0       	ldi	r25, 0x00	; 0
    54ee:	88 9e       	mul	r8, r24
    54f0:	f0 01       	movw	r30, r0
    54f2:	89 9e       	mul	r8, r25
    54f4:	f0 0d       	add	r31, r0
    54f6:	98 9e       	mul	r9, r24
    54f8:	f0 0d       	add	r31, r0
    54fa:	11 24       	eor	r1, r1
    54fc:	e7 5f       	subi	r30, 0xF7	; 247
    54fe:	f7 4f       	sbci	r31, 0xF7	; 247
    5500:	17 8a       	std	Z+23, r1	; 0x17
    5502:	16 8a       	std	Z+22, r1	; 0x16
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
    5504:	10 82       	st	Z, r1
				#endif
				CLOCK_ReleaseCountdownTimer( timer );
    5506:	c8 01       	movw	r24, r16
    5508:	4e c0       	rjmp	.+156    	; 0x55a6 <CloseTCPSocket+0x186>
	
		FreeEthernet();		

		timer = CLOCK_RegisterCoundowntimer();
		if( timer == CLOCK_FAILED ) return;
		CLOCK_SetCountdownTimer( timer , CLOSETIMEOUT, MSECOUND );
    550a:	68 ec       	ldi	r22, 0xC8	; 200
    550c:	70 e0       	ldi	r23, 0x00	; 0
    550e:	41 e0       	ldi	r20, 0x01	; 1
    5510:	0e 94 37 1b 	call	0x366e	; 0x366e <CLOCK_SetCountdownTimer>
		
		#ifdef TCP_delayed_ack
			LockEthernet();
    5514:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>

			MakeTCPheader( Socket, TCP_FIN_FLAG | TCP_ACK_FLAG , 0, ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5518:	f7 01       	movw	r30, r14
    551a:	86 8d       	ldd	r24, Z+30	; 0x1e
    551c:	97 8d       	ldd	r25, Z+31	; 0x1f
    551e:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5522:	c8 1a       	sub	r12, r24
    5524:	d9 0a       	sbc	r13, r25
    5526:	c4 01       	movw	r24, r8
    5528:	61 e1       	ldi	r22, 0x11	; 17
    552a:	40 e0       	ldi	r20, 0x00	; 0
    552c:	50 e0       	ldi	r21, 0x00	; 0
    552e:	96 01       	movw	r18, r12
    5530:	83 01       	movw	r16, r6
    5532:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>

			FreeEthernet();		
    5536:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

		while ( 1 )
		{
			LockEthernet();
			
			if ( ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_NOT_USE ) && ( CLOCK_GetCountdownTimer( timer ) != 0 ) )
    553a:	80 ea       	ldi	r24, 0xA0	; 160
    553c:	90 e0       	ldi	r25, 0x00	; 0
    553e:	88 9e       	mul	r8, r24
    5540:	80 01       	movw	r16, r0
    5542:	89 9e       	mul	r8, r25
    5544:	10 0d       	add	r17, r0
    5546:	98 9e       	mul	r9, r24
    5548:	10 0d       	add	r17, r0
    554a:	11 24       	eor	r1, r1
    554c:	07 5f       	subi	r16, 0xF7	; 247
    554e:	17 4f       	sbci	r17, 0xF7	; 247
			FreeEthernet();		
		#endif

		while ( 1 )
		{
			LockEthernet();
    5550:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
			
			if ( ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_NOT_USE ) && ( CLOCK_GetCountdownTimer( timer ) != 0 ) )
    5554:	f8 01       	movw	r30, r16
    5556:	80 81       	ld	r24, Z
    5558:	88 23       	and	r24, r24
    555a:	59 f4       	brne	.+22     	; 0x5572 <CloseTCPSocket+0x152>
    555c:	c5 01       	movw	r24, r10
    555e:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    5562:	89 2b       	or	r24, r25
    5564:	31 f0       	breq	.+12     	; 0x5572 <CloseTCPSocket+0x152>
			{
				CLOCK_ReleaseCountdownTimer( timer );
    5566:	c5 01       	movw	r24, r10
    5568:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
				FreeEthernet();
    556c:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
    5570:	1c c0       	rjmp	.+56     	; 0x55aa <CloseTCPSocket+0x18a>
				break;
			}
			
			FreeEthernet();
    5572:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

			if ( CLOCK_GetCountdownTimer( timer ) == 0 ) 
    5576:	c5 01       	movw	r24, r10
    5578:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    557c:	89 2b       	or	r24, r25
    557e:	41 f7       	brne	.-48     	; 0x5550 <CloseTCPSocket+0x130>
			{
				LockEthernet();
    5580:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
				#ifdef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = CloseTimeout ;
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
				#endif
				#ifndef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = 0 ;
    5584:	80 ea       	ldi	r24, 0xA0	; 160
    5586:	90 e0       	ldi	r25, 0x00	; 0
    5588:	88 9e       	mul	r8, r24
    558a:	f0 01       	movw	r30, r0
    558c:	89 9e       	mul	r8, r25
    558e:	f0 0d       	add	r31, r0
    5590:	98 9e       	mul	r9, r24
    5592:	f0 0d       	add	r31, r0
    5594:	11 24       	eor	r1, r1
    5596:	e7 5f       	subi	r30, 0xF7	; 247
    5598:	f7 4f       	sbci	r31, 0xF7	; 247
    559a:	17 8a       	std	Z+23, r1	; 0x17
    559c:	16 8a       	std	Z+22, r1	; 0x16
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
    559e:	10 82       	st	Z, r1
				#endif
				FreeEthernet();
    55a0:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

				CLOCK_ReleaseCountdownTimer( timer );
    55a4:	c5 01       	movw	r24, r10
    55a6:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
		}
		
		// TCP_sockettable[ Socket ].fifo = TCP_sockettable[ Socket ].old_fifo;

		return;
	}	
    55aa:	ce 5b       	subi	r28, 0xBE	; 190
    55ac:	df 4f       	sbci	r29, 0xFF	; 255
    55ae:	ee e0       	ldi	r30, 0x0E	; 14
    55b0:	0c 94 d9 6a 	jmp	0xd5b2	; 0xd5b2 <__epilogue_restores__+0x8>

000055b4 <PutSocketData_RPE>:
 * \param	Mode		Wie der Zeiger interpretiert werden soll, als RAM/FLASH/EEPROM.
 * \return	Datelenght	Anzahl der gesendeten Bytes oder -1 bei Fehler.
 */
/*------------------------------------------------------------------------------------------------------------*/	
int PutSocketData_RPE( int Socket, unsigned int Datalenght, unsigned char * Sendbuffer, unsigned char Mode )
	{
    55b4:	a5 e0       	ldi	r26, 0x05	; 5
    55b6:	b0 e0       	ldi	r27, 0x00	; 0
    55b8:	e0 ee       	ldi	r30, 0xE0	; 224
    55ba:	fa e2       	ldi	r31, 0x2A	; 42
    55bc:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    55c0:	5c 01       	movw	r10, r24
    55c2:	2b 01       	movw	r4, r22
    55c4:	5a 83       	std	Y+2, r21	; 0x02
    55c6:	49 83       	std	Y+1, r20	; 0x01
    55c8:	32 2e       	mov	r3, r18
		// schau mal ob socket g체ltig ist
		if ( Socket < 0 || Socket >= MAX_TCP_CONNECTIONS || TCP_sockettable[Socket].ConnectionState == SOCKET_NOT_USE ) return( SOCKET_ERROR );
    55ca:	83 30       	cpi	r24, 0x03	; 3
    55cc:	91 05       	cpc	r25, r1
    55ce:	08 f0       	brcs	.+2      	; 0x55d2 <PutSocketData_RPE+0x1e>
    55d0:	a8 c0       	rjmp	.+336    	; 0x5722 <PutSocketData_RPE+0x16e>
    55d2:	80 ea       	ldi	r24, 0xA0	; 160
    55d4:	90 e0       	ldi	r25, 0x00	; 0
    55d6:	a8 9e       	mul	r10, r24
    55d8:	f0 01       	movw	r30, r0
    55da:	a9 9e       	mul	r10, r25
    55dc:	f0 0d       	add	r31, r0
    55de:	b8 9e       	mul	r11, r24
    55e0:	f0 0d       	add	r31, r0
    55e2:	11 24       	eor	r1, r1
    55e4:	e7 5f       	subi	r30, 0xF7	; 247
    55e6:	f7 4f       	sbci	r31, 0xF7	; 247
    55e8:	80 81       	ld	r24, Z
    55ea:	88 23       	and	r24, r24
    55ec:	09 f4       	brne	.+2      	; 0x55f0 <PutSocketData_RPE+0x3c>
    55ee:	99 c0       	rjmp	.+306    	; 0x5722 <PutSocketData_RPE+0x16e>
			
		int Transmission=0,i,packet,TransmissionCounter=0;		

		// Anzahl der Packet berechnen die die maximall채nge haben
		packet = ( Datalenght / MAX_TCP_Datalenght );
    55f0:	4b 01       	movw	r8, r22
    55f2:	66 e0       	ldi	r22, 0x06	; 6
    55f4:	96 94       	lsr	r9
    55f6:	87 94       	ror	r8
    55f8:	6a 95       	dec	r22
    55fa:	e1 f7       	brne	.-8      	; 0x55f4 <PutSocketData_RPE+0x40>
    55fc:	6a 01       	movw	r12, r20
    55fe:	66 24       	eor	r6, r6
    5600:	77 24       	eor	r7, r7
    5602:	1d 82       	std	Y+5, r1	; 0x05
    5604:	1c 82       	std	Y+4, r1	; 0x04
    5606:	36 c0       	rjmp	.+108    	; 0x5674 <PutSocketData_RPE+0xc0>
		
		// Packet mit maximall채nge senden
		for ( i = 0 ; i < packet ; i++ )
    5608:	c7 01       	movw	r24, r14
    560a:	01 97       	sbiw	r24, 0x01	; 1
    560c:	9d 83       	std	Y+5, r25	; 0x05
    560e:	8c 83       	std	Y+4, r24	; 0x04
		{
			Transmission = 1;
			TransmissionCounter = 0;
			while( Transmission != 0 && TransmissionCounter < MAX_TCP_RETRANSMISSIONS )
			{
				switch ( Mode )
    5610:	33 20       	and	r3, r3
    5612:	29 f0       	breq	.+10     	; 0x561e <PutSocketData_RPE+0x6a>
    5614:	91 e0       	ldi	r25, 0x01	; 1
    5616:	39 16       	cp	r3, r25
    5618:	09 f0       	breq	.+2      	; 0x561c <PutSocketData_RPE+0x68>
    561a:	83 c0       	rjmp	.+262    	; 0x5722 <PutSocketData_RPE+0x16e>
    561c:	0e c0       	rjmp	.+28     	; 0x563a <PutSocketData_RPE+0x86>
				{
					case RAM:	if ( SendData_RPE( Socket, MAX_TCP_Datalenght , &Sendbuffer[i * MAX_TCP_Datalenght ], RAM, TransmissionCounter ) != SOCKET_ERROR )
    561e:	c5 01       	movw	r24, r10
    5620:	60 e4       	ldi	r22, 0x40	; 64
    5622:	70 e0       	ldi	r23, 0x00	; 0
    5624:	4b 81       	ldd	r20, Y+3	; 0x03
    5626:	52 2d       	mov	r21, r2
    5628:	20 e0       	ldi	r18, 0x00	; 0
    562a:	0c 81       	ldd	r16, Y+4	; 0x04
    562c:	1d 81       	ldd	r17, Y+5	; 0x05
    562e:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <SendData_RPE>
    5632:	8f 5f       	subi	r24, 0xFF	; 255
    5634:	9f 4f       	sbci	r25, 0xFF	; 255
    5636:	b9 f4       	brne	.+46     	; 0x5666 <PutSocketData_RPE+0xb2>
    5638:	0d c0       	rjmp	.+26     	; 0x5654 <PutSocketData_RPE+0xa0>
								{
									Transmission = 1;
									TransmissionCounter++;
								}
								break;
					case FLASH:	if ( SendData_RPE( Socket, MAX_TCP_Datalenght , &Sendbuffer[i * MAX_TCP_Datalenght ], FLASH, TransmissionCounter ) != SOCKET_ERROR )
    563a:	c5 01       	movw	r24, r10
    563c:	60 e4       	ldi	r22, 0x40	; 64
    563e:	70 e0       	ldi	r23, 0x00	; 0
    5640:	4b 81       	ldd	r20, Y+3	; 0x03
    5642:	52 2d       	mov	r21, r2
    5644:	21 e0       	ldi	r18, 0x01	; 1
    5646:	0c 81       	ldd	r16, Y+4	; 0x04
    5648:	1d 81       	ldd	r17, Y+5	; 0x05
    564a:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <SendData_RPE>
    564e:	8f 5f       	subi	r24, 0xFF	; 255
    5650:	9f 4f       	sbci	r25, 0xFF	; 255
    5652:	49 f4       	brne	.+18     	; 0x5666 <PutSocketData_RPE+0xb2>
    5654:	fd 82       	std	Y+5, r15	; 0x05
    5656:	ec 82       	std	Y+4, r14	; 0x04
    5658:	08 94       	sec
    565a:	e1 1c       	adc	r14, r1
    565c:	f1 1c       	adc	r15, r1
		// Packet mit maximall채nge senden
		for ( i = 0 ; i < packet ; i++ )
		{
			Transmission = 1;
			TransmissionCounter = 0;
			while( Transmission != 0 && TransmissionCounter < MAX_TCP_RETRANSMISSIONS )
    565e:	24 e0       	ldi	r18, 0x04	; 4
    5660:	e2 16       	cp	r14, r18
    5662:	f1 04       	cpc	r15, r1
    5664:	89 f6       	brne	.-94     	; 0x5608 <PutSocketData_RPE+0x54>

		// Anzahl der Packet berechnen die die maximall채nge haben
		packet = ( Datalenght / MAX_TCP_Datalenght );
		
		// Packet mit maximall채nge senden
		for ( i = 0 ; i < packet ; i++ )
    5666:	08 94       	sec
    5668:	61 1c       	adc	r6, r1
    566a:	71 1c       	adc	r7, r1
    566c:	80 e4       	ldi	r24, 0x40	; 64
    566e:	90 e0       	ldi	r25, 0x00	; 0
    5670:	c8 0e       	add	r12, r24
    5672:	d9 1e       	adc	r13, r25
    5674:	68 14       	cp	r6, r8
    5676:	79 04       	cpc	r7, r9
    5678:	34 f4       	brge	.+12     	; 0x5686 <PutSocketData_RPE+0xd2>
    567a:	cb 82       	std	Y+3, r12	; 0x03
    567c:	2d 2c       	mov	r2, r13
    567e:	31 e0       	ldi	r19, 0x01	; 1
    5680:	e3 2e       	mov	r14, r19
    5682:	f1 2c       	mov	r15, r1
    5684:	c1 cf       	rjmp	.-126    	; 0x5608 <PutSocketData_RPE+0x54>
					default:	return( -1 );
				}
			}
		}

		if ( TransmissionCounter == MAX_TCP_RETRANSMISSIONS )
    5686:	ec 81       	ldd	r30, Y+4	; 0x04
    5688:	fd 81       	ldd	r31, Y+5	; 0x05
    568a:	33 97       	sbiw	r30, 0x03	; 3
    568c:	09 f4       	brne	.+2      	; 0x5690 <PutSocketData_RPE+0xdc>
    568e:	43 c0       	rjmp	.+134    	; 0x5716 <PutSocketData_RPE+0x162>
			CloseTCPSocket( Socket );
			return( SOCKET_ERROR );
		}
				
		// Wenn noch Byte 체brig sind, senden
		if ( ( Datalenght % MAX_TCP_Datalenght ) != 0 )
    5690:	2f e3       	ldi	r18, 0x3F	; 63
    5692:	82 2e       	mov	r8, r18
    5694:	91 2c       	mov	r9, r1
    5696:	84 20       	and	r8, r4
    5698:	95 20       	and	r9, r5
    569a:	81 14       	cp	r8, r1
    569c:	91 04       	cpc	r9, r1
    569e:	b9 f1       	breq	.+110    	; 0x570e <PutSocketData_RPE+0x15a>
			TransmissionCounter = 0;
			while( Transmission == 0 && TransmissionCounter < MAX_TCP_RETRANSMISSIONS )
			{
				switch ( Mode )
				{
					case RAM:	if ( SendData_RPE( Socket, Datalenght % MAX_TCP_Datalenght , &Sendbuffer[i * MAX_TCP_Datalenght ], RAM, TransmissionCounter ) != SOCKET_ERROR )
    56a0:	63 01       	movw	r12, r6
    56a2:	96 e0       	ldi	r25, 0x06	; 6
    56a4:	cc 0c       	add	r12, r12
    56a6:	dd 1c       	adc	r13, r13
    56a8:	9a 95       	dec	r25
    56aa:	e1 f7       	brne	.-8      	; 0x56a4 <PutSocketData_RPE+0xf0>
    56ac:	89 81       	ldd	r24, Y+1	; 0x01
    56ae:	9a 81       	ldd	r25, Y+2	; 0x02
    56b0:	c8 0e       	add	r12, r24
    56b2:	d9 1e       	adc	r13, r25
    56b4:	81 e0       	ldi	r24, 0x01	; 1
    56b6:	e8 2e       	mov	r14, r24
    56b8:	f1 2c       	mov	r15, r1
    56ba:	f7 01       	movw	r30, r14
    56bc:	31 97       	sbiw	r30, 0x01	; 1
    56be:	fd 83       	std	Y+5, r31	; 0x05
    56c0:	ec 83       	std	Y+4, r30	; 0x04
		{
			Transmission = 0;
			TransmissionCounter = 0;
			while( Transmission == 0 && TransmissionCounter < MAX_TCP_RETRANSMISSIONS )
			{
				switch ( Mode )
    56c2:	33 20       	and	r3, r3
    56c4:	21 f0       	breq	.+8      	; 0x56ce <PutSocketData_RPE+0x11a>
    56c6:	f1 e0       	ldi	r31, 0x01	; 1
    56c8:	3f 16       	cp	r3, r31
    56ca:	59 f5       	brne	.+86     	; 0x5722 <PutSocketData_RPE+0x16e>
    56cc:	0c c0       	rjmp	.+24     	; 0x56e6 <PutSocketData_RPE+0x132>
				{
					case RAM:	if ( SendData_RPE( Socket, Datalenght % MAX_TCP_Datalenght , &Sendbuffer[i * MAX_TCP_Datalenght ], RAM, TransmissionCounter ) != SOCKET_ERROR )
    56ce:	c5 01       	movw	r24, r10
    56d0:	b4 01       	movw	r22, r8
    56d2:	a6 01       	movw	r20, r12
    56d4:	20 e0       	ldi	r18, 0x00	; 0
    56d6:	0c 81       	ldd	r16, Y+4	; 0x04
    56d8:	1d 81       	ldd	r17, Y+5	; 0x05
    56da:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <SendData_RPE>
    56de:	8f 5f       	subi	r24, 0xFF	; 255
    56e0:	9f 4f       	sbci	r25, 0xFF	; 255
    56e2:	a9 f4       	brne	.+42     	; 0x570e <PutSocketData_RPE+0x15a>
    56e4:	0b c0       	rjmp	.+22     	; 0x56fc <PutSocketData_RPE+0x148>
								{
									Transmission = 0;
									TransmissionCounter++;
								}
								break;
					case FLASH:	if ( SendData_RPE( Socket, Datalenght % MAX_TCP_Datalenght , &Sendbuffer[i * MAX_TCP_Datalenght ], FLASH, TransmissionCounter ) != SOCKET_ERROR )
    56e6:	c5 01       	movw	r24, r10
    56e8:	b4 01       	movw	r22, r8
    56ea:	a6 01       	movw	r20, r12
    56ec:	21 e0       	ldi	r18, 0x01	; 1
    56ee:	0c 81       	ldd	r16, Y+4	; 0x04
    56f0:	1d 81       	ldd	r17, Y+5	; 0x05
    56f2:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <SendData_RPE>
    56f6:	8f 5f       	subi	r24, 0xFF	; 255
    56f8:	9f 4f       	sbci	r25, 0xFF	; 255
    56fa:	49 f4       	brne	.+18     	; 0x570e <PutSocketData_RPE+0x15a>
    56fc:	fd 82       	std	Y+5, r15	; 0x05
    56fe:	ec 82       	std	Y+4, r14	; 0x04
    5700:	08 94       	sec
    5702:	e1 1c       	adc	r14, r1
    5704:	f1 1c       	adc	r15, r1
		// Wenn noch Byte 체brig sind, senden
		if ( ( Datalenght % MAX_TCP_Datalenght ) != 0 )
		{
			Transmission = 0;
			TransmissionCounter = 0;
			while( Transmission == 0 && TransmissionCounter < MAX_TCP_RETRANSMISSIONS )
    5706:	f4 e0       	ldi	r31, 0x04	; 4
    5708:	ef 16       	cp	r14, r31
    570a:	f1 04       	cpc	r15, r1
    570c:	b1 f6       	brne	.-84     	; 0x56ba <PutSocketData_RPE+0x106>
					default:	return( -1 );
				}
			}
		}

		if ( TransmissionCounter == MAX_TCP_RETRANSMISSIONS )
    570e:	8c 81       	ldd	r24, Y+4	; 0x04
    5710:	9d 81       	ldd	r25, Y+5	; 0x05
    5712:	03 97       	sbiw	r24, 0x03	; 3
    5714:	21 f4       	brne	.+8      	; 0x571e <PutSocketData_RPE+0x16a>
		{
			CloseTCPSocket( Socket );
    5716:	c5 01       	movw	r24, r10
    5718:	0e 94 10 2a 	call	0x5420	; 0x5420 <CloseTCPSocket>
    571c:	02 c0       	rjmp	.+4      	; 0x5722 <PutSocketData_RPE+0x16e>
			return( SOCKET_ERROR );
		}
		// anzahl der gesendet daten zur체ck geben
		return( Datalenght );		
    571e:	b2 01       	movw	r22, r4
    5720:	02 c0       	rjmp	.+4      	; 0x5726 <PutSocketData_RPE+0x172>
    5722:	6f ef       	ldi	r22, 0xFF	; 255
    5724:	7f ef       	ldi	r23, 0xFF	; 255
	}
    5726:	cb 01       	movw	r24, r22
    5728:	25 96       	adiw	r28, 0x05	; 5
    572a:	e2 e1       	ldi	r30, 0x12	; 18
    572c:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

00005730 <TCPTimeOutHandler>:
 * \warning Die Funktion wir in der tcp_init() beim timerinterrupt registiert und fortan zyklisch aufgerufen.
 * \retval	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void TCPTimeOutHandler( void )
	{
    5730:	a2 e4       	ldi	r26, 0x42	; 66
    5732:	b0 e0       	ldi	r27, 0x00	; 0
    5734:	ee e9       	ldi	r30, 0x9E	; 158
    5736:	fb e2       	ldi	r31, 0x2B	; 43
    5738:	0c 94 bc 6a 	jmp	0xd578	; 0xd578 <__prologue_saves__+0x6>
		int Socket;
		// durchl채ufe MAX_TCP_CONNECTIONS

		if ( TCP_LOCK == Lock )
    573c:	80 91 3a 01 	lds	r24, 0x013A
    5740:	88 23       	and	r24, r24
    5742:	09 f4       	brne	.+2      	; 0x5746 <TCPTimeOutHandler+0x16>
    5744:	6e c0       	rjmp	.+220    	; 0x5822 <TCPTimeOutHandler+0xf2>
			return;
    5746:	cc 24       	eor	r12, r12
    5748:	dd 24       	eor	r13, r13

		// Die einzelnen Socket nach einander durchgehen
		for ( Socket = 0 ; Socket < MAX_TCP_CONNECTIONS ; Socket ++ )
			{
				// Wenn TimeOutcounter unsgleich 0 dann verringern
				if ( TCP_sockettable[ Socket ].Timeoutcounter != 0 ) TCP_sockettable[ Socket ].Timeoutcounter--;
    574a:	f0 ea       	ldi	r31, 0xA0	; 160
    574c:	af 2e       	mov	r10, r31
    574e:	b1 2c       	mov	r11, r1
					MakeTCPheader( Socket, TCP_FIN_FLAG | TCP_ACK_FLAG , 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FINACK ;						
				}
				else if ( TCP_sockettable[ Socket ].Timeoutcounter == 0 && TCP_sockettable[ Socket ].ConnectionState != SOCKET_NOT_USE )
				{
					MakeTCPheader( Socket, TCP_RST_FLAG , 0 , 0 , ethernetbuffer );
    5750:	4e 01       	movw	r8, r28
    5752:	08 94       	sec
    5754:	81 1c       	adc	r8, r1
    5756:	91 1c       	adc	r9, r1
				unsigned char ethernetbuffer[ ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ];
				LockEthernet();

				if ( ( TCP_sockettable[ Socket ].Timeoutcounter == ( TimeOutCounter / 3 ) ) && TCP_sockettable[ Socket ].ConnectionState != SOCKET_NOT_USE )
				{
					MakeTCPheader( Socket, TCP_FIN_FLAG | TCP_ACK_FLAG , 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5758:	e0 e8       	ldi	r30, 0x80	; 128
    575a:	6e 2e       	mov	r6, r30
    575c:	71 2c       	mov	r7, r1
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FINACK ;						
    575e:	71 e7       	ldi	r23, 0x71	; 113
    5760:	57 2e       	mov	r5, r23

		// Die einzelnen Socket nach einander durchgehen
		for ( Socket = 0 ; Socket < MAX_TCP_CONNECTIONS ; Socket ++ )
			{
				// Wenn TimeOutcounter unsgleich 0 dann verringern
				if ( TCP_sockettable[ Socket ].Timeoutcounter != 0 ) TCP_sockettable[ Socket ].Timeoutcounter--;
    5762:	ca 9c       	mul	r12, r10
    5764:	f0 01       	movw	r30, r0
    5766:	cb 9c       	mul	r12, r11
    5768:	f0 0d       	add	r31, r0
    576a:	da 9c       	mul	r13, r10
    576c:	f0 0d       	add	r31, r0
    576e:	11 24       	eor	r1, r1
    5770:	e7 5f       	subi	r30, 0xF7	; 247
    5772:	f7 4f       	sbci	r31, 0xF7	; 247
    5774:	86 89       	ldd	r24, Z+22	; 0x16
    5776:	97 89       	ldd	r25, Z+23	; 0x17
    5778:	89 2b       	or	r24, r25
    577a:	29 f0       	breq	.+10     	; 0x5786 <TCPTimeOutHandler+0x56>
    577c:	86 89       	ldd	r24, Z+22	; 0x16
    577e:	97 89       	ldd	r25, Z+23	; 0x17
    5780:	01 97       	sbiw	r24, 0x01	; 1
    5782:	97 8b       	std	Z+23, r25	; 0x17
    5784:	86 8b       	std	Z+22, r24	; 0x16

				// Puffer f체r reservieren
				unsigned char ethernetbuffer[ ETHERNET_HEADER_LENGTH + IP_HEADER_LENGHT + TCP_HEADER_LENGHT ];
				LockEthernet();
    5786:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>

				if ( ( TCP_sockettable[ Socket ].Timeoutcounter == ( TimeOutCounter / 3 ) ) && TCP_sockettable[ Socket ].ConnectionState != SOCKET_NOT_USE )
    578a:	ca 9c       	mul	r12, r10
    578c:	70 01       	movw	r14, r0
    578e:	cb 9c       	mul	r12, r11
    5790:	f0 0c       	add	r15, r0
    5792:	da 9c       	mul	r13, r10
    5794:	f0 0c       	add	r15, r0
    5796:	11 24       	eor	r1, r1
    5798:	89 e0       	ldi	r24, 0x09	; 9
    579a:	98 e0       	ldi	r25, 0x08	; 8
    579c:	e8 0e       	add	r14, r24
    579e:	f9 1e       	adc	r15, r25
    57a0:	f7 01       	movw	r30, r14
    57a2:	86 89       	ldd	r24, Z+22	; 0x16
    57a4:	97 89       	ldd	r25, Z+23	; 0x17
    57a6:	0a 97       	sbiw	r24, 0x0a	; 10
    57a8:	a1 f4       	brne	.+40     	; 0x57d2 <TCPTimeOutHandler+0xa2>
    57aa:	80 81       	ld	r24, Z
    57ac:	88 23       	and	r24, r24
    57ae:	89 f0       	breq	.+34     	; 0x57d2 <TCPTimeOutHandler+0xa2>
				{
					MakeTCPheader( Socket, TCP_FIN_FLAG | TCP_ACK_FLAG , 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    57b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    57b2:	97 8d       	ldd	r25, Z+31	; 0x1f
    57b4:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    57b8:	93 01       	movw	r18, r6
    57ba:	28 1b       	sub	r18, r24
    57bc:	39 0b       	sbc	r19, r25
    57be:	c6 01       	movw	r24, r12
    57c0:	61 e1       	ldi	r22, 0x11	; 17
    57c2:	40 e0       	ldi	r20, 0x00	; 0
    57c4:	50 e0       	ldi	r21, 0x00	; 0
    57c6:	84 01       	movw	r16, r8
    57c8:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FINACK ;						
    57cc:	f7 01       	movw	r30, r14
    57ce:	50 82       	st	Z, r5
    57d0:	1e c0       	rjmp	.+60     	; 0x580e <TCPTimeOutHandler+0xde>
				}
				else if ( TCP_sockettable[ Socket ].Timeoutcounter == 0 && TCP_sockettable[ Socket ].ConnectionState != SOCKET_NOT_USE )
    57d2:	ca 9c       	mul	r12, r10
    57d4:	70 01       	movw	r14, r0
    57d6:	cb 9c       	mul	r12, r11
    57d8:	f0 0c       	add	r15, r0
    57da:	da 9c       	mul	r13, r10
    57dc:	f0 0c       	add	r15, r0
    57de:	11 24       	eor	r1, r1
    57e0:	89 e0       	ldi	r24, 0x09	; 9
    57e2:	98 e0       	ldi	r25, 0x08	; 8
    57e4:	e8 0e       	add	r14, r24
    57e6:	f9 1e       	adc	r15, r25
    57e8:	f7 01       	movw	r30, r14
    57ea:	86 89       	ldd	r24, Z+22	; 0x16
    57ec:	97 89       	ldd	r25, Z+23	; 0x17
    57ee:	89 2b       	or	r24, r25
    57f0:	71 f4       	brne	.+28     	; 0x580e <TCPTimeOutHandler+0xde>
    57f2:	80 81       	ld	r24, Z
    57f4:	88 23       	and	r24, r24
    57f6:	59 f0       	breq	.+22     	; 0x580e <TCPTimeOutHandler+0xde>
				{
					MakeTCPheader( Socket, TCP_RST_FLAG , 0 , 0 , ethernetbuffer );
    57f8:	c6 01       	movw	r24, r12
    57fa:	64 e0       	ldi	r22, 0x04	; 4
    57fc:	40 e0       	ldi	r20, 0x00	; 0
    57fe:	50 e0       	ldi	r21, 0x00	; 0
    5800:	20 e0       	ldi	r18, 0x00	; 0
    5802:	30 e0       	ldi	r19, 0x00	; 0
    5804:	84 01       	movw	r16, r8
    5806:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;						
    580a:	f7 01       	movw	r30, r14
    580c:	10 82       	st	Z, r1
				}

				FreeEthernet();
    580e:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>

		if ( TCP_LOCK == Lock )
			return;

		// Die einzelnen Socket nach einander durchgehen
		for ( Socket = 0 ; Socket < MAX_TCP_CONNECTIONS ; Socket ++ )
    5812:	08 94       	sec
    5814:	c1 1c       	adc	r12, r1
    5816:	d1 1c       	adc	r13, r1
    5818:	f3 e0       	ldi	r31, 0x03	; 3
    581a:	cf 16       	cp	r12, r31
    581c:	d1 04       	cpc	r13, r1
    581e:	09 f0       	breq	.+2      	; 0x5822 <TCPTimeOutHandler+0xf2>
    5820:	a0 cf       	rjmp	.-192    	; 0x5762 <TCPTimeOutHandler+0x32>
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;						
				}

				FreeEthernet();
			}
	}
    5822:	ce 5b       	subi	r28, 0xBE	; 190
    5824:	df 4f       	sbci	r29, 0xFF	; 255
    5826:	ef e0       	ldi	r30, 0x0F	; 15
    5828:	0c 94 d8 6a 	jmp	0xd5b0	; 0xd5b0 <__epilogue_restores__+0x6>

0000582c <tcp>:
 * \param 		ethernetbuffer  Zeiger auf den Ethernetbuffer, dieser enthaelt noch die kompletten Header aller Layer.
 * \retval		void
 */
/*------------------------------------------------------------------------------------------------------------*/
void tcp( unsigned int packet_lenght, unsigned char * ethernetbuffer)
	{
    582c:	a4 e0       	ldi	r26, 0x04	; 4
    582e:	b0 e0       	ldi	r27, 0x00	; 0
    5830:	ec e1       	ldi	r30, 0x1C	; 28
    5832:	fc e2       	ldi	r31, 0x2C	; 44
    5834:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    5838:	1b 01       	movw	r2, r22
		char sreg_tmp;
		
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    583a:	8b 01       	movw	r16, r22
    583c:	02 5f       	subi	r16, 0xF2	; 242
    583e:	1f 4f       	sbci	r17, 0xFF	; 255
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];
    5840:	fb 01       	movw	r30, r22
    5842:	86 85       	ldd	r24, Z+14	; 0x0e
    5844:	88 2e       	mov	r8, r24
    5846:	99 24       	eor	r9, r9
    5848:	ff e0       	ldi	r31, 0x0F	; 15
    584a:	8f 22       	and	r8, r31
    584c:	99 24       	eor	r9, r9
    584e:	88 0c       	add	r8, r8
    5850:	99 1c       	adc	r9, r9
    5852:	88 0c       	add	r8, r8
    5854:	99 1c       	adc	r9, r9
    5856:	2e e0       	ldi	r18, 0x0E	; 14
    5858:	30 e0       	ldi	r19, 0x00	; 0
    585a:	82 0e       	add	r8, r18
    585c:	93 1e       	adc	r9, r19
    585e:	86 0e       	add	r8, r22
    5860:	97 1e       	adc	r9, r23
		
		Socket = GetSocket ( ethernetbuffer );
    5862:	cb 01       	movw	r24, r22
    5864:	0e 94 76 25 	call	0x4aec	; 0x4aec <GetSocket>
    5868:	89 83       	std	Y+1, r24	; 0x01
    586a:	9a 83       	std	Y+2, r25	; 0x02
    586c:	2c 01       	movw	r4, r24

		TCP_packet->TCP_ControllFlags &= ( TCP_SYN_FLAG | TCP_ACK_FLAG | TCP_FIN_FLAG );
    586e:	f4 01       	movw	r30, r8
    5870:	85 85       	ldd	r24, Z+13	; 0x0d
    5872:	83 71       	andi	r24, 0x13	; 19
    5874:	85 87       	std	Z+13, r24	; 0x0d

		if ( Socket == SOCKET_ERROR )
    5876:	ff ef       	ldi	r31, 0xFF	; 255
    5878:	4f 16       	cp	r4, r31
    587a:	ff ef       	ldi	r31, 0xFF	; 255
    587c:	5f 06       	cpc	r5, r31
    587e:	c1 f4       	brne	.+48     	; 0x58b0 <tcp+0x84>
		{
			if ( ( CheckPortInList( ChangeEndian16bit ( TCP_packet->TCP_DestinationPort ) ) == SOCKET_ERROR ) ) 
    5880:	f4 01       	movw	r30, r8
    5882:	82 81       	ldd	r24, Z+2	; 0x02
    5884:	93 81       	ldd	r25, Z+3	; 0x03
    5886:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    588a:	ac 01       	movw	r20, r24
    588c:	20 e0       	ldi	r18, 0x00	; 0
    588e:	30 e0       	ldi	r19, 0x00	; 0
	{
		int i;
		
		for ( i = 0 ; i < MAX_LISTEN_PORTS ; i ++ ) 
			{
				if ( TCP_porttable[i].TCP_Port == Port ) return(0);
    5890:	f9 01       	movw	r30, r18
    5892:	ee 0f       	add	r30, r30
    5894:	ff 1f       	adc	r31, r31
    5896:	e7 51       	subi	r30, 0x17	; 23
    5898:	f6 4f       	sbci	r31, 0xF6	; 246
    589a:	80 81       	ld	r24, Z
    589c:	91 81       	ldd	r25, Z+1	; 0x01
    589e:	84 17       	cp	r24, r20
    58a0:	95 07       	cpc	r25, r21
    58a2:	31 f0       	breq	.+12     	; 0x58b0 <tcp+0x84>
/*------------------------------------------------------------------------------------------------------------*/	
int CheckPortInList( unsigned int Port )
	{
		int i;
		
		for ( i = 0 ; i < MAX_LISTEN_PORTS ; i ++ ) 
    58a4:	2f 5f       	subi	r18, 0xFF	; 255
    58a6:	3f 4f       	sbci	r19, 0xFF	; 255
    58a8:	24 30       	cpi	r18, 0x04	; 4
    58aa:	31 05       	cpc	r19, r1
    58ac:	89 f7       	brne	.-30     	; 0x5890 <tcp+0x64>
    58ae:	88 c3       	rjmp	.+1808   	; 0x5fc0 <tcp+0x794>
			{
				return;
			}
		}
		
		if ( TCP_packet->TCP_ControllFlags == TCP_SYN_FLAG ) // Packet mit SYN ?
    58b0:	f4 01       	movw	r30, r8
    58b2:	85 85       	ldd	r24, Z+13	; 0x0d
    58b4:	82 30       	cpi	r24, 0x02	; 2
    58b6:	09 f0       	breq	.+2      	; 0x58ba <tcp+0x8e>
    58b8:	47 c0       	rjmp	.+142    	; 0x5948 <tcp+0x11c>
			{
				Socket = RegisterSocket( ethernetbuffer ) ;
    58ba:	c1 01       	movw	r24, r2
    58bc:	0e 94 f4 26 	call	0x4de8	; 0x4de8 <RegisterSocket>
    58c0:	ac 01       	movw	r20, r24
				if ( Socket != SOCKET_ERROR ) // Verbinung einem neuem Socket zuordnen
    58c2:	ff ef       	ldi	r31, 0xFF	; 255
    58c4:	8f 3f       	cpi	r24, 0xFF	; 255
    58c6:	9f 07       	cpc	r25, r31
    58c8:	09 f4       	brne	.+2      	; 0x58cc <tcp+0xa0>
    58ca:	7a c3       	rjmp	.+1780   	; 0x5fc0 <tcp+0x794>
				{
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_SYNINIT ; // SYNINIT setzen so lange wie das packet noch nicht beantwortet wurde, wird in MakeTCP gebraucht um de MSS zu senden
    58cc:	80 ea       	ldi	r24, 0xA0	; 160
    58ce:	90 e0       	ldi	r25, 0x00	; 0
    58d0:	48 9f       	mul	r20, r24
    58d2:	70 01       	movw	r14, r0
    58d4:	49 9f       	mul	r20, r25
    58d6:	f0 0c       	add	r15, r0
    58d8:	58 9f       	mul	r21, r24
    58da:	f0 0c       	add	r15, r0
    58dc:	11 24       	eor	r1, r1
    58de:	29 e0       	ldi	r18, 0x09	; 9
    58e0:	38 e0       	ldi	r19, 0x08	; 8
    58e2:	e2 0e       	add	r14, r18
    58e4:	f3 1e       	adc	r15, r19
    58e6:	81 e0       	ldi	r24, 0x01	; 1
    58e8:	f7 01       	movw	r30, r14
    58ea:	80 83       	st	Z, r24
					TCP_sockettable[ Socket ].Windowsize = TCP_packet->TCP_Window; // Windowsize setzen, wird gebraucht um zu wissen wiviel gesendet werden kann ohne ACK
    58ec:	f4 01       	movw	r30, r8
    58ee:	86 85       	ldd	r24, Z+14	; 0x0e
    58f0:	97 85       	ldd	r25, Z+15	; 0x0f
    58f2:	f7 01       	movw	r30, r14
    58f4:	93 8b       	std	Z+19, r25	; 0x13
    58f6:	82 8b       	std	Z+18, r24	; 0x12
					TCP_sockettable[ Socket ].AcknowledgeNumber++; // SequenceNumber um 1 erh철hen, das geh철rt zur SYN-sequence dazu
    58f8:	86 85       	ldd	r24, Z+14	; 0x0e
    58fa:	97 85       	ldd	r25, Z+15	; 0x0f
    58fc:	a0 89       	ldd	r26, Z+16	; 0x10
    58fe:	b1 89       	ldd	r27, Z+17	; 0x11
    5900:	01 96       	adiw	r24, 0x01	; 1
    5902:	a1 1d       	adc	r26, r1
    5904:	b1 1d       	adc	r27, r1
    5906:	86 87       	std	Z+14, r24	; 0x0e
    5908:	97 87       	std	Z+15, r25	; 0x0f
    590a:	a0 8b       	std	Z+16, r26	; 0x10
    590c:	b1 8b       	std	Z+17, r27	; 0x11
					MakeTCPheader( Socket, TCP_SYN_FLAG | TCP_ACK_FLAG, 0 , MAX_RECIVEBUFFER_LENGHT , ethernetbuffer ); // Baue mal den TCP-Header mit Berechnung des Pseudoheader
    590e:	ca 01       	movw	r24, r20
    5910:	62 e1       	ldi	r22, 0x12	; 18
    5912:	40 e0       	ldi	r20, 0x00	; 0
    5914:	50 e0       	ldi	r21, 0x00	; 0
    5916:	20 e8       	ldi	r18, 0x80	; 128
    5918:	30 e0       	ldi	r19, 0x00	; 0
    591a:	81 01       	movw	r16, r2
    591c:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
					TCP_sockettable[ Socket ].SequenceNumber++; // SequenceNumber um 1 erh철hen, das geh철rt zur SYN-sequence dazu
    5920:	f7 01       	movw	r30, r14
    5922:	82 85       	ldd	r24, Z+10	; 0x0a
    5924:	93 85       	ldd	r25, Z+11	; 0x0b
    5926:	a4 85       	ldd	r26, Z+12	; 0x0c
    5928:	b5 85       	ldd	r27, Z+13	; 0x0d
    592a:	01 96       	adiw	r24, 0x01	; 1
    592c:	a1 1d       	adc	r26, r1
    592e:	b1 1d       	adc	r27, r1
    5930:	82 87       	std	Z+10, r24	; 0x0a
    5932:	93 87       	std	Z+11, r25	; 0x0b
    5934:	a4 87       	std	Z+12, r26	; 0x0c
    5936:	b5 87       	std	Z+13, r27	; 0x0d
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2SYNACK ; // State f체r den Socket auf WAIT2SYNACK und den den SYN abschlieen zu k철nnen
    5938:	84 e0       	ldi	r24, 0x04	; 4
    593a:	80 83       	st	Z, r24
					TCP_sockettable[ Socket ].SendState = SOCKET_READY2SEND ; // bereit zum senden
    593c:	11 82       	std	Z+1, r1	; 0x01
					TCP_sockettable[ Socket ].Timeoutcounter = 2;
    593e:	82 e0       	ldi	r24, 0x02	; 2
    5940:	90 e0       	ldi	r25, 0x00	; 0
    5942:	97 8b       	std	Z+23, r25	; 0x17
    5944:	86 8b       	std	Z+22, r24	; 0x16
    5946:	3c c3       	rjmp	.+1656   	; 0x5fc0 <tcp+0x794>
				}
				return;
			}
		
		// Wenn immer noch keine Verbindung zugeordnet beenden
		if ( Socket == SOCKET_ERROR ) return;
    5948:	ff ef       	ldi	r31, 0xFF	; 255
    594a:	4f 16       	cp	r4, r31
    594c:	ff ef       	ldi	r31, 0xFF	; 255
    594e:	5f 06       	cpc	r5, r31
    5950:	09 f4       	brne	.+2      	; 0x5954 <tcp+0x128>
    5952:	36 c3       	rjmp	.+1644   	; 0x5fc0 <tcp+0x794>
		// den Timeoutcounter wieder zuruecksetzen f체r die Verbindung auf den zugeordneten Socket
		TCP_sockettable[ Socket ].Timeoutcounter = TimeOutCounter;
    5954:	80 ea       	ldi	r24, 0xA0	; 160
    5956:	90 e0       	ldi	r25, 0x00	; 0
    5958:	48 9e       	mul	r4, r24
    595a:	90 01       	movw	r18, r0
    595c:	49 9e       	mul	r4, r25
    595e:	30 0d       	add	r19, r0
    5960:	58 9e       	mul	r5, r24
    5962:	30 0d       	add	r19, r0
    5964:	11 24       	eor	r1, r1
    5966:	27 5f       	subi	r18, 0xF7	; 247
    5968:	37 4f       	sbci	r19, 0xF7	; 247
    596a:	3c 83       	std	Y+4, r19	; 0x04
    596c:	2b 83       	std	Y+3, r18	; 0x03
    596e:	8e e1       	ldi	r24, 0x1E	; 30
    5970:	90 e0       	ldi	r25, 0x00	; 0
    5972:	f9 01       	movw	r30, r18
    5974:	97 8b       	std	Z+23, r25	; 0x17
    5976:	86 8b       	std	Z+22, r24	; 0x16
				
		if ( TCP_packet->TCP_ControllFlags == ( TCP_SYN_FLAG + TCP_ACK_FLAG ) ) // Packet mit SYN + ACK ?
    5978:	f4 01       	movw	r30, r8
    597a:	85 85       	ldd	r24, Z+13	; 0x0d
    597c:	82 31       	cpi	r24, 0x12	; 18
    597e:	69 f5       	brne	.+90     	; 0x59da <tcp+0x1ae>
			{
				// SequenceNumber um 1 erh철hen, das geh철rt zur SYN-sequence dazu
				TCP_sockettable[ Socket ].SequenceNumber = ChangeEndian32bit( TCP_packet->TCP_AcknowledgeNumber );
    5980:	60 85       	ldd	r22, Z+8	; 0x08
    5982:	71 85       	ldd	r23, Z+9	; 0x09
    5984:	82 85       	ldd	r24, Z+10	; 0x0a
    5986:	93 85       	ldd	r25, Z+11	; 0x0b
    5988:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    598c:	eb 81       	ldd	r30, Y+3	; 0x03
    598e:	fc 81       	ldd	r31, Y+4	; 0x04
    5990:	62 87       	std	Z+10, r22	; 0x0a
    5992:	73 87       	std	Z+11, r23	; 0x0b
    5994:	84 87       	std	Z+12, r24	; 0x0c
    5996:	95 87       	std	Z+13, r25	; 0x0d
				TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit( TCP_packet->TCP_SequenceNumber );
    5998:	f4 01       	movw	r30, r8
    599a:	64 81       	ldd	r22, Z+4	; 0x04
    599c:	75 81       	ldd	r23, Z+5	; 0x05
    599e:	86 81       	ldd	r24, Z+6	; 0x06
    59a0:	97 81       	ldd	r25, Z+7	; 0x07
    59a2:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    59a6:	eb 81       	ldd	r30, Y+3	; 0x03
    59a8:	fc 81       	ldd	r31, Y+4	; 0x04
    59aa:	66 87       	std	Z+14, r22	; 0x0e
    59ac:	77 87       	std	Z+15, r23	; 0x0f
    59ae:	80 8b       	std	Z+16, r24	; 0x10
    59b0:	91 8b       	std	Z+17, r25	; 0x11
				TCP_sockettable[ Socket ].AcknowledgeNumber++;
    59b2:	86 85       	ldd	r24, Z+14	; 0x0e
    59b4:	97 85       	ldd	r25, Z+15	; 0x0f
    59b6:	a0 89       	ldd	r26, Z+16	; 0x10
    59b8:	b1 89       	ldd	r27, Z+17	; 0x11
    59ba:	01 96       	adiw	r24, 0x01	; 1
    59bc:	a1 1d       	adc	r26, r1
    59be:	b1 1d       	adc	r27, r1
    59c0:	86 87       	std	Z+14, r24	; 0x0e
    59c2:	97 87       	std	Z+15, r25	; 0x0f
    59c4:	a0 8b       	std	Z+16, r26	; 0x10
    59c6:	b1 8b       	std	Z+17, r27	; 0x11
				// Windowsize setzen, wird gebraucht um zu wissen wiviel gesendet werden kann ohne ACK
				TCP_sockettable[ Socket ].Windowsize = TCP_packet->TCP_Window; 
    59c8:	f4 01       	movw	r30, r8
    59ca:	86 85       	ldd	r24, Z+14	; 0x0e
    59cc:	97 85       	ldd	r25, Z+15	; 0x0f
    59ce:	eb 81       	ldd	r30, Y+3	; 0x03
    59d0:	fc 81       	ldd	r31, Y+4	; 0x04
    59d2:	93 8b       	std	Z+19, r25	; 0x13
    59d4:	82 8b       	std	Z+18, r24	; 0x12
				// Baue mal den TCP-Header mit Berechnung des Pseudoheader
				// MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , MAX_RECIVEBUFFER_LENGHT , ethernetbuffer );
				TCP_sockettable[ Socket ].ConnectionState = SOCKET_READY ; // State f체r den Socket auf WAIT2SYNACK und den den SYN abschlieen zu k철nnen
    59d6:	80 e1       	ldi	r24, 0x10	; 16
    59d8:	cd c2       	rjmp	.+1434   	; 0x5f74 <tcp+0x748>
				TCP_sockettable[ Socket ].SendState = SOCKET_READY2SEND ; // bereit zum senden
				return;
			}

		// anzahl der Daten im TCP-Datagram berechnen
		i =	( ChangeEndian16bit ( IP_packet->IP_Totallenght )
    59da:	f8 01       	movw	r30, r16
    59dc:	82 81       	ldd	r24, Z+2	; 0x02
    59de:	93 81       	ldd	r25, Z+3	; 0x03
    59e0:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    59e4:	f4 01       	movw	r30, r8
    59e6:	44 85       	ldd	r20, Z+12	; 0x0c
    59e8:	f1 01       	movw	r30, r2
    59ea:	26 85       	ldd	r18, Z+14	; 0x0e
    59ec:	30 e0       	ldi	r19, 0x00	; 0
    59ee:	2f 70       	andi	r18, 0x0F	; 15
    59f0:	30 70       	andi	r19, 0x00	; 0
    59f2:	22 0f       	add	r18, r18
    59f4:	33 1f       	adc	r19, r19
    59f6:	22 0f       	add	r18, r18
    59f8:	33 1f       	adc	r19, r19
    59fa:	50 e0       	ldi	r21, 0x00	; 0
    59fc:	40 7f       	andi	r20, 0xF0	; 240
    59fe:	50 70       	andi	r21, 0x00	; 0
    5a00:	55 95       	asr	r21
    5a02:	47 95       	ror	r20
    5a04:	55 95       	asr	r21
    5a06:	47 95       	ror	r20
    5a08:	3c 01       	movw	r6, r24
    5a0a:	62 1a       	sub	r6, r18
    5a0c:	73 0a       	sbc	r7, r19
    5a0e:	64 1a       	sub	r6, r20
    5a10:	75 0a       	sbc	r7, r21
    5a12:	53 01       	movw	r10, r6
    5a14:	cc 24       	eor	r12, r12
    5a16:	dd 24       	eor	r13, r13
					- ( ( IP_packet->IP_Version_Headerlen & 0x0f ) * 4 + ( ( TCP_packet->TCP_DataOffset & 0xf0 ) >> 2 ) ) ) ;
		
		if ( Get_FIFOrestsize( TCP_sockettable[ Socket ].fifo ) < i )
    5a18:	eb 81       	ldd	r30, Y+3	; 0x03
    5a1a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    5a1e:	97 8d       	ldd	r25, Z+31	; 0x1f
    5a20:	0e 94 63 3e 	call	0x7cc6	; 0x7cc6 <Get_FIFOrestsize>
    5a24:	aa 27       	eor	r26, r26
    5a26:	97 fd       	sbrc	r25, 7
    5a28:	a0 95       	com	r26
    5a2a:	ba 2f       	mov	r27, r26
    5a2c:	8a 15       	cp	r24, r10
    5a2e:	9b 05       	cpc	r25, r11
    5a30:	ac 05       	cpc	r26, r12
    5a32:	bd 05       	cpc	r27, r13
    5a34:	08 f4       	brcc	.+2      	; 0x5a38 <tcp+0x20c>
    5a36:	c4 c2       	rjmp	.+1416   	; 0x5fc0 <tcp+0x794>
		{
			return;
		}
		
		// Wenn Daten vorhanden einffach mal kopieren in den Socket-Puffer und best채tigung senden
		if ( i != 0 )
    5a38:	a1 14       	cp	r10, r1
    5a3a:	b1 04       	cpc	r11, r1
    5a3c:	c1 04       	cpc	r12, r1
    5a3e:	d1 04       	cpc	r13, r1
    5a40:	09 f4       	brne	.+2      	; 0x5a44 <tcp+0x218>
    5a42:	68 c1       	rjmp	.+720    	; 0x5d14 <tcp+0x4e8>
		{
			// Richtige Reihnfolger der Daten ?
			// Hier kann erzwungen werden das die in der richtigen reihnfolge ankommen, 
			// wenn nicht wird ein ACK-Packet mit einer alten Seqnummer gesendet
			if ( ( TCP_sockettable[ Socket ].AcknowledgeNumber ) == ( ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) ) )
    5a44:	eb 81       	ldd	r30, Y+3	; 0x03
    5a46:	fc 81       	ldd	r31, Y+4	; 0x04
    5a48:	e6 84       	ldd	r14, Z+14	; 0x0e
    5a4a:	f7 84       	ldd	r15, Z+15	; 0x0f
    5a4c:	00 89       	ldd	r16, Z+16	; 0x10
    5a4e:	11 89       	ldd	r17, Z+17	; 0x11
    5a50:	f4 01       	movw	r30, r8
    5a52:	64 81       	ldd	r22, Z+4	; 0x04
    5a54:	75 81       	ldd	r23, Z+5	; 0x05
    5a56:	86 81       	ldd	r24, Z+6	; 0x06
    5a58:	97 81       	ldd	r25, Z+7	; 0x07
    5a5a:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5a5e:	e6 16       	cp	r14, r22
    5a60:	f7 06       	cpc	r15, r23
    5a62:	08 07       	cpc	r16, r24
    5a64:	19 07       	cpc	r17, r25
    5a66:	09 f0       	breq	.+2      	; 0x5a6a <tcp+0x23e>
    5a68:	b2 c0       	rjmp	.+356    	; 0x5bce <tcp+0x3a2>
			{
				// Wenn kopieren in Puffer ok war, Acknummer richtig setzen, sonst nix machen, dann wird automatisch die alte Seqnummer gesendet
				// mit der richtigen Windowsize
				if ( CopyTCPdata2socketbuffer( Socket, i , ethernetbuffer ) != SOCKET_ERROR )
    5a6a:	89 81       	ldd	r24, Y+1	; 0x01
    5a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    5a6e:	b3 01       	movw	r22, r6
    5a70:	a1 01       	movw	r20, r2
    5a72:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <CopyTCPdata2socketbuffer>
    5a76:	8f 5f       	subi	r24, 0xFF	; 255
    5a78:	9f 4f       	sbci	r25, 0xFF	; 255
    5a7a:	89 f0       	breq	.+34     	; 0x5a9e <tcp+0x272>
					TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) + i ;					
    5a7c:	f4 01       	movw	r30, r8
    5a7e:	64 81       	ldd	r22, Z+4	; 0x04
    5a80:	75 81       	ldd	r23, Z+5	; 0x05
    5a82:	86 81       	ldd	r24, Z+6	; 0x06
    5a84:	97 81       	ldd	r25, Z+7	; 0x07
    5a86:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5a8a:	6a 0d       	add	r22, r10
    5a8c:	7b 1d       	adc	r23, r11
    5a8e:	8c 1d       	adc	r24, r12
    5a90:	9d 1d       	adc	r25, r13
    5a92:	eb 81       	ldd	r30, Y+3	; 0x03
    5a94:	fc 81       	ldd	r31, Y+4	; 0x04
    5a96:	66 87       	std	Z+14, r22	; 0x0e
    5a98:	77 87       	std	Z+15, r23	; 0x0f
    5a9a:	80 8b       	std	Z+16, r24	; 0x10
    5a9c:	91 8b       	std	Z+17, r25	; 0x11

				// ACK senden
				MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5a9e:	80 ea       	ldi	r24, 0xA0	; 160
    5aa0:	90 e0       	ldi	r25, 0x00	; 0
    5aa2:	48 9e       	mul	r4, r24
    5aa4:	70 01       	movw	r14, r0
    5aa6:	49 9e       	mul	r4, r25
    5aa8:	f0 0c       	add	r15, r0
    5aaa:	58 9e       	mul	r5, r24
    5aac:	f0 0c       	add	r15, r0
    5aae:	11 24       	eor	r1, r1
    5ab0:	29 e0       	ldi	r18, 0x09	; 9
    5ab2:	38 e0       	ldi	r19, 0x08	; 8
    5ab4:	e2 0e       	add	r14, r18
    5ab6:	f3 1e       	adc	r15, r19
    5ab8:	f7 01       	movw	r30, r14
    5aba:	86 8d       	ldd	r24, Z+30	; 0x1e
    5abc:	97 8d       	ldd	r25, Z+31	; 0x1f
    5abe:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5ac2:	20 e8       	ldi	r18, 0x80	; 128
    5ac4:	30 e0       	ldi	r19, 0x00	; 0
    5ac6:	28 1b       	sub	r18, r24
    5ac8:	39 0b       	sbc	r19, r25
    5aca:	89 81       	ldd	r24, Y+1	; 0x01
    5acc:	9a 81       	ldd	r25, Y+2	; 0x02
    5ace:	60 e1       	ldi	r22, 0x10	; 16
    5ad0:	40 e0       	ldi	r20, 0x00	; 0
    5ad2:	50 e0       	ldi	r21, 0x00	; 0
    5ad4:	81 01       	movw	r16, r2
    5ad6:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>

				#ifdef TCP_with_unsortseq
				// schau mal nach ob vorher ein TCP-Packet kam was in der falschen Reinfolge an kam
				if ( TCP_Unsort.socket == Socket && TCP_Unsort.lenght != 0 )
    5ada:	60 90 f3 09 	lds	r6, 0x09F3
    5ade:	70 90 f4 09 	lds	r7, 0x09F4
    5ae2:	64 14       	cp	r6, r4
    5ae4:	75 04       	cpc	r7, r5
    5ae6:	09 f0       	breq	.+2      	; 0x5aea <tcp+0x2be>
    5ae8:	6d c0       	rjmp	.+218    	; 0x5bc4 <tcp+0x398>
    5aea:	20 91 f1 09 	lds	r18, 0x09F1
    5aee:	30 91 f2 09 	lds	r19, 0x09F2
    5af2:	21 15       	cp	r18, r1
    5af4:	31 05       	cpc	r19, r1
    5af6:	09 f4       	brne	.+2      	; 0x5afa <tcp+0x2ce>
    5af8:	65 c0       	rjmp	.+202    	; 0x5bc4 <tcp+0x398>
				{
					if ( TCP_sockettable[ Socket ].AcknowledgeNumber + TCP_Unsort.lenght == TCP_Unsort.Sequencenumber + TCP_Unsort.lenght )
    5afa:	f7 01       	movw	r30, r14
    5afc:	86 85       	ldd	r24, Z+14	; 0x0e
    5afe:	97 85       	ldd	r25, Z+15	; 0x0f
    5b00:	a0 89       	ldd	r26, Z+16	; 0x10
    5b02:	b1 89       	ldd	r27, Z+17	; 0x11
    5b04:	40 e0       	ldi	r20, 0x00	; 0
    5b06:	50 e0       	ldi	r21, 0x00	; 0
    5b08:	82 0f       	add	r24, r18
    5b0a:	93 1f       	adc	r25, r19
    5b0c:	a4 1f       	adc	r26, r20
    5b0e:	b5 1f       	adc	r27, r21
    5b10:	e0 90 f5 09 	lds	r14, 0x09F5
    5b14:	f0 90 f6 09 	lds	r15, 0x09F6
    5b18:	00 91 f7 09 	lds	r16, 0x09F7
    5b1c:	10 91 f8 09 	lds	r17, 0x09F8
    5b20:	2e 0d       	add	r18, r14
    5b22:	3f 1d       	adc	r19, r15
    5b24:	40 1f       	adc	r20, r16
    5b26:	51 1f       	adc	r21, r17
    5b28:	82 17       	cp	r24, r18
    5b2a:	93 07       	cpc	r25, r19
    5b2c:	a4 07       	cpc	r26, r20
    5b2e:	b5 07       	cpc	r27, r21
    5b30:	09 f0       	breq	.+2      	; 0x5b34 <tcp+0x308>
    5b32:	3f c0       	rjmp	.+126    	; 0x5bb2 <tcp+0x386>
					{
						LockEthernet();
    5b34:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
						// SREG sichern um state zu behalten und interrupts freigeben
						sreg_tmp = SREG;
    5b38:	ff b6       	in	r15, 0x3f	; 63
						sei();
    5b3a:	78 94       	sei
						Put_Block_in_FIFO ( TCP_sockettable[ Socket ].fifo , TCP_Unsort.lenght, TCP_Unsort.Recivebuffer );
    5b3c:	80 ea       	ldi	r24, 0xA0	; 160
    5b3e:	90 e0       	ldi	r25, 0x00	; 0
    5b40:	68 9e       	mul	r6, r24
    5b42:	80 01       	movw	r16, r0
    5b44:	69 9e       	mul	r6, r25
    5b46:	10 0d       	add	r17, r0
    5b48:	78 9e       	mul	r7, r24
    5b4a:	10 0d       	add	r17, r0
    5b4c:	11 24       	eor	r1, r1
    5b4e:	07 5f       	subi	r16, 0xF7	; 247
    5b50:	17 4f       	sbci	r17, 0xF7	; 247
    5b52:	f8 01       	movw	r30, r16
    5b54:	86 8d       	ldd	r24, Z+30	; 0x1e
    5b56:	97 8d       	ldd	r25, Z+31	; 0x1f
    5b58:	60 91 f1 09 	lds	r22, 0x09F1
    5b5c:	70 91 f2 09 	lds	r23, 0x09F2
    5b60:	49 ef       	ldi	r20, 0xF9	; 249
    5b62:	59 e0       	ldi	r21, 0x09	; 9
    5b64:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <Put_Block_in_FIFO>
						// SREG wiederherstellen
						SREG = sreg_tmp;
    5b68:	ff be       	out	0x3f, r15	; 63
						FreeEthernet();
    5b6a:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
						
						TCP_sockettable[ Socket ].AcknowledgeNumber = TCP_Unsort.Sequencenumber + i ;
    5b6e:	80 91 f5 09 	lds	r24, 0x09F5
    5b72:	90 91 f6 09 	lds	r25, 0x09F6
    5b76:	a0 91 f7 09 	lds	r26, 0x09F7
    5b7a:	b0 91 f8 09 	lds	r27, 0x09F8
    5b7e:	a8 0e       	add	r10, r24
    5b80:	b9 1e       	adc	r11, r25
    5b82:	ca 1e       	adc	r12, r26
    5b84:	db 1e       	adc	r13, r27
    5b86:	f8 01       	movw	r30, r16
    5b88:	a6 86       	std	Z+14, r10	; 0x0e
    5b8a:	b7 86       	std	Z+15, r11	; 0x0f
    5b8c:	c0 8a       	std	Z+16, r12	; 0x10
    5b8e:	d1 8a       	std	Z+17, r13	; 0x11
						MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5b90:	86 8d       	ldd	r24, Z+30	; 0x1e
    5b92:	97 8d       	ldd	r25, Z+31	; 0x1f
    5b94:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5b98:	20 e8       	ldi	r18, 0x80	; 128
    5b9a:	30 e0       	ldi	r19, 0x00	; 0
    5b9c:	28 1b       	sub	r18, r24
    5b9e:	39 0b       	sbc	r19, r25
    5ba0:	89 81       	ldd	r24, Y+1	; 0x01
    5ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ba4:	60 e1       	ldi	r22, 0x10	; 16
    5ba6:	40 e0       	ldi	r20, 0x00	; 0
    5ba8:	50 e0       	ldi	r21, 0x00	; 0
    5baa:	81 01       	movw	r16, r2
    5bac:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
    5bb0:	09 c0       	rjmp	.+18     	; 0x5bc4 <tcp+0x398>
					}
					else
					{
						RXErrorCounter++;
    5bb2:	80 91 d1 01 	lds	r24, 0x01D1
    5bb6:	90 91 d2 01 	lds	r25, 0x01D2
    5bba:	01 96       	adiw	r24, 0x01	; 1
    5bbc:	90 93 d2 01 	sts	0x01D2, r25
    5bc0:	80 93 d1 01 	sts	0x01D1, r24
					}
				}
				TCP_Unsort.lenght = 0;
    5bc4:	10 92 f2 09 	sts	0x09F2, r1
    5bc8:	10 92 f1 09 	sts	0x09F1, r1
    5bcc:	a3 c0       	rjmp	.+326    	; 0x5d14 <tcp+0x4e8>
			else
			{
				
				// Naja, falsche reihnfolge kann man nur sagen :-) aber kein Problem
				// alte sequencenummer ? wenn ja nochmal best채tigen
				if ( ( TCP_sockettable[ Socket ].AcknowledgeNumber + i ) > ( ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) + i ) )
    5bce:	eb 81       	ldd	r30, Y+3	; 0x03
    5bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    5bd2:	e6 84       	ldd	r14, Z+14	; 0x0e
    5bd4:	f7 84       	ldd	r15, Z+15	; 0x0f
    5bd6:	00 89       	ldd	r16, Z+16	; 0x10
    5bd8:	11 89       	ldd	r17, Z+17	; 0x11
    5bda:	f4 01       	movw	r30, r8
    5bdc:	64 81       	ldd	r22, Z+4	; 0x04
    5bde:	75 81       	ldd	r23, Z+5	; 0x05
    5be0:	86 81       	ldd	r24, Z+6	; 0x06
    5be2:	97 81       	ldd	r25, Z+7	; 0x07
    5be4:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5be8:	ea 0c       	add	r14, r10
    5bea:	fb 1c       	adc	r15, r11
    5bec:	0c 1d       	adc	r16, r12
    5bee:	1d 1d       	adc	r17, r13
    5bf0:	a6 0e       	add	r10, r22
    5bf2:	b7 1e       	adc	r11, r23
    5bf4:	c8 1e       	adc	r12, r24
    5bf6:	d9 1e       	adc	r13, r25
    5bf8:	ae 14       	cp	r10, r14
    5bfa:	bf 04       	cpc	r11, r15
    5bfc:	c0 06       	cpc	r12, r16
    5bfe:	d1 06       	cpc	r13, r17
    5c00:	88 f5       	brcc	.+98     	; 0x5c64 <tcp+0x438>
				{
					unsigned long ACK;
					
					ACK = TCP_sockettable[ Socket ].AcknowledgeNumber;
    5c02:	eb 81       	ldd	r30, Y+3	; 0x03
    5c04:	fc 81       	ldd	r31, Y+4	; 0x04
    5c06:	c6 84       	ldd	r12, Z+14	; 0x0e
    5c08:	d7 84       	ldd	r13, Z+15	; 0x0f
    5c0a:	e0 88       	ldd	r14, Z+16	; 0x10
    5c0c:	f1 88       	ldd	r15, Z+17	; 0x11
					TCP_sockettable[ Socket ].AcknowledgeNumber = TCP_packet->TCP_SequenceNumber;
    5c0e:	f4 01       	movw	r30, r8
    5c10:	84 81       	ldd	r24, Z+4	; 0x04
    5c12:	95 81       	ldd	r25, Z+5	; 0x05
    5c14:	a6 81       	ldd	r26, Z+6	; 0x06
    5c16:	b7 81       	ldd	r27, Z+7	; 0x07
    5c18:	eb 81       	ldd	r30, Y+3	; 0x03
    5c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    5c1c:	86 87       	std	Z+14, r24	; 0x0e
    5c1e:	97 87       	std	Z+15, r25	; 0x0f
    5c20:	a0 8b       	std	Z+16, r26	; 0x10
    5c22:	b1 8b       	std	Z+17, r27	; 0x11
					MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5c24:	86 8d       	ldd	r24, Z+30	; 0x1e
    5c26:	97 8d       	ldd	r25, Z+31	; 0x1f
    5c28:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5c2c:	20 e8       	ldi	r18, 0x80	; 128
    5c2e:	30 e0       	ldi	r19, 0x00	; 0
    5c30:	28 1b       	sub	r18, r24
    5c32:	39 0b       	sbc	r19, r25
    5c34:	89 81       	ldd	r24, Y+1	; 0x01
    5c36:	9a 81       	ldd	r25, Y+2	; 0x02
    5c38:	60 e1       	ldi	r22, 0x10	; 16
    5c3a:	40 e0       	ldi	r20, 0x00	; 0
    5c3c:	50 e0       	ldi	r21, 0x00	; 0
    5c3e:	81 01       	movw	r16, r2
    5c40:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
					TCP_sockettable[ Socket ].AcknowledgeNumber = ACK;
    5c44:	eb 81       	ldd	r30, Y+3	; 0x03
    5c46:	fc 81       	ldd	r31, Y+4	; 0x04
    5c48:	c6 86       	std	Z+14, r12	; 0x0e
    5c4a:	d7 86       	std	Z+15, r13	; 0x0f
    5c4c:	e0 8a       	std	Z+16, r14	; 0x10
    5c4e:	f1 8a       	std	Z+17, r15	; 0x11
					
					RXErrorOldSeq++;
    5c50:	80 91 d3 01 	lds	r24, 0x01D3
    5c54:	90 91 d4 01 	lds	r25, 0x01D4
    5c58:	01 96       	adiw	r24, 0x01	; 1
    5c5a:	90 93 d4 01 	sts	0x01D4, r25
    5c5e:	80 93 d3 01 	sts	0x01D3, r24
    5c62:	58 c0       	rjmp	.+176    	; 0x5d14 <tcp+0x4e8>
				}
				#ifdef TCP_with_unsortseq
				else
				{
					// speicher mal die Daten zwischen, damit sie nicht verloren gehen, aber nur wenn der Puffer noch nicht belegt ist, sonst RX-Error
					if ( TCP_Unsort.lenght == 0 )
    5c64:	80 91 f1 09 	lds	r24, 0x09F1
    5c68:	90 91 f2 09 	lds	r25, 0x09F2
    5c6c:	89 2b       	or	r24, r25
    5c6e:	09 f0       	breq	.+2      	; 0x5c72 <tcp+0x446>
    5c70:	48 c0       	rjmp	.+144    	; 0x5d02 <tcp+0x4d6>
					{
						unsigned int Offset = ETHERNET_HEADER_LENGTH + ( IP_packet->IP_Version_Headerlen & 0x0f ) * 4 + ( ( TCP_packet->TCP_DataOffset & 0xf0 ) >> 2 ) ;				
    5c72:	f4 01       	movw	r30, r8
    5c74:	84 85       	ldd	r24, Z+12	; 0x0c
    5c76:	f1 01       	movw	r30, r2
    5c78:	06 85       	ldd	r16, Z+14	; 0x0e
    5c7a:	10 e0       	ldi	r17, 0x00	; 0
    5c7c:	0f 70       	andi	r16, 0x0F	; 15
    5c7e:	10 70       	andi	r17, 0x00	; 0
    5c80:	00 0f       	add	r16, r16
    5c82:	11 1f       	adc	r17, r17
    5c84:	00 0f       	add	r16, r16
    5c86:	11 1f       	adc	r17, r17
    5c88:	90 e0       	ldi	r25, 0x00	; 0
    5c8a:	80 7f       	andi	r24, 0xF0	; 240
    5c8c:	90 70       	andi	r25, 0x00	; 0
    5c8e:	95 95       	asr	r25
    5c90:	87 95       	ror	r24
    5c92:	95 95       	asr	r25
    5c94:	87 95       	ror	r24
    5c96:	08 0f       	add	r16, r24
    5c98:	19 1f       	adc	r17, r25
    5c9a:	02 5f       	subi	r16, 0xF2	; 242
    5c9c:	1f 4f       	sbci	r17, 0xFF	; 255
						TCP_Unsort.Sequencenumber = ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber );
    5c9e:	f4 01       	movw	r30, r8
    5ca0:	64 81       	ldd	r22, Z+4	; 0x04
    5ca2:	75 81       	ldd	r23, Z+5	; 0x05
    5ca4:	86 81       	ldd	r24, Z+6	; 0x06
    5ca6:	97 81       	ldd	r25, Z+7	; 0x07
    5ca8:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5cac:	60 93 f5 09 	sts	0x09F5, r22
    5cb0:	70 93 f6 09 	sts	0x09F6, r23
    5cb4:	80 93 f7 09 	sts	0x09F7, r24
    5cb8:	90 93 f8 09 	sts	0x09F8, r25
						TCP_Unsort.socket = Socket ;
    5cbc:	50 92 f4 09 	sts	0x09F4, r5
    5cc0:	40 92 f3 09 	sts	0x09F3, r4
						
						LockEthernet();
    5cc4:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
						// SREG sichern um state zu behalten und interrupts freigeben
						sreg_tmp = SREG;
    5cc8:	ff b6       	in	r15, 0x3f	; 63
						sei();
    5cca:	78 94       	sei
						memcpy( &TCP_Unsort.Recivebuffer , &ethernetbuffer[ Offset ] , i );
    5ccc:	29 ef       	ldi	r18, 0xF9	; 249
    5cce:	39 e0       	ldi	r19, 0x09	; 9
    5cd0:	a1 01       	movw	r20, r2
    5cd2:	40 0f       	add	r20, r16
    5cd4:	51 1f       	adc	r21, r17
    5cd6:	c9 01       	movw	r24, r18
    5cd8:	ba 01       	movw	r22, r20
    5cda:	a3 01       	movw	r20, r6
    5cdc:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
						// SREG wiederherstellen
						SREG = sreg_tmp;
    5ce0:	ff be       	out	0x3f, r15	; 63
						FreeEthernet();
    5ce2:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
						
						TCP_Unsort.lenght = i;					
    5ce6:	70 92 f2 09 	sts	0x09F2, r7
    5cea:	60 92 f1 09 	sts	0x09F1, r6
						RXErrorUnsort++;
    5cee:	80 91 d5 01 	lds	r24, 0x01D5
    5cf2:	90 91 d6 01 	lds	r25, 0x01D6
    5cf6:	01 96       	adiw	r24, 0x01	; 1
    5cf8:	90 93 d6 01 	sts	0x01D6, r25
    5cfc:	80 93 d5 01 	sts	0x01D5, r24
    5d00:	09 c0       	rjmp	.+18     	; 0x5d14 <tcp+0x4e8>
						}
					else
					{
						RXErrorCounter++;
    5d02:	80 91 d1 01 	lds	r24, 0x01D1
    5d06:	90 91 d2 01 	lds	r25, 0x01D2
    5d0a:	01 96       	adiw	r24, 0x01	; 1
    5d0c:	90 93 d2 01 	sts	0x01D2, r25
    5d10:	80 93 d1 01 	sts	0x01D1, r24
				#endif
			}
		}

		// Anforderung f체r das schliessen des Socket/Verbindung
		if ( TCP_packet->TCP_ControllFlags == ( TCP_FIN_FLAG ) )
    5d14:	f4 01       	movw	r30, r8
    5d16:	85 85       	ldd	r24, Z+13	; 0x0d
    5d18:	81 30       	cpi	r24, 0x01	; 1
    5d1a:	09 f0       	breq	.+2      	; 0x5d1e <tcp+0x4f2>
    5d1c:	a9 c0       	rjmp	.+338    	; 0x5e70 <tcp+0x644>
		{
			// haben wir die Schliessung angefordert ?
			if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_WAIT2FIN )
    5d1e:	80 ea       	ldi	r24, 0xA0	; 160
    5d20:	90 e0       	ldi	r25, 0x00	; 0
    5d22:	48 9e       	mul	r4, r24
    5d24:	70 01       	movw	r14, r0
    5d26:	49 9e       	mul	r4, r25
    5d28:	f0 0c       	add	r15, r0
    5d2a:	58 9e       	mul	r5, r24
    5d2c:	f0 0c       	add	r15, r0
    5d2e:	11 24       	eor	r1, r1
    5d30:	29 e0       	ldi	r18, 0x09	; 9
    5d32:	38 e0       	ldi	r19, 0x08	; 8
    5d34:	e2 0e       	add	r14, r18
    5d36:	f3 1e       	adc	r15, r19
    5d38:	f7 01       	movw	r30, r14
    5d3a:	80 81       	ld	r24, Z
    5d3c:	82 37       	cpi	r24, 0x72	; 114
    5d3e:	21 f5       	brne	.+72     	; 0x5d88 <tcp+0x55c>
			{
				TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) + 1;
    5d40:	f4 01       	movw	r30, r8
    5d42:	64 81       	ldd	r22, Z+4	; 0x04
    5d44:	75 81       	ldd	r23, Z+5	; 0x05
    5d46:	86 81       	ldd	r24, Z+6	; 0x06
    5d48:	97 81       	ldd	r25, Z+7	; 0x07
    5d4a:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5d4e:	6f 5f       	subi	r22, 0xFF	; 255
    5d50:	7f 4f       	sbci	r23, 0xFF	; 255
    5d52:	8f 4f       	sbci	r24, 0xFF	; 255
    5d54:	9f 4f       	sbci	r25, 0xFF	; 255
    5d56:	f7 01       	movw	r30, r14
    5d58:	66 87       	std	Z+14, r22	; 0x0e
    5d5a:	77 87       	std	Z+15, r23	; 0x0f
    5d5c:	80 8b       	std	Z+16, r24	; 0x10
    5d5e:	91 8b       	std	Z+17, r25	; 0x11
				MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5d60:	86 8d       	ldd	r24, Z+30	; 0x1e
    5d62:	97 8d       	ldd	r25, Z+31	; 0x1f
    5d64:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5d68:	20 e8       	ldi	r18, 0x80	; 128
    5d6a:	30 e0       	ldi	r19, 0x00	; 0
    5d6c:	28 1b       	sub	r18, r24
    5d6e:	39 0b       	sbc	r19, r25
    5d70:	89 81       	ldd	r24, Y+1	; 0x01
    5d72:	9a 81       	ldd	r25, Y+2	; 0x02
    5d74:	60 e1       	ldi	r22, 0x10	; 16
    5d76:	40 e0       	ldi	r20, 0x00	; 0
    5d78:	50 e0       	ldi	r21, 0x00	; 0
    5d7a:	81 01       	movw	r16, r2
    5d7c:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
				#ifdef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = CloseTimeout ;
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
				#endif
				#ifndef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = 0 ;
    5d80:	f7 01       	movw	r30, r14
    5d82:	17 8a       	std	Z+23, r1	; 0x17
    5d84:	16 8a       	std	Z+22, r1	; 0x16
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
    5d86:	10 82       	st	Z, r1
				#endif
			}
			// haben wir die Schliessung angefordert ?
			if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_WAIT2FINACK )
    5d88:	80 ea       	ldi	r24, 0xA0	; 160
    5d8a:	90 e0       	ldi	r25, 0x00	; 0
    5d8c:	48 9e       	mul	r4, r24
    5d8e:	70 01       	movw	r14, r0
    5d90:	49 9e       	mul	r4, r25
    5d92:	f0 0c       	add	r15, r0
    5d94:	58 9e       	mul	r5, r24
    5d96:	f0 0c       	add	r15, r0
    5d98:	11 24       	eor	r1, r1
    5d9a:	29 e0       	ldi	r18, 0x09	; 9
    5d9c:	38 e0       	ldi	r19, 0x08	; 8
    5d9e:	e2 0e       	add	r14, r18
    5da0:	f3 1e       	adc	r15, r19
    5da2:	f7 01       	movw	r30, r14
    5da4:	80 81       	ld	r24, Z
    5da6:	81 37       	cpi	r24, 0x71	; 113
    5da8:	29 f5       	brne	.+74     	; 0x5df4 <tcp+0x5c8>
			{
				TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) + 1;
    5daa:	f4 01       	movw	r30, r8
    5dac:	64 81       	ldd	r22, Z+4	; 0x04
    5dae:	75 81       	ldd	r23, Z+5	; 0x05
    5db0:	86 81       	ldd	r24, Z+6	; 0x06
    5db2:	97 81       	ldd	r25, Z+7	; 0x07
    5db4:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5db8:	6f 5f       	subi	r22, 0xFF	; 255
    5dba:	7f 4f       	sbci	r23, 0xFF	; 255
    5dbc:	8f 4f       	sbci	r24, 0xFF	; 255
    5dbe:	9f 4f       	sbci	r25, 0xFF	; 255
    5dc0:	f7 01       	movw	r30, r14
    5dc2:	66 87       	std	Z+14, r22	; 0x0e
    5dc4:	77 87       	std	Z+15, r23	; 0x0f
    5dc6:	80 8b       	std	Z+16, r24	; 0x10
    5dc8:	91 8b       	std	Z+17, r25	; 0x11
				MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5dca:	86 8d       	ldd	r24, Z+30	; 0x1e
    5dcc:	97 8d       	ldd	r25, Z+31	; 0x1f
    5dce:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5dd2:	20 e8       	ldi	r18, 0x80	; 128
    5dd4:	30 e0       	ldi	r19, 0x00	; 0
    5dd6:	28 1b       	sub	r18, r24
    5dd8:	39 0b       	sbc	r19, r25
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
    5ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dde:	60 e1       	ldi	r22, 0x10	; 16
    5de0:	40 e0       	ldi	r20, 0x00	; 0
    5de2:	50 e0       	ldi	r21, 0x00	; 0
    5de4:	81 01       	movw	r16, r2
    5de6:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
				#ifdef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = CloseTimeout ;
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
				#endif
				#ifndef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = 0 ;
    5dea:	f7 01       	movw	r30, r14
    5dec:	17 8a       	std	Z+23, r1	; 0x17
    5dee:	16 8a       	std	Z+22, r1	; 0x16
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
    5df0:	10 82       	st	Z, r1
    5df2:	27 c0       	rjmp	.+78     	; 0x5e42 <tcp+0x616>
				#endif
			}
			// Client hat Schliessung angefordert
			else if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_READY ) 
    5df4:	f7 01       	movw	r30, r14
    5df6:	80 81       	ld	r24, Z
    5df8:	80 31       	cpi	r24, 0x10	; 16
    5dfa:	19 f5       	brne	.+70     	; 0x5e42 <tcp+0x616>
			{
				TCP_sockettable[ Socket ].SequenceNumber = ChangeEndian32bit ( TCP_packet->TCP_AcknowledgeNumber ) + 1;
    5dfc:	f4 01       	movw	r30, r8
    5dfe:	60 85       	ldd	r22, Z+8	; 0x08
    5e00:	71 85       	ldd	r23, Z+9	; 0x09
    5e02:	82 85       	ldd	r24, Z+10	; 0x0a
    5e04:	93 85       	ldd	r25, Z+11	; 0x0b
    5e06:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5e0a:	6f 5f       	subi	r22, 0xFF	; 255
    5e0c:	7f 4f       	sbci	r23, 0xFF	; 255
    5e0e:	8f 4f       	sbci	r24, 0xFF	; 255
    5e10:	9f 4f       	sbci	r25, 0xFF	; 255
    5e12:	f7 01       	movw	r30, r14
    5e14:	62 87       	std	Z+10, r22	; 0x0a
    5e16:	73 87       	std	Z+11, r23	; 0x0b
    5e18:	84 87       	std	Z+12, r24	; 0x0c
    5e1a:	95 87       	std	Z+13, r25	; 0x0d
				MakeTCPheader( Socket, TCP_ACK_FLAG | TCP_FIN_FLAG , 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5e1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    5e1e:	97 8d       	ldd	r25, Z+31	; 0x1f
    5e20:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5e24:	20 e8       	ldi	r18, 0x80	; 128
    5e26:	30 e0       	ldi	r19, 0x00	; 0
    5e28:	28 1b       	sub	r18, r24
    5e2a:	39 0b       	sbc	r19, r25
    5e2c:	89 81       	ldd	r24, Y+1	; 0x01
    5e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e30:	61 e1       	ldi	r22, 0x11	; 17
    5e32:	40 e0       	ldi	r20, 0x00	; 0
    5e34:	50 e0       	ldi	r21, 0x00	; 0
    5e36:	81 01       	movw	r16, r2
    5e38:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
//				MakeTCPheader( Socket, TCP_ACK_FLAG , 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
				TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FIN ;
    5e3c:	82 e7       	ldi	r24, 0x72	; 114
    5e3e:	f7 01       	movw	r30, r14
    5e40:	80 83       	st	Z, r24
			}				

			// Laut RFC ist Seqnummer um 1 zu erh철hen beim FIN
			TCP_sockettable[ Socket ].SequenceNumber++;
    5e42:	80 ea       	ldi	r24, 0xA0	; 160
    5e44:	90 e0       	ldi	r25, 0x00	; 0
    5e46:	48 9e       	mul	r4, r24
    5e48:	f0 01       	movw	r30, r0
    5e4a:	49 9e       	mul	r4, r25
    5e4c:	f0 0d       	add	r31, r0
    5e4e:	58 9e       	mul	r5, r24
    5e50:	f0 0d       	add	r31, r0
    5e52:	11 24       	eor	r1, r1
    5e54:	e7 5f       	subi	r30, 0xF7	; 247
    5e56:	f7 4f       	sbci	r31, 0xF7	; 247
    5e58:	82 85       	ldd	r24, Z+10	; 0x0a
    5e5a:	93 85       	ldd	r25, Z+11	; 0x0b
    5e5c:	a4 85       	ldd	r26, Z+12	; 0x0c
    5e5e:	b5 85       	ldd	r27, Z+13	; 0x0d
    5e60:	01 96       	adiw	r24, 0x01	; 1
    5e62:	a1 1d       	adc	r26, r1
    5e64:	b1 1d       	adc	r27, r1
    5e66:	82 87       	std	Z+10, r24	; 0x0a
    5e68:	93 87       	std	Z+11, r25	; 0x0b
    5e6a:	a4 87       	std	Z+12, r26	; 0x0c
    5e6c:	b5 87       	std	Z+13, r27	; 0x0d
    5e6e:	a8 c0       	rjmp	.+336    	; 0x5fc0 <tcp+0x794>
			return;
		}

		if ( TCP_packet->TCP_ControllFlags == ( TCP_FIN_FLAG | TCP_ACK_FLAG) )
    5e70:	f4 01       	movw	r30, r8
    5e72:	85 85       	ldd	r24, Z+13	; 0x0d
    5e74:	81 31       	cpi	r24, 0x11	; 17
    5e76:	09 f0       	breq	.+2      	; 0x5e7a <tcp+0x64e>
    5e78:	67 c0       	rjmp	.+206    	; 0x5f48 <tcp+0x71c>
		{
			if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_WAIT2FINACK )
    5e7a:	80 ea       	ldi	r24, 0xA0	; 160
    5e7c:	90 e0       	ldi	r25, 0x00	; 0
    5e7e:	48 9e       	mul	r4, r24
    5e80:	70 01       	movw	r14, r0
    5e82:	49 9e       	mul	r4, r25
    5e84:	f0 0c       	add	r15, r0
    5e86:	58 9e       	mul	r5, r24
    5e88:	f0 0c       	add	r15, r0
    5e8a:	11 24       	eor	r1, r1
    5e8c:	29 e0       	ldi	r18, 0x09	; 9
    5e8e:	38 e0       	ldi	r19, 0x08	; 8
    5e90:	e2 0e       	add	r14, r18
    5e92:	f3 1e       	adc	r15, r19
    5e94:	f7 01       	movw	r30, r14
    5e96:	80 81       	ld	r24, Z
    5e98:	81 37       	cpi	r24, 0x71	; 113
    5e9a:	71 f5       	brne	.+92     	; 0x5ef8 <tcp+0x6cc>
			{
				TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) + 1;
    5e9c:	f4 01       	movw	r30, r8
    5e9e:	64 81       	ldd	r22, Z+4	; 0x04
    5ea0:	75 81       	ldd	r23, Z+5	; 0x05
    5ea2:	86 81       	ldd	r24, Z+6	; 0x06
    5ea4:	97 81       	ldd	r25, Z+7	; 0x07
    5ea6:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5eaa:	6f 5f       	subi	r22, 0xFF	; 255
    5eac:	7f 4f       	sbci	r23, 0xFF	; 255
    5eae:	8f 4f       	sbci	r24, 0xFF	; 255
    5eb0:	9f 4f       	sbci	r25, 0xFF	; 255
    5eb2:	f7 01       	movw	r30, r14
    5eb4:	66 87       	std	Z+14, r22	; 0x0e
    5eb6:	77 87       	std	Z+15, r23	; 0x0f
    5eb8:	80 8b       	std	Z+16, r24	; 0x10
    5eba:	91 8b       	std	Z+17, r25	; 0x11
				TCP_sockettable[ Socket ].SequenceNumber = ChangeEndian32bit ( TCP_packet->TCP_AcknowledgeNumber );
    5ebc:	f4 01       	movw	r30, r8
    5ebe:	60 85       	ldd	r22, Z+8	; 0x08
    5ec0:	71 85       	ldd	r23, Z+9	; 0x09
    5ec2:	82 85       	ldd	r24, Z+10	; 0x0a
    5ec4:	93 85       	ldd	r25, Z+11	; 0x0b
    5ec6:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5eca:	f7 01       	movw	r30, r14
    5ecc:	62 87       	std	Z+10, r22	; 0x0a
    5ece:	73 87       	std	Z+11, r23	; 0x0b
    5ed0:	84 87       	std	Z+12, r24	; 0x0c
    5ed2:	95 87       	std	Z+13, r25	; 0x0d
				MakeTCPheader( Socket, TCP_ACK_FLAG, 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5ed4:	86 8d       	ldd	r24, Z+30	; 0x1e
    5ed6:	97 8d       	ldd	r25, Z+31	; 0x1f
    5ed8:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5edc:	20 e8       	ldi	r18, 0x80	; 128
    5ede:	30 e0       	ldi	r19, 0x00	; 0
    5ee0:	28 1b       	sub	r18, r24
    5ee2:	39 0b       	sbc	r19, r25
    5ee4:	89 81       	ldd	r24, Y+1	; 0x01
    5ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    5ee8:	60 e1       	ldi	r22, 0x10	; 16
    5eea:	40 e0       	ldi	r20, 0x00	; 0
    5eec:	50 e0       	ldi	r21, 0x00	; 0
    5eee:	81 01       	movw	r16, r2
    5ef0:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
				TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
    5ef4:	f7 01       	movw	r30, r14
    5ef6:	47 c0       	rjmp	.+142    	; 0x5f86 <tcp+0x75a>
			}
			else if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_READY ) 
    5ef8:	f7 01       	movw	r30, r14
    5efa:	80 81       	ld	r24, Z
    5efc:	80 31       	cpi	r24, 0x10	; 16
    5efe:	09 f0       	breq	.+2      	; 0x5f02 <tcp+0x6d6>
    5f00:	5f c0       	rjmp	.+190    	; 0x5fc0 <tcp+0x794>
			{
				TCP_sockettable[ Socket ].AcknowledgeNumber = ChangeEndian32bit ( TCP_packet->TCP_SequenceNumber ) + 1;
    5f02:	f4 01       	movw	r30, r8
    5f04:	64 81       	ldd	r22, Z+4	; 0x04
    5f06:	75 81       	ldd	r23, Z+5	; 0x05
    5f08:	86 81       	ldd	r24, Z+6	; 0x06
    5f0a:	97 81       	ldd	r25, Z+7	; 0x07
    5f0c:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5f10:	6f 5f       	subi	r22, 0xFF	; 255
    5f12:	7f 4f       	sbci	r23, 0xFF	; 255
    5f14:	8f 4f       	sbci	r24, 0xFF	; 255
    5f16:	9f 4f       	sbci	r25, 0xFF	; 255
    5f18:	f7 01       	movw	r30, r14
    5f1a:	66 87       	std	Z+14, r22	; 0x0e
    5f1c:	77 87       	std	Z+15, r23	; 0x0f
    5f1e:	80 8b       	std	Z+16, r24	; 0x10
    5f20:	91 8b       	std	Z+17, r25	; 0x11
//				TCP_sockettable[ Socket ].SequenceNumber = ChangeEndian32bit ( TCP_packet->TCP_AcknowledgeNumber ) + 1;
				MakeTCPheader( Socket, TCP_ACK_FLAG | TCP_FIN_FLAG , 0 , ( MAX_RECIVEBUFFER_LENGHT - Get_Bytes_in_FIFO ( TCP_sockettable[ Socket ].fifo ) ) , ethernetbuffer );
    5f22:	86 8d       	ldd	r24, Z+30	; 0x1e
    5f24:	97 8d       	ldd	r25, Z+31	; 0x1f
    5f26:	0e 94 8d 3d 	call	0x7b1a	; 0x7b1a <Get_Bytes_in_FIFO>
    5f2a:	20 e8       	ldi	r18, 0x80	; 128
    5f2c:	30 e0       	ldi	r19, 0x00	; 0
    5f2e:	28 1b       	sub	r18, r24
    5f30:	39 0b       	sbc	r19, r25
    5f32:	89 81       	ldd	r24, Y+1	; 0x01
    5f34:	9a 81       	ldd	r25, Y+2	; 0x02
    5f36:	61 e1       	ldi	r22, 0x11	; 17
    5f38:	40 e0       	ldi	r20, 0x00	; 0
    5f3a:	50 e0       	ldi	r21, 0x00	; 0
    5f3c:	81 01       	movw	r16, r2
    5f3e:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <MakeTCPheader>
				TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FIN ;
    5f42:	82 e7       	ldi	r24, 0x72	; 114
    5f44:	f7 01       	movw	r30, r14
    5f46:	26 c0       	rjmp	.+76     	; 0x5f94 <tcp+0x768>
			}
			return;
		}

		// normale best채tigung der gesendeten Daten
		if ( TCP_packet->TCP_ControllFlags == TCP_ACK_FLAG ) 						// mach mal wenn ACK empfangen
    5f48:	f4 01       	movw	r30, r8
    5f4a:	85 85       	ldd	r24, Z+13	; 0x0d
    5f4c:	80 31       	cpi	r24, 0x10	; 16
    5f4e:	c1 f5       	brne	.+112    	; 0x5fc0 <tcp+0x794>
			{
				// War das ein ACK von einen Verbindungsaufbau ? Wenn ja steht die verbindung jetzt
				if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_WAIT2SYNACK )  			// Wartet socket auf SYN + ACK ?
    5f50:	80 ea       	ldi	r24, 0xA0	; 160
    5f52:	90 e0       	ldi	r25, 0x00	; 0
    5f54:	48 9e       	mul	r4, r24
    5f56:	60 01       	movw	r12, r0
    5f58:	49 9e       	mul	r4, r25
    5f5a:	d0 0c       	add	r13, r0
    5f5c:	58 9e       	mul	r5, r24
    5f5e:	d0 0c       	add	r13, r0
    5f60:	11 24       	eor	r1, r1
    5f62:	29 e0       	ldi	r18, 0x09	; 9
    5f64:	38 e0       	ldi	r19, 0x08	; 8
    5f66:	c2 0e       	add	r12, r18
    5f68:	d3 1e       	adc	r13, r19
    5f6a:	f6 01       	movw	r30, r12
    5f6c:	80 81       	ld	r24, Z
    5f6e:	84 30       	cpi	r24, 0x04	; 4
    5f70:	21 f4       	brne	.+8      	; 0x5f7a <tcp+0x74e>
				{
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_READY2USE;					// Socket auf Ready2Use setzen
    5f72:	8f e0       	ldi	r24, 0x0F	; 15
    5f74:	80 83       	st	Z, r24
					TCP_sockettable[ Socket ].SendState = SOCKET_READY2SEND;						// Socket auf Bereit um senden setzen
    5f76:	11 82       	std	Z+1, r1	; 0x01
    5f78:	23 c0       	rjmp	.+70     	; 0x5fc0 <tcp+0x794>
				}				
				else if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_WAIT2FIN ) 
    5f7a:	f6 01       	movw	r30, r12
    5f7c:	80 81       	ld	r24, Z
    5f7e:	82 37       	cpi	r24, 0x72	; 114
    5f80:	21 f4       	brne	.+8      	; 0x5f8a <tcp+0x75e>
				#ifdef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = CloseTimeout ;
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
				#endif
				#ifndef CLOSE_WAIT
					TCP_sockettable[ Socket ].Timeoutcounter = 0 ;
    5f82:	17 8a       	std	Z+23, r1	; 0x17
    5f84:	16 8a       	std	Z+22, r1	; 0x16
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_NOT_USE ;
    5f86:	10 82       	st	Z, r1
    5f88:	1b c0       	rjmp	.+54     	; 0x5fc0 <tcp+0x794>
				#endif
				}
				else if ( TCP_sockettable[ Socket ].ConnectionState == SOCKET_WAIT2FINACK )
    5f8a:	f6 01       	movw	r30, r12
    5f8c:	80 81       	ld	r24, Z
    5f8e:	81 37       	cpi	r24, 0x71	; 113
    5f90:	19 f4       	brne	.+6      	; 0x5f98 <tcp+0x76c>
				{
					TCP_sockettable[ Socket ].ConnectionState = SOCKET_WAIT2FIN ;
    5f92:	82 e7       	ldi	r24, 0x72	; 114
    5f94:	80 83       	st	Z, r24
    5f96:	14 c0       	rjmp	.+40     	; 0x5fc0 <tcp+0x794>
				}
				else if ( TCP_sockettable[ Socket ].SequenceNumber == ChangeEndian32bit ( TCP_packet->TCP_AcknowledgeNumber ) )
    5f98:	f6 01       	movw	r30, r12
    5f9a:	e2 84       	ldd	r14, Z+10	; 0x0a
    5f9c:	f3 84       	ldd	r15, Z+11	; 0x0b
    5f9e:	04 85       	ldd	r16, Z+12	; 0x0c
    5fa0:	15 85       	ldd	r17, Z+13	; 0x0d
    5fa2:	f4 01       	movw	r30, r8
    5fa4:	60 85       	ldd	r22, Z+8	; 0x08
    5fa6:	71 85       	ldd	r23, Z+9	; 0x09
    5fa8:	82 85       	ldd	r24, Z+10	; 0x0a
    5faa:	93 85       	ldd	r25, Z+11	; 0x0b
    5fac:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    5fb0:	e6 16       	cp	r14, r22
    5fb2:	f7 06       	cpc	r15, r23
    5fb4:	08 07       	cpc	r16, r24
    5fb6:	19 07       	cpc	r17, r25
    5fb8:	19 f4       	brne	.+6      	; 0x5fc0 <tcp+0x794>
				{
					TCP_sockettable[ Socket ].SendetBytes = 0;
    5fba:	f6 01       	movw	r30, r12
    5fbc:	15 8a       	std	Z+21, r1	; 0x15
    5fbe:	14 8a       	std	Z+20, r1	; 0x14
				}
			}
		return;
	}
    5fc0:	24 96       	adiw	r28, 0x04	; 4
    5fc2:	e2 e1       	ldi	r30, 0x12	; 18
    5fc4:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

00005fc8 <tcp_init>:
 * und alle Offenen kontrolliert.
 * \return		void
 */
/*------------------------------------------------------------------------------------------------------------*/
void tcp_init( void )
{
    5fc8:	0f 93       	push	r16
    5fca:	1f 93       	push	r17
	unsigned int i;
	
	// CAllback f체r Timeout registrieren
	CLOCK_RegisterCallbackFunction( TCPTimeOutHandler, SECOUND );
    5fcc:	88 e9       	ldi	r24, 0x98	; 152
    5fce:	9b e2       	ldi	r25, 0x2B	; 43
    5fd0:	62 e0       	ldi	r22, 0x02	; 2
    5fd2:	0e 94 82 1b 	call	0x3704	; 0x3704 <CLOCK_RegisterCallbackFunction>
	
	#ifdef TCP_with_unsortseq
		TCP_Unsort.lenght = 0 ;
    5fd6:	10 92 f2 09 	sts	0x09F2, r1
    5fda:	10 92 f1 09 	sts	0x09F1, r1
	
	// FIFOs f체r den Recivebuffer anlegen
	// und den state festlegen
	for ( i = 0 ; i < MAX_TCP_CONNECTIONS ; i++ )
	{
		TCP_sockettable[ i ].fifo = Get_FIFO( TCP_sockettable[ i ].Recivebuffer, MAX_RECIVEBUFFER_LENGHT );
    5fde:	09 e2       	ldi	r16, 0x29	; 41
    5fe0:	18 e0       	ldi	r17, 0x08	; 8
    5fe2:	c8 01       	movw	r24, r16
    5fe4:	60 e8       	ldi	r22, 0x80	; 128
    5fe6:	70 e0       	ldi	r23, 0x00	; 0
    5fe8:	0e 94 61 3d 	call	0x7ac2	; 0x7ac2 <Get_FIFO>
    5fec:	f8 01       	movw	r30, r16
    5fee:	92 93       	st	-Z, r25
    5ff0:	82 93       	st	-Z, r24
    5ff2:	8f 01       	movw	r16, r30
		TCP_sockettable[ i ].Timeoutcounter = 0 ;
    5ff4:	08 50       	subi	r16, 0x08	; 8
    5ff6:	10 40       	sbci	r17, 0x00	; 0
    5ff8:	f8 01       	movw	r30, r16
    5ffa:	11 82       	std	Z+1, r1	; 0x01
    5ffc:	10 82       	st	Z, r1
		TCP_sockettable[ i ].ConnectionState = SOCKET_NOT_USE;
    5ffe:	06 51       	subi	r16, 0x16	; 22
    6000:	10 40       	sbci	r17, 0x00	; 0
    6002:	f8 01       	movw	r30, r16
    6004:	10 82       	st	Z, r1
	
	// FIFOs f체r den Recivebuffer anlegen
	// und den state festlegen
	for ( i = 0 ; i < MAX_TCP_CONNECTIONS ; i++ )
	{
		TCP_sockettable[ i ].fifo = Get_FIFO( TCP_sockettable[ i ].Recivebuffer, MAX_RECIVEBUFFER_LENGHT );
    6006:	89 ec       	ldi	r24, 0xC9	; 201
    6008:	98 e0       	ldi	r25, 0x08	; 8
    600a:	60 e8       	ldi	r22, 0x80	; 128
    600c:	70 e0       	ldi	r23, 0x00	; 0
    600e:	0e 94 61 3d 	call	0x7ac2	; 0x7ac2 <Get_FIFO>
    6012:	90 93 c8 08 	sts	0x08C8, r25
    6016:	80 93 c7 08 	sts	0x08C7, r24
		TCP_sockettable[ i ].Timeoutcounter = 0 ;
    601a:	10 92 c0 08 	sts	0x08C0, r1
    601e:	10 92 bf 08 	sts	0x08BF, r1
		TCP_sockettable[ i ].ConnectionState = SOCKET_NOT_USE;
    6022:	10 92 a9 08 	sts	0x08A9, r1
	
	// FIFOs f체r den Recivebuffer anlegen
	// und den state festlegen
	for ( i = 0 ; i < MAX_TCP_CONNECTIONS ; i++ )
	{
		TCP_sockettable[ i ].fifo = Get_FIFO( TCP_sockettable[ i ].Recivebuffer, MAX_RECIVEBUFFER_LENGHT );
    6026:	89 e6       	ldi	r24, 0x69	; 105
    6028:	99 e0       	ldi	r25, 0x09	; 9
    602a:	60 e8       	ldi	r22, 0x80	; 128
    602c:	70 e0       	ldi	r23, 0x00	; 0
    602e:	0e 94 61 3d 	call	0x7ac2	; 0x7ac2 <Get_FIFO>
    6032:	90 93 68 09 	sts	0x0968, r25
    6036:	80 93 67 09 	sts	0x0967, r24
		TCP_sockettable[ i ].Timeoutcounter = 0 ;
    603a:	10 92 60 09 	sts	0x0960, r1
    603e:	10 92 5f 09 	sts	0x095F, r1
		TCP_sockettable[ i ].ConnectionState = SOCKET_NOT_USE;
    6042:	10 92 49 09 	sts	0x0949, r1
	}
}
    6046:	1f 91       	pop	r17
    6048:	0f 91       	pop	r16
    604a:	08 95       	ret

0000604c <MakeETHheader>:
	
/* -----------------------------------------------------------------------------------------------------------
Erstellt den richtigen Ethernetheader zur passenden Verbindung die gerade mit TCP_socket gew채hlt ist
------------------------------------------------------------------------------------------------------------*/
void MakeETHheader( unsigned char * MACadress , unsigned char * ethernetbuffer )
	{
    604c:	ac 01       	movw	r20, r24
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
    604e:	fb 01       	movw	r30, r22

		unsigned int i;			

		ETH_packet->ETH_typefield = 0x0008;
    6050:	88 e0       	ldi	r24, 0x08	; 8
    6052:	90 e0       	ldi	r25, 0x00	; 0
    6054:	95 87       	std	Z+13, r25	; 0x0d
    6056:	84 87       	std	Z+12, r24	; 0x0c
    6058:	db 01       	movw	r26, r22
    605a:	20 e0       	ldi	r18, 0x00	; 0
    605c:	30 e0       	ldi	r19, 0x00	; 0
		
		for ( i = 0 ; i < 6 ; i++ ) 
		{
			ETH_packet->ETH_sourceMac[i] = mymac[i];			
    605e:	f9 01       	movw	r30, r18
    6060:	e5 5c       	subi	r30, 0xC5	; 197
    6062:	fe 4f       	sbci	r31, 0xFE	; 254
    6064:	80 81       	ld	r24, Z
    6066:	16 96       	adiw	r26, 0x06	; 6
    6068:	8c 93       	st	X, r24
    606a:	16 97       	sbiw	r26, 0x06	; 6
			ETH_packet->ETH_destMac[i] = MACadress[i];
    606c:	fa 01       	movw	r30, r20
    606e:	e2 0f       	add	r30, r18
    6070:	f3 1f       	adc	r31, r19
    6072:	80 81       	ld	r24, Z
    6074:	8d 93       	st	X+, r24

		unsigned int i;			

		ETH_packet->ETH_typefield = 0x0008;
		
		for ( i = 0 ; i < 6 ; i++ ) 
    6076:	2f 5f       	subi	r18, 0xFF	; 255
    6078:	3f 4f       	sbci	r19, 0xFF	; 255
    607a:	26 30       	cpi	r18, 0x06	; 6
    607c:	31 05       	cpc	r19, r1
    607e:	79 f7       	brne	.-34     	; 0x605e <MakeETHheader+0x12>
		{
			ETH_packet->ETH_sourceMac[i] = mymac[i];			
			ETH_packet->ETH_destMac[i] = MACadress[i];
		}
		return;		
	}
    6080:	08 95       	ret

00006082 <FreeEthernet>:
/* -----------------------------------------------------------------------------------------------------------
Erstellt den richtigen Ethernetheader zur passenden Verbindung die gerade mit TCP_socket gew채hlt ist
------------------------------------------------------------------------------------------------------------*/
void FreeEthernet( void )
{
	FreeTCP();
    6082:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <FreeTCP>

#if defined(__AVR_ATmega2561__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__)
	#if defined(OpenMCP) || defined(AVRNETIO)
		EXTINT_free ( interrupt );
    6086:	82 e0       	ldi	r24, 0x02	; 2
    6088:	0e 94 ae 17 	call	0x2f5c	; 0x2f5c <EXTINT_free>
		SREG = sreg_tmp;
	#else
		#error "Hardwareplatform wird nicht unterst체tzt!"
	#endif
#endif
}
    608c:	08 95       	ret

0000608e <LockEthernet>:
Erstellt den richtigen Ethernetheader zur passenden Verbindung die gerade mit TCP_socket gew채hlt ist
------------------------------------------------------------------------------------------------------------*/
void LockEthernet( void )
{

	LockTCP();
    608e:	0e 94 6f 25 	call	0x4ade	; 0x4ade <LockTCP>

#if defined(__AVR_ATmega2561__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__)
	#if defined(OpenMCP) || defined(AVRNETIO)
		EXTINT_block( interrupt );
    6092:	82 e0       	ldi	r24, 0x02	; 2
    6094:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <EXTINT_block>
	#else
		#error "Hardwareplatform wird nicht unterst체tzt!"
	#endif
#endif

}
    6098:	08 95       	ret

0000609a <sendEthernetframe>:
	
/* -----------------------------------------------------------------------------------------------------------
Sendet ein Ethernetframe
------------------------------------------------------------------------------------------------------------*/
void sendEthernetframe( unsigned int packet_lenght, unsigned char *ethernetbuffer)
	{
    609a:	ef 92       	push	r14
    609c:	ff 92       	push	r15
    609e:	0f 93       	push	r16
    60a0:	1f 93       	push	r17
#if defined(__AVR_ATmega644P__) && defined(myAVR) && defined(LED)
		LED_on(1);
#endif
		PacketCounter++;
    60a2:	20 91 39 0a 	lds	r18, 0x0A39
    60a6:	30 91 3a 0a 	lds	r19, 0x0A3A
    60aa:	40 91 3b 0a 	lds	r20, 0x0A3B
    60ae:	50 91 3c 0a 	lds	r21, 0x0A3C
    60b2:	2f 5f       	subi	r18, 0xFF	; 255
    60b4:	3f 4f       	sbci	r19, 0xFF	; 255
    60b6:	4f 4f       	sbci	r20, 0xFF	; 255
    60b8:	5f 4f       	sbci	r21, 0xFF	; 255
    60ba:	20 93 39 0a 	sts	0x0A39, r18
    60be:	30 93 3a 0a 	sts	0x0A3A, r19
    60c2:	40 93 3b 0a 	sts	0x0A3B, r20
    60c6:	50 93 3c 0a 	sts	0x0A3C, r21
		ByteCounter = ByteCounter + packet_lenght;
    60ca:	7c 01       	movw	r14, r24
    60cc:	00 e0       	ldi	r16, 0x00	; 0
    60ce:	10 e0       	ldi	r17, 0x00	; 0
    60d0:	20 91 3d 0a 	lds	r18, 0x0A3D
    60d4:	30 91 3e 0a 	lds	r19, 0x0A3E
    60d8:	40 91 3f 0a 	lds	r20, 0x0A3F
    60dc:	50 91 40 0a 	lds	r21, 0x0A40
    60e0:	2e 0d       	add	r18, r14
    60e2:	3f 1d       	adc	r19, r15
    60e4:	40 1f       	adc	r20, r16
    60e6:	51 1f       	adc	r21, r17
    60e8:	20 93 3d 0a 	sts	0x0A3D, r18
    60ec:	30 93 3e 0a 	sts	0x0A3E, r19
    60f0:	40 93 3f 0a 	sts	0x0A3F, r20
    60f4:	50 93 40 0a 	sts	0x0A40, r21
 		enc28j60PacketSend( packet_lenght, ethernetbuffer );
    60f8:	0e 94 6b 1e 	call	0x3cd6	; 0x3cd6 <enc28j60PacketSend>
#if defined(__AVR_ATmega644P__) && defined(myAVR) && defined(LED)
		LED_off(1);
#endif
	}
    60fc:	1f 91       	pop	r17
    60fe:	0f 91       	pop	r16
    6100:	ff 90       	pop	r15
    6102:	ef 90       	pop	r14
    6104:	08 95       	ret

00006106 <EthernetInit>:

/* -----------------------------------------------------------------------------------------------------------
f체hrt den Init durch
------------------------------------------------------------------------------------------------------------*/
void EthernetInit( void )
{
    6106:	a0 e0       	ldi	r26, 0x00	; 0
    6108:	b2 e0       	ldi	r27, 0x02	; 2
    610a:	e9 e8       	ldi	r30, 0x89	; 137
    610c:	f0 e3       	ldi	r31, 0x30	; 48
    610e:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
		PCINT_init();
	#else
		#error "Hardwareplatform wird nicht unterst체tzt!"
	#endif
#endif
		enc28j60Init();
    6112:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <enc28j60Init>
		nicSetMacAddress( mymac );
    6116:	8b e3       	ldi	r24, 0x3B	; 59
    6118:	91 e0       	ldi	r25, 0x01	; 1
    611a:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <nicSetMacAddress>
/* -----------------------------------------------------------------------------------------------------------
Holt ein Ethernetframe
------------------------------------------------------------------------------------------------------------*/
unsigned int getEthernetframe( unsigned int maxlen, unsigned char *ethernetbuffer)
	{
		return( enc28j60PacketReceive( maxlen , ethernetbuffer) );
    611e:	8e 01       	movw	r16, r28
    6120:	0f 5f       	subi	r16, 0xFF	; 255
    6122:	1f 4f       	sbci	r17, 0xFF	; 255
    6124:	80 e0       	ldi	r24, 0x00	; 0
    6126:	92 e0       	ldi	r25, 0x02	; 2
    6128:	b8 01       	movw	r22, r16
    612a:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <enc28j60PacketReceive>
		enc28j60Init();
		nicSetMacAddress( mymac );

		// Alle Packet lesen und ins leere laufen lassen damit ein definierter zustand herrscht
		unsigned char ethernetbuffer[ MAX_FRAMELEN ];
		while ( getEthernetframe( MAX_FRAMELEN, ethernetbuffer) != 0 ) { };
    612e:	89 2b       	or	r24, r25
    6130:	c9 f7       	brne	.-14     	; 0x6124 <EthernetInit+0x1e>
		
#if defined(__AVR_ATmega2561__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644__)
	#if defined(OpenMCP) || defined(AVRNETIO)
		EXTINT_set ( interrupt , SENSE_LOW , ethernet );
    6132:	82 e0       	ldi	r24, 0x02	; 2
    6134:	60 e0       	ldi	r22, 0x00	; 0
    6136:	46 ea       	ldi	r20, 0xA6	; 166
    6138:	50 e3       	ldi	r21, 0x30	; 48
    613a:	0e 94 75 17 	call	0x2eea	; 0x2eea <EXTINT_set>
	#else
		#error "Hardwareplatform wird nicht unterst체tzt!"
	#endif
#endif
		// gibt Ethernet frei
		FreeEthernet();
    613e:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
}
    6142:	c0 50       	subi	r28, 0x00	; 0
    6144:	de 4f       	sbci	r29, 0xFE	; 254
    6146:	e4 e0       	ldi	r30, 0x04	; 4
    6148:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

0000614c <ethernet>:
 -----------------------------------------------------------------------------------------------------------
   Die Routine die die Packete nacheinander abarbeitet
------------------------------------------------------------------------------------------------------------*/

void ethernet(void)
	{
    614c:	a0 e0       	ldi	r26, 0x00	; 0
    614e:	b2 e0       	ldi	r27, 0x02	; 2
    6150:	ec ea       	ldi	r30, 0xAC	; 172
    6152:	f0 e3       	ldi	r31, 0x30	; 48
    6154:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
/* -----------------------------------------------------------------------------------------------------------
Holt ein Ethernetframe
------------------------------------------------------------------------------------------------------------*/
unsigned int getEthernetframe( unsigned int maxlen, unsigned char *ethernetbuffer)
	{
		return( enc28j60PacketReceive( maxlen , ethernetbuffer) );
    6158:	80 e0       	ldi	r24, 0x00	; 0
    615a:	92 e0       	ldi	r25, 0x02	; 2
    615c:	8e 01       	movw	r16, r28
    615e:	0f 5f       	subi	r16, 0xFF	; 255
    6160:	1f 4f       	sbci	r17, 0xFF	; 255
    6162:	b8 01       	movw	r22, r16
    6164:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <enc28j60PacketReceive>
    6168:	bc 01       	movw	r22, r24
		// hole ein Frame
		packet_lenght = getEthernetframe( MAX_FRAMELEN, ethernetbuffer);
		// wenn Frame vorhanden packet_lenght != 0
		// arbeite so lange die Frames ab bis keine mehr da sind
		
		while ( packet_lenght != 0 )
    616a:	00 97       	sbiw	r24, 0x00	; 0
    616c:	d9 f1       	breq	.+118    	; 0x61e4 <ethernet+0x98>
			{
				PacketCounter++;
    616e:	80 91 39 0a 	lds	r24, 0x0A39
    6172:	90 91 3a 0a 	lds	r25, 0x0A3A
    6176:	a0 91 3b 0a 	lds	r26, 0x0A3B
    617a:	b0 91 3c 0a 	lds	r27, 0x0A3C
    617e:	01 96       	adiw	r24, 0x01	; 1
    6180:	a1 1d       	adc	r26, r1
    6182:	b1 1d       	adc	r27, r1
    6184:	80 93 39 0a 	sts	0x0A39, r24
    6188:	90 93 3a 0a 	sts	0x0A3A, r25
    618c:	a0 93 3b 0a 	sts	0x0A3B, r26
    6190:	b0 93 3c 0a 	sts	0x0A3C, r27
				ByteCounter = ByteCounter + packet_lenght;
    6194:	9b 01       	movw	r18, r22
    6196:	40 e0       	ldi	r20, 0x00	; 0
    6198:	50 e0       	ldi	r21, 0x00	; 0
    619a:	80 91 3d 0a 	lds	r24, 0x0A3D
    619e:	90 91 3e 0a 	lds	r25, 0x0A3E
    61a2:	a0 91 3f 0a 	lds	r26, 0x0A3F
    61a6:	b0 91 40 0a 	lds	r27, 0x0A40
    61aa:	82 0f       	add	r24, r18
    61ac:	93 1f       	adc	r25, r19
    61ae:	a4 1f       	adc	r26, r20
    61b0:	b5 1f       	adc	r27, r21
    61b2:	80 93 3d 0a 	sts	0x0A3D, r24
    61b6:	90 93 3e 0a 	sts	0x0A3E, r25
    61ba:	a0 93 3f 0a 	sts	0x0A3F, r26
    61be:	b0 93 40 0a 	sts	0x0A40, r27
				struct ETH_header *ETH_packet; 		//ETH_struc anlegen
				ETH_packet = (struct ETH_header *) ethernetbuffer; 
				switch ( ETH_packet->ETH_typefield ) // welcher type ist gesetzt 
    61c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    61c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    61c6:	88 30       	cpi	r24, 0x08	; 8
    61c8:	91 05       	cpc	r25, r1
    61ca:	41 f0       	breq	.+16     	; 0x61dc <ethernet+0x90>
    61cc:	88 50       	subi	r24, 0x08	; 8
    61ce:	96 40       	sbci	r25, 0x06	; 6
    61d0:	49 f4       	brne	.+18     	; 0x61e4 <ethernet+0x98>
					{
					case 0x0608:		
										#ifdef _DEBUG_
											printf_P( PSTR("-->> ARP\r\n") );
										#endif
										arp( packet_lenght , ethernetbuffer );
    61d2:	cb 01       	movw	r24, r22
    61d4:	b8 01       	movw	r22, r16
    61d6:	0e 94 4c 31 	call	0x6298	; 0x6298 <arp>
    61da:	04 c0       	rjmp	.+8      	; 0x61e4 <ethernet+0x98>
										break;
					case 0x0008:		
										#ifdef _DEBUG_
											printf_P( PSTR("-->> IP\r\n") );										
										#endif
										ip( packet_lenght , ethernetbuffer );
    61dc:	cb 01       	movw	r24, r22
    61de:	b8 01       	movw	r22, r16
    61e0:	0e 94 dc 33 	call	0x67b8	; 0x67b8 <ip>
	#else
		#error "Hardwareplatform wird nicht unterst체tzt!"
	#endif
#endif
		return;
	}
    61e4:	c0 50       	subi	r28, 0x00	; 0
    61e6:	de 4f       	sbci	r29, 0xFE	; 254
    61e8:	e4 e0       	ldi	r30, 0x04	; 4
    61ea:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

000061ee <ARP_Timeouthandler>:
void ARP_Timeouthandler( void )
{
	unsigned char i;
	
	for ( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
		if ( ARPtable[ i ].ttl != 0 )
    61ee:	80 91 4b 0a 	lds	r24, 0x0A4B
    61f2:	88 23       	and	r24, r24
    61f4:	19 f0       	breq	.+6      	; 0x61fc <ARP_Timeouthandler+0xe>
			ARPtable[ i ].ttl--;
    61f6:	81 50       	subi	r24, 0x01	; 1
    61f8:	80 93 4b 0a 	sts	0x0A4B, r24
void ARP_Timeouthandler( void )
{
	unsigned char i;
	
	for ( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
		if ( ARPtable[ i ].ttl != 0 )
    61fc:	80 91 56 0a 	lds	r24, 0x0A56
    6200:	88 23       	and	r24, r24
    6202:	19 f0       	breq	.+6      	; 0x620a <ARP_Timeouthandler+0x1c>
			ARPtable[ i ].ttl--;
    6204:	81 50       	subi	r24, 0x01	; 1
    6206:	80 93 56 0a 	sts	0x0A56, r24
    620a:	08 95       	ret

0000620c <mactostr>:
 * \return			R체chgabewert der Funktion.
 * \retval 0		Wandlung war erfolgreich. 
 * \retval -1		Wandlung war nicht erfolgreich. 
 */
char * mactostr( unsigned char * MAC, char * strMAC )
{
    620c:	0f 93       	push	r16
    620e:	1f 93       	push	r17
    6210:	cf 93       	push	r28
    6212:	df 93       	push	r29
    6214:	dc 01       	movw	r26, r24
    6216:	16 2f       	mov	r17, r22
    6218:	07 2f       	mov	r16, r23
	sprintf_P( strMAC, PSTR("%02x:%02x:%02x:%02x:%02x:%02x") , MAC[0], MAC[1], MAC[2], MAC[3], MAC[4], MAC[5] );
    621a:	8d b7       	in	r24, 0x3d	; 61
    621c:	9e b7       	in	r25, 0x3e	; 62
    621e:	40 97       	sbiw	r24, 0x10	; 16
    6220:	0f b6       	in	r0, 0x3f	; 63
    6222:	f8 94       	cli
    6224:	9e bf       	out	0x3e, r25	; 62
    6226:	0f be       	out	0x3f, r0	; 63
    6228:	8d bf       	out	0x3d, r24	; 61
    622a:	ed b7       	in	r30, 0x3d	; 61
    622c:	fe b7       	in	r31, 0x3e	; 62
    622e:	31 96       	adiw	r30, 0x01	; 1
    6230:	cd b7       	in	r28, 0x3d	; 61
    6232:	de b7       	in	r29, 0x3e	; 62
    6234:	69 83       	std	Y+1, r22	; 0x01
    6236:	71 83       	std	Z+1, r23	; 0x01
    6238:	80 e7       	ldi	r24, 0x70	; 112
    623a:	90 e0       	ldi	r25, 0x00	; 0
    623c:	93 83       	std	Z+3, r25	; 0x03
    623e:	82 83       	std	Z+2, r24	; 0x02
    6240:	8c 91       	ld	r24, X
    6242:	84 83       	std	Z+4, r24	; 0x04
    6244:	15 82       	std	Z+5, r1	; 0x05
    6246:	11 96       	adiw	r26, 0x01	; 1
    6248:	8c 91       	ld	r24, X
    624a:	11 97       	sbiw	r26, 0x01	; 1
    624c:	86 83       	std	Z+6, r24	; 0x06
    624e:	17 82       	std	Z+7, r1	; 0x07
    6250:	12 96       	adiw	r26, 0x02	; 2
    6252:	8c 91       	ld	r24, X
    6254:	12 97       	sbiw	r26, 0x02	; 2
    6256:	80 87       	std	Z+8, r24	; 0x08
    6258:	11 86       	std	Z+9, r1	; 0x09
    625a:	13 96       	adiw	r26, 0x03	; 3
    625c:	8c 91       	ld	r24, X
    625e:	13 97       	sbiw	r26, 0x03	; 3
    6260:	82 87       	std	Z+10, r24	; 0x0a
    6262:	13 86       	std	Z+11, r1	; 0x0b
    6264:	14 96       	adiw	r26, 0x04	; 4
    6266:	8c 91       	ld	r24, X
    6268:	14 97       	sbiw	r26, 0x04	; 4
    626a:	84 87       	std	Z+12, r24	; 0x0c
    626c:	15 86       	std	Z+13, r1	; 0x0d
    626e:	15 96       	adiw	r26, 0x05	; 5
    6270:	8c 91       	ld	r24, X
    6272:	86 87       	std	Z+14, r24	; 0x0e
    6274:	17 86       	std	Z+15, r1	; 0x0f
    6276:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
    627a:	8d b7       	in	r24, 0x3d	; 61
    627c:	9e b7       	in	r25, 0x3e	; 62
    627e:	40 96       	adiw	r24, 0x10	; 16
    6280:	0f b6       	in	r0, 0x3f	; 63
    6282:	f8 94       	cli
    6284:	9e bf       	out	0x3e, r25	; 62
    6286:	0f be       	out	0x3f, r0	; 63
    6288:	8d bf       	out	0x3d, r24	; 61
	return( strMAC );
}
    628a:	81 2f       	mov	r24, r17
    628c:	90 2f       	mov	r25, r16
    628e:	df 91       	pop	r29
    6290:	cf 91       	pop	r28
    6292:	1f 91       	pop	r17
    6294:	0f 91       	pop	r16
    6296:	08 95       	ret

00006298 <arp>:
/*!\brief Die ARP-Funktion wenn ein ARP-Packet eintrifft
 * \param packet_lenght			Anzahl der Byte im Ethernetbuffer
 * \param ethernetbuffer		Zeiger auf den Ethernetbuffer an sich
 */
void arp( unsigned int packet_lenght, unsigned char *ethernetbuffer)
	{
    6298:	ef 92       	push	r14
    629a:	ff 92       	push	r15
    629c:	0f 93       	push	r16
    629e:	1f 93       	push	r17
    62a0:	cf 93       	push	r28
    62a2:	df 93       	push	r29
    62a4:	8c 01       	movw	r16, r24
		unsigned char i,a;
		
		struct ETH_header *ETH_packet;
		ETH_packet = (struct ETH_header *) ethernetbuffer; 
    62a6:	f6 2e       	mov	r15, r22
    62a8:	e7 2e       	mov	r14, r23
		struct ARP_header *ARP_packet;
		ARP_packet = (struct ARP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    62aa:	eb 01       	movw	r28, r22
    62ac:	2e 96       	adiw	r28, 0x0e	; 14
		switch ( ARP_packet->ARP_Opcode ) {
    62ae:	8e 81       	ldd	r24, Y+6	; 0x06
    62b0:	9f 81       	ldd	r25, Y+7	; 0x07
    62b2:	21 e0       	ldi	r18, 0x01	; 1
    62b4:	80 30       	cpi	r24, 0x00	; 0
    62b6:	92 07       	cpc	r25, r18
    62b8:	29 f0       	breq	.+10     	; 0x62c4 <arp+0x2c>
    62ba:	80 50       	subi	r24, 0x00	; 0
    62bc:	92 40       	sbci	r25, 0x02	; 2
    62be:	09 f0       	breq	.+2      	; 0x62c2 <arp+0x2a>
    62c0:	6a c0       	rjmp	.+212    	; 0x6396 <arp+0xfe>
    62c2:	47 c0       	rjmp	.+142    	; 0x6352 <arp+0xba>
			
			case 0x0100:		// check mal ob das f체r mich ist !
								if ( ARP_packet->ARP_destIP != myIP ) return ;
    62c4:	28 8d       	ldd	r18, Y+24	; 0x18
    62c6:	39 8d       	ldd	r19, Y+25	; 0x19
    62c8:	4a 8d       	ldd	r20, Y+26	; 0x1a
    62ca:	5b 8d       	ldd	r21, Y+27	; 0x1b
    62cc:	80 91 41 01 	lds	r24, 0x0141
    62d0:	90 91 42 01 	lds	r25, 0x0142
    62d4:	a0 91 43 01 	lds	r26, 0x0143
    62d8:	b0 91 44 01 	lds	r27, 0x0144
    62dc:	28 17       	cp	r18, r24
    62de:	39 07       	cpc	r19, r25
    62e0:	4a 07       	cpc	r20, r26
    62e2:	5b 07       	cpc	r21, r27
    62e4:	09 f0       	breq	.+2      	; 0x62e8 <arp+0x50>
    62e6:	57 c0       	rjmp	.+174    	; 0x6396 <arp+0xfe>
										for ( a = 0 ; a < 6 ; a++ ) ARPtable[i].MAC[a] = ARP_packet->ARP_sourceMac[a];
									}
								}
*/
								// wenn ja fang mal an die antwort zusammen zu basteln
								ARP_packet->ARP_Opcode = 0x0200;
    62e8:	80 e0       	ldi	r24, 0x00	; 0
    62ea:	92 e0       	ldi	r25, 0x02	; 2
    62ec:	9f 83       	std	Y+7, r25	; 0x07
    62ee:	8e 83       	std	Y+6, r24	; 0x06
    62f0:	fe 01       	movw	r30, r28
    62f2:	90 e0       	ldi	r25, 0x00	; 0
								// mac und ip des senders in ziel kopieren
								for ( i = 0; i < 10; i++ )ARP_packet->ARP_destMac[i] = ARP_packet->ARP_sourceMac[i]; // MAC und IP umkopieren
    62f4:	80 85       	ldd	r24, Z+8	; 0x08
    62f6:	82 8b       	std	Z+18, r24	; 0x12
    62f8:	9f 5f       	subi	r25, 0xFF	; 255
    62fa:	31 96       	adiw	r30, 0x01	; 1
    62fc:	9a 30       	cpi	r25, 0x0A	; 10
    62fe:	d1 f7       	brne	.-12     	; 0x62f4 <arp+0x5c>
								// meine mac und ip als absender einsetzen
								for ( i = 0; i < 6 ; i++ )ARP_packet->ARP_sourceMac[i] = mymac[i]; // MAC einsetzen
    6300:	80 91 3b 01 	lds	r24, 0x013B
    6304:	88 87       	std	Y+8, r24	; 0x08
    6306:	80 91 3c 01 	lds	r24, 0x013C
    630a:	89 87       	std	Y+9, r24	; 0x09
    630c:	80 91 3d 01 	lds	r24, 0x013D
    6310:	8a 87       	std	Y+10, r24	; 0x0a
    6312:	80 91 3e 01 	lds	r24, 0x013E
    6316:	8b 87       	std	Y+11, r24	; 0x0b
    6318:	80 91 3f 01 	lds	r24, 0x013F
    631c:	8c 87       	std	Y+12, r24	; 0x0c
    631e:	80 91 40 01 	lds	r24, 0x0140
    6322:	8d 87       	std	Y+13, r24	; 0x0d
								ARP_packet->ARP_sourceIP = myIP ; // IP einsetzen
    6324:	2e 87       	std	Y+14, r18	; 0x0e
    6326:	3f 87       	std	Y+15, r19	; 0x0f
    6328:	48 8b       	std	Y+16, r20	; 0x10
    632a:	59 8b       	std	Y+17, r21	; 0x11
    632c:	2f 2d       	mov	r18, r15
    632e:	3e 2d       	mov	r19, r14
    6330:	c9 01       	movw	r24, r18
    6332:	fc 01       	movw	r30, r24
    6334:	ab e3       	ldi	r26, 0x3B	; 59
    6336:	b1 e0       	ldi	r27, 0x01	; 1
								// sourceMAC in destMAC eintragen und meine MAC in sourceMAC kopieren
								for( i = 0 ; i < 6 ; i++){	
										ETH_packet->ETH_destMac[i] = ETH_packet->ETH_sourceMac[i];	
    6338:	86 81       	ldd	r24, Z+6	; 0x06
    633a:	80 83       	st	Z, r24
										ETH_packet->ETH_sourceMac[i] = mymac[i]; }
    633c:	8d 91       	ld	r24, X+
    633e:	86 83       	std	Z+6, r24	; 0x06
    6340:	31 96       	adiw	r30, 0x01	; 1
								for ( i = 0; i < 10; i++ )ARP_packet->ARP_destMac[i] = ARP_packet->ARP_sourceMac[i]; // MAC und IP umkopieren
								// meine mac und ip als absender einsetzen
								for ( i = 0; i < 6 ; i++ )ARP_packet->ARP_sourceMac[i] = mymac[i]; // MAC einsetzen
								ARP_packet->ARP_sourceIP = myIP ; // IP einsetzen
								// sourceMAC in destMAC eintragen und meine MAC in sourceMAC kopieren
								for( i = 0 ; i < 6 ; i++){	
    6342:	81 e0       	ldi	r24, 0x01	; 1
    6344:	a1 34       	cpi	r26, 0x41	; 65
    6346:	b8 07       	cpc	r27, r24
    6348:	b9 f7       	brne	.-18     	; 0x6338 <arp+0xa0>
										ETH_packet->ETH_destMac[i] = ETH_packet->ETH_sourceMac[i];	
										ETH_packet->ETH_sourceMac[i] = mymac[i]; }
								sendEthernetframe( packet_lenght, ethernetbuffer);
    634a:	c8 01       	movw	r24, r16
    634c:	0e 94 4d 30 	call	0x609a	; 0x609a <sendEthernetframe>
    6350:	22 c0       	rjmp	.+68     	; 0x6396 <arp+0xfe>
								break;
    6352:	e1 e4       	ldi	r30, 0x41	; 65
    6354:	fa e0       	ldi	r31, 0x0A	; 10
								for( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
								{
									if( ARPtable[ i ].IP == ARP_packet->ARP_sourceIP )
									{
										ARPtable[i].IP = ARP_packet->ARP_sourceIP;
										ARPtable[i].ttl = Default_ARP_ttl;
    6356:	6e e1       	ldi	r22, 0x1E	; 30
								sendEthernetframe( packet_lenght, ethernetbuffer);
								break;
			case 0x0200:		// check mal ob das f체r mich ist !
								for( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
								{
									if( ARPtable[ i ].IP == ARP_packet->ARP_sourceIP )
    6358:	20 81       	ld	r18, Z
    635a:	31 81       	ldd	r19, Z+1	; 0x01
    635c:	42 81       	ldd	r20, Z+2	; 0x02
    635e:	53 81       	ldd	r21, Z+3	; 0x03
    6360:	8e 85       	ldd	r24, Y+14	; 0x0e
    6362:	9f 85       	ldd	r25, Y+15	; 0x0f
    6364:	a8 89       	ldd	r26, Y+16	; 0x10
    6366:	b9 89       	ldd	r27, Y+17	; 0x11
    6368:	28 17       	cp	r18, r24
    636a:	39 07       	cpc	r19, r25
    636c:	4a 07       	cpc	r20, r26
    636e:	5b 07       	cpc	r21, r27
    6370:	69 f4       	brne	.+26     	; 0x638c <arp+0xf4>
									{
										ARPtable[i].IP = ARP_packet->ARP_sourceIP;
										ARPtable[i].ttl = Default_ARP_ttl;
    6372:	62 87       	std	Z+10, r22	; 0x0a
										for ( a = 0 ; a < 6 ; a++ ) ARPtable[i].MAC[a] = ARP_packet->ARP_sourceMac[a];
    6374:	88 85       	ldd	r24, Y+8	; 0x08
    6376:	84 83       	std	Z+4, r24	; 0x04
    6378:	89 85       	ldd	r24, Y+9	; 0x09
    637a:	85 83       	std	Z+5, r24	; 0x05
    637c:	8a 85       	ldd	r24, Y+10	; 0x0a
    637e:	86 83       	std	Z+6, r24	; 0x06
    6380:	8b 85       	ldd	r24, Y+11	; 0x0b
    6382:	87 83       	std	Z+7, r24	; 0x07
    6384:	8c 85       	ldd	r24, Y+12	; 0x0c
    6386:	80 87       	std	Z+8, r24	; 0x08
    6388:	8d 85       	ldd	r24, Y+13	; 0x0d
    638a:	81 87       	std	Z+9, r24	; 0x09
    638c:	3b 96       	adiw	r30, 0x0b	; 11
										ETH_packet->ETH_destMac[i] = ETH_packet->ETH_sourceMac[i];	
										ETH_packet->ETH_sourceMac[i] = mymac[i]; }
								sendEthernetframe( packet_lenght, ethernetbuffer);
								break;
			case 0x0200:		// check mal ob das f체r mich ist !
								for( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
    638e:	2a e0       	ldi	r18, 0x0A	; 10
    6390:	e7 35       	cpi	r30, 0x57	; 87
    6392:	f2 07       	cpc	r31, r18
    6394:	09 f7       	brne	.-62     	; 0x6358 <arp+0xc0>
										for ( a = 0 ; a < 6 ; a++ ) ARPtable[i].MAC[a] = ARP_packet->ARP_sourceMac[a];
									}
								}
								break;
		}
	}
    6396:	cd b7       	in	r28, 0x3d	; 61
    6398:	de b7       	in	r29, 0x3e	; 62
    639a:	e6 e0       	ldi	r30, 0x06	; 6
    639c:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

000063a0 <GetIP2MAC>:
 * \return				Die MAC-Adresse im Puffer.
 * \retval ARP_ANSWER	Die MAC anfrage war erfolgrich.
 * \retval NO_ARP_ANSWER Die MAC-anfrage ist Fehlgeschlagen.
 */
unsigned int GetIP2MAC( unsigned long IP, unsigned char * MACbuffer )
	{
    63a0:	6f 92       	push	r6
    63a2:	7f 92       	push	r7
    63a4:	8f 92       	push	r8
    63a6:	9f 92       	push	r9
    63a8:	af 92       	push	r10
    63aa:	bf 92       	push	r11
    63ac:	df 92       	push	r13
    63ae:	ef 92       	push	r14
    63b0:	ff 92       	push	r15
    63b2:	0f 93       	push	r16
    63b4:	1f 93       	push	r17
    63b6:	df 93       	push	r29
    63b8:	cf 93       	push	r28
    63ba:	cd b7       	in	r28, 0x3d	; 61
    63bc:	de b7       	in	r29, 0x3e	; 62
    63be:	7b 01       	movw	r14, r22
    63c0:	8c 01       	movw	r16, r24
    63c2:	4a 01       	movw	r8, r20
			{
				CLOCK_ReleaseCountdownTimer( timer );
				return( NO_ARP_ANSWER );
			}
		}
	}
    63c4:	6d b6       	in	r6, 0x3d	; 61
    63c6:	7e b6       	in	r7, 0x3e	; 62
		unsigned int i,a,ARPentry=0;

		// Ist die MAC schon in der Liste und g체ltig ?
		for( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
		{		
			if ( ARPtable[ i ].ttl > 0 )
    63c8:	30 91 4b 0a 	lds	r19, 0x0A4B
    63cc:	33 23       	and	r19, r19
    63ce:	81 f0       	breq	.+32     	; 0x63f0 <GetIP2MAC+0x50>
			{
				if ( ARPtable[ i ].IP == IP )
    63d0:	80 91 41 0a 	lds	r24, 0x0A41
    63d4:	90 91 42 0a 	lds	r25, 0x0A42
    63d8:	a0 91 43 0a 	lds	r26, 0x0A43
    63dc:	b0 91 44 0a 	lds	r27, 0x0A44
    63e0:	8e 15       	cp	r24, r14
    63e2:	9f 05       	cpc	r25, r15
    63e4:	a0 07       	cpc	r26, r16
    63e6:	b1 07       	cpc	r27, r17
    63e8:	19 f4       	brne	.+6      	; 0x63f0 <GetIP2MAC+0x50>
    63ea:	20 e0       	ldi	r18, 0x00	; 0
    63ec:	30 e0       	ldi	r19, 0x00	; 0
    63ee:	13 c0       	rjmp	.+38     	; 0x6416 <GetIP2MAC+0x76>
		unsigned int i,a,ARPentry=0;

		// Ist die MAC schon in der Liste und g체ltig ?
		for( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
		{		
			if ( ARPtable[ i ].ttl > 0 )
    63f0:	20 91 56 0a 	lds	r18, 0x0A56
    63f4:	22 23       	and	r18, r18
    63f6:	39 f1       	breq	.+78     	; 0x6446 <GetIP2MAC+0xa6>
			{
				if ( ARPtable[ i ].IP == IP )
    63f8:	80 91 4c 0a 	lds	r24, 0x0A4C
    63fc:	90 91 4d 0a 	lds	r25, 0x0A4D
    6400:	a0 91 4e 0a 	lds	r26, 0x0A4E
    6404:	b0 91 4f 0a 	lds	r27, 0x0A4F
    6408:	8e 15       	cp	r24, r14
    640a:	9f 05       	cpc	r25, r15
    640c:	a0 07       	cpc	r26, r16
    640e:	b1 07       	cpc	r27, r17
    6410:	d1 f4       	brne	.+52     	; 0x6446 <GetIP2MAC+0xa6>
    6412:	21 e0       	ldi	r18, 0x01	; 1
    6414:	30 e0       	ldi	r19, 0x00	; 0
    6416:	8b e0       	ldi	r24, 0x0B	; 11
    6418:	90 e0       	ldi	r25, 0x00	; 0
    641a:	28 9f       	mul	r18, r24
    641c:	d0 01       	movw	r26, r0
    641e:	29 9f       	mul	r18, r25
    6420:	b0 0d       	add	r27, r0
    6422:	38 9f       	mul	r19, r24
    6424:	b0 0d       	add	r27, r0
    6426:	11 24       	eor	r1, r1
    6428:	ab 5b       	subi	r26, 0xBB	; 187
    642a:	b5 4f       	sbci	r27, 0xF5	; 245
    642c:	20 e0       	ldi	r18, 0x00	; 0
    642e:	30 e0       	ldi	r19, 0x00	; 0
				{
					for( a = 0 ; a < 6 ; a++ ) MACbuffer[a] = ARPtable[ i ].MAC[a];
    6430:	f4 01       	movw	r30, r8
    6432:	e2 0f       	add	r30, r18
    6434:	f3 1f       	adc	r31, r19
    6436:	8d 91       	ld	r24, X+
    6438:	80 83       	st	Z, r24
    643a:	2f 5f       	subi	r18, 0xFF	; 255
    643c:	3f 4f       	sbci	r19, 0xFF	; 255
    643e:	26 30       	cpi	r18, 0x06	; 6
    6440:	31 05       	cpc	r19, r1
    6442:	b1 f7       	brne	.-20     	; 0x6430 <GetIP2MAC+0x90>
    6444:	b0 c0       	rjmp	.+352    	; 0x65a6 <GetIP2MAC+0x206>
		}

		// Suche nach freien Eintrag
		for( i = 0 ; i < MAX_ARPTABLE_ENTRYS ; i++ )
		{
			if ( ARPtable[ i ].ttl == 0 )
    6446:	33 23       	and	r19, r19
    6448:	29 f4       	brne	.+10     	; 0x6454 <GetIP2MAC+0xb4>
    644a:	20 e0       	ldi	r18, 0x00	; 0
    644c:	30 e0       	ldi	r19, 0x00	; 0
    644e:	40 e0       	ldi	r20, 0x00	; 0
    6450:	50 e0       	ldi	r21, 0x00	; 0
    6452:	09 c0       	rjmp	.+18     	; 0x6466 <GetIP2MAC+0xc6>
    6454:	22 23       	and	r18, r18
    6456:	19 f0       	breq	.+6      	; 0x645e <GetIP2MAC+0xbe>
    6458:	aa 24       	eor	r10, r10
    645a:	bb 24       	eor	r11, r11
    645c:	14 c0       	rjmp	.+40     	; 0x6486 <GetIP2MAC+0xe6>
    645e:	21 e0       	ldi	r18, 0x01	; 1
    6460:	30 e0       	ldi	r19, 0x00	; 0
    6462:	41 e0       	ldi	r20, 0x01	; 1
    6464:	50 e0       	ldi	r21, 0x00	; 0
			{
				ARPtable[ i ].IP = IP;
    6466:	8b e0       	ldi	r24, 0x0B	; 11
    6468:	90 e0       	ldi	r25, 0x00	; 0
    646a:	28 9f       	mul	r18, r24
    646c:	f0 01       	movw	r30, r0
    646e:	29 9f       	mul	r18, r25
    6470:	f0 0d       	add	r31, r0
    6472:	38 9f       	mul	r19, r24
    6474:	f0 0d       	add	r31, r0
    6476:	11 24       	eor	r1, r1
    6478:	ef 5b       	subi	r30, 0xBF	; 191
    647a:	f5 4f       	sbci	r31, 0xF5	; 245
    647c:	e0 82       	st	Z, r14
    647e:	f1 82       	std	Z+1, r15	; 0x01
    6480:	02 83       	std	Z+2, r16	; 0x02
    6482:	13 83       	std	Z+3, r17	; 0x03
    6484:	5a 01       	movw	r10, r20
				break;
			}
		}
		
		unsigned char * ethernetbuffer;
		ethernetbuffer = (unsigned char*) __builtin_alloca (( size_t ) ETHERNET_HEADER_LENGTH + ARP_HEADER_LENGHT );
    6486:	8d b7       	in	r24, 0x3d	; 61
    6488:	9e b7       	in	r25, 0x3e	; 62
    648a:	8a 97       	sbiw	r24, 0x2a	; 42
    648c:	0f b6       	in	r0, 0x3f	; 63
    648e:	f8 94       	cli
    6490:	9e bf       	out	0x3e, r25	; 62
    6492:	0f be       	out	0x3f, r0	; 63
    6494:	8d bf       	out	0x3d, r24	; 61
    6496:	4d b7       	in	r20, 0x3d	; 61
    6498:	5e b7       	in	r21, 0x3e	; 62
    649a:	4f 5f       	subi	r20, 0xFF	; 255
    649c:	5f 4f       	sbci	r21, 0xFF	; 255
		
		struct ETH_header *ETH_packet;
		ETH_packet = (struct ETH_header *) ethernetbuffer; 
		struct ARP_header *ARP_packet;
		ARP_packet = (struct ARP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    649e:	ed b7       	in	r30, 0x3d	; 61
    64a0:	fe b7       	in	r31, 0x3e	; 62
    64a2:	3f 96       	adiw	r30, 0x0f	; 15

		// Hardware Type Ethernet
		ARP_packet->HWtype = 0x0100;
    64a4:	20 e0       	ldi	r18, 0x00	; 0
    64a6:	31 e0       	ldi	r19, 0x01	; 1
    64a8:	ad b7       	in	r26, 0x3d	; 61
    64aa:	be b7       	in	r27, 0x3e	; 62
    64ac:	50 96       	adiw	r26, 0x10	; 16
    64ae:	3c 93       	st	X, r19
    64b0:	2e 93       	st	-X, r18
    64b2:	1f 97       	sbiw	r26, 0x0f	; 15
		// Protocoltype = IP
		ARP_packet->Protocoltype = 0x0008;
    64b4:	88 e0       	ldi	r24, 0x08	; 8
    64b6:	90 e0       	ldi	r25, 0x00	; 0
    64b8:	93 83       	std	Z+3, r25	; 0x03
    64ba:	82 83       	std	Z+2, r24	; 0x02
		// Hardware adresse size 6
		ARP_packet->HWsize = 0x06;
    64bc:	86 e0       	ldi	r24, 0x06	; 6
    64be:	84 83       	std	Z+4, r24	; 0x04
		// Protocolsize 4
		ARP_packet->Protocolsize = 0x4;
    64c0:	84 e0       	ldi	r24, 0x04	; 4
    64c2:	85 83       	std	Z+5, r24	; 0x05
		// Opcode f체r request
		ARP_packet->ARP_Opcode = 0x0100;
    64c4:	37 83       	std	Z+7, r19	; 0x07
    64c6:	26 83       	std	Z+6, r18	; 0x06
		// mac auf 0 setzen
		for ( i = 0; i < 6; i++ )ARP_packet->ARP_destMac[i] = 0x00;
    64c8:	12 8a       	std	Z+18, r1	; 0x12
    64ca:	13 8a       	std	Z+19, r1	; 0x13
    64cc:	14 8a       	std	Z+20, r1	; 0x14
    64ce:	15 8a       	std	Z+21, r1	; 0x15
    64d0:	16 8a       	std	Z+22, r1	; 0x16
    64d2:	17 8a       	std	Z+23, r1	; 0x17
		// IP die abgefragt werden soll
		ARP_packet->ARP_destIP = IP;
    64d4:	e0 8e       	std	Z+24, r14	; 0x18
    64d6:	f1 8e       	std	Z+25, r15	; 0x19
    64d8:	02 8f       	std	Z+26, r16	; 0x1a
    64da:	13 8f       	std	Z+27, r17	; 0x1b
		// meine mac und ip als absender einsetzen
		for ( i = 0; i < 6 ; i++ )ARP_packet->ARP_sourceMac[i] = mymac[i]; // MAC einsetzen
    64dc:	80 91 3b 01 	lds	r24, 0x013B
    64e0:	80 87       	std	Z+8, r24	; 0x08
    64e2:	80 91 3c 01 	lds	r24, 0x013C
    64e6:	81 87       	std	Z+9, r24	; 0x09
    64e8:	80 91 3d 01 	lds	r24, 0x013D
    64ec:	82 87       	std	Z+10, r24	; 0x0a
    64ee:	80 91 3e 01 	lds	r24, 0x013E
    64f2:	83 87       	std	Z+11, r24	; 0x0b
    64f4:	80 91 3f 01 	lds	r24, 0x013F
    64f8:	84 87       	std	Z+12, r24	; 0x0c
    64fa:	80 91 40 01 	lds	r24, 0x0140
    64fe:	85 87       	std	Z+13, r24	; 0x0d
		ARP_packet->ARP_sourceIP = myIP ; // IP einsetzen
    6500:	80 91 41 01 	lds	r24, 0x0141
    6504:	90 91 42 01 	lds	r25, 0x0142
    6508:	a0 91 43 01 	lds	r26, 0x0143
    650c:	b0 91 44 01 	lds	r27, 0x0144
    6510:	86 87       	std	Z+14, r24	; 0x0e
    6512:	97 87       	std	Z+15, r25	; 0x0f
    6514:	a0 8b       	std	Z+16, r26	; 0x10
    6516:	b1 8b       	std	Z+17, r27	; 0x11
    6518:	ab e3       	ldi	r26, 0x3B	; 59
    651a:	b1 e0       	ldi	r27, 0x01	; 1
    651c:	fa 01       	movw	r30, r20
		// sourceMAC in destMAC in Ethernetframe eintragen

		for( i = 0 ; i < 6 ; i++){	
				ETH_packet->ETH_destMac[i] = 0xff;	
    651e:	9f ef       	ldi	r25, 0xFF	; 255
    6520:	90 83       	st	Z, r25
				ETH_packet->ETH_sourceMac[i] = mymac[i]; }
    6522:	8d 91       	ld	r24, X+
    6524:	86 83       	std	Z+6, r24	; 0x06
    6526:	31 96       	adiw	r30, 0x01	; 1
		// meine mac und ip als absender einsetzen
		for ( i = 0; i < 6 ; i++ )ARP_packet->ARP_sourceMac[i] = mymac[i]; // MAC einsetzen
		ARP_packet->ARP_sourceIP = myIP ; // IP einsetzen
		// sourceMAC in destMAC in Ethernetframe eintragen

		for( i = 0 ; i < 6 ; i++){	
    6528:	81 e0       	ldi	r24, 0x01	; 1
    652a:	a1 34       	cpi	r26, 0x41	; 65
    652c:	b8 07       	cpc	r27, r24
    652e:	c1 f7       	brne	.-16     	; 0x6520 <GetIP2MAC+0x180>
				ETH_packet->ETH_destMac[i] = 0xff;	
				ETH_packet->ETH_sourceMac[i] = mymac[i]; }
		ETH_packet->ETH_typefield = 0x0608;
    6530:	88 e0       	ldi	r24, 0x08	; 8
    6532:	96 e0       	ldi	r25, 0x06	; 6
    6534:	da 01       	movw	r26, r20
    6536:	1d 96       	adiw	r26, 0x0d	; 13
    6538:	9c 93       	st	X, r25
    653a:	8e 93       	st	-X, r24
    653c:	1c 97       	sbiw	r26, 0x0c	; 12
				
		sendEthernetframe( ETHERNET_HEADER_LENGTH + ARP_HEADER_LENGHT , ethernetbuffer);
    653e:	8a e2       	ldi	r24, 0x2A	; 42
    6540:	90 e0       	ldi	r25, 0x00	; 0
    6542:	ba 01       	movw	r22, r20
    6544:	0e 94 4d 30 	call	0x609a	; 0x609a <sendEthernetframe>
		
		unsigned char timer;
		
		timer = CLOCK_RegisterCoundowntimer();
    6548:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <CLOCK_RegisterCoundowntimer>
    654c:	d8 2e       	mov	r13, r24
		CLOCK_SetCountdownTimer( timer, 10 , MSECOUND );
    654e:	90 e0       	ldi	r25, 0x00	; 0
    6550:	6a e0       	ldi	r22, 0x0A	; 10
    6552:	70 e0       	ldi	r23, 0x00	; 0
    6554:	41 e0       	ldi	r20, 0x01	; 1
    6556:	0e 94 37 1b 	call	0x366e	; 0x366e <CLOCK_SetCountdownTimer>

		while ( 1 )
		{
			if ( ( ARPtable[ ARPentry ].ttl > 0 ) )
    655a:	8b e0       	ldi	r24, 0x0B	; 11
    655c:	90 e0       	ldi	r25, 0x00	; 0
    655e:	a8 9e       	mul	r10, r24
    6560:	80 01       	movw	r16, r0
    6562:	a9 9e       	mul	r10, r25
    6564:	10 0d       	add	r17, r0
    6566:	b8 9e       	mul	r11, r24
    6568:	10 0d       	add	r17, r0
    656a:	11 24       	eor	r1, r1
    656c:	8b e4       	ldi	r24, 0x4B	; 75
    656e:	e8 2e       	mov	r14, r24
    6570:	8a e0       	ldi	r24, 0x0A	; 10
    6572:	f8 2e       	mov	r15, r24
    6574:	e0 0e       	add	r14, r16
    6576:	f1 1e       	adc	r15, r17
    6578:	f7 01       	movw	r30, r14
    657a:	80 81       	ld	r24, Z
    657c:	88 23       	and	r24, r24
    657e:	b1 f0       	breq	.+44     	; 0x65ac <GetIP2MAC+0x20c>
    6580:	d8 01       	movw	r26, r16
    6582:	ab 5b       	subi	r26, 0xBB	; 187
    6584:	b5 4f       	sbci	r27, 0xF5	; 245
    6586:	20 e0       	ldi	r18, 0x00	; 0
    6588:	30 e0       	ldi	r19, 0x00	; 0
			{
				for( i = 0 ; i < 6 ; i++ ) MACbuffer[i] = ARPtable[ ARPentry ].MAC[i];
    658a:	f4 01       	movw	r30, r8
    658c:	e2 0f       	add	r30, r18
    658e:	f3 1f       	adc	r31, r19
    6590:	8d 91       	ld	r24, X+
    6592:	80 83       	st	Z, r24
    6594:	2f 5f       	subi	r18, 0xFF	; 255
    6596:	3f 4f       	sbci	r19, 0xFF	; 255
    6598:	26 30       	cpi	r18, 0x06	; 6
    659a:	31 05       	cpc	r19, r1
    659c:	b1 f7       	brne	.-20     	; 0x658a <GetIP2MAC+0x1ea>
				CLOCK_ReleaseCountdownTimer( timer );
    659e:	8d 2d       	mov	r24, r13
    65a0:	90 e0       	ldi	r25, 0x00	; 0
    65a2:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
    65a6:	20 e0       	ldi	r18, 0x00	; 0
    65a8:	30 e0       	ldi	r19, 0x00	; 0
    65aa:	0c c0       	rjmp	.+24     	; 0x65c4 <GetIP2MAC+0x224>
				return( ARP_ANSWER );
			}
			if ( CLOCK_GetCountdownTimer( timer ) == 0 ) 
    65ac:	8d 2d       	mov	r24, r13
    65ae:	90 e0       	ldi	r25, 0x00	; 0
    65b0:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    65b4:	89 2b       	or	r24, r25
    65b6:	01 f7       	brne	.-64     	; 0x6578 <GetIP2MAC+0x1d8>
			{
				CLOCK_ReleaseCountdownTimer( timer );
    65b8:	8d 2d       	mov	r24, r13
    65ba:	90 e0       	ldi	r25, 0x00	; 0
    65bc:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
    65c0:	21 e0       	ldi	r18, 0x01	; 1
    65c2:	30 e0       	ldi	r19, 0x00	; 0
				return( NO_ARP_ANSWER );
			}
		}
	}
    65c4:	c9 01       	movw	r24, r18
    65c6:	0f b6       	in	r0, 0x3f	; 63
    65c8:	f8 94       	cli
    65ca:	7e be       	out	0x3e, r7	; 62
    65cc:	0f be       	out	0x3f, r0	; 63
    65ce:	6d be       	out	0x3d, r6	; 61
    65d0:	cf 91       	pop	r28
    65d2:	df 91       	pop	r29
    65d4:	1f 91       	pop	r17
    65d6:	0f 91       	pop	r16
    65d8:	ff 90       	pop	r15
    65da:	ef 90       	pop	r14
    65dc:	df 90       	pop	r13
    65de:	bf 90       	pop	r11
    65e0:	af 90       	pop	r10
    65e2:	9f 90       	pop	r9
    65e4:	8f 90       	pop	r8
    65e6:	7f 90       	pop	r7
    65e8:	6f 90       	pop	r6
    65ea:	08 95       	ret

000065ec <ARP_INIT>:
void ARP_INIT( void )
{
	unsigned int i;
	
	for( i = 0; i < MAX_ARPTABLE_ENTRYS ; i++ )
		ARPtable[ i ].ttl = 0;
    65ec:	10 92 4b 0a 	sts	0x0A4B, r1
    65f0:	10 92 56 0a 	sts	0x0A56, r1

	CLOCK_RegisterCallbackFunction( ARP_Timeouthandler, SECOUND );
    65f4:	87 ef       	ldi	r24, 0xF7	; 247
    65f6:	90 e3       	ldi	r25, 0x30	; 48
    65f8:	62 e0       	ldi	r22, 0x02	; 2
    65fa:	0e 94 82 1b 	call	0x3704	; 0x3704 <CLOCK_RegisterCallbackFunction>
}
    65fe:	08 95       	ret

00006600 <iptostr>:
	else
		return( 0 );
}

char * iptostr( unsigned long IP, char * strIP )
{
    6600:	0f 93       	push	r16
    6602:	1f 93       	push	r17
    6604:	14 2f       	mov	r17, r20
    6606:	05 2f       	mov	r16, r21
	// Union f체r IP
	union IP_ADDRESS IPnum;

	IPnum.IP = IP;
	
	sprintf_P( strIP, PSTR("%d.%d.%d.%d"), IPnum.IPbyte[0],IPnum.IPbyte[1],IPnum.IPbyte[2],IPnum.IPbyte[3]);
    6608:	2d b7       	in	r18, 0x3d	; 61
    660a:	3e b7       	in	r19, 0x3e	; 62
    660c:	2c 50       	subi	r18, 0x0C	; 12
    660e:	30 40       	sbci	r19, 0x00	; 0
    6610:	0f b6       	in	r0, 0x3f	; 63
    6612:	f8 94       	cli
    6614:	3e bf       	out	0x3e, r19	; 62
    6616:	0f be       	out	0x3f, r0	; 63
    6618:	2d bf       	out	0x3d, r18	; 61
    661a:	ed b7       	in	r30, 0x3d	; 61
    661c:	fe b7       	in	r31, 0x3e	; 62
    661e:	31 96       	adiw	r30, 0x01	; 1
    6620:	ad b7       	in	r26, 0x3d	; 61
    6622:	be b7       	in	r27, 0x3e	; 62
    6624:	11 96       	adiw	r26, 0x01	; 1
    6626:	4c 93       	st	X, r20
    6628:	51 83       	std	Z+1, r21	; 0x01
    662a:	2e e8       	ldi	r18, 0x8E	; 142
    662c:	30 e0       	ldi	r19, 0x00	; 0
    662e:	33 83       	std	Z+3, r19	; 0x03
    6630:	22 83       	std	Z+2, r18	; 0x02
    6632:	64 83       	std	Z+4, r22	; 0x04
    6634:	15 82       	std	Z+5, r1	; 0x05
    6636:	76 83       	std	Z+6, r23	; 0x06
    6638:	17 82       	std	Z+7, r1	; 0x07
    663a:	80 87       	std	Z+8, r24	; 0x08
    663c:	11 86       	std	Z+9, r1	; 0x09
    663e:	92 87       	std	Z+10, r25	; 0x0a
    6640:	13 86       	std	Z+11, r1	; 0x0b
    6642:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
    6646:	2d b7       	in	r18, 0x3d	; 61
    6648:	3e b7       	in	r19, 0x3e	; 62
    664a:	24 5f       	subi	r18, 0xF4	; 244
    664c:	3f 4f       	sbci	r19, 0xFF	; 255
    664e:	0f b6       	in	r0, 0x3f	; 63
    6650:	f8 94       	cli
    6652:	3e bf       	out	0x3e, r19	; 62
    6654:	0f be       	out	0x3f, r0	; 63
    6656:	2d bf       	out	0x3d, r18	; 61
	
	return( strIP );
}
    6658:	81 2f       	mov	r24, r17
    665a:	90 2f       	mov	r25, r16
    665c:	1f 91       	pop	r17
    665e:	0f 91       	pop	r16
    6660:	08 95       	ret

00006662 <strtoip>:
 * \param	buffer		Pointer auf den String der umgewandelt werden soll.
 * \return  	IP		Die IP oder 0 wenn keine g체ltiger String da war.
 */
/* -----------------------------------------------------------------------------------------------------------*/
unsigned long strtoip( unsigned char * buffer )
{
    6662:	a0 e0       	ldi	r26, 0x00	; 0
    6664:	b0 e0       	ldi	r27, 0x00	; 0
    6666:	e7 e3       	ldi	r30, 0x37	; 55
    6668:	f3 e3       	ldi	r31, 0x33	; 51
    666a:	0c 94 bd 6a 	jmp	0xd57a	; 0xd57a <__prologue_saves__+0x8>
    666e:	3c 01       	movw	r6, r24
	unsigned int i , len , y = 0;
	unsigned long IP = 0;
	
	len = strlen( buffer );
    6670:	dc 01       	movw	r26, r24
    6672:	0d 90       	ld	r0, X+
    6674:	00 20       	and	r0, r0
    6676:	e9 f7       	brne	.-6      	; 0x6672 <strtoip+0x10>
    6678:	5d 01       	movw	r10, r26
    667a:	08 94       	sec
    667c:	a1 08       	sbc	r10, r1
    667e:	b1 08       	sbc	r11, r1
    6680:	a8 1a       	sub	r10, r24
    6682:	b9 0a       	sbc	r11, r25
    6684:	c0 e0       	ldi	r28, 0x00	; 0
    6686:	d0 e0       	ldi	r29, 0x00	; 0
    6688:	88 24       	eor	r8, r8
    668a:	99 24       	eor	r9, r9
    668c:	cc 24       	eor	r12, r12
    668e:	dd 24       	eor	r13, r13
    6690:	76 01       	movw	r14, r12
    6692:	22 c0       	rjmp	.+68     	; 0x66d8 <strtoip+0x76>
	// string zerlegen
	for( i = 0 ; i < len && y < 4 ; i++ )
	{
		IP = IP<<8;
		// zeichen in zahl wandeln
		IP |= atoi( &buffer[i] );
    6694:	83 01       	movw	r16, r6
    6696:	0c 0f       	add	r16, r28
    6698:	1d 1f       	adc	r17, r29
    669a:	c8 01       	movw	r24, r16
    669c:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    66a0:	9c 01       	movw	r18, r24
    66a2:	f8 01       	movw	r30, r16
		
		// nach dem n채chsten punkt suchen
		for ( ; i < len ; i++ )
		{
			if ( buffer[i] == '.' )
    66a4:	80 81       	ld	r24, Z
    66a6:	8e 32       	cpi	r24, 0x2E	; 46
    66a8:	21 f4       	brne	.+8      	; 0x66b2 <strtoip+0x50>
			{
				y++;
    66aa:	08 94       	sec
    66ac:	81 1c       	adc	r8, r1
    66ae:	91 1c       	adc	r9, r1
    66b0:	05 c0       	rjmp	.+10     	; 0x66bc <strtoip+0x5a>
		IP = IP<<8;
		// zeichen in zahl wandeln
		IP |= atoi( &buffer[i] );
		
		// nach dem n채chsten punkt suchen
		for ( ; i < len ; i++ )
    66b2:	21 96       	adiw	r28, 0x01	; 1
    66b4:	31 96       	adiw	r30, 0x01	; 1
    66b6:	ca 15       	cp	r28, r10
    66b8:	db 05       	cpc	r29, r11
    66ba:	a0 f3       	brcs	.-24     	; 0x66a4 <strtoip+0x42>
		}
	
	// string zerlegen
	for( i = 0 ; i < len && y < 4 ; i++ )
	{
		IP = IP<<8;
    66bc:	fe 2c       	mov	r15, r14
    66be:	ed 2c       	mov	r14, r13
    66c0:	dc 2c       	mov	r13, r12
    66c2:	cc 24       	eor	r12, r12
		// zeichen in zahl wandeln
		IP |= atoi( &buffer[i] );
    66c4:	c9 01       	movw	r24, r18
    66c6:	aa 27       	eor	r26, r26
    66c8:	97 fd       	sbrc	r25, 7
    66ca:	a0 95       	com	r26
    66cc:	ba 2f       	mov	r27, r26
    66ce:	c8 2a       	or	r12, r24
    66d0:	d9 2a       	or	r13, r25
    66d2:	ea 2a       	or	r14, r26
    66d4:	fb 2a       	or	r15, r27
		{
			return( 0 );
		}
	
	// string zerlegen
	for( i = 0 ; i < len && y < 4 ; i++ )
    66d6:	21 96       	adiw	r28, 0x01	; 1
    66d8:	ca 15       	cp	r28, r10
    66da:	db 05       	cpc	r29, r11
    66dc:	28 f0       	brcs	.+10     	; 0x66e8 <strtoip+0x86>
			}
		}
	}	

	// wenn schon 4 zahlen gewandelt, verlassen
	if( y == 3 )
    66de:	b3 e0       	ldi	r27, 0x03	; 3
    66e0:	8b 16       	cp	r8, r27
    66e2:	91 04       	cpc	r9, r1
    66e4:	69 f4       	brne	.+26     	; 0x6700 <strtoip+0x9e>
    66e6:	05 c0       	rjmp	.+10     	; 0x66f2 <strtoip+0x90>
		{
			return( 0 );
		}
	
	// string zerlegen
	for( i = 0 ; i < len && y < 4 ; i++ )
    66e8:	84 e0       	ldi	r24, 0x04	; 4
    66ea:	88 16       	cp	r8, r24
    66ec:	91 04       	cpc	r9, r1
    66ee:	90 f2       	brcs	.-92     	; 0x6694 <strtoip+0x32>
    66f0:	07 c0       	rjmp	.+14     	; 0x6700 <strtoip+0x9e>
		}
	}	

	// wenn schon 4 zahlen gewandelt, verlassen
	if( y == 3 )
		return( ChangeEndian32bit(IP) );
    66f2:	c7 01       	movw	r24, r14
    66f4:	b6 01       	movw	r22, r12
    66f6:	0e 94 9e 37 	call	0x6f3c	; 0x6f3c <ChangeEndian32bit>
    66fa:	9b 01       	movw	r18, r22
    66fc:	ac 01       	movw	r20, r24
    66fe:	04 c0       	rjmp	.+8      	; 0x6708 <strtoip+0xa6>
    6700:	20 e0       	ldi	r18, 0x00	; 0
    6702:	30 e0       	ldi	r19, 0x00	; 0
    6704:	40 e0       	ldi	r20, 0x00	; 0
    6706:	50 e0       	ldi	r21, 0x00	; 0
	else
		return( 0 );
}
    6708:	b9 01       	movw	r22, r18
    670a:	ca 01       	movw	r24, r20
    670c:	cd b7       	in	r28, 0x3d	; 61
    670e:	de b7       	in	r29, 0x3e	; 62
    6710:	ee e0       	ldi	r30, 0x0E	; 14
    6712:	0c 94 d9 6a 	jmp	0xd5b2	; 0xd5b2 <__epilogue_restores__+0x8>

00006716 <MakeIPheader>:
 * \param	ethernetbuffer	Zeiger auf das komplette packet wo es im Speicher liegt
 * \return  kein
 */
/* -----------------------------------------------------------------------------------------------------------*/
void MakeIPheader( unsigned long SourceIP, unsigned char Protocoll, unsigned int Datalenght , unsigned char *ethernetbuffer )
	{
    6716:	9f 92       	push	r9
    6718:	af 92       	push	r10
    671a:	bf 92       	push	r11
    671c:	cf 92       	push	r12
    671e:	df 92       	push	r13
    6720:	ef 92       	push	r14
    6722:	ff 92       	push	r15
    6724:	0f 93       	push	r16
    6726:	1f 93       	push	r17
    6728:	5b 01       	movw	r10, r22
    672a:	6c 01       	movw	r12, r24
    672c:	94 2e       	mov	r9, r20
    672e:	c9 01       	movw	r24, r18
    6730:	78 01       	movw	r14, r16
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *) ethernetbuffer;
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH];
    6732:	02 5f       	subi	r16, 0xF2	; 242
    6734:	1f 4f       	sbci	r17, 0xFF	; 255
		struct TCP_header *TCP_packet;		// TCP_struct anlegen
		TCP_packet = ( struct TCP_header *) &ethernetbuffer[ETHERNET_HEADER_LENGTH + ((IP_packet->IP_Version_Headerlen & 0x0f) * 4 )];

		IP_packet->IP_Version_Headerlen = 0x45;
    6736:	25 e4       	ldi	r18, 0x45	; 69
    6738:	f7 01       	movw	r30, r14
    673a:	26 87       	std	Z+14, r18	; 0x0e
		IP_packet->IP_TOS = 0x0;
    673c:	f8 01       	movw	r30, r16
    673e:	11 82       	std	Z+1, r1	; 0x01
		IP_packet->IP_Totallenght = ChangeEndian16bit ( IP_HEADER_LENGHT + Datalenght );
    6740:	44 96       	adiw	r24, 0x14	; 20
    6742:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    6746:	f8 01       	movw	r30, r16
    6748:	93 83       	std	Z+3, r25	; 0x03
    674a:	82 83       	std	Z+2, r24	; 0x02
		IP_packet->IP_Identification = 0x1DAC;
    674c:	8c ea       	ldi	r24, 0xAC	; 172
    674e:	9d e1       	ldi	r25, 0x1D	; 29
    6750:	95 83       	std	Z+5, r25	; 0x05
    6752:	84 83       	std	Z+4, r24	; 0x04
		IP_packet->IP_Flags = 0x40;
    6754:	80 e4       	ldi	r24, 0x40	; 64
    6756:	86 83       	std	Z+6, r24	; 0x06
		IP_packet->IP_Fragmentoffset = 0x0;
    6758:	17 82       	std	Z+7, r1	; 0x07
		IP_packet->IP_TTL = 64 ;		
    675a:	80 87       	std	Z+8, r24	; 0x08
		IP_packet->IP_Protocol = Protocoll;
    675c:	91 86       	std	Z+9, r9	; 0x09
		IP_packet->IP_Headerchecksum = 0x0;
    675e:	13 86       	std	Z+11, r1	; 0x0b
    6760:	12 86       	std	Z+10, r1	; 0x0a
		IP_packet->IP_SourceIP = myIP;
    6762:	80 91 41 01 	lds	r24, 0x0141
    6766:	90 91 42 01 	lds	r25, 0x0142
    676a:	a0 91 43 01 	lds	r26, 0x0143
    676e:	b0 91 44 01 	lds	r27, 0x0144
    6772:	84 87       	std	Z+12, r24	; 0x0c
    6774:	95 87       	std	Z+13, r25	; 0x0d
    6776:	a6 87       	std	Z+14, r26	; 0x0e
    6778:	b7 87       	std	Z+15, r27	; 0x0f
		IP_packet->IP_DestinationIP = SourceIP;
    677a:	a0 8a       	std	Z+16, r10	; 0x10
    677c:	b1 8a       	std	Z+17, r11	; 0x11
    677e:	c2 8a       	std	Z+18, r12	; 0x12
    6780:	d3 8a       	std	Z+19, r13	; 0x13
		IP_packet->IP_Headerchecksum = ChangeEndian16bit( Checksum_16( &ethernetbuffer[ETHERNET_HEADER_LENGTH] ,(IP_packet->IP_Version_Headerlen & 0x0f) * 4 ) );
    6782:	f7 01       	movw	r30, r14
    6784:	66 85       	ldd	r22, Z+14	; 0x0e
    6786:	70 e0       	ldi	r23, 0x00	; 0
    6788:	6f 70       	andi	r22, 0x0F	; 15
    678a:	70 70       	andi	r23, 0x00	; 0
    678c:	66 0f       	add	r22, r22
    678e:	77 1f       	adc	r23, r23
    6790:	66 0f       	add	r22, r22
    6792:	77 1f       	adc	r23, r23
    6794:	c8 01       	movw	r24, r16
    6796:	0e 94 dd 37 	call	0x6fba	; 0x6fba <Checksum_16>
    679a:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    679e:	f8 01       	movw	r30, r16
    67a0:	93 87       	std	Z+11, r25	; 0x0b
    67a2:	82 87       	std	Z+10, r24	; 0x0a

		return;
	}
    67a4:	1f 91       	pop	r17
    67a6:	0f 91       	pop	r16
    67a8:	ff 90       	pop	r15
    67aa:	ef 90       	pop	r14
    67ac:	df 90       	pop	r13
    67ae:	cf 90       	pop	r12
    67b0:	bf 90       	pop	r11
    67b2:	af 90       	pop	r10
    67b4:	9f 90       	pop	r9
    67b6:	08 95       	ret

000067b8 <ip>:
 * \param	buffer			Zeiger auf das komplette Paket, wo es im Speicher liegt.
 * \return  kein
 */
/* -----------------------------------------------------------------------------------------------------------*/
void ip( unsigned int packet_lenght , unsigned char *buffer )
	{
    67b8:	cf 93       	push	r28
    67ba:	df 93       	push	r29
    67bc:	ec 01       	movw	r28, r24
		struct ETH_header *ETH_packet; 		// ETH_struct anlegen
		ETH_packet = (struct ETH_header *)&buffer[0];
		struct IP_header *IP_packet;		// IP_struct anlegen
		IP_packet = ( struct IP_header *)&buffer[ETHERNET_HEADER_LENGTH];
    67be:	fb 01       	movw	r30, r22
    67c0:	3e 96       	adiw	r30, 0x0e	; 14
											// checke mal ob dat 쩌berhaupt f쩌r uns ist
		// if ( IP_packet->IP_DestinationIP != myIP || IP_packet->IP_DestinationIP != 0xffffffff ) return;
			
		switch ( IP_packet->IP_Protocol )
    67c2:	81 85       	ldd	r24, Z+9	; 0x09
    67c4:	86 30       	cpi	r24, 0x06	; 6
    67c6:	31 f1       	breq	.+76     	; 0x6814 <ip+0x5c>
    67c8:	81 31       	cpi	r24, 0x11	; 17
    67ca:	c9 f1       	breq	.+114    	; 0x683e <ip+0x86>
    67cc:	81 30       	cpi	r24, 0x01	; 1
    67ce:	d1 f5       	brne	.+116    	; 0x6844 <ip+0x8c>
			{
				case 0x01:			if (( IP_packet->IP_DestinationIP != myIP )&&( IP_packet->IP_DestinationIP !=myBroadcast)) return;
    67d0:	20 89       	ldd	r18, Z+16	; 0x10
    67d2:	31 89       	ldd	r19, Z+17	; 0x11
    67d4:	42 89       	ldd	r20, Z+18	; 0x12
    67d6:	53 89       	ldd	r21, Z+19	; 0x13
    67d8:	80 91 41 01 	lds	r24, 0x0141
    67dc:	90 91 42 01 	lds	r25, 0x0142
    67e0:	a0 91 43 01 	lds	r26, 0x0143
    67e4:	b0 91 44 01 	lds	r27, 0x0144
    67e8:	28 17       	cp	r18, r24
    67ea:	39 07       	cpc	r19, r25
    67ec:	4a 07       	cpc	r20, r26
    67ee:	5b 07       	cpc	r21, r27
    67f0:	69 f0       	breq	.+26     	; 0x680c <ip+0x54>
    67f2:	80 91 45 01 	lds	r24, 0x0145
    67f6:	90 91 46 01 	lds	r25, 0x0146
    67fa:	a0 91 47 01 	lds	r26, 0x0147
    67fe:	b0 91 48 01 	lds	r27, 0x0148
    6802:	28 17       	cp	r18, r24
    6804:	39 07       	cpc	r19, r25
    6806:	4a 07       	cpc	r20, r26
    6808:	5b 07       	cpc	r21, r27
    680a:	e1 f4       	brne	.+56     	; 0x6844 <ip+0x8c>
									icmp( packet_lenght , buffer);
    680c:	ce 01       	movw	r24, r28
    680e:	0e 94 0f 22 	call	0x441e	; 0x441e <icmp>
    6812:	18 c0       	rjmp	.+48     	; 0x6844 <ip+0x8c>
									break;
				case 0x06:			if ( IP_packet->IP_DestinationIP != myIP ) return;
    6814:	20 89       	ldd	r18, Z+16	; 0x10
    6816:	31 89       	ldd	r19, Z+17	; 0x11
    6818:	42 89       	ldd	r20, Z+18	; 0x12
    681a:	53 89       	ldd	r21, Z+19	; 0x13
    681c:	80 91 41 01 	lds	r24, 0x0141
    6820:	90 91 42 01 	lds	r25, 0x0142
    6824:	a0 91 43 01 	lds	r26, 0x0143
    6828:	b0 91 44 01 	lds	r27, 0x0144
    682c:	28 17       	cp	r18, r24
    682e:	39 07       	cpc	r19, r25
    6830:	4a 07       	cpc	r20, r26
    6832:	5b 07       	cpc	r21, r27
    6834:	39 f4       	brne	.+14     	; 0x6844 <ip+0x8c>
									tcp( packet_lenght , buffer );
    6836:	ce 01       	movw	r24, r28
    6838:	0e 94 16 2c 	call	0x582c	; 0x582c <tcp>
    683c:	03 c0       	rjmp	.+6      	; 0x6844 <ip+0x8c>
									break;
				case 0x11:			udp( packet_lenght , buffer );
    683e:	ce 01       	movw	r24, r28
    6840:	0e 94 cf 23 	call	0x479e	; 0x479e <udp>
									break;
			}
	}
    6844:	df 91       	pop	r29
    6846:	cf 91       	pop	r28
    6848:	08 95       	ret

0000684a <NTP_GetTime>:
 * \param 	timedif			Der Zeitunterschied, wichtig bei Sommer/Winterzeit.
 * \return	int
 */
/*------------------------------------------------------------------------------------------------------------*/
unsigned int NTP_GetTime( unsigned long IP, unsigned char * dnsbuffer, long timedif )
	{
    684a:	a8 e0       	ldi	r26, 0x08	; 8
    684c:	b0 e0       	ldi	r27, 0x00	; 0
    684e:	eb e2       	ldi	r30, 0x2B	; 43
    6850:	f4 e3       	ldi	r31, 0x34	; 52
    6852:	0c 94 bf 6a 	jmp	0xd57e	; 0xd57e <__prologue_saves__+0xc>
    6856:	48 01       	movw	r8, r16
    6858:	59 01       	movw	r10, r18
		
		union DATE ZeitInSek;
		
		struct TIME time;
	
		if ( IP == 0 )
    685a:	61 15       	cp	r22, r1
    685c:	71 05       	cpc	r23, r1
    685e:	81 05       	cpc	r24, r1
    6860:	91 05       	cpc	r25, r1
    6862:	81 f4       	brne	.+32     	; 0x6884 <NTP_GetTime+0x3a>
		{
#ifdef UDP
	#ifdef DNS
			if ( dnsbuffer != 0 )
    6864:	41 15       	cp	r20, r1
    6866:	51 05       	cpc	r21, r1
    6868:	09 f4       	brne	.+2      	; 0x686c <NTP_GetTime+0x22>
    686a:	6f c0       	rjmp	.+222    	; 0x694a <NTP_GetTime+0x100>
			{
				// Host nach IP aufl철sen
				IP = DNS_ResolveName( dnsbuffer );
    686c:	ca 01       	movw	r24, r20
    686e:	0e 94 e4 34 	call	0x69c8	; 0x69c8 <DNS_ResolveName>
				// k철nnte er aufgel철st werden ?
				if ( IP == DNS_NO_ANSWER ) return( NTP_ERROR );
    6872:	6f 3f       	cpi	r22, 0xFF	; 255
    6874:	2f ef       	ldi	r18, 0xFF	; 255
    6876:	72 07       	cpc	r23, r18
    6878:	2f ef       	ldi	r18, 0xFF	; 255
    687a:	82 07       	cpc	r24, r18
    687c:	2f ef       	ldi	r18, 0xFF	; 255
    687e:	92 07       	cpc	r25, r18
    6880:	09 f4       	brne	.+2      	; 0x6884 <NTP_GetTime+0x3a>
    6882:	63 c0       	rjmp	.+198    	; 0x694a <NTP_GetTime+0x100>
#endif
				return( NTP_ERROR );
		}
		
		// UDP-socket aufmachen f체r Bootp
		SOCKET = UDP_RegisterSocket( IP , 37 , 4 , buffer);
    6884:	45 e2       	ldi	r20, 0x25	; 37
    6886:	50 e0       	ldi	r21, 0x00	; 0
    6888:	24 e0       	ldi	r18, 0x04	; 4
    688a:	30 e0       	ldi	r19, 0x00	; 0
    688c:	7e 01       	movw	r14, r28
    688e:	08 94       	sec
    6890:	e1 1c       	adc	r14, r1
    6892:	f1 1c       	adc	r15, r1
    6894:	87 01       	movw	r16, r14
    6896:	0e 94 bc 24 	call	0x4978	; 0x4978 <UDP_RegisterSocket>
    689a:	6c 01       	movw	r12, r24
		// Wenn Fehler aufgetretten, return
		if ( SOCKET == UDP_SOCKET_ERROR ) 
    689c:	8f ef       	ldi	r24, 0xFF	; 255
    689e:	c8 16       	cp	r12, r24
    68a0:	8f ef       	ldi	r24, 0xFF	; 255
    68a2:	d8 06       	cpc	r13, r24
    68a4:	09 f4       	brne	.+2      	; 0x68a8 <NTP_GetTime+0x5e>
    68a6:	51 c0       	rjmp	.+162    	; 0x694a <NTP_GetTime+0x100>

#if defined(NTP_DEBUG)
			printf_P( PSTR("UDP-Socket aufgemacht zur %s.\r\n"), iptostr( IP, String ) );
#endif
		// leeres UDP-Packet an Time-server senden
		UDP_SendPacket( SOCKET, 0 , buffer);
    68a8:	c6 01       	movw	r24, r12
    68aa:	60 e0       	ldi	r22, 0x00	; 0
    68ac:	70 e0       	ldi	r23, 0x00	; 0
    68ae:	a7 01       	movw	r20, r14
    68b0:	0e 94 4e 24 	call	0x489c	; 0x489c <UDP_SendPacket>

#if defined(NTP_DEBUG)
		printf_P( PSTR("UDP-Packet gesendet.\r\n"));
#endif
		// Timeout-counter reservieren und starten
		timer = CLOCK_RegisterCoundowntimer();
    68b4:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <CLOCK_RegisterCoundowntimer>
    68b8:	7c 01       	movw	r14, r24
		if ( timer == CLOCK_FAILED ) return ( NTP_ERROR );
    68ba:	2f ef       	ldi	r18, 0xFF	; 255
    68bc:	8f 3f       	cpi	r24, 0xFF	; 255
    68be:	92 07       	cpc	r25, r18
    68c0:	09 f4       	brne	.+2      	; 0x68c4 <NTP_GetTime+0x7a>
    68c2:	43 c0       	rjmp	.+134    	; 0x694a <NTP_GetTime+0x100>

		CLOCK_SetCountdownTimer( timer , 500, MSECOUND );
    68c4:	64 ef       	ldi	r22, 0xF4	; 244
    68c6:	71 e0       	ldi	r23, 0x01	; 1
    68c8:	41 e0       	ldi	r20, 0x01	; 1
    68ca:	0e 94 37 1b 	call	0x366e	; 0x366e <CLOCK_SetCountdownTimer>
#endif
		// Auf Antwort des Timer-Servers warten
		while( 1 )
		{
			// Wenn Time-Server geantwortet hat inerhalb des Timeouts, hier weiter
			if ( UDP_GetSocketState( SOCKET ) == UDP_SOCKET_BUSY && ( CLOCK_GetCountdownTimer( timer ) != 0 ) )
    68ce:	c6 01       	movw	r24, r12
    68d0:	0e 94 90 22 	call	0x4520	; 0x4520 <UDP_GetSocketState>
    68d4:	80 97       	sbiw	r24, 0x20	; 32
    68d6:	59 f5       	brne	.+86     	; 0x692e <NTP_GetTime+0xe4>
    68d8:	c7 01       	movw	r24, r14
    68da:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    68de:	89 2b       	or	r24, r25
    68e0:	31 f1       	breq	.+76     	; 0x692e <NTP_GetTime+0xe4>
			{
				// Sind 4 Bytes empfangen worden, wenn ja okay, sonst fehler
				if ( UDP_GetByteInBuffer( SOCKET ) >= 4 )
    68e2:	c6 01       	movw	r24, r12
    68e4:	0e 94 a7 22 	call	0x454e	; 0x454e <UDP_GetByteInBuffer>
    68e8:	04 97       	sbiw	r24, 0x04	; 4
    68ea:	34 f1       	brlt	.+76     	; 0x6938 <NTP_GetTime+0xee>
    68ec:	fe 01       	movw	r30, r28
    68ee:	34 96       	adiw	r30, 0x04	; 4
    68f0:	de 01       	movw	r26, r28
    68f2:	15 96       	adiw	r26, 0x05	; 5
				{				
					// Daten kopieren und Zeit ausrechnen
					for ( i = 0 ; i < 4 ; i++ ) 
						ZeitInSek.DateByte[ i ] = buffer[ 3 - i ];
    68f4:	80 81       	ld	r24, Z
    68f6:	8d 93       	st	X+, r24
    68f8:	31 97       	sbiw	r30, 0x01	; 1
			{
				// Sind 4 Bytes empfangen worden, wenn ja okay, sonst fehler
				if ( UDP_GetByteInBuffer( SOCKET ) >= 4 )
				{				
					// Daten kopieren und Zeit ausrechnen
					for ( i = 0 ; i < 4 ; i++ ) 
    68fa:	ec 17       	cp	r30, r28
    68fc:	fd 07       	cpc	r31, r29
    68fe:	d1 f7       	brne	.-12     	; 0x68f4 <NTP_GetTime+0xaa>
						ZeitInSek.DateByte[ i ] = buffer[ 3 - i ];

					CLOCK_decode_time( ZeitInSek.Date + ( timedif * 3600 ) );
    6900:	c5 01       	movw	r24, r10
    6902:	b4 01       	movw	r22, r8
    6904:	20 e1       	ldi	r18, 0x10	; 16
    6906:	3e e0       	ldi	r19, 0x0E	; 14
    6908:	40 e0       	ldi	r20, 0x00	; 0
    690a:	50 e0       	ldi	r21, 0x00	; 0
    690c:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    6910:	9b 01       	movw	r18, r22
    6912:	ac 01       	movw	r20, r24
    6914:	6d 81       	ldd	r22, Y+5	; 0x05
    6916:	7e 81       	ldd	r23, Y+6	; 0x06
    6918:	8f 81       	ldd	r24, Y+7	; 0x07
    691a:	98 85       	ldd	r25, Y+8	; 0x08
    691c:	62 0f       	add	r22, r18
    691e:	73 1f       	adc	r23, r19
    6920:	84 1f       	adc	r24, r20
    6922:	95 1f       	adc	r25, r21
    6924:	0e 94 4c 18 	call	0x3098	; 0x3098 <CLOCK_decode_time>
    6928:	00 e0       	ldi	r16, 0x00	; 0
    692a:	10 e0       	ldi	r17, 0x00	; 0
    692c:	07 c0       	rjmp	.+14     	; 0x693c <NTP_GetTime+0xf2>
					retval = NTP_ERROR;
					break;
				}
			}
			// Timeout erreicht ? Wenn ja Fehler.
			if ( CLOCK_GetCountdownTimer( timer ) == 0 )
    692e:	c7 01       	movw	r24, r14
    6930:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    6934:	89 2b       	or	r24, r25
    6936:	59 f6       	brne	.-106    	; 0x68ce <NTP_GetTime+0x84>
    6938:	0f ef       	ldi	r16, 0xFF	; 255
    693a:	1f ef       	ldi	r17, 0xFF	; 255
				retval = NTP_ERROR;
				break;
			}
		}
		// timer freigeben und UDP-Socket schliessen
		CLOCK_ReleaseCountdownTimer( timer );
    693c:	c7 01       	movw	r24, r14
    693e:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
		UDP_CloseSocket( SOCKET );
    6942:	c6 01       	movw	r24, r12
    6944:	0e 94 d7 22 	call	0x45ae	; 0x45ae <UDP_CloseSocket>
    6948:	02 c0       	rjmp	.+4      	; 0x694e <NTP_GetTime+0x104>
#if defined(NTP_DEBUG)
		printf_P( PSTR("UDP-Socket geschlossen.\r\n"));
#endif
		return( retval );
    694a:	0f ef       	ldi	r16, 0xFF	; 255
    694c:	1f ef       	ldi	r17, 0xFF	; 255
	}
    694e:	c8 01       	movw	r24, r16
    6950:	28 96       	adiw	r28, 0x08	; 8
    6952:	ec e0       	ldi	r30, 0x0C	; 12
    6954:	0c 94 db 6a 	jmp	0xd5b6	; 0xd5b6 <__epilogue_restores__+0xc>

00006958 <DNS_convertHostName>:
 * \param	HOSTNAME	Zeiger auf den Hostnamestring der mit 0 terminiert ist.
 * \param	Destbuffer	Zeiger auf den Zielspeicher in welchen der neue String abgelegt werden soll.
 * \retval	strlaenge	Die laenge des neuen Strings.
 */
unsigned int DNS_convertHostName( char * HOSTNAME , char * Destbuffer )
{
    6958:	1f 93       	push	r17
    695a:	cf 93       	push	r28
    695c:	df 93       	push	r29
	int i,j=0,k;
	int strlaenge = strlen( HOSTNAME );
    695e:	dc 01       	movw	r26, r24
    6960:	0d 90       	ld	r0, X+
    6962:	00 20       	and	r0, r0
    6964:	e9 f7       	brne	.-6      	; 0x6960 <DNS_convertHostName+0x8>
    6966:	11 97       	sbiw	r26, 0x01	; 1
    6968:	a8 1b       	sub	r26, r24
    696a:	b9 0b       	sbc	r27, r25
	k = strlaenge;
	
	for ( i = strlaenge - 1 ; i >= 0 ; i-- )
    696c:	9d 01       	movw	r18, r26
    696e:	21 50       	subi	r18, 0x01	; 1
    6970:	30 40       	sbci	r19, 0x00	; 0
    6972:	eb 01       	movw	r28, r22
    6974:	ca 0f       	add	r28, r26
    6976:	db 1f       	adc	r29, r27
    6978:	ac 01       	movw	r20, r24
    697a:	42 0f       	add	r20, r18
    697c:	53 1f       	adc	r21, r19
    697e:	80 e0       	ldi	r24, 0x00	; 0
    6980:	90 e0       	ldi	r25, 0x00	; 0
    6982:	0f c0       	rjmp	.+30     	; 0x69a2 <DNS_convertHostName+0x4a>
	{
		if ( HOSTNAME[i] == '.' )
    6984:	fa 01       	movw	r30, r20
    6986:	10 81       	ld	r17, Z
    6988:	1e 32       	cpi	r17, 0x2E	; 46
    698a:	21 f4       	brne	.+8      	; 0x6994 <DNS_convertHostName+0x3c>
		{
			Destbuffer[k] = j;
    698c:	88 83       	st	Y, r24
    698e:	80 e0       	ldi	r24, 0x00	; 0
    6990:	90 e0       	ldi	r25, 0x00	; 0
    6992:	02 c0       	rjmp	.+4      	; 0x6998 <DNS_convertHostName+0x40>
			k--;
			j = 0;
		}
		else
		{
			Destbuffer[k] = HOSTNAME[i];
    6994:	18 83       	st	Y, r17
			k--;
			j++;
    6996:	01 96       	adiw	r24, 0x01	; 1
{
	int i,j=0,k;
	int strlaenge = strlen( HOSTNAME );
	k = strlaenge;
	
	for ( i = strlaenge - 1 ; i >= 0 ; i-- )
    6998:	21 50       	subi	r18, 0x01	; 1
    699a:	30 40       	sbci	r19, 0x00	; 0
    699c:	21 97       	sbiw	r28, 0x01	; 1
    699e:	41 50       	subi	r20, 0x01	; 1
    69a0:	50 40       	sbci	r21, 0x00	; 0
    69a2:	f9 01       	movw	r30, r18
    69a4:	31 96       	adiw	r30, 0x01	; 1
    69a6:	37 ff       	sbrs	r19, 7
    69a8:	ed cf       	rjmp	.-38     	; 0x6984 <DNS_convertHostName+0x2c>
			Destbuffer[k] = HOSTNAME[i];
			k--;
			j++;
		}
	}
	Destbuffer[k] = j;
    69aa:	e6 0f       	add	r30, r22
    69ac:	f7 1f       	adc	r31, r23
    69ae:	80 83       	st	Z, r24

	Destbuffer[ strlaenge + 1 ] = '\0';
    69b0:	6a 0f       	add	r22, r26
    69b2:	7b 1f       	adc	r23, r27
    69b4:	fb 01       	movw	r30, r22
    69b6:	11 82       	std	Z+1, r1	; 0x01
    69b8:	9d 01       	movw	r18, r26
    69ba:	2f 5f       	subi	r18, 0xFF	; 255
    69bc:	3f 4f       	sbci	r19, 0xFF	; 255

	return( strlaenge + 1 );
}
    69be:	c9 01       	movw	r24, r18
    69c0:	df 91       	pop	r29
    69c2:	cf 91       	pop	r28
    69c4:	1f 91       	pop	r17
    69c6:	08 95       	ret

000069c8 <DNS_ResolveName>:
 * \param	HOSTNAME	Zeiger auf den Hostnamestring der mit 0 teminiert ist.
 * \retval	IP		Die IP des Hostname, wenn IP = DNS_NO_ANSWER ist war die Anfrage nicht erfolgreich. Es sollte der DNSserver Eintrag ueberprueft werden
 * oder die richtigkeit des Hostname.
 */
unsigned long DNS_ResolveName( char * HOSTNAME )
{		
    69c8:	a0 e0       	ldi	r26, 0x00	; 0
    69ca:	b0 e0       	ldi	r27, 0x00	; 0
    69cc:	ea ee       	ldi	r30, 0xEA	; 234
    69ce:	f4 e3       	ldi	r31, 0x34	; 52
    69d0:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    69d4:	8c 01       	movw	r16, r24
				DNS_ans = ( void * ) &DNS_question->Queries[i];
			}
			else break;
		}
		return( DNS_ans->Adress );		
}
    69d6:	4d b6       	in	r4, 0x3d	; 61
    69d8:	5e b6       	in	r5, 0x3e	; 62
		int i,UDP_socket;
		int timer;
				
		// udp-puffer anlegen
		unsigned char * udpbuffer;
		udpbuffer = (unsigned char*) __builtin_alloca (( size_t ) DNS_BUFFER_LENGHT );
    69da:	2d b7       	in	r18, 0x3d	; 61
    69dc:	3e b7       	in	r19, 0x3e	; 62
    69de:	22 5d       	subi	r18, 0xD2	; 210
    69e0:	30 40       	sbci	r19, 0x00	; 0
    69e2:	0f b6       	in	r0, 0x3f	; 63
    69e4:	f8 94       	cli
    69e6:	3e bf       	out	0x3e, r19	; 62
    69e8:	0f be       	out	0x3f, r0	; 63
    69ea:	2d bf       	out	0x3d, r18	; 61
    69ec:	8d b6       	in	r8, 0x3d	; 61
    69ee:	9e b6       	in	r9, 0x3e	; 62
    69f0:	08 94       	sec
    69f2:	81 1c       	adc	r8, r1
    69f4:	91 1c       	adc	r9, r1
			
		// DNS-struct in udp-puffer anlegen
		struct DNS_header * DNS_question;
		DNS_question = ( struct DNS_header *) udpbuffer;
    69f6:	64 01       	movw	r12, r8
			
		// DNS anfrage bauen
		DNS_question->TransactionID = 0x1acd;
    69f8:	8d ec       	ldi	r24, 0xCD	; 205
    69fa:	9a e1       	ldi	r25, 0x1A	; 26
    69fc:	f4 01       	movw	r30, r8
    69fe:	91 83       	std	Z+1, r25	; 0x01
    6a00:	80 83       	st	Z, r24
		DNS_question->Flags = ChangeEndian16bit( 0x0100 );
    6a02:	80 e0       	ldi	r24, 0x00	; 0
    6a04:	91 e0       	ldi	r25, 0x01	; 1
    6a06:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    6a0a:	f4 01       	movw	r30, r8
    6a0c:	93 83       	std	Z+3, r25	; 0x03
    6a0e:	82 83       	std	Z+2, r24	; 0x02
		DNS_question->Questions = ChangeEndian16bit( 1 );
    6a10:	81 e0       	ldi	r24, 0x01	; 1
    6a12:	90 e0       	ldi	r25, 0x00	; 0
    6a14:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    6a18:	f4 01       	movw	r30, r8
    6a1a:	95 83       	std	Z+5, r25	; 0x05
    6a1c:	84 83       	std	Z+4, r24	; 0x04
		DNS_question->Answer_RRs = 0;
    6a1e:	17 82       	std	Z+7, r1	; 0x07
    6a20:	16 82       	std	Z+6, r1	; 0x06
		DNS_question->Authority_RRs = 0;
    6a22:	11 86       	std	Z+9, r1	; 0x09
    6a24:	10 86       	std	Z+8, r1	; 0x08
		DNS_question->Additional_RRs = 0;
    6a26:	13 86       	std	Z+11, r1	; 0x0b
    6a28:	12 86       	std	Z+10, r1	; 0x0a
		
		// Hostename f체r DNS umwandeln, in i steht die l채nge des neuen strings
		i = DNS_convertHostName( HOSTNAME, DNS_question->Queries );
    6a2a:	b4 01       	movw	r22, r8
    6a2c:	64 5f       	subi	r22, 0xF4	; 244
    6a2e:	7f 4f       	sbci	r23, 0xFF	; 255
    6a30:	c8 01       	movw	r24, r16
    6a32:	0e 94 ac 34 	call	0x6958	; 0x6958 <DNS_convertHostName>
    6a36:	7c 01       	movw	r14, r24
		
		DNS_question->Queries[i + 1] = '\0';
    6a38:	f4 01       	movw	r30, r8
    6a3a:	e8 0f       	add	r30, r24
    6a3c:	f9 1f       	adc	r31, r25
    6a3e:	15 86       	std	Z+13, r1	; 0x0d
		DNS_question->Queries[i + 2] = 1;
    6a40:	81 e0       	ldi	r24, 0x01	; 1
    6a42:	86 87       	std	Z+14, r24	; 0x0e
		DNS_question->Queries[i + 3] = '\0';
    6a44:	17 86       	std	Z+15, r1	; 0x0f
		DNS_question->Queries[i + 4] = 1;
    6a46:	80 8b       	std	Z+16, r24	; 0x10
		// Antwortstruct anlegen
		struct DNS_answer * DNS_ans;
		DNS_ans = ( void * ) &DNS_question->Queries[i];
		
		// UDP-Paccket senden
		UDP_socket = UDP_RegisterSocket( DNSserver , DNS_SERVER_PORT, DNS_BUFFER_LENGHT , udpbuffer);
    6a48:	60 91 51 01 	lds	r22, 0x0151
    6a4c:	70 91 52 01 	lds	r23, 0x0152
    6a50:	80 91 53 01 	lds	r24, 0x0153
    6a54:	90 91 54 01 	lds	r25, 0x0154
    6a58:	45 e3       	ldi	r20, 0x35	; 53
    6a5a:	50 e0       	ldi	r21, 0x00	; 0
    6a5c:	22 ed       	ldi	r18, 0xD2	; 210
    6a5e:	30 e0       	ldi	r19, 0x00	; 0
    6a60:	84 01       	movw	r16, r8
    6a62:	0e 94 bc 24 	call	0x4978	; 0x4978 <UDP_RegisterSocket>
    6a66:	5c 01       	movw	r10, r24
		if ( UDP_socket == UDP_SOCKET_ERROR )
    6a68:	ff ef       	ldi	r31, 0xFF	; 255
    6a6a:	8f 3f       	cpi	r24, 0xFF	; 255
    6a6c:	9f 07       	cpc	r25, r31
    6a6e:	09 f4       	brne	.+2      	; 0x6a72 <DNS_ResolveName+0xaa>
    6a70:	5d c0       	rjmp	.+186    	; 0x6b2c <DNS_ResolveName+0x164>
		DNS_question->Queries[i + 1] = '\0';
		DNS_question->Queries[i + 2] = 1;
		DNS_question->Queries[i + 3] = '\0';
		DNS_question->Queries[i + 4] = 1;

		i = i + 5;
    6a72:	95 e0       	ldi	r25, 0x05	; 5
    6a74:	69 2e       	mov	r6, r25
    6a76:	71 2c       	mov	r7, r1
    6a78:	6e 0c       	add	r6, r14
    6a7a:	7f 1c       	adc	r7, r15
		
		// UDP-Paccket senden
		UDP_socket = UDP_RegisterSocket( DNSserver , DNS_SERVER_PORT, DNS_BUFFER_LENGHT , udpbuffer);
		if ( UDP_socket == UDP_SOCKET_ERROR )
				return( DNS_NO_ANSWER );
		UDP_SendPacket( UDP_socket, DNS_HEADER_LENGHT + i , udpbuffer);
    6a7c:	21 e1       	ldi	r18, 0x11	; 17
    6a7e:	30 e0       	ldi	r19, 0x00	; 0
    6a80:	e2 0e       	add	r14, r18
    6a82:	f3 1e       	adc	r15, r19
    6a84:	c5 01       	movw	r24, r10
    6a86:	b7 01       	movw	r22, r14
    6a88:	a4 01       	movw	r20, r8
    6a8a:	0e 94 4e 24 	call	0x489c	; 0x489c <UDP_SendPacket>

		// empfang des der DNS-Atwort abwarten
		timer = CLOCK_RegisterCoundowntimer();
    6a8e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <CLOCK_RegisterCoundowntimer>
    6a92:	8c 01       	movw	r16, r24
		if ( timer == CLOCK_FAILED ) return ( DNS_NO_ANSWER );
    6a94:	3f ef       	ldi	r19, 0xFF	; 255
    6a96:	8f 3f       	cpi	r24, 0xFF	; 255
    6a98:	93 07       	cpc	r25, r19
    6a9a:	09 f4       	brne	.+2      	; 0x6a9e <DNS_ResolveName+0xd6>
    6a9c:	47 c0       	rjmp	.+142    	; 0x6b2c <DNS_ResolveName+0x164>

		CLOCK_SetCountdownTimer ( timer, DNS_REQUEST_TIMEOUT, MSECOUND );
    6a9e:	68 ec       	ldi	r22, 0xC8	; 200
    6aa0:	70 e0       	ldi	r23, 0x00	; 0
    6aa2:	41 e0       	ldi	r20, 0x01	; 1
    6aa4:	0e 94 37 1b 	call	0x366e	; 0x366e <CLOCK_SetCountdownTimer>

		while ( 1 )
		{
			if ( UDP_GetSocketState( UDP_socket ) == UDP_SOCKET_BUSY )
    6aa8:	c5 01       	movw	r24, r10
    6aaa:	0e 94 90 22 	call	0x4520	; 0x4520 <UDP_GetSocketState>
    6aae:	80 97       	sbiw	r24, 0x20	; 32
    6ab0:	81 f4       	brne	.+32     	; 0x6ad2 <DNS_ResolveName+0x10a>
			{
				CLOCK_ReleaseCountdownTimer( timer );
    6ab2:	c8 01       	movw	r24, r16
    6ab4:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
				UDP_CloseSocket( UDP_socket );
    6ab8:	c5 01       	movw	r24, r10
    6aba:	0e 94 d7 22 	call	0x45ae	; 0x45ae <UDP_CloseSocket>
				if ( ( ChangeEndian16bit( DNS_question->Flags ) & 0x000f ) != 0 ) return ( DNS_NO_ANSWER );
    6abe:	f6 01       	movw	r30, r12
    6ac0:	82 81       	ldd	r24, Z+2	; 0x02
    6ac2:	93 81       	ldd	r25, Z+3	; 0x03
    6ac4:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    6ac8:	8f 70       	andi	r24, 0x0F	; 15
    6aca:	90 70       	andi	r25, 0x00	; 0
    6acc:	89 2b       	or	r24, r25
    6ace:	69 f0       	breq	.+26     	; 0x6aea <DNS_ResolveName+0x122>
    6ad0:	2d c0       	rjmp	.+90     	; 0x6b2c <DNS_ResolveName+0x164>
				break;
			}
			if ( CLOCK_GetCountdownTimer( timer ) == 0 ) 
    6ad2:	c8 01       	movw	r24, r16
    6ad4:	0e 94 1b 1b 	call	0x3636	; 0x3636 <CLOCK_GetCountdownTimer>
    6ad8:	89 2b       	or	r24, r25
    6ada:	31 f7       	brne	.-52     	; 0x6aa8 <DNS_ResolveName+0xe0>
			{
				CLOCK_ReleaseCountdownTimer( timer );
    6adc:	c8 01       	movw	r24, r16
    6ade:	0e 94 40 18 	call	0x3080	; 0x3080 <CLOCK_ReleaseCountdownTimer>
				UDP_CloseSocket( UDP_socket );
    6ae2:	c5 01       	movw	r24, r10
    6ae4:	0e 94 d7 22 	call	0x45ae	; 0x45ae <UDP_CloseSocket>
    6ae8:	21 c0       	rjmp	.+66     	; 0x6b2c <DNS_ResolveName+0x164>

		i = i + 5;
		
		// Antwortstruct anlegen
		struct DNS_answer * DNS_ans;
		DNS_ans = ( void * ) &DNS_question->Queries[i];
    6aea:	8c e0       	ldi	r24, 0x0C	; 12
    6aec:	e8 2e       	mov	r14, r24
    6aee:	f1 2c       	mov	r15, r1
    6af0:	ec 0c       	add	r14, r12
    6af2:	fd 1c       	adc	r15, r13
    6af4:	87 01       	movw	r16, r14
    6af6:	06 0d       	add	r16, r6
    6af8:	17 1d       	adc	r17, r7

		// Antwortpacket auseinander nehmen
		while ( 1 )
		{
			// Wenn noch nicht der Hosteintrag dann n채chsten DNS-Answer Datensatz
			if ( ChangeEndian16bit( DNS_ans->Type ) != A_HOSTNAME )
    6afa:	f8 01       	movw	r30, r16
    6afc:	82 81       	ldd	r24, Z+2	; 0x02
    6afe:	93 81       	ldd	r25, Z+3	; 0x03
    6b00:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    6b04:	01 97       	sbiw	r24, 0x01	; 1
    6b06:	61 f0       	breq	.+24     	; 0x6b20 <DNS_ResolveName+0x158>
			{
				i = i + ChangeEndian16bit( DNS_ans->Datalenght ) + DNS_ANSWER_HEADER_LENGHT;
    6b08:	f8 01       	movw	r30, r16
    6b0a:	82 85       	ldd	r24, Z+10	; 0x0a
    6b0c:	93 85       	ldd	r25, Z+11	; 0x0b
    6b0e:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <ChangeEndian16bit>
    6b12:	2c e0       	ldi	r18, 0x0C	; 12
    6b14:	30 e0       	ldi	r19, 0x00	; 0
    6b16:	62 0e       	add	r6, r18
    6b18:	73 1e       	adc	r7, r19
    6b1a:	68 0e       	add	r6, r24
    6b1c:	79 1e       	adc	r7, r25
    6b1e:	ea cf       	rjmp	.-44     	; 0x6af4 <DNS_ResolveName+0x12c>
				DNS_ans = ( void * ) &DNS_question->Queries[i];
			}
			else break;
		}
		return( DNS_ans->Adress );		
    6b20:	f8 01       	movw	r30, r16
    6b22:	24 85       	ldd	r18, Z+12	; 0x0c
    6b24:	35 85       	ldd	r19, Z+13	; 0x0d
    6b26:	46 85       	ldd	r20, Z+14	; 0x0e
    6b28:	57 85       	ldd	r21, Z+15	; 0x0f
    6b2a:	04 c0       	rjmp	.+8      	; 0x6b34 <DNS_ResolveName+0x16c>
    6b2c:	2f ef       	ldi	r18, 0xFF	; 255
    6b2e:	3f ef       	ldi	r19, 0xFF	; 255
    6b30:	4f ef       	ldi	r20, 0xFF	; 255
    6b32:	5f ef       	ldi	r21, 0xFF	; 255
}
    6b34:	b9 01       	movw	r22, r18
    6b36:	ca 01       	movw	r24, r20
    6b38:	0f b6       	in	r0, 0x3f	; 63
    6b3a:	f8 94       	cli
    6b3c:	5e be       	out	0x3e, r5	; 62
    6b3e:	0f be       	out	0x3f, r0	; 63
    6b40:	4d be       	out	0x3d, r4	; 61
    6b42:	20 96       	adiw	r28, 0x00	; 0
    6b44:	e0 e1       	ldi	r30, 0x10	; 16
    6b46:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

00006b4a <network_init>:
#if defined(TCP)
	#include "system/net/tcp.h"
#endif

void network_init( void )
{
    6b4a:	a1 e3       	ldi	r26, 0x31	; 49
    6b4c:	b0 e0       	ldi	r27, 0x00	; 0
    6b4e:	eb ea       	ldi	r30, 0xAB	; 171
    6b50:	f5 e3       	ldi	r31, 0x35	; 53
    6b52:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
	
	char ip[32];
	long timedif = 0;
	
	// Ethernet starten
	if (  checkConfigName_P( PSTR("MAC") ) != -1 ) 
    6b56:	83 e4       	ldi	r24, 0x43	; 67
    6b58:	92 e0       	ldi	r25, 0x02	; 2
    6b5a:	0e 94 91 39 	call	0x7322	; 0x7322 <checkConfigName_P>
    6b5e:	8f 5f       	subi	r24, 0xFF	; 255
    6b60:	9f 4f       	sbci	r25, 0xFF	; 255
    6b62:	79 f0       	breq	.+30     	; 0x6b82 <network_init+0x38>
	{
		readConfig_P ( PSTR("MAC"), ip );
    6b64:	8e 01       	movw	r16, r28
    6b66:	0e 5e       	subi	r16, 0xEE	; 238
    6b68:	1f 4f       	sbci	r17, 0xFF	; 255
    6b6a:	8f e3       	ldi	r24, 0x3F	; 63
    6b6c:	92 e0       	ldi	r25, 0x02	; 2
    6b6e:	b8 01       	movw	r22, r16
    6b70:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
		strtobin( ip, mymac, 12 );
    6b74:	c8 01       	movw	r24, r16
    6b76:	6b e3       	ldi	r22, 0x3B	; 59
    6b78:	71 e0       	ldi	r23, 0x01	; 1
    6b7a:	4c e0       	ldi	r20, 0x0C	; 12
    6b7c:	50 e0       	ldi	r21, 0x00	; 0
    6b7e:	0e 94 21 40 	call	0x8042	; 0x8042 <strtobin>
	}
	
	// Ethernet starten
	EthernetInit();
    6b82:	0e 94 83 30 	call	0x6106	; 0x6106 <EthernetInit>
		LED_off(0);
		CLOCK_delay( 500 );
	}
	LED_on(0);
*/
	printf_P( PSTR("ENC28j60 initialisiert ( HW-Add: %02x:%02x:%02x:%02x:%02x:%02x )"), mymac[ 0 ] , mymac[ 1 ] , mymac[ 2 ] , mymac[ 3 ] , mymac[ 4 ] , mymac[ 5 ] );
    6b86:	8d b7       	in	r24, 0x3d	; 61
    6b88:	9e b7       	in	r25, 0x3e	; 62
    6b8a:	0e 97       	sbiw	r24, 0x0e	; 14
    6b8c:	0f b6       	in	r0, 0x3f	; 63
    6b8e:	f8 94       	cli
    6b90:	9e bf       	out	0x3e, r25	; 62
    6b92:	0f be       	out	0x3f, r0	; 63
    6b94:	8d bf       	out	0x3d, r24	; 61
    6b96:	ed b7       	in	r30, 0x3d	; 61
    6b98:	fe b7       	in	r31, 0x3e	; 62
    6b9a:	31 96       	adiw	r30, 0x01	; 1
    6b9c:	8e ef       	ldi	r24, 0xFE	; 254
    6b9e:	91 e0       	ldi	r25, 0x01	; 1
    6ba0:	ad b7       	in	r26, 0x3d	; 61
    6ba2:	be b7       	in	r27, 0x3e	; 62
    6ba4:	12 96       	adiw	r26, 0x02	; 2
    6ba6:	9c 93       	st	X, r25
    6ba8:	8e 93       	st	-X, r24
    6baa:	11 97       	sbiw	r26, 0x01	; 1
    6bac:	80 91 3b 01 	lds	r24, 0x013B
    6bb0:	82 83       	std	Z+2, r24	; 0x02
    6bb2:	13 82       	std	Z+3, r1	; 0x03
    6bb4:	80 91 3c 01 	lds	r24, 0x013C
    6bb8:	84 83       	std	Z+4, r24	; 0x04
    6bba:	15 82       	std	Z+5, r1	; 0x05
    6bbc:	80 91 3d 01 	lds	r24, 0x013D
    6bc0:	86 83       	std	Z+6, r24	; 0x06
    6bc2:	17 82       	std	Z+7, r1	; 0x07
    6bc4:	80 91 3e 01 	lds	r24, 0x013E
    6bc8:	80 87       	std	Z+8, r24	; 0x08
    6bca:	11 86       	std	Z+9, r1	; 0x09
    6bcc:	80 91 3f 01 	lds	r24, 0x013F
    6bd0:	82 87       	std	Z+10, r24	; 0x0a
    6bd2:	13 86       	std	Z+11, r1	; 0x0b
    6bd4:	80 91 40 01 	lds	r24, 0x0140
    6bd8:	84 87       	std	Z+12, r24	; 0x0c
    6bda:	15 86       	std	Z+13, r1	; 0x0d
    6bdc:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
		printf_P( PSTR(" Halfduplex:"));
	}			
	#endif

	#ifdef ETH_LINK_FULL
		enc28j60EnableFullDuplex();
    6be0:	ed b7       	in	r30, 0x3d	; 61
    6be2:	fe b7       	in	r31, 0x3e	; 62
    6be4:	3e 96       	adiw	r30, 0x0e	; 14
    6be6:	0f b6       	in	r0, 0x3f	; 63
    6be8:	f8 94       	cli
    6bea:	fe bf       	out	0x3e, r31	; 62
    6bec:	0f be       	out	0x3f, r0	; 63
    6bee:	ed bf       	out	0x3d, r30	; 61
    6bf0:	0e 94 58 1f 	call	0x3eb0	; 0x3eb0 <enc28j60EnableFullDuplex>
		printf_P( PSTR(" Fullduplex:"));
    6bf4:	00 d0       	rcall	.+0      	; 0x6bf6 <network_init+0xac>
    6bf6:	81 ef       	ldi	r24, 0xF1	; 241
    6bf8:	91 e0       	ldi	r25, 0x01	; 1
    6bfa:	ad b7       	in	r26, 0x3d	; 61
    6bfc:	be b7       	in	r27, 0x3e	; 62
    6bfe:	12 96       	adiw	r26, 0x02	; 2
    6c00:	9c 93       	st	X, r25
    6c02:	8e 93       	st	-X, r24
    6c04:	11 97       	sbiw	r26, 0x01	; 1
    6c06:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    6c0a:	0f 90       	pop	r0
    6c0c:	0f 90       	pop	r0
				printf_P( PSTR(" Fullduplex:"));
			#endif
		#endif
	#endif
	
	while( enc28j60Linkcheck() );
    6c0e:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <enc28j60Linkcheck>
    6c12:	88 23       	and	r24, r24
    6c14:	e1 f7       	brne	.-8      	; 0x6c0e <network_init+0xc4>
	
	printf_P( PSTR(" Link ready\r\n"));
    6c16:	00 d0       	rcall	.+0      	; 0x6c18 <network_init+0xce>
    6c18:	83 ee       	ldi	r24, 0xE3	; 227
    6c1a:	91 e0       	ldi	r25, 0x01	; 1
    6c1c:	ed b7       	in	r30, 0x3d	; 61
    6c1e:	fe b7       	in	r31, 0x3e	; 62
    6c20:	92 83       	std	Z+2, r25	; 0x02
    6c22:	81 83       	std	Z+1, r24	; 0x01
    6c24:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	// ARP starten
	ARP_INIT ();
    6c28:	0f 90       	pop	r0
    6c2a:	0f 90       	pop	r0
    6c2c:	0e 94 f6 32 	call	0x65ec	; 0x65ec <ARP_INIT>
	printf_P( PSTR("-+-> ARP initialisiert\r\n"));
    6c30:	00 d0       	rcall	.+0      	; 0x6c32 <network_init+0xe8>
    6c32:	8a ec       	ldi	r24, 0xCA	; 202
    6c34:	91 e0       	ldi	r25, 0x01	; 1
    6c36:	ad b7       	in	r26, 0x3d	; 61
    6c38:	be b7       	in	r27, 0x3e	; 62
    6c3a:	12 96       	adiw	r26, 0x02	; 2
    6c3c:	9c 93       	st	X, r25
    6c3e:	8e 93       	st	-X, r24
    6c40:	11 97       	sbiw	r26, 0x01	; 1
    6c42:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	
	#ifdef UDP
		// UDP starten
		UDP_init();
    6c46:	0f 90       	pop	r0
    6c48:	0f 90       	pop	r0
    6c4a:	0e 94 83 22 	call	0x4506	; 0x4506 <UDP_init>
		printf_P( PSTR(" |-> UDP (Tornado-engine) initialisiert\r\n"));
    6c4e:	00 d0       	rcall	.+0      	; 0x6c50 <network_init+0x106>
    6c50:	80 ea       	ldi	r24, 0xA0	; 160
    6c52:	91 e0       	ldi	r25, 0x01	; 1
    6c54:	ed b7       	in	r30, 0x3d	; 61
    6c56:	fe b7       	in	r31, 0x3e	; 62
    6c58:	92 83       	std	Z+2, r25	; 0x02
    6c5a:	81 83       	std	Z+1, r24	; 0x01
    6c5c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	#endif
		
	#ifdef TCP
		// tcp starten
		tcp_init();
    6c60:	0f 90       	pop	r0
    6c62:	0f 90       	pop	r0
    6c64:	0e 94 e4 2f 	call	0x5fc8	; 0x5fc8 <tcp_init>
		printf_P( PSTR(" |-> TCP (Hurrican-engine) initialisiert\r\n"));
    6c68:	00 d0       	rcall	.+0      	; 0x6c6a <network_init+0x120>
    6c6a:	85 e7       	ldi	r24, 0x75	; 117
    6c6c:	91 e0       	ldi	r25, 0x01	; 1
    6c6e:	ad b7       	in	r26, 0x3d	; 61
    6c70:	be b7       	in	r27, 0x3e	; 62
    6c72:	12 96       	adiw	r26, 0x02	; 2
    6c74:	9c 93       	st	X, r25
    6c76:	8e 93       	st	-X, r24
    6c78:	11 97       	sbiw	r26, 0x01	; 1
    6c7a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	}
#endif
	
#ifndef DHCP
	#ifdef READ_CONFIG
		if ( readConfig_P ( PSTR("IP"), ip ) != -1)
    6c7e:	0f 90       	pop	r0
    6c80:	0f 90       	pop	r0
    6c82:	8e 01       	movw	r16, r28
    6c84:	0e 5e       	subi	r16, 0xEE	; 238
    6c86:	1f 4f       	sbci	r17, 0xFF	; 255
    6c88:	82 e7       	ldi	r24, 0x72	; 114
    6c8a:	91 e0       	ldi	r25, 0x01	; 1
    6c8c:	b8 01       	movw	r22, r16
    6c8e:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    6c92:	8f 5f       	subi	r24, 0xFF	; 255
    6c94:	9f 4f       	sbci	r25, 0xFF	; 255
    6c96:	59 f0       	breq	.+22     	; 0x6cae <network_init+0x164>
			myIP = strtoip( ip );
    6c98:	c8 01       	movw	r24, r16
    6c9a:	0e 94 31 33 	call	0x6662	; 0x6662 <strtoip>
    6c9e:	60 93 41 01 	sts	0x0141, r22
    6ca2:	70 93 42 01 	sts	0x0142, r23
    6ca6:	80 93 43 01 	sts	0x0143, r24
    6caa:	90 93 44 01 	sts	0x0144, r25
		if ( readConfig_P ( PSTR("MASK"), ip ) != -1)
    6cae:	8e 01       	movw	r16, r28
    6cb0:	0e 5e       	subi	r16, 0xEE	; 238
    6cb2:	1f 4f       	sbci	r17, 0xFF	; 255
    6cb4:	8d e6       	ldi	r24, 0x6D	; 109
    6cb6:	91 e0       	ldi	r25, 0x01	; 1
    6cb8:	b8 01       	movw	r22, r16
    6cba:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    6cbe:	8f 5f       	subi	r24, 0xFF	; 255
    6cc0:	9f 4f       	sbci	r25, 0xFF	; 255
    6cc2:	59 f0       	breq	.+22     	; 0x6cda <network_init+0x190>
			Netmask = strtoip( ip );
    6cc4:	c8 01       	movw	r24, r16
    6cc6:	0e 94 31 33 	call	0x6662	; 0x6662 <strtoip>
    6cca:	60 93 49 01 	sts	0x0149, r22
    6cce:	70 93 4a 01 	sts	0x014A, r23
    6cd2:	80 93 4b 01 	sts	0x014B, r24
    6cd6:	90 93 4c 01 	sts	0x014C, r25
		if ( readConfig_P ( PSTR("GATE"), ip ) != -1)
    6cda:	8e 01       	movw	r16, r28
    6cdc:	0e 5e       	subi	r16, 0xEE	; 238
    6cde:	1f 4f       	sbci	r17, 0xFF	; 255
    6ce0:	88 e6       	ldi	r24, 0x68	; 104
    6ce2:	91 e0       	ldi	r25, 0x01	; 1
    6ce4:	b8 01       	movw	r22, r16
    6ce6:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    6cea:	8f 5f       	subi	r24, 0xFF	; 255
    6cec:	9f 4f       	sbci	r25, 0xFF	; 255
    6cee:	59 f0       	breq	.+22     	; 0x6d06 <network_init+0x1bc>
			Gateway = strtoip( ip );
    6cf0:	c8 01       	movw	r24, r16
    6cf2:	0e 94 31 33 	call	0x6662	; 0x6662 <strtoip>
    6cf6:	60 93 4d 01 	sts	0x014D, r22
    6cfa:	70 93 4e 01 	sts	0x014E, r23
    6cfe:	80 93 4f 01 	sts	0x014F, r24
    6d02:	90 93 50 01 	sts	0x0150, r25
		#ifdef DNS
			if ( readConfig_P ( PSTR("DNS"), ip ) != -1)
    6d06:	8e 01       	movw	r16, r28
    6d08:	0e 5e       	subi	r16, 0xEE	; 238
    6d0a:	1f 4f       	sbci	r17, 0xFF	; 255
    6d0c:	84 e6       	ldi	r24, 0x64	; 100
    6d0e:	91 e0       	ldi	r25, 0x01	; 1
    6d10:	b8 01       	movw	r22, r16
    6d12:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    6d16:	8f 5f       	subi	r24, 0xFF	; 255
    6d18:	9f 4f       	sbci	r25, 0xFF	; 255
    6d1a:	59 f0       	breq	.+22     	; 0x6d32 <network_init+0x1e8>
				DNSserver = strtoip( ip );
    6d1c:	c8 01       	movw	r24, r16
    6d1e:	0e 94 31 33 	call	0x6662	; 0x6662 <strtoip>
    6d22:	60 93 51 01 	sts	0x0151, r22
    6d26:	70 93 52 01 	sts	0x0152, r23
    6d2a:	80 93 53 01 	sts	0x0153, r24
    6d2e:	90 93 54 01 	sts	0x0154, r25
		#endif
	#endif
#endif
	
	myBroadcast = (myIP|0xff000000) ;
    6d32:	60 91 41 01 	lds	r22, 0x0141
    6d36:	70 91 42 01 	lds	r23, 0x0142
    6d3a:	80 91 43 01 	lds	r24, 0x0143
    6d3e:	90 91 44 01 	lds	r25, 0x0144
    6d42:	9b 01       	movw	r18, r22
    6d44:	ac 01       	movw	r20, r24
    6d46:	5f 6f       	ori	r21, 0xFF	; 255
    6d48:	20 93 45 01 	sts	0x0145, r18
    6d4c:	30 93 46 01 	sts	0x0146, r19
    6d50:	40 93 47 01 	sts	0x0147, r20
    6d54:	50 93 48 01 	sts	0x0148, r21
	
	printf_P( PSTR(	" |   IP     : %s\r\n"), iptostr( myIP, ip ));
    6d58:	22 e1       	ldi	r18, 0x12	; 18
    6d5a:	c2 2e       	mov	r12, r18
    6d5c:	d1 2c       	mov	r13, r1
    6d5e:	cc 0e       	add	r12, r28
    6d60:	dd 1e       	adc	r13, r29
    6d62:	a6 01       	movw	r20, r12
    6d64:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    6d68:	00 d0       	rcall	.+0      	; 0x6d6a <network_init+0x220>
    6d6a:	00 d0       	rcall	.+0      	; 0x6d6c <network_init+0x222>
    6d6c:	21 e5       	ldi	r18, 0x51	; 81
    6d6e:	31 e0       	ldi	r19, 0x01	; 1
    6d70:	ad b7       	in	r26, 0x3d	; 61
    6d72:	be b7       	in	r27, 0x3e	; 62
    6d74:	12 96       	adiw	r26, 0x02	; 2
    6d76:	3c 93       	st	X, r19
    6d78:	2e 93       	st	-X, r18
    6d7a:	11 97       	sbiw	r26, 0x01	; 1
    6d7c:	14 96       	adiw	r26, 0x04	; 4
    6d7e:	9c 93       	st	X, r25
    6d80:	8e 93       	st	-X, r24
    6d82:	13 97       	sbiw	r26, 0x03	; 3
    6d84:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR(	" |   Netmask: %s\r\n"), iptostr( Netmask, ip ));
    6d88:	0f 90       	pop	r0
    6d8a:	0f 90       	pop	r0
    6d8c:	0f 90       	pop	r0
    6d8e:	0f 90       	pop	r0
    6d90:	60 91 49 01 	lds	r22, 0x0149
    6d94:	70 91 4a 01 	lds	r23, 0x014A
    6d98:	80 91 4b 01 	lds	r24, 0x014B
    6d9c:	90 91 4c 01 	lds	r25, 0x014C
    6da0:	a6 01       	movw	r20, r12
    6da2:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    6da6:	00 d0       	rcall	.+0      	; 0x6da8 <network_init+0x25e>
    6da8:	00 d0       	rcall	.+0      	; 0x6daa <network_init+0x260>
    6daa:	2e e3       	ldi	r18, 0x3E	; 62
    6dac:	31 e0       	ldi	r19, 0x01	; 1
    6dae:	ed b7       	in	r30, 0x3d	; 61
    6db0:	fe b7       	in	r31, 0x3e	; 62
    6db2:	32 83       	std	Z+2, r19	; 0x02
    6db4:	21 83       	std	Z+1, r18	; 0x01
    6db6:	94 83       	std	Z+4, r25	; 0x04
    6db8:	83 83       	std	Z+3, r24	; 0x03
    6dba:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR(	" |   Gateway: %s\r\n"), iptostr( Gateway, ip ) );
    6dbe:	0f 90       	pop	r0
    6dc0:	0f 90       	pop	r0
    6dc2:	0f 90       	pop	r0
    6dc4:	0f 90       	pop	r0
    6dc6:	60 91 4d 01 	lds	r22, 0x014D
    6dca:	70 91 4e 01 	lds	r23, 0x014E
    6dce:	80 91 4f 01 	lds	r24, 0x014F
    6dd2:	90 91 50 01 	lds	r25, 0x0150
    6dd6:	a6 01       	movw	r20, r12
    6dd8:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    6ddc:	00 d0       	rcall	.+0      	; 0x6dde <network_init+0x294>
    6dde:	00 d0       	rcall	.+0      	; 0x6de0 <network_init+0x296>
    6de0:	2b e2       	ldi	r18, 0x2B	; 43
    6de2:	31 e0       	ldi	r19, 0x01	; 1
    6de4:	ad b7       	in	r26, 0x3d	; 61
    6de6:	be b7       	in	r27, 0x3e	; 62
    6de8:	12 96       	adiw	r26, 0x02	; 2
    6dea:	3c 93       	st	X, r19
    6dec:	2e 93       	st	-X, r18
    6dee:	11 97       	sbiw	r26, 0x01	; 1
    6df0:	14 96       	adiw	r26, 0x04	; 4
    6df2:	9c 93       	st	X, r25
    6df4:	8e 93       	st	-X, r24
    6df6:	13 97       	sbiw	r26, 0x03	; 3
    6df8:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	#ifdef DNS
		printf_P( PSTR(" |   DNS    : %s\r\n"), iptostr( DNSserver, ip ) );
    6dfc:	0f 90       	pop	r0
    6dfe:	0f 90       	pop	r0
    6e00:	0f 90       	pop	r0
    6e02:	0f 90       	pop	r0
    6e04:	60 91 51 01 	lds	r22, 0x0151
    6e08:	70 91 52 01 	lds	r23, 0x0152
    6e0c:	80 91 53 01 	lds	r24, 0x0153
    6e10:	90 91 54 01 	lds	r25, 0x0154
    6e14:	a6 01       	movw	r20, r12
    6e16:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    6e1a:	00 d0       	rcall	.+0      	; 0x6e1c <network_init+0x2d2>
    6e1c:	00 d0       	rcall	.+0      	; 0x6e1e <network_init+0x2d4>
    6e1e:	28 e1       	ldi	r18, 0x18	; 24
    6e20:	31 e0       	ldi	r19, 0x01	; 1
    6e22:	ed b7       	in	r30, 0x3d	; 61
    6e24:	fe b7       	in	r31, 0x3e	; 62
    6e26:	32 83       	std	Z+2, r19	; 0x02
    6e28:	21 83       	std	Z+1, r18	; 0x01
    6e2a:	94 83       	std	Z+4, r25	; 0x04
    6e2c:	83 83       	std	Z+3, r24	; 0x03
    6e2e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	#endif
		
#ifdef NTP
	// Uhr einstellen
	if( readConfig_P( PSTR("NTP"), ip ) != -1 )
    6e32:	0f 90       	pop	r0
    6e34:	0f 90       	pop	r0
    6e36:	0f 90       	pop	r0
    6e38:	0f 90       	pop	r0
    6e3a:	84 e1       	ldi	r24, 0x14	; 20
    6e3c:	91 e0       	ldi	r25, 0x01	; 1
    6e3e:	b6 01       	movw	r22, r12
    6e40:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    6e44:	8f 5f       	subi	r24, 0xFF	; 255
    6e46:	9f 4f       	sbci	r25, 0xFF	; 255
    6e48:	09 f4       	brne	.+2      	; 0x6e4c <network_init+0x302>
    6e4a:	74 c0       	rjmp	.+232    	; 0x6f34 <network_init+0x3ea>
	{
		if ( !strcmp_P( ip, PSTR("on") ) )
    6e4c:	c6 01       	movw	r24, r12
    6e4e:	61 e1       	ldi	r22, 0x11	; 17
    6e50:	71 e0       	ldi	r23, 0x01	; 1
    6e52:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    6e56:	89 2b       	or	r24, r25
    6e58:	09 f0       	breq	.+2      	; 0x6e5c <network_init+0x312>
    6e5a:	6c c0       	rjmp	.+216    	; 0x6f34 <network_init+0x3ea>
		{
			printf_P( PSTR(" |-> NTP-Server Zeit aktualisieren:"));
    6e5c:	00 d0       	rcall	.+0      	; 0x6e5e <network_init+0x314>
    6e5e:	8d ee       	ldi	r24, 0xED	; 237
    6e60:	90 e0       	ldi	r25, 0x00	; 0
    6e62:	ad b7       	in	r26, 0x3d	; 61
    6e64:	be b7       	in	r27, 0x3e	; 62
    6e66:	12 96       	adiw	r26, 0x02	; 2
    6e68:	9c 93       	st	X, r25
    6e6a:	8e 93       	st	-X, r24
    6e6c:	11 97       	sbiw	r26, 0x01	; 1
    6e6e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
			if( readConfig_P ( PSTR("UTCZONE"), ip ) != -1 )
    6e72:	0f 90       	pop	r0
    6e74:	0f 90       	pop	r0
    6e76:	85 ee       	ldi	r24, 0xE5	; 229
    6e78:	90 e0       	ldi	r25, 0x00	; 0
    6e7a:	b6 01       	movw	r22, r12
    6e7c:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    6e80:	8f 5f       	subi	r24, 0xFF	; 255
    6e82:	9f 4f       	sbci	r25, 0xFF	; 255
    6e84:	09 f4       	brne	.+2      	; 0x6e88 <network_init+0x33e>
    6e86:	4b c0       	rjmp	.+150    	; 0x6f1e <network_init+0x3d4>
			{
				timedif = atol( ip );
    6e88:	c6 01       	movw	r24, r12
    6e8a:	0e 94 c7 13 	call	0x278e	; 0x278e <atol>
    6e8e:	7b 01       	movw	r14, r22
    6e90:	8c 01       	movw	r16, r24
				readConfig_P ( PSTR("NTPSERVER"), ip );
    6e92:	8b ed       	ldi	r24, 0xDB	; 219
    6e94:	90 e0       	ldi	r25, 0x00	; 0
    6e96:	b6 01       	movw	r22, r12
    6e98:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
				if( NTP_GetTime( 0 , ip, timedif ) == NTP_OK )
    6e9c:	60 e0       	ldi	r22, 0x00	; 0
    6e9e:	70 e0       	ldi	r23, 0x00	; 0
    6ea0:	80 e0       	ldi	r24, 0x00	; 0
    6ea2:	90 e0       	ldi	r25, 0x00	; 0
    6ea4:	a6 01       	movw	r20, r12
    6ea6:	98 01       	movw	r18, r16
    6ea8:	87 01       	movw	r16, r14
    6eaa:	0e 94 25 34 	call	0x684a	; 0x684a <NTP_GetTime>
    6eae:	89 2b       	or	r24, r25
    6eb0:	61 f5       	brne	.+88     	; 0x6f0a <network_init+0x3c0>
				{
					CLOCK_GetTime ( &Time );
    6eb2:	ce 01       	movw	r24, r28
    6eb4:	01 96       	adiw	r24, 0x01	; 1
    6eb6:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <CLOCK_GetTime>
					printf_P( PSTR(" Zeit: %02d:%02d:%02d.%02d\r\n"),Time.hh,Time.mm,Time.ss,Time.ms);
    6eba:	2c 81       	ldd	r18, Y+4	; 0x04
    6ebc:	3b 81       	ldd	r19, Y+3	; 0x03
    6ebe:	4a 81       	ldd	r20, Y+2	; 0x02
    6ec0:	59 81       	ldd	r21, Y+1	; 0x01
    6ec2:	ed b7       	in	r30, 0x3d	; 61
    6ec4:	fe b7       	in	r31, 0x3e	; 62
    6ec6:	3a 97       	sbiw	r30, 0x0a	; 10
    6ec8:	0f b6       	in	r0, 0x3f	; 63
    6eca:	f8 94       	cli
    6ecc:	fe bf       	out	0x3e, r31	; 62
    6ece:	0f be       	out	0x3f, r0	; 63
    6ed0:	ed bf       	out	0x3d, r30	; 61
    6ed2:	31 96       	adiw	r30, 0x01	; 1
    6ed4:	8e eb       	ldi	r24, 0xBE	; 190
    6ed6:	90 e0       	ldi	r25, 0x00	; 0
    6ed8:	ad b7       	in	r26, 0x3d	; 61
    6eda:	be b7       	in	r27, 0x3e	; 62
    6edc:	12 96       	adiw	r26, 0x02	; 2
    6ede:	9c 93       	st	X, r25
    6ee0:	8e 93       	st	-X, r24
    6ee2:	11 97       	sbiw	r26, 0x01	; 1
    6ee4:	22 83       	std	Z+2, r18	; 0x02
    6ee6:	13 82       	std	Z+3, r1	; 0x03
    6ee8:	34 83       	std	Z+4, r19	; 0x04
    6eea:	15 82       	std	Z+5, r1	; 0x05
    6eec:	46 83       	std	Z+6, r20	; 0x06
    6eee:	17 82       	std	Z+7, r1	; 0x07
    6ef0:	50 87       	std	Z+8, r21	; 0x08
    6ef2:	11 86       	std	Z+9, r1	; 0x09
    6ef4:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    6ef8:	ed b7       	in	r30, 0x3d	; 61
    6efa:	fe b7       	in	r31, 0x3e	; 62
    6efc:	3a 96       	adiw	r30, 0x0a	; 10
    6efe:	0f b6       	in	r0, 0x3f	; 63
    6f00:	f8 94       	cli
    6f02:	fe bf       	out	0x3e, r31	; 62
    6f04:	0f be       	out	0x3f, r0	; 63
    6f06:	ed bf       	out	0x3d, r30	; 61
    6f08:	15 c0       	rjmp	.+42     	; 0x6f34 <network_init+0x3ea>
				}
				else
					printf_P( PSTR(" fehlgeschlagen\r\n"));
    6f0a:	00 d0       	rcall	.+0      	; 0x6f0c <network_init+0x3c2>
    6f0c:	8c ea       	ldi	r24, 0xAC	; 172
    6f0e:	90 e0       	ldi	r25, 0x00	; 0
    6f10:	ad b7       	in	r26, 0x3d	; 61
    6f12:	be b7       	in	r27, 0x3e	; 62
    6f14:	12 96       	adiw	r26, 0x02	; 2
    6f16:	9c 93       	st	X, r25
    6f18:	8e 93       	st	-X, r24
    6f1a:	11 97       	sbiw	r26, 0x01	; 1
    6f1c:	07 c0       	rjmp	.+14     	; 0x6f2c <network_init+0x3e2>
			}
			else
				printf_P( PSTR(" fehlgeschlagen\r\n"));
    6f1e:	00 d0       	rcall	.+0      	; 0x6f20 <network_init+0x3d6>
    6f20:	8a e9       	ldi	r24, 0x9A	; 154
    6f22:	90 e0       	ldi	r25, 0x00	; 0
    6f24:	ed b7       	in	r30, 0x3d	; 61
    6f26:	fe b7       	in	r31, 0x3e	; 62
    6f28:	92 83       	std	Z+2, r25	; 0x02
    6f2a:	81 83       	std	Z+1, r24	; 0x01
    6f2c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    6f30:	0f 90       	pop	r0
    6f32:	0f 90       	pop	r0
			printf_P( PSTR("\r\n%s"), iptostr( myIP, ip ) );
	
			STDOUT_set( RS232, 0);	
	#endif
#endif
}
    6f34:	e1 96       	adiw	r28, 0x31	; 49
    6f36:	e8 e0       	ldi	r30, 0x08	; 8
    6f38:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

00006f3c <ChangeEndian32bit>:
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
//@{
unsigned long ChangeEndian32bit( unsigned long Wert)
	{
    6f3c:	af 92       	push	r10
    6f3e:	bf 92       	push	r11
    6f40:	cf 92       	push	r12
    6f42:	df 92       	push	r13
    6f44:	ef 92       	push	r14
    6f46:	ff 92       	push	r15
    6f48:	0f 93       	push	r16
    6f4a:	1f 93       	push	r17
		Wert = ( ( Wert & 0xff000000 ) >> 24 ) | ( ( Wert & 0x000000ff ) << 24 ) | ( ( Wert & 0x00ff0000 ) >> 8 ) | ( ( Wert & 0x0000ff00 ) << 8 );
    6f4c:	a1 2c       	mov	r10, r1
    6f4e:	1f ef       	ldi	r17, 0xFF	; 255
    6f50:	b1 2e       	mov	r11, r17
    6f52:	c1 2c       	mov	r12, r1
    6f54:	d1 2c       	mov	r13, r1
    6f56:	a6 22       	and	r10, r22
    6f58:	b7 22       	and	r11, r23
    6f5a:	c8 22       	and	r12, r24
    6f5c:	d9 22       	and	r13, r25
    6f5e:	dc 2c       	mov	r13, r12
    6f60:	cb 2c       	mov	r12, r11
    6f62:	ba 2c       	mov	r11, r10
    6f64:	aa 24       	eor	r10, r10
    6f66:	56 2f       	mov	r21, r22
    6f68:	44 27       	eor	r20, r20
    6f6a:	33 27       	eor	r19, r19
    6f6c:	22 27       	eor	r18, r18
    6f6e:	e9 2e       	mov	r14, r25
    6f70:	ff 24       	eor	r15, r15
    6f72:	00 27       	eor	r16, r16
    6f74:	11 27       	eor	r17, r17
    6f76:	2e 29       	or	r18, r14
    6f78:	3f 29       	or	r19, r15
    6f7a:	40 2b       	or	r20, r16
    6f7c:	51 2b       	or	r21, r17
    6f7e:	60 70       	andi	r22, 0x00	; 0
    6f80:	70 70       	andi	r23, 0x00	; 0
    6f82:	90 70       	andi	r25, 0x00	; 0
    6f84:	67 2f       	mov	r22, r23
    6f86:	78 2f       	mov	r23, r24
    6f88:	89 2f       	mov	r24, r25
    6f8a:	99 27       	eor	r25, r25
    6f8c:	26 2b       	or	r18, r22
    6f8e:	37 2b       	or	r19, r23
    6f90:	48 2b       	or	r20, r24
    6f92:	59 2b       	or	r21, r25
    6f94:	2a 29       	or	r18, r10
    6f96:	3b 29       	or	r19, r11
    6f98:	4c 29       	or	r20, r12
    6f9a:	5d 29       	or	r21, r13
		return( Wert );
	}
    6f9c:	b9 01       	movw	r22, r18
    6f9e:	ca 01       	movw	r24, r20
    6fa0:	1f 91       	pop	r17
    6fa2:	0f 91       	pop	r16
    6fa4:	ff 90       	pop	r15
    6fa6:	ef 90       	pop	r14
    6fa8:	df 90       	pop	r13
    6faa:	cf 90       	pop	r12
    6fac:	bf 90       	pop	r11
    6fae:	af 90       	pop	r10
    6fb0:	08 95       	ret

00006fb2 <ChangeEndian16bit>:
	
unsigned int ChangeEndian16bit( unsigned int Wert)
	{
    6fb2:	28 2f       	mov	r18, r24
		Wert = ( ( Wert & 0xff00 ) >> 8 ) | ( ( Wert & 0x00ff ) << 8 );
		return( Wert );
	}
    6fb4:	89 2f       	mov	r24, r25
    6fb6:	92 2f       	mov	r25, r18
    6fb8:	08 95       	ret

00006fba <Checksum_16>:
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
//@{
int Checksum_16 (unsigned char * pointer, unsigned int headerlenght)
	{
    6fba:	ef 92       	push	r14
    6fbc:	ff 92       	push	r15
    6fbe:	0f 93       	push	r16
    6fc0:	1f 93       	push	r17
    6fc2:	cf 93       	push	r28
    6fc4:	df 93       	push	r29
    6fc6:	7c 01       	movw	r14, r24
    6fc8:	8b 01       	movw	r16, r22
    6fca:	ec 01       	movw	r28, r24
    6fcc:	20 e0       	ldi	r18, 0x00	; 0
    6fce:	30 e0       	ldi	r19, 0x00	; 0
    6fd0:	40 e0       	ldi	r20, 0x00	; 0
    6fd2:	50 e0       	ldi	r21, 0x00	; 0
    6fd4:	13 c0       	rjmp	.+38     	; 0x6ffc <Checksum_16+0x42>
		unsigned char DataL;
		
		//Jetzt werden alle Packete in einer While Schleife addiert
		while( headerlenght > 1)
			{
				DataH=*pointer++;
    6fd6:	88 81       	ld	r24, Y
				DataL=*pointer++;
    6fd8:	99 81       	ldd	r25, Y+1	; 0x01
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
//@{
int Checksum_16 (unsigned char * pointer, unsigned int headerlenght)
	{
    6fda:	22 96       	adiw	r28, 0x02	; 2
		while( headerlenght > 1)
			{
				DataH=*pointer++;
				DataL=*pointer++;
				result =~ ((DataH << 8)+ DataL);
				checksum = checksum + result;
    6fdc:	f8 2f       	mov	r31, r24
    6fde:	e0 e0       	ldi	r30, 0x00	; 0
    6fe0:	df 01       	movw	r26, r30
    6fe2:	a9 0f       	add	r26, r25
    6fe4:	b1 1d       	adc	r27, r1
    6fe6:	cd 01       	movw	r24, r26
    6fe8:	80 95       	com	r24
    6fea:	90 95       	com	r25
    6fec:	a0 e0       	ldi	r26, 0x00	; 0
    6fee:	b0 e0       	ldi	r27, 0x00	; 0
    6ff0:	28 0f       	add	r18, r24
    6ff2:	39 1f       	adc	r19, r25
    6ff4:	4a 1f       	adc	r20, r26
    6ff6:	5b 1f       	adc	r21, r27
				//decrimiert L채nge von TCP Headerschleife um 2
				headerlenght -=2 ;
    6ff8:	62 50       	subi	r22, 0x02	; 2
    6ffa:	70 40       	sbci	r23, 0x00	; 0
		unsigned int result;
		unsigned char DataH;
		unsigned char DataL;
		
		//Jetzt werden alle Packete in einer While Schleife addiert
		while( headerlenght > 1)
    6ffc:	62 30       	cpi	r22, 0x02	; 2
    6ffe:	71 05       	cpc	r23, r1
    7000:	50 f7       	brcc	.-44     	; 0x6fd6 <Checksum_16+0x1c>
    7002:	f8 01       	movw	r30, r16
    7004:	ee 7f       	andi	r30, 0xFE	; 254
    7006:	ee 0d       	add	r30, r14
    7008:	ff 1d       	adc	r31, r15
				checksum = checksum + result;
				//decrimiert L채nge von TCP Headerschleife um 2
				headerlenght -=2 ;
			}
		//Ist der Wert result16 ungerade ist DataL = 0
		if( headerlenght > 0)
    700a:	00 ff       	sbrs	r16, 0
    700c:	0a c0       	rjmp	.+20     	; 0x7022 <Checksum_16+0x68>
			{
				DataH=*pointer;
				result =~ (DataH << 8);
				checksum = checksum + result;
    700e:	90 81       	ld	r25, Z
    7010:	80 e0       	ldi	r24, 0x00	; 0
    7012:	80 95       	com	r24
    7014:	90 95       	com	r25
    7016:	a0 e0       	ldi	r26, 0x00	; 0
    7018:	b0 e0       	ldi	r27, 0x00	; 0
    701a:	28 0f       	add	r18, r24
    701c:	39 1f       	adc	r19, r25
    701e:	4a 1f       	adc	r20, r26
    7020:	5b 1f       	adc	r21, r27
			}
		//Komplementbildung (addiert Long INT_H Byte mit Long INT L Byte)
		checksum = ((checksum & 0x0000FFFF)+ ((checksum & 0xFFFF0000) >> 16));
    7022:	ca 01       	movw	r24, r20
    7024:	aa 27       	eor	r26, r26
    7026:	bb 27       	eor	r27, r27
    7028:	40 70       	andi	r20, 0x00	; 0
    702a:	50 70       	andi	r21, 0x00	; 0
    702c:	82 0f       	add	r24, r18
    702e:	93 1f       	adc	r25, r19
    7030:	a4 1f       	adc	r26, r20
    7032:	b5 1f       	adc	r27, r21
		checksum = ((checksum & 0x0000FFFF)+ ((checksum & 0xFFFF0000) >> 16));
    7034:	9d 01       	movw	r18, r26
    7036:	44 27       	eor	r20, r20
    7038:	55 27       	eor	r21, r21
    703a:	a0 70       	andi	r26, 0x00	; 0
    703c:	b0 70       	andi	r27, 0x00	; 0
    703e:	28 0f       	add	r18, r24
    7040:	39 1f       	adc	r19, r25
    7042:	4a 1f       	adc	r20, r26
    7044:	5b 1f       	adc	r21, r27
    7046:	40 70       	andi	r20, 0x00	; 0
    7048:	50 70       	andi	r21, 0x00	; 0
		checksum = (checksum & 0x0000FFFF);
		return (checksum);
}
    704a:	c9 01       	movw	r24, r18
    704c:	cd b7       	in	r28, 0x3d	; 61
    704e:	de b7       	in	r29, 0x3e	; 62
    7050:	e6 e0       	ldi	r30, 0x06	; 6
    7052:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

00007056 <STDOUT_INIT>:
 */
/*------------------------------------------------------------------------------------------------------------*/
void STDOUT_INIT( void )
{
	// printf auf uart umbiegen
	stdout = stdin = &mystdout;
    7056:	85 e5       	ldi	r24, 0x55	; 85
    7058:	91 e0       	ldi	r25, 0x01	; 1
    705a:	90 93 f6 0b 	sts	0x0BF6, r25
    705e:	80 93 f5 0b 	sts	0x0BF5, r24
    7062:	90 93 f8 0b 	sts	0x0BF8, r25
    7066:	80 93 f7 0b 	sts	0x0BF7, r24
	streamout.TYPE = UNKNOWN;
    706a:	8f ef       	ldi	r24, 0xFF	; 255
    706c:	80 93 57 0a 	sts	0x0A57, r24
	streamout.BUFFER = BUFFER ;
    7070:	87 ed       	ldi	r24, 0xD7	; 215
    7072:	91 e0       	ldi	r25, 0x01	; 1
    7074:	90 93 5b 0a 	sts	0x0A5B, r25
    7078:	80 93 5a 0a 	sts	0x0A5A, r24
	streamout.BUFFER_POS = 0 ;
    707c:	10 92 5d 0a 	sts	0x0A5D, r1
    7080:	10 92 5c 0a 	sts	0x0A5C, r1
	streamout.XPOS = 1;
    7084:	81 e0       	ldi	r24, 0x01	; 1
    7086:	90 e0       	ldi	r25, 0x00	; 0
    7088:	90 93 5f 0a 	sts	0x0A5F, r25
    708c:	80 93 5e 0a 	sts	0x0A5E, r24
	streamout.YPOS = 1;
    7090:	90 93 61 0a 	sts	0x0A61, r25
    7094:	80 93 60 0a 	sts	0x0A60, r24
	streamout.SEND = NULL;
    7098:	10 92 63 0a 	sts	0x0A63, r1
    709c:	10 92 62 0a 	sts	0x0A62, r1
	streamout.GET = NULL;
    70a0:	10 92 65 0a 	sts	0x0A65, r1
    70a4:	10 92 64 0a 	sts	0x0A64, r1
}	
    70a8:	08 95       	ret

000070aa <STDOUT_Get_Byte>:
						break;
		#endif
		default:		break;
	} */
	return( EOF );
}
    70aa:	8f ef       	ldi	r24, 0xFF	; 255
    70ac:	9f ef       	ldi	r25, 0xFF	; 255
    70ae:	08 95       	ret

000070b0 <STDOUT_Flush>:
/*!\brief Schickt alle Daten die sich um Puffer befinden k철nnten raus.
 */
/*------------------------------------------------------------------------------------------------------------*/
void STDOUT_Flush( void )
{
	switch( streamout.TYPE )
    70b0:	80 91 57 0a 	lds	r24, 0x0A57
    70b4:	82 30       	cpi	r24, 0x02	; 2
    70b6:	c9 f4       	brne	.+50     	; 0x70ea <STDOUT_Flush+0x3a>
	{
		case	RS232:		break;
#ifdef TCP
		case	_TCP:		if ( streamout.BUFFER_POS != 0 )
    70b8:	80 91 5c 0a 	lds	r24, 0x0A5C
    70bc:	90 91 5d 0a 	lds	r25, 0x0A5D
    70c0:	89 2b       	or	r24, r25
    70c2:	79 f0       	breq	.+30     	; 0x70e2 <STDOUT_Flush+0x32>
								PutSocketData_RPE ( streamout.DEVICE, streamout.BUFFER_POS, (unsigned char *) streamout.BUFFER, RAM );
    70c4:	80 91 58 0a 	lds	r24, 0x0A58
    70c8:	90 91 59 0a 	lds	r25, 0x0A59
    70cc:	60 91 5c 0a 	lds	r22, 0x0A5C
    70d0:	70 91 5d 0a 	lds	r23, 0x0A5D
    70d4:	40 91 5a 0a 	lds	r20, 0x0A5A
    70d8:	50 91 5b 0a 	lds	r21, 0x0A5B
    70dc:	20 e0       	ldi	r18, 0x00	; 0
    70de:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <PutSocketData_RPE>
							streamout.BUFFER_POS = 0;
    70e2:	10 92 5d 0a 	sts	0x0A5D, r1
    70e6:	10 92 5c 0a 	sts	0x0A5C, r1
    70ea:	08 95       	ret

000070ec <STDOUT_set>:
 * \param 	DEVICE		Devicenummer oder Socket auf den umgebogen werden soll.
 * \return	int			0 alles Okay. Fehler gleich -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
int STDOUT_set( char TYPE, int DEVICE )
{
    70ec:	ff 92       	push	r15
    70ee:	0f 93       	push	r16
    70f0:	1f 93       	push	r17
    70f2:	18 2f       	mov	r17, r24
    70f4:	06 2f       	mov	r16, r22
    70f6:	f7 2e       	mov	r15, r23
	STDOUT_Flush();
    70f8:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
	
	streamout.TYPE = TYPE;
    70fc:	10 93 57 0a 	sts	0x0A57, r17
	streamout.DEVICE = DEVICE;
    7100:	80 2f       	mov	r24, r16
    7102:	9f 2d       	mov	r25, r15
    7104:	90 93 59 0a 	sts	0x0A59, r25
    7108:	80 93 58 0a 	sts	0x0A58, r24
	streamout.BUFFER_POS = 0;
    710c:	10 92 5d 0a 	sts	0x0A5D, r1
    7110:	10 92 5c 0a 	sts	0x0A5C, r1
	
}
    7114:	1f 91       	pop	r17
    7116:	0f 91       	pop	r16
    7118:	ff 90       	pop	r15
    711a:	08 95       	ret

0000711c <STDOUT_restore>:
 * \param 	pStruct		Pointer auf Struktur vom Typ streamout in den der wieder hergestellt werden soll.
 * \return	int			0 alles Okay.
 */
/*------------------------------------------------------------------------------------------------------------*/
int STDOUT_restore( void * pStruct )
{
    711c:	0f 93       	push	r16
    711e:	1f 93       	push	r17
    7120:	18 2f       	mov	r17, r24
    7122:	09 2f       	mov	r16, r25
	STDOUT_Flush();
    7124:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
	memcpy( &streamout, pStruct, sizeof( streamout ) );
    7128:	a7 e5       	ldi	r26, 0x57	; 87
    712a:	ba e0       	ldi	r27, 0x0A	; 10
    712c:	21 2f       	mov	r18, r17
    712e:	30 2f       	mov	r19, r16
    7130:	c9 01       	movw	r24, r18
    7132:	fc 01       	movw	r30, r24
    7134:	8f e0       	ldi	r24, 0x0F	; 15
    7136:	01 90       	ld	r0, Z+
    7138:	0d 92       	st	X+, r0
    713a:	81 50       	subi	r24, 0x01	; 1
    713c:	e1 f7       	brne	.-8      	; 0x7136 <STDOUT_restore+0x1a>
	return( 0 );
}
    713e:	80 e0       	ldi	r24, 0x00	; 0
    7140:	90 e0       	ldi	r25, 0x00	; 0
    7142:	1f 91       	pop	r17
    7144:	0f 91       	pop	r16
    7146:	08 95       	ret

00007148 <STDOUT_save>:
 * \param 	pStruct		Pointer auf Struktur vom Typ streamout in den der aktuelle Standart Out gesichert werden soll.
 * \return	int			0 alles Okay.
 */
/*------------------------------------------------------------------------------------------------------------*/
int STDOUT_save( void * pStruct )
{
    7148:	0f 93       	push	r16
    714a:	1f 93       	push	r17
    714c:	18 2f       	mov	r17, r24
    714e:	09 2f       	mov	r16, r25
	STDOUT_Flush();
    7150:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
	memcpy( pStruct, &streamout, sizeof( streamout ) );
    7154:	21 2f       	mov	r18, r17
    7156:	30 2f       	mov	r19, r16
    7158:	c9 01       	movw	r24, r18
    715a:	dc 01       	movw	r26, r24
    715c:	e7 e5       	ldi	r30, 0x57	; 87
    715e:	fa e0       	ldi	r31, 0x0A	; 10
    7160:	8f e0       	ldi	r24, 0x0F	; 15
    7162:	01 90       	ld	r0, Z+
    7164:	0d 92       	st	X+, r0
    7166:	81 50       	subi	r24, 0x01	; 1
    7168:	e1 f7       	brne	.-8      	; 0x7162 <STDOUT_save+0x1a>
	return( 0 );
}
    716a:	80 e0       	ldi	r24, 0x00	; 0
    716c:	90 e0       	ldi	r25, 0x00	; 0
    716e:	1f 91       	pop	r17
    7170:	0f 91       	pop	r16
    7172:	08 95       	ret

00007174 <STDOUT_Send_Byte>:
 * \param   Byte		Byte welchen gesendet werden soll.
 * \param   stream		Pointer auf den Stream.
 * \retval  int			keiner.
/*------------------------------------------------------------------------------------------------------------*/
int STDOUT_Send_Byte ( char Byte, FILE * stream )
{
    7174:	1f 93       	push	r17
    7176:	18 2f       	mov	r17, r24
	switch ( streamout.TYPE )
    7178:	80 91 57 0a 	lds	r24, 0x0A57
    717c:	81 30       	cpi	r24, 0x01	; 1
    717e:	19 f0       	breq	.+6      	; 0x7186 <STDOUT_Send_Byte+0x12>
    7180:	82 30       	cpi	r24, 0x02	; 2
    7182:	f1 f4       	brne	.+60     	; 0x71c0 <STDOUT_Send_Byte+0x4c>
    7184:	04 c0       	rjmp	.+8      	; 0x718e <STDOUT_Send_Byte+0x1a>
	{
		
		case RS232:		UART_Send_Byte ( Byte );
    7186:	81 2f       	mov	r24, r17
    7188:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <UART_Send_Byte>
    718c:	19 c0       	rjmp	.+50     	; 0x71c0 <STDOUT_Send_Byte+0x4c>
						break;		
#if defined(TCP)
		case _TCP:		if ( streamout.BUFFER_POS == STDIO_BUFFER )
    718e:	80 91 5c 0a 	lds	r24, 0x0A5C
    7192:	90 91 5d 0a 	lds	r25, 0x0A5D
    7196:	80 34       	cpi	r24, 0x40	; 64
    7198:	91 05       	cpc	r25, r1
    719a:	11 f4       	brne	.+4      	; 0x71a0 <STDOUT_Send_Byte+0x2c>
							STDOUT_Flush();
    719c:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
		
						streamout.BUFFER[ streamout.BUFFER_POS++ ] = Byte;
    71a0:	80 91 5c 0a 	lds	r24, 0x0A5C
    71a4:	90 91 5d 0a 	lds	r25, 0x0A5D
    71a8:	e0 91 5a 0a 	lds	r30, 0x0A5A
    71ac:	f0 91 5b 0a 	lds	r31, 0x0A5B
    71b0:	e8 0f       	add	r30, r24
    71b2:	f9 1f       	adc	r31, r25
    71b4:	10 83       	st	Z, r17
    71b6:	01 96       	adiw	r24, 0x01	; 1
    71b8:	90 93 5d 0a 	sts	0x0A5D, r25
    71bc:	80 93 5c 0a 	sts	0x0A5C, r24
						}
						break;
#endif
		default:		break;
	}
}
    71c0:	1f 91       	pop	r17
    71c2:	08 95       	ret

000071c4 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    71c4:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    71c6:	f9 99       	sbic	0x1f, 1	; 31
    71c8:	fe cf       	rjmp	.-4      	; 0x71c6 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    71ca:	32 bd       	out	0x22, r19	; 34
    71cc:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    71ce:	f8 9a       	sbi	0x1f, 0	; 31
    71d0:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    71d2:	08 95       	ret

000071d4 <getConfigsizeUsed>:
/*------------------------------------------------------------------------------------------------------------*/
int getConfigsizeUsed( void )
{
	int i;
	
	if ( ConfigPos == -1 ) return( -1 );
    71d4:	80 91 65 01 	lds	r24, 0x0165
    71d8:	90 91 66 01 	lds	r25, 0x0166
    71dc:	8f 5f       	subi	r24, 0xFF	; 255
    71de:	9f 4f       	sbci	r25, 0xFF	; 255
    71e0:	19 f4       	brne	.+6      	; 0x71e8 <getConfigsizeUsed+0x14>
    71e2:	2f ef       	ldi	r18, 0xFF	; 255
    71e4:	3f ef       	ldi	r19, 0xFF	; 255
    71e6:	1b c0       	rjmp	.+54     	; 0x721e <getConfigsizeUsed+0x4a>
	
	for( i = 0 ; i < MCPconfig.Configlen ; i++ )
    71e8:	60 91 23 02 	lds	r22, 0x0223
    71ec:	70 91 24 02 	lds	r23, 0x0224
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' )
    71f0:	40 91 63 01 	lds	r20, 0x0163
    71f4:	50 91 64 01 	lds	r21, 0x0164
    71f8:	20 e0       	ldi	r18, 0x00	; 0
    71fa:	30 e0       	ldi	r19, 0x00	; 0
    71fc:	0d c0       	rjmp	.+26     	; 0x7218 <getConfigsizeUsed+0x44>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    71fe:	f9 99       	sbic	0x1f, 1	; 31
    7200:	fe cf       	rjmp	.-4      	; 0x71fe <getConfigsizeUsed+0x2a>
    7202:	c9 01       	movw	r24, r18
    7204:	84 0f       	add	r24, r20
    7206:	95 1f       	adc	r25, r21
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    7208:	92 bd       	out	0x22, r25	; 34
    720a:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    720c:	f8 9a       	sbi	0x1f, 0	; 31
    720e:	80 b5       	in	r24, 0x20	; 32
    7210:	88 23       	and	r24, r24
    7212:	29 f0       	breq	.+10     	; 0x721e <getConfigsizeUsed+0x4a>
{
	int i;
	
	if ( ConfigPos == -1 ) return( -1 );
	
	for( i = 0 ; i < MCPconfig.Configlen ; i++ )
    7214:	2f 5f       	subi	r18, 0xFF	; 255
    7216:	3f 4f       	sbci	r19, 0xFF	; 255
    7218:	26 17       	cp	r18, r22
    721a:	37 07       	cpc	r19, r23
    721c:	84 f3       	brlt	.-32     	; 0x71fe <getConfigsizeUsed+0x2a>
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' )
			break;
	
	return( i );
}
    721e:	c9 01       	movw	r24, r18
    7220:	08 95       	ret

00007222 <setprotectConfig>:
	return( checkConfigName ( ConfigNameBuffer ) );
}

void setprotectConfig( int Protect )
{
	ConfigProtect = Protect;
    7222:	90 93 18 02 	sts	0x0218, r25
    7226:	80 93 17 02 	sts	0x0217, r24
}
    722a:	08 95       	ret

0000722c <checkConfigName>:
 * \retval	>=0		Position im EEprom, alles okay, wurde was gefunden.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int checkConfigName( char * ConfigName )
{
    722c:	ae e1       	ldi	r26, 0x1E	; 30
    722e:	b0 e0       	ldi	r27, 0x00	; 0
    7230:	ec e1       	ldi	r30, 0x1C	; 28
    7232:	f9 e3       	ldi	r31, 0x39	; 57
    7234:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    7238:	2c 01       	movw	r4, r24
		for ( ; i < getConfigsizeUsed () ; Pos++ , i++ )
		{
			if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' || eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' ) break;
		}
		
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' ) return( -1 );
    723a:	80 90 63 01 	lds	r8, 0x0163
    723e:	90 90 64 01 	lds	r9, 0x0164
    7242:	aa 24       	eor	r10, r10
    7244:	bb 24       	eor	r11, r11
	{
		E2NamePos = i;
		Pos = 0 ;
		for( ; i < getConfigsizeUsed () ; Pos++ , i++ )
		{
			E2ConfigName[ Pos ] = eeprom_read_byte( (const char * ) ConfigOffset + i );
    7246:	3e 01       	movw	r6, r28
    7248:	08 94       	sec
    724a:	61 1c       	adc	r6, r1
    724c:	71 1c       	adc	r7, r1
    724e:	54 c0       	rjmp	.+168    	; 0x72f8 <checkConfigName+0xcc>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7250:	f9 99       	sbic	0x1f, 1	; 31
    7252:	fe cf       	rjmp	.-4      	; 0x7250 <checkConfigName+0x24>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    7254:	d2 bc       	out	0x22, r13	; 34
    7256:	c1 bc       	out	0x21, r12	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7258:	f8 9a       	sbi	0x1f, 0	; 31
    725a:	80 b5       	in	r24, 0x20	; 32
    725c:	f3 01       	movw	r30, r6
    725e:	e0 0f       	add	r30, r16
    7260:	f1 1f       	adc	r31, r17
    7262:	80 83       	st	Z, r24
			if ( E2ConfigName[ Pos ] == '=' || E2ConfigName[ Pos ] == '\0' ) 
    7264:	8d 33       	cpi	r24, 0x3D	; 61
    7266:	29 f0       	breq	.+10     	; 0x7272 <checkConfigName+0x46>
    7268:	08 94       	sec
    726a:	c1 1c       	adc	r12, r1
    726c:	d1 1c       	adc	r13, r1
    726e:	88 23       	and	r24, r24
    7270:	79 f4       	brne	.+30     	; 0x7290 <checkConfigName+0x64>
			{
				E2ConfigName[ Pos ] = '\0';
    7272:	06 0d       	add	r16, r6
    7274:	17 1d       	adc	r17, r7
    7276:	f8 01       	movw	r30, r16
    7278:	10 82       	st	Z, r1
				if ( !strcmp( E2ConfigName , ConfigName ) ) return( E2NamePos );
    727a:	c3 01       	movw	r24, r6
    727c:	b2 01       	movw	r22, r4
    727e:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    7282:	00 97       	sbiw	r24, 0x00	; 0
    7284:	09 f4       	brne	.+2      	; 0x7288 <checkConfigName+0x5c>
    7286:	44 c0       	rjmp	.+136    	; 0x7310 <checkConfigName+0xe4>
    7288:	87 01       	movw	r16, r14
    728a:	08 0d       	add	r16, r8
    728c:	19 1d       	adc	r17, r9
    728e:	20 c0       	rjmp	.+64     	; 0x72d0 <checkConfigName+0xa4>
	
	for( ; i < getConfigsizeUsed () ; i++ )
	{
		E2NamePos = i;
		Pos = 0 ;
		for( ; i < getConfigsizeUsed () ; Pos++ , i++ )
    7290:	0f 5f       	subi	r16, 0xFF	; 255
    7292:	1f 4f       	sbci	r17, 0xFF	; 255
    7294:	08 94       	sec
    7296:	e1 1c       	adc	r14, r1
    7298:	f1 1c       	adc	r15, r1
    729a:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    729e:	e8 16       	cp	r14, r24
    72a0:	f9 06       	cpc	r15, r25
    72a2:	b4 f2       	brlt	.-84     	; 0x7250 <checkConfigName+0x24>
    72a4:	f1 cf       	rjmp	.-30     	; 0x7288 <checkConfigName+0x5c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    72a6:	f9 99       	sbic	0x1f, 1	; 31
    72a8:	fe cf       	rjmp	.-4      	; 0x72a6 <checkConfigName+0x7a>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    72aa:	12 bd       	out	0x22, r17	; 34
    72ac:	01 bd       	out	0x21, r16	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72ae:	f8 9a       	sbi	0x1f, 0	; 31
    72b0:	80 b5       	in	r24, 0x20	; 32
			}
		}
		
		for ( ; i < getConfigsizeUsed () ; Pos++ , i++ )
		{
			if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' || eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' ) break;
    72b2:	8d 30       	cpi	r24, 0x0D	; 13
    72b4:	91 f0       	breq	.+36     	; 0x72da <checkConfigName+0xae>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    72b6:	f9 99       	sbic	0x1f, 1	; 31
    72b8:	fe cf       	rjmp	.-4      	; 0x72b6 <checkConfigName+0x8a>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    72ba:	12 bd       	out	0x22, r17	; 34
    72bc:	01 bd       	out	0x21, r16	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72be:	f8 9a       	sbi	0x1f, 0	; 31
    72c0:	80 b5       	in	r24, 0x20	; 32
    72c2:	0f 5f       	subi	r16, 0xFF	; 255
    72c4:	1f 4f       	sbci	r17, 0xFF	; 255
    72c6:	88 23       	and	r24, r24
    72c8:	41 f0       	breq	.+16     	; 0x72da <checkConfigName+0xae>
				if ( !strcmp( E2ConfigName , ConfigName ) ) return( E2NamePos );
				else break;
			}
		}
		
		for ( ; i < getConfigsizeUsed () ; Pos++ , i++ )
    72ca:	08 94       	sec
    72cc:	e1 1c       	adc	r14, r1
    72ce:	f1 1c       	adc	r15, r1
    72d0:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    72d4:	e8 16       	cp	r14, r24
    72d6:	f9 06       	cpc	r15, r25
    72d8:	34 f3       	brlt	.-52     	; 0x72a6 <checkConfigName+0x7a>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    72da:	f9 99       	sbic	0x1f, 1	; 31
    72dc:	fe cf       	rjmp	.-4      	; 0x72da <checkConfigName+0xae>
		{
			if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' || eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' ) break;
		}
		
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' ) return( -1 );
    72de:	c7 01       	movw	r24, r14
    72e0:	88 0d       	add	r24, r8
    72e2:	99 1d       	adc	r25, r9
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    72e4:	92 bd       	out	0x22, r25	; 34
    72e6:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72e8:	f8 9a       	sbi	0x1f, 0	; 31
    72ea:	80 b5       	in	r24, 0x20	; 32
    72ec:	88 23       	and	r24, r24
    72ee:	91 f0       	breq	.+36     	; 0x7314 <checkConfigName+0xe8>
	int i = 0, ConfigNameLen, Pos, E2NamePos;
	char E2ConfigName[30];
	
	ConfigNameLen = strlen( ConfigName );
	
	for( ; i < getConfigsizeUsed () ; i++ )
    72f0:	57 01       	movw	r10, r14
    72f2:	08 94       	sec
    72f4:	a1 1c       	adc	r10, r1
    72f6:	b1 1c       	adc	r11, r1
    72f8:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    72fc:	a8 16       	cp	r10, r24
    72fe:	b9 06       	cpc	r11, r25
    7300:	4c f4       	brge	.+18     	; 0x7314 <checkConfigName+0xe8>
    7302:	65 01       	movw	r12, r10
    7304:	c8 0c       	add	r12, r8
    7306:	d9 1c       	adc	r13, r9
    7308:	75 01       	movw	r14, r10
    730a:	00 e0       	ldi	r16, 0x00	; 0
    730c:	10 e0       	ldi	r17, 0x00	; 0
    730e:	c5 cf       	rjmp	.-118    	; 0x729a <checkConfigName+0x6e>
    7310:	95 01       	movw	r18, r10
    7312:	02 c0       	rjmp	.+4      	; 0x7318 <checkConfigName+0xec>
    7314:	2f ef       	ldi	r18, 0xFF	; 255
    7316:	3f ef       	ldi	r19, 0xFF	; 255
		}
		
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\0' ) return( -1 );
	}
	return( -1 );
}
    7318:	c9 01       	movw	r24, r18
    731a:	6e 96       	adiw	r28, 0x1e	; 30
    731c:	e0 e1       	ldi	r30, 0x10	; 16
    731e:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

00007322 <checkConfigName_P>:
 * \retval	>= 0	Position im EEprom, alles okay, wurde was gefunden.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int checkConfigName_P( const char * ConfigName )
{
    7322:	a0 e0       	ldi	r26, 0x00	; 0
    7324:	b0 e0       	ldi	r27, 0x00	; 0
    7326:	e7 e9       	ldi	r30, 0x97	; 151
    7328:	f9 e3       	ldi	r31, 0x39	; 57
    732a:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    732e:	7c 01       	movw	r14, r24
	unsigned char * ConfigNameBuffer;
	ConfigNameBuffer = (unsigned char*) __builtin_alloca (( size_t ) strlen_P( ConfigName ) + 1);
	strcpy_P( ConfigNameBuffer , ConfigName );
	return( checkConfigName ( ConfigNameBuffer ) );
}
    7330:	cd b6       	in	r12, 0x3d	; 61
    7332:	de b6       	in	r13, 0x3e	; 62
 */
/*------------------------------------------------------------------------------------------------------------*/
int checkConfigName_P( const char * ConfigName )
{
	unsigned char * ConfigNameBuffer;
	ConfigNameBuffer = (unsigned char*) __builtin_alloca (( size_t ) strlen_P( ConfigName ) + 1);
    7334:	0e 94 07 14 	call	0x280e	; 0x280e <strlen_P>
    7338:	01 96       	adiw	r24, 0x01	; 1
    733a:	2d b7       	in	r18, 0x3d	; 61
    733c:	3e b7       	in	r19, 0x3e	; 62
    733e:	28 1b       	sub	r18, r24
    7340:	39 0b       	sbc	r19, r25
    7342:	0f b6       	in	r0, 0x3f	; 63
    7344:	f8 94       	cli
    7346:	3e bf       	out	0x3e, r19	; 62
    7348:	0f be       	out	0x3f, r0	; 63
    734a:	2d bf       	out	0x3d, r18	; 61
    734c:	0d b7       	in	r16, 0x3d	; 61
    734e:	1e b7       	in	r17, 0x3e	; 62
    7350:	0f 5f       	subi	r16, 0xFF	; 255
    7352:	1f 4f       	sbci	r17, 0xFF	; 255
	strcpy_P( ConfigNameBuffer , ConfigName );
    7354:	c8 01       	movw	r24, r16
    7356:	b7 01       	movw	r22, r14
    7358:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
	return( checkConfigName ( ConfigNameBuffer ) );
    735c:	c8 01       	movw	r24, r16
    735e:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
}
    7362:	0f b6       	in	r0, 0x3f	; 63
    7364:	f8 94       	cli
    7366:	de be       	out	0x3e, r13	; 62
    7368:	0f be       	out	0x3f, r0	; 63
    736a:	cd be       	out	0x3d, r12	; 61
    736c:	20 96       	adiw	r28, 0x00	; 0
    736e:	e8 e0       	ldi	r30, 0x08	; 8
    7370:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

00007374 <deleteConfig>:
 * \retval	1		Alles okay.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int deleteConfig( char * ConfigName)
{
    7374:	a0 e0       	ldi	r26, 0x00	; 0
    7376:	b0 e0       	ldi	r27, 0x00	; 0
    7378:	e0 ec       	ldi	r30, 0xC0	; 192
    737a:	f9 e3       	ldi	r31, 0x39	; 57
    737c:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    7380:	ec 01       	movw	r28, r24
	int i, E2Pos, EntryLen=0, E2Size;
	char Buffer='\r';

	if ( ConfigProtect == PROTECT ) return( 1 );
    7382:	80 91 17 02 	lds	r24, 0x0217
    7386:	90 91 18 02 	lds	r25, 0x0218
    738a:	01 97       	sbiw	r24, 0x01	; 1
    738c:	09 f4       	brne	.+2      	; 0x7390 <deleteConfig+0x1c>
    738e:	71 c0       	rjmp	.+226    	; 0x7472 <deleteConfig+0xfe>

	E2Size = getConfigsizeUsed ();
    7390:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    7394:	8c 01       	movw	r16, r24
	
	i = checkConfigName ( ConfigName );
    7396:	ce 01       	movw	r24, r28
    7398:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
    739c:	ac 01       	movw	r20, r24
	
	if ( i == -1 ) return( -1 );
    739e:	8f ef       	ldi	r24, 0xFF	; 255
    73a0:	4f 3f       	cpi	r20, 0xFF	; 255
    73a2:	58 07       	cpc	r21, r24
    73a4:	19 f4       	brne	.+6      	; 0x73ac <deleteConfig+0x38>
    73a6:	2f ef       	ldi	r18, 0xFF	; 255
    73a8:	3f ef       	ldi	r19, 0xFF	; 255
    73aa:	65 c0       	rjmp	.+202    	; 0x7476 <deleteConfig+0x102>
	
	for ( ; i < E2Size ; i++ )
	{
		Buffer = eeprom_read_byte( (const char * ) ConfigOffset + i );
    73ac:	e0 90 63 01 	lds	r14, 0x0163
    73b0:	f0 90 64 01 	lds	r15, 0x0164
 * \retval	1		Alles okay.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int deleteConfig( char * ConfigName)
{
    73b4:	9a 01       	movw	r18, r20
    73b6:	2e 0d       	add	r18, r14
    73b8:	3f 1d       	adc	r19, r15
    73ba:	aa 24       	eor	r10, r10
    73bc:	bb 24       	eor	r11, r11
    73be:	8d e0       	ldi	r24, 0x0D	; 13
    73c0:	d8 2e       	mov	r13, r24
    73c2:	10 c0       	rjmp	.+32     	; 0x73e4 <deleteConfig+0x70>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73c4:	f9 99       	sbic	0x1f, 1	; 31
    73c6:	fe cf       	rjmp	.-4      	; 0x73c4 <deleteConfig+0x50>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    73c8:	32 bd       	out	0x22, r19	; 34
    73ca:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73cc:	f8 9a       	sbi	0x1f, 0	; 31
    73ce:	d0 b4       	in	r13, 0x20	; 32
	if ( i == -1 ) return( -1 );
	
	for ( ; i < E2Size ; i++ )
	{
		Buffer = eeprom_read_byte( (const char * ) ConfigOffset + i );
		if ( Buffer == '\r' || Buffer == '\0' )
    73d0:	8d e0       	ldi	r24, 0x0D	; 13
    73d2:	d8 16       	cp	r13, r24
    73d4:	69 f0       	breq	.+26     	; 0x73f0 <deleteConfig+0x7c>
    73d6:	2f 5f       	subi	r18, 0xFF	; 255
    73d8:	3f 4f       	sbci	r19, 0xFF	; 255
    73da:	dd 20       	and	r13, r13
    73dc:	49 f0       	breq	.+18     	; 0x73f0 <deleteConfig+0x7c>
			break;
		EntryLen++;
    73de:	08 94       	sec
    73e0:	a1 1c       	adc	r10, r1
    73e2:	b1 1c       	adc	r11, r1
	
	i = checkConfigName ( ConfigName );
	
	if ( i == -1 ) return( -1 );
	
	for ( ; i < E2Size ; i++ )
    73e4:	c5 01       	movw	r24, r10
    73e6:	84 0f       	add	r24, r20
    73e8:	95 1f       	adc	r25, r21
    73ea:	80 17       	cp	r24, r16
    73ec:	91 07       	cpc	r25, r17
    73ee:	54 f3       	brlt	.-44     	; 0x73c4 <deleteConfig+0x50>
		if ( Buffer == '\r' || Buffer == '\0' )
			break;
		EntryLen++;
	}
	
	i = checkConfigName ( ConfigName );
    73f0:	ce 01       	movw	r24, r28
    73f2:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
    73f6:	8c 01       	movw	r16, r24

	if ( Buffer == '\r' )
    73f8:	8d e0       	ldi	r24, 0x0D	; 13
    73fa:	d8 16       	cp	r13, r24
    73fc:	51 f5       	brne	.+84     	; 0x7452 <deleteConfig+0xde>
 * \retval	1		Alles okay.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int deleteConfig( char * ConfigName)
{
    73fe:	68 01       	movw	r12, r16
    7400:	ce 0c       	add	r12, r14
    7402:	df 1c       	adc	r13, r15
    7404:	e7 01       	movw	r28, r14
    7406:	21 96       	adiw	r28, 0x01	; 1
    7408:	c0 0f       	add	r28, r16
    740a:	d1 1f       	adc	r29, r17
    740c:	ca 0d       	add	r28, r10
    740e:	db 1d       	adc	r29, r11
    7410:	17 c0       	rjmp	.+46     	; 0x7440 <deleteConfig+0xcc>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7412:	f9 99       	sbic	0x1f, 1	; 31
    7414:	fe cf       	rjmp	.-4      	; 0x7412 <deleteConfig+0x9e>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    7416:	d2 bd       	out	0x22, r29	; 34
    7418:	c1 bd       	out	0x21, r28	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    741a:	f8 9a       	sbi	0x1f, 0	; 31
    741c:	80 b5       	in	r24, 0x20	; 32
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    741e:	f9 99       	sbic	0x1f, 1	; 31
    7420:	fe cf       	rjmp	.-4      	; 0x741e <deleteConfig+0xaa>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7422:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7424:	d2 bc       	out	0x22, r13	; 34
    7426:	c1 bc       	out	0x21, r12	; 33
#endif
    EEDR = __value;
    7428:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    742a:	0f b6       	in	r0, 0x3f	; 63
    742c:	f8 94       	cli
    742e:	fa 9a       	sbi	0x1f, 2	; 31
    7430:	f9 9a       	sbi	0x1f, 1	; 31
    7432:	0f be       	out	0x3f, r0	; 63
	i = checkConfigName ( ConfigName );

	if ( Buffer == '\r' )
	{
		EntryLen++;
		for( ; i < getConfigsizeUsed () ; i++ )
    7434:	0f 5f       	subi	r16, 0xFF	; 255
    7436:	1f 4f       	sbci	r17, 0xFF	; 255
    7438:	08 94       	sec
    743a:	c1 1c       	adc	r12, r1
    743c:	d1 1c       	adc	r13, r1
    743e:	21 96       	adiw	r28, 0x01	; 1
    7440:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    7444:	08 17       	cp	r16, r24
    7446:	19 07       	cpc	r17, r25
    7448:	24 f3       	brlt	.-56     	; 0x7412 <deleteConfig+0x9e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    744a:	f9 99       	sbic	0x1f, 1	; 31
    744c:	fe cf       	rjmp	.-4      	; 0x744a <deleteConfig+0xd6>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    744e:	1f ba       	out	0x1f, r1	; 31
    7450:	06 c0       	rjmp	.+12     	; 0x745e <deleteConfig+0xea>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    7452:	f9 99       	sbic	0x1f, 1	; 31
    7454:	fe cf       	rjmp	.-4      	; 0x7452 <deleteConfig+0xde>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7456:	1f ba       	out	0x1f, r1	; 31
		}
		eeprom_write_byte( ( char *) ConfigOffset + i, '\0' );
	}
	else
	{
		eeprom_write_byte( ( char *) ConfigOffset + i - 1, '\0' );
    7458:	08 94       	sec
    745a:	e1 08       	sbc	r14, r1
    745c:	f1 08       	sbc	r15, r1
    745e:	e0 0e       	add	r14, r16
    7460:	f1 1e       	adc	r15, r17
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7462:	f2 bc       	out	0x22, r15	; 34
    7464:	e1 bc       	out	0x21, r14	; 33
#endif
    EEDR = __value;
    7466:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    7468:	0f b6       	in	r0, 0x3f	; 63
    746a:	f8 94       	cli
    746c:	fa 9a       	sbi	0x1f, 2	; 31
    746e:	f9 9a       	sbi	0x1f, 1	; 31
    7470:	0f be       	out	0x3f, r0	; 63
    7472:	21 e0       	ldi	r18, 0x01	; 1
    7474:	30 e0       	ldi	r19, 0x00	; 0
	}
		
	return(1);
}
    7476:	c9 01       	movw	r24, r18
    7478:	cd b7       	in	r28, 0x3d	; 61
    747a:	de b7       	in	r29, 0x3e	; 62
    747c:	ea e0       	ldi	r30, 0x0A	; 10
    747e:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00007482 <writeConfig>:
 * \retval	1		Alles okay.
 * \retval  -1		Ging irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int writeConfig( char * ConfigName, char * ConfigValue )
{
    7482:	ef 92       	push	r14
    7484:	ff 92       	push	r15
    7486:	0f 93       	push	r16
    7488:	1f 93       	push	r17
    748a:	cf 93       	push	r28
    748c:	df 93       	push	r29
    748e:	ec 01       	movw	r28, r24
    7490:	f6 2e       	mov	r15, r22
    7492:	e7 2e       	mov	r14, r23
	int Pos,i;
		
	if ( checkConfigName ( ConfigName ) != -1 ) return( -1 );
    7494:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
    7498:	8f 5f       	subi	r24, 0xFF	; 255
    749a:	9f 4f       	sbci	r25, 0xFF	; 255
    749c:	19 f0       	breq	.+6      	; 0x74a4 <writeConfig+0x22>
    749e:	2f ef       	ldi	r18, 0xFF	; 255
    74a0:	3f ef       	ldi	r19, 0xFF	; 255
    74a2:	97 c0       	rjmp	.+302    	; 0x75d2 <writeConfig+0x150>

	if ( ConfigProtect == PROTECT ) return( 1 );
    74a4:	80 91 17 02 	lds	r24, 0x0217
    74a8:	90 91 18 02 	lds	r25, 0x0218
    74ac:	01 97       	sbiw	r24, 0x01	; 1
    74ae:	09 f4       	brne	.+2      	; 0x74b2 <writeConfig+0x30>
    74b0:	8e c0       	rjmp	.+284    	; 0x75ce <writeConfig+0x14c>
	
	Pos = getConfigsizeUsed();
    74b2:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
		
	if ( Pos != 0 ) eeprom_write_byte( ( char * ) ConfigOffset + Pos++ , '\r' );
    74b6:	00 97       	sbiw	r24, 0x00	; 0
    74b8:	b1 f0       	breq	.+44     	; 0x74e6 <writeConfig+0x64>
    74ba:	40 91 63 01 	lds	r20, 0x0163
    74be:	50 91 64 01 	lds	r21, 0x0164
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    74c2:	f9 99       	sbic	0x1f, 1	; 31
    74c4:	fe cf       	rjmp	.-4      	; 0x74c2 <writeConfig+0x40>
    74c6:	9c 01       	movw	r18, r24
    74c8:	2f 5f       	subi	r18, 0xFF	; 255
    74ca:	3f 4f       	sbci	r19, 0xFF	; 255

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    74cc:	1f ba       	out	0x1f, r1	; 31
    74ce:	48 0f       	add	r20, r24
    74d0:	59 1f       	adc	r21, r25
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    74d2:	52 bd       	out	0x22, r21	; 34
    74d4:	41 bd       	out	0x21, r20	; 33
#endif
    EEDR = __value;
    74d6:	8d e0       	ldi	r24, 0x0D	; 13
    74d8:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    74da:	0f b6       	in	r0, 0x3f	; 63
    74dc:	f8 94       	cli
    74de:	fa 9a       	sbi	0x1f, 2	; 31
    74e0:	f9 9a       	sbi	0x1f, 1	; 31
    74e2:	0f be       	out	0x3f, r0	; 63
    74e4:	c9 01       	movw	r24, r18

	for( i = 0 ; i < strlen( ConfigName ) ; i++ )
    74e6:	de 01       	movw	r26, r28
    74e8:	0d 90       	ld	r0, X+
    74ea:	00 20       	and	r0, r0
    74ec:	e9 f7       	brne	.-6      	; 0x74e8 <writeConfig+0x66>
    74ee:	11 97       	sbiw	r26, 0x01	; 1
    74f0:	ac 1b       	sub	r26, r28
    74f2:	bd 0b       	sbc	r27, r29
	{
		eeprom_write_byte( ( char * ) ConfigOffset + Pos++, ConfigName[ i ] ) ;
    74f4:	60 91 63 01 	lds	r22, 0x0163
    74f8:	70 91 64 01 	lds	r23, 0x0164
    74fc:	ac 01       	movw	r20, r24
    74fe:	46 0f       	add	r20, r22
    7500:	57 1f       	adc	r21, r23
    7502:	20 e0       	ldi	r18, 0x00	; 0
    7504:	30 e0       	ldi	r19, 0x00	; 0
    7506:	13 c0       	rjmp	.+38     	; 0x752e <writeConfig+0xac>
    7508:	fe 01       	movw	r30, r28
    750a:	e2 0f       	add	r30, r18
    750c:	f3 1f       	adc	r31, r19
    750e:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    7510:	f9 99       	sbic	0x1f, 1	; 31
    7512:	fe cf       	rjmp	.-4      	; 0x7510 <writeConfig+0x8e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7514:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7516:	52 bd       	out	0x22, r21	; 34
    7518:	41 bd       	out	0x21, r20	; 33
#endif
    EEDR = __value;
    751a:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
    751c:	0f b6       	in	r0, 0x3f	; 63
    751e:	f8 94       	cli
    7520:	fa 9a       	sbi	0x1f, 2	; 31
    7522:	f9 9a       	sbi	0x1f, 1	; 31
    7524:	0f be       	out	0x3f, r0	; 63
	
	Pos = getConfigsizeUsed();
		
	if ( Pos != 0 ) eeprom_write_byte( ( char * ) ConfigOffset + Pos++ , '\r' );

	for( i = 0 ; i < strlen( ConfigName ) ; i++ )
    7526:	2f 5f       	subi	r18, 0xFF	; 255
    7528:	3f 4f       	sbci	r19, 0xFF	; 255
    752a:	4f 5f       	subi	r20, 0xFF	; 255
    752c:	5f 4f       	sbci	r21, 0xFF	; 255
    752e:	2a 17       	cp	r18, r26
    7530:	3b 07       	cpc	r19, r27
    7532:	50 f3       	brcs	.-44     	; 0x7508 <writeConfig+0x86>
    7534:	8c 01       	movw	r16, r24
    7536:	0a 0f       	add	r16, r26
    7538:	1b 1f       	adc	r17, r27
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    753a:	f9 99       	sbic	0x1f, 1	; 31
    753c:	fe cf       	rjmp	.-4      	; 0x753a <writeConfig+0xb8>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    753e:	1f ba       	out	0x1f, r1	; 31
	{
		eeprom_write_byte( ( char * ) ConfigOffset + Pos++, ConfigName[ i ] ) ;
	}
	eeprom_write_byte( ( char * ) ConfigOffset + Pos++, '=' );
    7540:	c8 01       	movw	r24, r16
    7542:	86 0f       	add	r24, r22
    7544:	97 1f       	adc	r25, r23
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7546:	92 bd       	out	0x22, r25	; 34
    7548:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    754a:	8d e3       	ldi	r24, 0x3D	; 61
    754c:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    754e:	0f b6       	in	r0, 0x3f	; 63
    7550:	f8 94       	cli
    7552:	fa 9a       	sbi	0x1f, 2	; 31
    7554:	f9 9a       	sbi	0x1f, 1	; 31
    7556:	0f be       	out	0x3f, r0	; 63

	for( i = 0 ; i < strlen( ConfigValue ) ; i++ )
    7558:	ef 2d       	mov	r30, r15
    755a:	fe 2d       	mov	r31, r14
    755c:	ef 01       	movw	r28, r30
    755e:	09 90       	ld	r0, Y+
    7560:	00 20       	and	r0, r0
    7562:	e9 f7       	brne	.-6      	; 0x755e <writeConfig+0xdc>
    7564:	6f 5f       	subi	r22, 0xFF	; 255
    7566:	7f 4f       	sbci	r23, 0xFF	; 255
    7568:	ab 01       	movw	r20, r22
    756a:	40 0f       	add	r20, r16
    756c:	51 1f       	adc	r21, r17
    756e:	61 50       	subi	r22, 0x01	; 1
    7570:	70 40       	sbci	r23, 0x00	; 0
    7572:	2f 2d       	mov	r18, r15
    7574:	3e 2d       	mov	r19, r14
    7576:	c9 01       	movw	r24, r18
    7578:	dc 01       	movw	r26, r24
    757a:	ce 1b       	sub	r28, r30
    757c:	df 0b       	sbc	r29, r31
    757e:	ce 01       	movw	r24, r28
    7580:	86 0f       	add	r24, r22
    7582:	97 1f       	adc	r25, r23
    7584:	80 0f       	add	r24, r16
    7586:	91 1f       	adc	r25, r17
    7588:	0f c0       	rjmp	.+30     	; 0x75a8 <writeConfig+0x126>
		eeprom_write_byte( ( char * ) ConfigOffset + Pos++, ConfigValue[ i ] );
    758a:	2c 91       	ld	r18, X
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    758c:	f9 99       	sbic	0x1f, 1	; 31
    758e:	fe cf       	rjmp	.-4      	; 0x758c <writeConfig+0x10a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7590:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7592:	52 bd       	out	0x22, r21	; 34
    7594:	41 bd       	out	0x21, r20	; 33
#endif
    EEDR = __value;
    7596:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    7598:	0f b6       	in	r0, 0x3f	; 63
    759a:	f8 94       	cli
    759c:	fa 9a       	sbi	0x1f, 2	; 31
    759e:	f9 9a       	sbi	0x1f, 1	; 31
    75a0:	0f be       	out	0x3f, r0	; 63
    75a2:	4f 5f       	subi	r20, 0xFF	; 255
    75a4:	5f 4f       	sbci	r21, 0xFF	; 255
    75a6:	11 96       	adiw	r26, 0x01	; 1
	{
		eeprom_write_byte( ( char * ) ConfigOffset + Pos++, ConfigName[ i ] ) ;
	}
	eeprom_write_byte( ( char * ) ConfigOffset + Pos++, '=' );

	for( i = 0 ; i < strlen( ConfigValue ) ; i++ )
    75a8:	48 17       	cp	r20, r24
    75aa:	59 07       	cpc	r21, r25
    75ac:	71 f7       	brne	.-36     	; 0x758a <writeConfig+0x108>

	for( i = 0 ; i < strlen( ConfigName ) ; i++ )
	{
		eeprom_write_byte( ( char * ) ConfigOffset + Pos++, ConfigName[ i ] ) ;
	}
	eeprom_write_byte( ( char * ) ConfigOffset + Pos++, '=' );
    75ae:	9e 01       	movw	r18, r28
    75b0:	20 0f       	add	r18, r16
    75b2:	31 1f       	adc	r19, r17
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    75b4:	f9 99       	sbic	0x1f, 1	; 31
    75b6:	fe cf       	rjmp	.-4      	; 0x75b4 <writeConfig+0x132>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    75b8:	1f ba       	out	0x1f, r1	; 31

	for( i = 0 ; i < strlen( ConfigValue ) ; i++ )
		eeprom_write_byte( ( char * ) ConfigOffset + Pos++, ConfigValue[ i ] );
	
	eeprom_write_byte( ( char * ) ConfigOffset + Pos, '\0' );
    75ba:	26 0f       	add	r18, r22
    75bc:	37 1f       	adc	r19, r23
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    75be:	32 bd       	out	0x22, r19	; 34
    75c0:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    75c2:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    75c4:	0f b6       	in	r0, 0x3f	; 63
    75c6:	f8 94       	cli
    75c8:	fa 9a       	sbi	0x1f, 2	; 31
    75ca:	f9 9a       	sbi	0x1f, 1	; 31
    75cc:	0f be       	out	0x3f, r0	; 63
    75ce:	21 e0       	ldi	r18, 0x01	; 1
    75d0:	30 e0       	ldi	r19, 0x00	; 0
	
	return( 1 );
}
    75d2:	c9 01       	movw	r24, r18
    75d4:	cd b7       	in	r28, 0x3d	; 61
    75d6:	de b7       	in	r29, 0x3e	; 62
    75d8:	e6 e0       	ldi	r30, 0x06	; 6
    75da:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

000075de <changeConfig>:
 * \retval	1		Alles okay.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int changeConfig( char * ConfigName, char * ConfigValue )
{
    75de:	0f 93       	push	r16
    75e0:	1f 93       	push	r17
    75e2:	cf 93       	push	r28
    75e4:	df 93       	push	r29
    75e6:	ec 01       	movw	r28, r24
    75e8:	8b 01       	movw	r16, r22
	int i;
	
	i = checkConfigName ( ConfigName );
    75ea:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
	
	if ( i != -1 ) deleteConfig ( ConfigName );
    75ee:	8f 5f       	subi	r24, 0xFF	; 255
    75f0:	9f 4f       	sbci	r25, 0xFF	; 255
    75f2:	19 f0       	breq	.+6      	; 0x75fa <changeConfig+0x1c>
    75f4:	ce 01       	movw	r24, r28
    75f6:	0e 94 ba 39 	call	0x7374	; 0x7374 <deleteConfig>
	
	writeConfig ( ConfigName, ConfigValue );
    75fa:	ce 01       	movw	r24, r28
    75fc:	b8 01       	movw	r22, r16
    75fe:	0e 94 41 3a 	call	0x7482	; 0x7482 <writeConfig>
	
	return( 1 );
}
    7602:	81 e0       	ldi	r24, 0x01	; 1
    7604:	90 e0       	ldi	r25, 0x00	; 0
    7606:	df 91       	pop	r29
    7608:	cf 91       	pop	r28
    760a:	1f 91       	pop	r17
    760c:	0f 91       	pop	r16
    760e:	08 95       	ret

00007610 <changeConfig_P>:
 * \retval	1		Alles okay.
 * \retval  -1		Gin irgentwie net, what ever.
 */
/*------------------------------------------------------------------------------------------------------------*/
int changeConfig_P( const char * ConfigName, char * ConfigValue )
{
    7610:	a0 e0       	ldi	r26, 0x00	; 0
    7612:	b0 e0       	ldi	r27, 0x00	; 0
    7614:	ee e0       	ldi	r30, 0x0E	; 14
    7616:	fb e3       	ldi	r31, 0x3B	; 59
    7618:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    761c:	7c 01       	movw	r14, r24
    761e:	6b 01       	movw	r12, r22
	unsigned char * ConfigNameBuffer;
	ConfigNameBuffer = (unsigned char*) __builtin_alloca (( size_t ) strlen_P( ConfigName ) + 1);
	strcpy_P( ConfigNameBuffer , ConfigName );
	return( changeConfig ( ConfigNameBuffer, ConfigValue ) );
}
    7620:	ad b6       	in	r10, 0x3d	; 61
    7622:	be b6       	in	r11, 0x3e	; 62
 */
/*------------------------------------------------------------------------------------------------------------*/
int changeConfig_P( const char * ConfigName, char * ConfigValue )
{
	unsigned char * ConfigNameBuffer;
	ConfigNameBuffer = (unsigned char*) __builtin_alloca (( size_t ) strlen_P( ConfigName ) + 1);
    7624:	0e 94 07 14 	call	0x280e	; 0x280e <strlen_P>
    7628:	01 96       	adiw	r24, 0x01	; 1
    762a:	2d b7       	in	r18, 0x3d	; 61
    762c:	3e b7       	in	r19, 0x3e	; 62
    762e:	28 1b       	sub	r18, r24
    7630:	39 0b       	sbc	r19, r25
    7632:	0f b6       	in	r0, 0x3f	; 63
    7634:	f8 94       	cli
    7636:	3e bf       	out	0x3e, r19	; 62
    7638:	0f be       	out	0x3f, r0	; 63
    763a:	2d bf       	out	0x3d, r18	; 61
    763c:	0d b7       	in	r16, 0x3d	; 61
    763e:	1e b7       	in	r17, 0x3e	; 62
    7640:	0f 5f       	subi	r16, 0xFF	; 255
    7642:	1f 4f       	sbci	r17, 0xFF	; 255
	strcpy_P( ConfigNameBuffer , ConfigName );
    7644:	c8 01       	movw	r24, r16
    7646:	b7 01       	movw	r22, r14
    7648:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
	return( changeConfig ( ConfigNameBuffer, ConfigValue ) );
    764c:	c8 01       	movw	r24, r16
    764e:	b6 01       	movw	r22, r12
    7650:	0e 94 ef 3a 	call	0x75de	; 0x75de <changeConfig>
}
    7654:	0f b6       	in	r0, 0x3f	; 63
    7656:	f8 94       	cli
    7658:	be be       	out	0x3e, r11	; 62
    765a:	0f be       	out	0x3f, r0	; 63
    765c:	ad be       	out	0x3d, r10	; 61
    765e:	20 96       	adiw	r28, 0x00	; 0
    7660:	ea e0       	ldi	r30, 0x0A	; 10
    7662:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00007666 <readConfig>:
 * \retval	1		Alles okay, es wurde was gefunden.
 * \retval  -1		Nix gefunden. Eintrag nicht vorhanden.
 */
/*------------------------------------------------------------------------------------------------------------*/
int readConfig( char * ConfigName, char * ConfigValue )
{
    7666:	ae e1       	ldi	r26, 0x1E	; 30
    7668:	b0 e0       	ldi	r27, 0x00	; 0
    766a:	e9 e3       	ldi	r30, 0x39	; 57
    766c:	fb e3       	ldi	r31, 0x3B	; 59
    766e:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    7672:	5c 01       	movw	r10, r24
    7674:	2b 01       	movw	r4, r22
	int i = 0, ConfigNameLen, Pos=0;
	char E2ConfigName[30];
	
	ConfigNameLen = strlen( ConfigName );
	
	i = checkConfigName ( ConfigName );
    7676:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
    767a:	7c 01       	movw	r14, r24
	
	if ( i == -1 ) return( -1 );
    767c:	8f ef       	ldi	r24, 0xFF	; 255
    767e:	e8 16       	cp	r14, r24
    7680:	8f ef       	ldi	r24, 0xFF	; 255
    7682:	f8 06       	cpc	r15, r24
    7684:	09 f4       	brne	.+2      	; 0x7688 <readConfig+0x22>
    7686:	6f c0       	rjmp	.+222    	; 0x7766 <readConfig+0x100>
	
	for( ; i < getConfigsizeUsed () ; Pos++ , i++ )
	{
		E2ConfigName[ Pos ] = eeprom_read_byte( (const char * ) ConfigOffset + i );
    7688:	80 90 63 01 	lds	r8, 0x0163
    768c:	90 90 64 01 	lds	r9, 0x0164
    7690:	67 01       	movw	r12, r14
    7692:	c8 0c       	add	r12, r8
    7694:	d9 1c       	adc	r13, r9
    7696:	00 e0       	ldi	r16, 0x00	; 0
    7698:	10 e0       	ldi	r17, 0x00	; 0
    769a:	3e 01       	movw	r6, r28
    769c:	08 94       	sec
    769e:	61 1c       	adc	r6, r1
    76a0:	71 1c       	adc	r7, r1
    76a2:	1b c0       	rjmp	.+54     	; 0x76da <readConfig+0x74>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    76a4:	f9 99       	sbic	0x1f, 1	; 31
    76a6:	fe cf       	rjmp	.-4      	; 0x76a4 <readConfig+0x3e>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    76a8:	d2 bc       	out	0x22, r13	; 34
    76aa:	c1 bc       	out	0x21, r12	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    76ac:	f8 9a       	sbi	0x1f, 0	; 31
    76ae:	80 b5       	in	r24, 0x20	; 32
    76b0:	f3 01       	movw	r30, r6
    76b2:	e0 0f       	add	r30, r16
    76b4:	f1 1f       	adc	r31, r17
    76b6:	80 83       	st	Z, r24
		if ( E2ConfigName[ Pos ] == '=' || E2ConfigName[ Pos ] == '\0' ) 
    76b8:	8d 33       	cpi	r24, 0x3D	; 61
    76ba:	29 f0       	breq	.+10     	; 0x76c6 <readConfig+0x60>
    76bc:	08 94       	sec
    76be:	c1 1c       	adc	r12, r1
    76c0:	d1 1c       	adc	r13, r1
    76c2:	88 23       	and	r24, r24
    76c4:	29 f4       	brne	.+10     	; 0x76d0 <readConfig+0x6a>
		{
			E2ConfigName[ Pos ] = '\0';
    76c6:	0c 0f       	add	r16, r28
    76c8:	1d 1f       	adc	r17, r29
    76ca:	f8 01       	movw	r30, r16
    76cc:	11 82       	std	Z+1, r1	; 0x01
    76ce:	0a c0       	rjmp	.+20     	; 0x76e4 <readConfig+0x7e>
	
	i = checkConfigName ( ConfigName );
	
	if ( i == -1 ) return( -1 );
	
	for( ; i < getConfigsizeUsed () ; Pos++ , i++ )
    76d0:	0f 5f       	subi	r16, 0xFF	; 255
    76d2:	1f 4f       	sbci	r17, 0xFF	; 255
    76d4:	08 94       	sec
    76d6:	e1 1c       	adc	r14, r1
    76d8:	f1 1c       	adc	r15, r1
    76da:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    76de:	e8 16       	cp	r14, r24
    76e0:	f9 06       	cpc	r15, r25
    76e2:	04 f3       	brlt	.-64     	; 0x76a4 <readConfig+0x3e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    76e4:	f9 99       	sbic	0x1f, 1	; 31
    76e6:	fe cf       	rjmp	.-4      	; 0x76e4 <readConfig+0x7e>
			E2ConfigName[ Pos ] = '\0';
			break;
		}
	}
		
	if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '=' )
    76e8:	c7 01       	movw	r24, r14
    76ea:	88 0d       	add	r24, r8
    76ec:	99 1d       	adc	r25, r9
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    76ee:	92 bd       	out	0x22, r25	; 34
    76f0:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    76f2:	f8 9a       	sbi	0x1f, 0	; 31
    76f4:	80 b5       	in	r24, 0x20	; 32
    76f6:	8d 33       	cpi	r24, 0x3D	; 61
    76f8:	b1 f5       	brne	.+108    	; 0x7766 <readConfig+0x100>
	{
		if ( !strcmp( E2ConfigName , ConfigName ) ) 
    76fa:	ce 01       	movw	r24, r28
    76fc:	01 96       	adiw	r24, 0x01	; 1
    76fe:	b5 01       	movw	r22, r10
    7700:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    7704:	00 97       	sbiw	r24, 0x00	; 0
    7706:	79 f5       	brne	.+94     	; 0x7766 <readConfig+0x100>
		{
			i++;
    7708:	57 01       	movw	r10, r14
    770a:	08 94       	sec
    770c:	a1 1c       	adc	r10, r1
    770e:	b1 1c       	adc	r11, r1
    7710:	64 01       	movw	r12, r8
    7712:	08 94       	sec
    7714:	c1 1c       	adc	r12, r1
    7716:	d1 1c       	adc	r13, r1
    7718:	ce 0c       	add	r12, r14
    771a:	df 1c       	adc	r13, r15
    771c:	00 e0       	ldi	r16, 0x00	; 0
    771e:	10 e0       	ldi	r17, 0x00	; 0
    7720:	16 c0       	rjmp	.+44     	; 0x774e <readConfig+0xe8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7722:	f9 99       	sbic	0x1f, 1	; 31
    7724:	fe cf       	rjmp	.-4      	; 0x7722 <readConfig+0xbc>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    7726:	d2 bc       	out	0x22, r13	; 34
    7728:	c1 bc       	out	0x21, r12	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    772a:	f8 9a       	sbi	0x1f, 0	; 31
    772c:	80 b5       	in	r24, 0x20	; 32
			Pos = 0;
			for ( ; i < getConfigsizeUsed () ; Pos++ , i++ )
			{
				ConfigValue[ Pos ] = eeprom_read_byte( (const char * ) ConfigOffset + i );
    772e:	f2 01       	movw	r30, r4
    7730:	e0 0f       	add	r30, r16
    7732:	f1 1f       	adc	r31, r17
    7734:	80 83       	st	Z, r24
				if ( ConfigValue[ Pos ] == '\r' || ConfigValue[ Pos ] == '\0' ) break;
    7736:	8d 30       	cpi	r24, 0x0D	; 13
    7738:	79 f0       	breq	.+30     	; 0x7758 <readConfig+0xf2>
    773a:	08 94       	sec
    773c:	c1 1c       	adc	r12, r1
    773e:	d1 1c       	adc	r13, r1
    7740:	88 23       	and	r24, r24
    7742:	51 f0       	breq	.+20     	; 0x7758 <readConfig+0xf2>
	{
		if ( !strcmp( E2ConfigName , ConfigName ) ) 
		{
			i++;
			Pos = 0;
			for ( ; i < getConfigsizeUsed () ; Pos++ , i++ )
    7744:	0f 5f       	subi	r16, 0xFF	; 255
    7746:	1f 4f       	sbci	r17, 0xFF	; 255
    7748:	08 94       	sec
    774a:	a1 1c       	adc	r10, r1
    774c:	b1 1c       	adc	r11, r1
    774e:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    7752:	a8 16       	cp	r10, r24
    7754:	b9 06       	cpc	r11, r25
    7756:	2c f3       	brlt	.-54     	; 0x7722 <readConfig+0xbc>
			{
				ConfigValue[ Pos ] = eeprom_read_byte( (const char * ) ConfigOffset + i );
				if ( ConfigValue[ Pos ] == '\r' || ConfigValue[ Pos ] == '\0' ) break;
			}
			ConfigValue[ Pos ] = '\0';
    7758:	04 0d       	add	r16, r4
    775a:	15 1d       	adc	r17, r5
    775c:	f8 01       	movw	r30, r16
    775e:	10 82       	st	Z, r1
    7760:	21 e0       	ldi	r18, 0x01	; 1
    7762:	30 e0       	ldi	r19, 0x00	; 0
    7764:	02 c0       	rjmp	.+4      	; 0x776a <readConfig+0x104>
			return( 1 );
    7766:	2f ef       	ldi	r18, 0xFF	; 255
    7768:	3f ef       	ldi	r19, 0xFF	; 255
		}
	}
	return( -1 );
}
    776a:	c9 01       	movw	r24, r18
    776c:	6e 96       	adiw	r28, 0x1e	; 30
    776e:	e0 e1       	ldi	r30, 0x10	; 16
    7770:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

00007774 <readConfig_P>:
 * \retval	1		Alles okay, es wurde was gefunden.
 * \retval  -1		Nix gefunden. Eintrag nicht vorhanden.
 */
/*------------------------------------------------------------------------------------------------------------*/
int readConfig_P( const char * ConfigName, char * ConfigValue )
{
    7774:	a0 e0       	ldi	r26, 0x00	; 0
    7776:	b0 e0       	ldi	r27, 0x00	; 0
    7778:	e0 ec       	ldi	r30, 0xC0	; 192
    777a:	fb e3       	ldi	r31, 0x3B	; 59
    777c:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    7780:	7c 01       	movw	r14, r24
    7782:	6b 01       	movw	r12, r22
	unsigned char * ConfigNameBuffer;
	ConfigNameBuffer = (unsigned char*) __builtin_alloca (( size_t ) strlen_P( ConfigName ) + 1);
	strcpy_P( ConfigNameBuffer , ConfigName );
	return( readConfig ( ConfigNameBuffer, ConfigValue ) );
}
    7784:	ad b6       	in	r10, 0x3d	; 61
    7786:	be b6       	in	r11, 0x3e	; 62
 */
/*------------------------------------------------------------------------------------------------------------*/
int readConfig_P( const char * ConfigName, char * ConfigValue )
{
	unsigned char * ConfigNameBuffer;
	ConfigNameBuffer = (unsigned char*) __builtin_alloca (( size_t ) strlen_P( ConfigName ) + 1);
    7788:	0e 94 07 14 	call	0x280e	; 0x280e <strlen_P>
    778c:	01 96       	adiw	r24, 0x01	; 1
    778e:	2d b7       	in	r18, 0x3d	; 61
    7790:	3e b7       	in	r19, 0x3e	; 62
    7792:	28 1b       	sub	r18, r24
    7794:	39 0b       	sbc	r19, r25
    7796:	0f b6       	in	r0, 0x3f	; 63
    7798:	f8 94       	cli
    779a:	3e bf       	out	0x3e, r19	; 62
    779c:	0f be       	out	0x3f, r0	; 63
    779e:	2d bf       	out	0x3d, r18	; 61
    77a0:	0d b7       	in	r16, 0x3d	; 61
    77a2:	1e b7       	in	r17, 0x3e	; 62
    77a4:	0f 5f       	subi	r16, 0xFF	; 255
    77a6:	1f 4f       	sbci	r17, 0xFF	; 255
	strcpy_P( ConfigNameBuffer , ConfigName );
    77a8:	c8 01       	movw	r24, r16
    77aa:	b7 01       	movw	r22, r14
    77ac:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
	return( readConfig ( ConfigNameBuffer, ConfigValue ) );
    77b0:	c8 01       	movw	r24, r16
    77b2:	b6 01       	movw	r22, r12
    77b4:	0e 94 33 3b 	call	0x7666	; 0x7666 <readConfig>
}
    77b8:	0f b6       	in	r0, 0x3f	; 63
    77ba:	f8 94       	cli
    77bc:	be be       	out	0x3e, r11	; 62
    77be:	0f be       	out	0x3f, r0	; 63
    77c0:	ad be       	out	0x3d, r10	; 61
    77c2:	20 96       	adiw	r28, 0x00	; 0
    77c4:	ea e0       	ldi	r30, 0x0A	; 10
    77c6:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

000077ca <makeConfig>:
{
	int i;
	int len = E2END - sizeof ( MCPconfig );
	int Pos =0;
		
	memcpy_P( &MCPconfig.TAG , PSTR( configID ), sizeof ( configID ) );
    77ca:	89 e1       	ldi	r24, 0x19	; 25
    77cc:	92 e0       	ldi	r25, 0x02	; 2
    77ce:	67 e4       	ldi	r22, 0x47	; 71
    77d0:	72 e0       	ldi	r23, 0x02	; 2
    77d2:	4a e0       	ldi	r20, 0x0A	; 10
    77d4:	50 e0       	ldi	r21, 0x00	; 0
    77d6:	0e 94 ee 13 	call	0x27dc	; 0x27dc <memcpy_P>
	MCPconfig.Configlen = len;
    77da:	83 ef       	ldi	r24, 0xF3	; 243
    77dc:	97 e0       	ldi	r25, 0x07	; 7
    77de:	90 93 24 02 	sts	0x0224, r25
    77e2:	80 93 23 02 	sts	0x0223, r24
    77e6:	80 e0       	ldi	r24, 0x00	; 0
    77e8:	90 e0       	ldi	r25, 0x00	; 0
    77ea:	10 c0       	rjmp	.+32     	; 0x780c <makeConfig+0x42>
	
	for( i = 0; i < sizeof( MCPconfig ) ; i++ )
		eeprom_write_byte(  ( char * ) Pos + i, MCPconfig.TAG[i] );
    77ec:	fc 01       	movw	r30, r24
    77ee:	e7 5e       	subi	r30, 0xE7	; 231
    77f0:	fd 4f       	sbci	r31, 0xFD	; 253
    77f2:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    77f4:	f9 99       	sbic	0x1f, 1	; 31
    77f6:	fe cf       	rjmp	.-4      	; 0x77f4 <makeConfig+0x2a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    77f8:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    77fa:	92 bd       	out	0x22, r25	; 34
    77fc:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    77fe:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
    7800:	0f b6       	in	r0, 0x3f	; 63
    7802:	f8 94       	cli
    7804:	fa 9a       	sbi	0x1f, 2	; 31
    7806:	f9 9a       	sbi	0x1f, 1	; 31
    7808:	0f be       	out	0x3f, r0	; 63
	int Pos =0;
		
	memcpy_P( &MCPconfig.TAG , PSTR( configID ), sizeof ( configID ) );
	MCPconfig.Configlen = len;
	
	for( i = 0; i < sizeof( MCPconfig ) ; i++ )
    780a:	01 96       	adiw	r24, 0x01	; 1
    780c:	8c 30       	cpi	r24, 0x0C	; 12
    780e:	91 05       	cpc	r25, r1
    7810:	69 f7       	brne	.-38     	; 0x77ec <makeConfig+0x22>
		eeprom_write_byte(  ( char * ) Pos + i, MCPconfig.TAG[i] );
	
	ConfigOffset = Pos + sizeof( MCPconfig ) + 1;
    7812:	8d e0       	ldi	r24, 0x0D	; 13
    7814:	90 e0       	ldi	r25, 0x00	; 0
    7816:	90 93 64 01 	sts	0x0164, r25
    781a:	80 93 63 01 	sts	0x0163, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    781e:	f9 99       	sbic	0x1f, 1	; 31
    7820:	fe cf       	rjmp	.-4      	; 0x781e <makeConfig+0x54>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7822:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7824:	8d e0       	ldi	r24, 0x0D	; 13
    7826:	90 e0       	ldi	r25, 0x00	; 0
    7828:	92 bd       	out	0x22, r25	; 34
    782a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    782c:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    782e:	0f b6       	in	r0, 0x3f	; 63
    7830:	f8 94       	cli
    7832:	fa 9a       	sbi	0x1f, 2	; 31
    7834:	f9 9a       	sbi	0x1f, 1	; 31
    7836:	0f be       	out	0x3f, r0	; 63
	
	eeprom_write_byte( ( char * ) ConfigOffset, '\0' );
	
	return;
}
    7838:	08 95       	ret

0000783a <PrintConfig>:
/*!\brief Gibt den Inhalt der Config auf der aktuellen STDOUT aus.
 * \return	void
 */
/*------------------------------------------------------------------------------------------------------------*/
void PrintConfig( void )
{
    783a:	a0 e0       	ldi	r26, 0x00	; 0
    783c:	b0 e0       	ldi	r27, 0x00	; 0
    783e:	e3 e2       	ldi	r30, 0x23	; 35
    7840:	fc e3       	ldi	r31, 0x3C	; 60
    7842:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
	int i ;
	
	printf_P( PSTR("Config ist %d bytes gross, %d byte werden benutzt. Offset %d\r\n\r\n"), MCPconfig.Configlen, getConfigsizeUsed(),ConfigOffset );
    7846:	00 91 23 02 	lds	r16, 0x0223
    784a:	10 91 24 02 	lds	r17, 0x0224
    784e:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    7852:	2d b7       	in	r18, 0x3d	; 61
    7854:	3e b7       	in	r19, 0x3e	; 62
    7856:	28 50       	subi	r18, 0x08	; 8
    7858:	30 40       	sbci	r19, 0x00	; 0
    785a:	0f b6       	in	r0, 0x3f	; 63
    785c:	f8 94       	cli
    785e:	3e bf       	out	0x3e, r19	; 62
    7860:	0f be       	out	0x3f, r0	; 63
    7862:	2d bf       	out	0x3d, r18	; 61
    7864:	ed b7       	in	r30, 0x3d	; 61
    7866:	fe b7       	in	r31, 0x3e	; 62
    7868:	31 96       	adiw	r30, 0x01	; 1
    786a:	29 e5       	ldi	r18, 0x59	; 89
    786c:	32 e0       	ldi	r19, 0x02	; 2
    786e:	ad b7       	in	r26, 0x3d	; 61
    7870:	be b7       	in	r27, 0x3e	; 62
    7872:	12 96       	adiw	r26, 0x02	; 2
    7874:	3c 93       	st	X, r19
    7876:	2e 93       	st	-X, r18
    7878:	11 97       	sbiw	r26, 0x01	; 1
    787a:	13 83       	std	Z+3, r17	; 0x03
    787c:	02 83       	std	Z+2, r16	; 0x02
    787e:	95 83       	std	Z+5, r25	; 0x05
    7880:	84 83       	std	Z+4, r24	; 0x04
    7882:	80 91 63 01 	lds	r24, 0x0163
    7886:	90 91 64 01 	lds	r25, 0x0164
    788a:	97 83       	std	Z+7, r25	; 0x07
    788c:	86 83       	std	Z+6, r24	; 0x06
    788e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    7892:	00 e0       	ldi	r16, 0x00	; 0
    7894:	10 e0       	ldi	r17, 0x00	; 0
    7896:	ed b7       	in	r30, 0x3d	; 61
    7898:	fe b7       	in	r31, 0x3e	; 62
    789a:	38 96       	adiw	r30, 0x08	; 8
    789c:	0f b6       	in	r0, 0x3f	; 63
    789e:	f8 94       	cli
    78a0:	fe bf       	out	0x3e, r31	; 62
    78a2:	0f be       	out	0x3f, r0	; 63
    78a4:	ed bf       	out	0x3d, r30	; 61
					break;
			}
		}
		else
		{
			printf_P(PSTR("%c"), eeprom_read_byte( (const char * ) ConfigOffset + i ) );
    78a6:	26 e5       	ldi	r18, 0x56	; 86
    78a8:	c2 2e       	mov	r12, r18
    78aa:	22 e0       	ldi	r18, 0x02	; 2
    78ac:	d2 2e       	mov	r13, r18
			if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' ) printf_P( PSTR("\n"));
    78ae:	94 e5       	ldi	r25, 0x54	; 84
    78b0:	e9 2e       	mov	r14, r25
    78b2:	92 e0       	ldi	r25, 0x02	; 2
    78b4:	f9 2e       	mov	r15, r25
    78b6:	53 c0       	rjmp	.+166    	; 0x795e <PrintConfig+0x124>
	printf_P( PSTR("Config ist %d bytes gross, %d byte werden benutzt. Offset %d\r\n\r\n"), MCPconfig.Configlen, getConfigsizeUsed(),ConfigOffset );

	for ( i = 0 ; i < getConfigsizeUsed() ; i++ )
	{
		// Wenn '&' vorhanden, die zeile 체berspringen, soll sowas wie ein geheimer Eintrag sein
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '&' )
    78b8:	c0 91 63 01 	lds	r28, 0x0163
    78bc:	d0 91 64 01 	lds	r29, 0x0164
    78c0:	c0 0f       	add	r28, r16
    78c2:	d1 1f       	adc	r29, r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    78c4:	f9 99       	sbic	0x1f, 1	; 31
    78c6:	fe cf       	rjmp	.-4      	; 0x78c4 <PrintConfig+0x8a>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    78c8:	d2 bd       	out	0x22, r29	; 34
    78ca:	c1 bd       	out	0x21, r28	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    78cc:	f8 9a       	sbi	0x1f, 0	; 31
    78ce:	80 b5       	in	r24, 0x20	; 32
    78d0:	86 32       	cpi	r24, 0x26	; 38
    78d2:	99 f4       	brne	.+38     	; 0x78fa <PrintConfig+0xc0>
    78d4:	0c c0       	rjmp	.+24     	; 0x78ee <PrintConfig+0xb4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    78d6:	f9 99       	sbic	0x1f, 1	; 31
    78d8:	fe cf       	rjmp	.-4      	; 0x78d6 <PrintConfig+0x9c>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    78da:	d2 bd       	out	0x22, r29	; 34
    78dc:	c1 bd       	out	0x21, r28	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    78de:	f8 9a       	sbi	0x1f, 0	; 31
    78e0:	80 b5       	in	r24, 0x20	; 32
    78e2:	21 96       	adiw	r28, 0x01	; 1
		{
			for( ; i < getConfigsizeUsed() ; i++ )
			{
				if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' )
    78e4:	8d 30       	cpi	r24, 0x0D	; 13
    78e6:	09 f4       	brne	.+2      	; 0x78ea <PrintConfig+0xb0>
    78e8:	38 c0       	rjmp	.+112    	; 0x795a <PrintConfig+0x120>
	for ( i = 0 ; i < getConfigsizeUsed() ; i++ )
	{
		// Wenn '&' vorhanden, die zeile 체berspringen, soll sowas wie ein geheimer Eintrag sein
		if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '&' )
		{
			for( ; i < getConfigsizeUsed() ; i++ )
    78ea:	0f 5f       	subi	r16, 0xFF	; 255
    78ec:	1f 4f       	sbci	r17, 0xFF	; 255
    78ee:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    78f2:	08 17       	cp	r16, r24
    78f4:	19 07       	cpc	r17, r25
    78f6:	7c f3       	brlt	.-34     	; 0x78d6 <PrintConfig+0x9c>
    78f8:	30 c0       	rjmp	.+96     	; 0x795a <PrintConfig+0x120>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    78fa:	f9 99       	sbic	0x1f, 1	; 31
    78fc:	fe cf       	rjmp	.-4      	; 0x78fa <PrintConfig+0xc0>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    78fe:	d2 bd       	out	0x22, r29	; 34
    7900:	c1 bd       	out	0x21, r28	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7902:	f8 9a       	sbi	0x1f, 0	; 31
    7904:	80 b5       	in	r24, 0x20	; 32
					break;
			}
		}
		else
		{
			printf_P(PSTR("%c"), eeprom_read_byte( (const char * ) ConfigOffset + i ) );
    7906:	00 d0       	rcall	.+0      	; 0x7908 <PrintConfig+0xce>
    7908:	00 d0       	rcall	.+0      	; 0x790a <PrintConfig+0xd0>
    790a:	ed b7       	in	r30, 0x3d	; 61
    790c:	fe b7       	in	r31, 0x3e	; 62
    790e:	31 96       	adiw	r30, 0x01	; 1
    7910:	ad b7       	in	r26, 0x3d	; 61
    7912:	be b7       	in	r27, 0x3e	; 62
    7914:	12 96       	adiw	r26, 0x02	; 2
    7916:	dc 92       	st	X, r13
    7918:	ce 92       	st	-X, r12
    791a:	11 97       	sbiw	r26, 0x01	; 1
    791c:	82 83       	std	Z+2, r24	; 0x02
    791e:	13 82       	std	Z+3, r1	; 0x03
    7920:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
			if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' ) printf_P( PSTR("\n"));
    7924:	80 91 63 01 	lds	r24, 0x0163
    7928:	90 91 64 01 	lds	r25, 0x0164
    792c:	0f 90       	pop	r0
    792e:	0f 90       	pop	r0
    7930:	0f 90       	pop	r0
    7932:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7934:	f9 99       	sbic	0x1f, 1	; 31
    7936:	fe cf       	rjmp	.-4      	; 0x7934 <PrintConfig+0xfa>
    7938:	80 0f       	add	r24, r16
    793a:	91 1f       	adc	r25, r17
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    793c:	92 bd       	out	0x22, r25	; 34
    793e:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7940:	f8 9a       	sbi	0x1f, 0	; 31
    7942:	80 b5       	in	r24, 0x20	; 32
    7944:	8d 30       	cpi	r24, 0x0D	; 13
    7946:	49 f4       	brne	.+18     	; 0x795a <PrintConfig+0x120>
    7948:	00 d0       	rcall	.+0      	; 0x794a <PrintConfig+0x110>
    794a:	ed b7       	in	r30, 0x3d	; 61
    794c:	fe b7       	in	r31, 0x3e	; 62
    794e:	f2 82       	std	Z+2, r15	; 0x02
    7950:	e1 82       	std	Z+1, r14	; 0x01
    7952:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    7956:	0f 90       	pop	r0
    7958:	0f 90       	pop	r0
{
	int i ;
	
	printf_P( PSTR("Config ist %d bytes gross, %d byte werden benutzt. Offset %d\r\n\r\n"), MCPconfig.Configlen, getConfigsizeUsed(),ConfigOffset );

	for ( i = 0 ; i < getConfigsizeUsed() ; i++ )
    795a:	0f 5f       	subi	r16, 0xFF	; 255
    795c:	1f 4f       	sbci	r17, 0xFF	; 255
    795e:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <getConfigsizeUsed>
    7962:	08 17       	cp	r16, r24
    7964:	19 07       	cpc	r17, r25
    7966:	0c f4       	brge	.+2      	; 0x796a <PrintConfig+0x130>
    7968:	a7 cf       	rjmp	.-178    	; 0x78b8 <PrintConfig+0x7e>
			printf_P(PSTR("%c"), eeprom_read_byte( (const char * ) ConfigOffset + i ) );
			if ( eeprom_read_byte( (const char * ) ConfigOffset + i ) == '\r' ) printf_P( PSTR("\n"));
		}
	}
	
	printf_P( PSTR("\r\n"));	
    796a:	00 d0       	rcall	.+0      	; 0x796c <PrintConfig+0x132>
    796c:	81 e5       	ldi	r24, 0x51	; 81
    796e:	92 e0       	ldi	r25, 0x02	; 2
    7970:	ad b7       	in	r26, 0x3d	; 61
    7972:	be b7       	in	r27, 0x3e	; 62
    7974:	12 96       	adiw	r26, 0x02	; 2
    7976:	9c 93       	st	X, r25
    7978:	8e 93       	st	-X, r24
    797a:	11 97       	sbiw	r26, 0x01	; 1
    797c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    7980:	0f 90       	pop	r0
    7982:	0f 90       	pop	r0
}
    7984:	cd b7       	in	r28, 0x3d	; 61
    7986:	de b7       	in	r29, 0x3e	; 62
    7988:	e8 e0       	ldi	r30, 0x08	; 8
    798a:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000798e <findConfig>:
 * \retval  0		Okay
 * \retval  -1		Fehler
 */
/*------------------------------------------------------------------------------------------------------------*/
int findConfig( void )
{
    798e:	a0 e2       	ldi	r26, 0x20	; 32
    7990:	b0 e0       	ldi	r27, 0x00	; 0
    7992:	ed ec       	ldi	r30, 0xCD	; 205
    7994:	fc e3       	ldi	r31, 0x3C	; 60
    7996:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
    799a:	00 e0       	ldi	r16, 0x00	; 0
    799c:	10 e0       	ldi	r17, 0x00	; 0
    799e:	29 c0       	rjmp	.+82     	; 0x79f2 <findConfig+0x64>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    79a0:	89 e1       	ldi	r24, 0x19	; 25
    79a2:	92 e0       	ldi	r25, 0x02	; 2
    79a4:	b8 01       	movw	r22, r16
    79a6:	4a e0       	ldi	r20, 0x0A	; 10
    79a8:	50 e0       	ldi	r21, 0x00	; 0
    79aa:	22 ee       	ldi	r18, 0xE2	; 226
    79ac:	38 e3       	ldi	r19, 0x38	; 56
    79ae:	0e 94 69 14 	call	0x28d2	; 0x28d2 <__eerd_block>
	char string[32];
	
	for ( i = 0 ; i < ( E2END - sizeof ( MCPconfig ) ); i++ )
	{
		eeprom_read_block( MCPconfig.TAG , (const char * ) i, sizeof ( configstring ) );
		if ( !memcmp( MCPconfig.TAG , configID , sizeof ( configstring ) ) )
    79b2:	89 e1       	ldi	r24, 0x19	; 25
    79b4:	92 e0       	ldi	r25, 0x02	; 2
    79b6:	60 e0       	ldi	r22, 0x00	; 0
    79b8:	71 e0       	ldi	r23, 0x01	; 1
    79ba:	4a e0       	ldi	r20, 0x0A	; 10
    79bc:	50 e0       	ldi	r21, 0x00	; 0
    79be:	0e 94 10 14 	call	0x2820	; 0x2820 <memcmp>
    79c2:	00 97       	sbiw	r24, 0x00	; 0
    79c4:	a1 f4       	brne	.+40     	; 0x79ee <findConfig+0x60>
    79c6:	89 e1       	ldi	r24, 0x19	; 25
    79c8:	92 e0       	ldi	r25, 0x02	; 2
    79ca:	b8 01       	movw	r22, r16
    79cc:	4c e0       	ldi	r20, 0x0C	; 12
    79ce:	50 e0       	ldi	r21, 0x00	; 0
    79d0:	22 ee       	ldi	r18, 0xE2	; 226
    79d2:	38 e3       	ldi	r19, 0x38	; 56
    79d4:	0e 94 69 14 	call	0x28d2	; 0x28d2 <__eerd_block>
		{
			eeprom_read_block( &MCPconfig, (const char * ) i, sizeof ( MCPconfig ) ); 
			ConfigPos = i;
    79d8:	10 93 66 01 	sts	0x0166, r17
    79dc:	00 93 65 01 	sts	0x0165, r16
			ConfigOffset = ConfigPos + sizeof( MCPconfig ) + 1;
    79e0:	03 5f       	subi	r16, 0xF3	; 243
    79e2:	1f 4f       	sbci	r17, 0xFF	; 255
    79e4:	10 93 64 01 	sts	0x0164, r17
    79e8:	00 93 63 01 	sts	0x0163, r16
    79ec:	06 c0       	rjmp	.+12     	; 0x79fa <findConfig+0x6c>
	int len, i;
	char configstring[] = ( configID );

	char string[32];
	
	for ( i = 0 ; i < ( E2END - sizeof ( MCPconfig ) ); i++ )
    79ee:	0f 5f       	subi	r16, 0xFF	; 255
    79f0:	1f 4f       	sbci	r17, 0xFF	; 255
    79f2:	27 e0       	ldi	r18, 0x07	; 7
    79f4:	03 3f       	cpi	r16, 0xF3	; 243
    79f6:	12 07       	cpc	r17, r18
    79f8:	99 f6       	brne	.-90     	; 0x79a0 <findConfig+0x12>
			ConfigOffset = ConfigPos + sizeof( MCPconfig ) + 1;
			break;
		}
	}
	
	if( ConfigPos == -1 ) 
    79fa:	80 91 65 01 	lds	r24, 0x0165
    79fe:	90 91 66 01 	lds	r25, 0x0166
    7a02:	8f 5f       	subi	r24, 0xFF	; 255
    7a04:	9f 4f       	sbci	r25, 0xFF	; 255
    7a06:	19 f4       	brne	.+6      	; 0x7a0e <findConfig+0x80>
    7a08:	2f ef       	ldi	r18, 0xFF	; 255
    7a0a:	3f ef       	ldi	r19, 0xFF	; 255
    7a0c:	1f c0       	rjmp	.+62     	; 0x7a4c <findConfig+0xbe>
		return(-1);
	else 
	{
		if( readConfig_P ( PSTR("WRITE_PROTECT"), string ) != -1 )
    7a0e:	8e e9       	ldi	r24, 0x9E	; 158
    7a10:	92 e0       	ldi	r25, 0x02	; 2
    7a12:	8e 01       	movw	r16, r28
    7a14:	0f 5f       	subi	r16, 0xFF	; 255
    7a16:	1f 4f       	sbci	r17, 0xFF	; 255
    7a18:	b8 01       	movw	r22, r16
    7a1a:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    7a1e:	8f 5f       	subi	r24, 0xFF	; 255
    7a20:	9f 4f       	sbci	r25, 0xFF	; 255
    7a22:	91 f0       	breq	.+36     	; 0x7a48 <findConfig+0xba>
		{
			if ( !strcmp_P( string, PSTR("OFF") ) )
    7a24:	c8 01       	movw	r24, r16
    7a26:	6a e9       	ldi	r22, 0x9A	; 154
    7a28:	72 e0       	ldi	r23, 0x02	; 2
    7a2a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    7a2e:	89 2b       	or	r24, r25
    7a30:	29 f4       	brne	.+10     	; 0x7a3c <findConfig+0xae>
			    ConfigProtect = UNPROTECT;
    7a32:	10 92 18 02 	sts	0x0218, r1
    7a36:	10 92 17 02 	sts	0x0217, r1
    7a3a:	06 c0       	rjmp	.+12     	; 0x7a48 <findConfig+0xba>
			else
			    ConfigProtect = PROTECT;
    7a3c:	81 e0       	ldi	r24, 0x01	; 1
    7a3e:	90 e0       	ldi	r25, 0x00	; 0
    7a40:	90 93 18 02 	sts	0x0218, r25
    7a44:	80 93 17 02 	sts	0x0217, r24
    7a48:	20 e0       	ldi	r18, 0x00	; 0
    7a4a:	30 e0       	ldi	r19, 0x00	; 0
		}
		return(0);
	}
	return(0);
}
    7a4c:	c9 01       	movw	r24, r18
    7a4e:	a0 96       	adiw	r28, 0x20	; 32
    7a50:	e4 e0       	ldi	r30, 0x04	; 4
    7a52:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

00007a56 <Config_Init>:
 */
/*------------------------------------------------------------------------------------------------------------*/
void Config_Init( void )
{	
//	makeConfig( 0, E2END - sizeof ( MCPconfig ) );
	if ( findConfig() == -1 )
    7a56:	0e 94 c7 3c 	call	0x798e	; 0x798e <findConfig>
    7a5a:	8f 5f       	subi	r24, 0xFF	; 255
    7a5c:	9f 4f       	sbci	r25, 0xFF	; 255
    7a5e:	21 f4       	brne	.+8      	; 0x7a68 <Config_Init+0x12>
	{
//		printf_P( PSTR("Keine Config gefunden. Lege Config (%d Bytes) im EEprom an -> "),E2END);
		makeConfig( );
    7a60:	0e 94 e5 3b 	call	0x77ca	; 0x77ca <makeConfig>
		findConfig();
    7a64:	0e 94 c7 3c 	call	0x798e	; 0x798e <findConfig>
    7a68:	08 95       	ret

00007a6a <softreset>:
// Function Implementation
void softreset( void )
{
	do                          
	{                           
   		wdt_enable(WDTO_15MS);  
    7a6a:	28 e0       	ldi	r18, 0x08	; 8
    7a6c:	88 e1       	ldi	r24, 0x18	; 24
    7a6e:	90 e0       	ldi	r25, 0x00	; 0
    7a70:	0f b6       	in	r0, 0x3f	; 63
    7a72:	f8 94       	cli
    7a74:	a8 95       	wdr
    7a76:	80 93 60 00 	sts	0x0060, r24
    7a7a:	0f be       	out	0x3f, r0	; 63
    7a7c:	20 93 60 00 	sts	0x0060, r18
    7a80:	ff cf       	rjmp	.-2      	; 0x7a80 <softreset+0x16>

00007a82 <INIT_FIFO>:
/*------------------------------------------------------------------------------------------------------------*/
void INIT_FIFO( void )
{
	unsigned int i;
	
	if ( FIFO_initstate != 0 )
    7a82:	80 91 25 02 	lds	r24, 0x0225
    7a86:	88 23       	and	r24, r24
    7a88:	d9 f4       	brne	.+54     	; 0x7ac0 <INIT_FIFO+0x3e>
		return;
	
	FIFO_initstate = 1;
    7a8a:	81 e0       	ldi	r24, 0x01	; 1
    7a8c:	80 93 25 02 	sts	0x0225, r24
	// l철schen aller FIFOs
	for ( i = 0 ; i < MAX_FIFO_BUFFERS ; i++ )
		FIFO_Table[ i ].buffer = NULL;
    7a90:	10 92 67 0a 	sts	0x0A67, r1
    7a94:	10 92 66 0a 	sts	0x0A66, r1
    7a98:	10 92 72 0a 	sts	0x0A72, r1
    7a9c:	10 92 71 0a 	sts	0x0A71, r1
    7aa0:	10 92 7d 0a 	sts	0x0A7D, r1
    7aa4:	10 92 7c 0a 	sts	0x0A7C, r1
    7aa8:	10 92 88 0a 	sts	0x0A88, r1
    7aac:	10 92 87 0a 	sts	0x0A87, r1
    7ab0:	10 92 93 0a 	sts	0x0A93, r1
    7ab4:	10 92 92 0a 	sts	0x0A92, r1
    7ab8:	10 92 9e 0a 	sts	0x0A9E, r1
    7abc:	10 92 9d 0a 	sts	0x0A9D, r1
    7ac0:	08 95       	ret

00007ac2 <Get_FIFO>:
 * \param	bufferlenght	Gr철e des Puffer.
 * \return	FIFOnumber		Die Nummer des FIFO oder FIFO_ERROR.
 */
/*------------------------------------------------------------------------------------------------------------*/
int Get_FIFO( unsigned char * buffer, int bufferlenght )
{
    7ac2:	ac 01       	movw	r20, r24
    7ac4:	e6 e6       	ldi	r30, 0x66	; 102
    7ac6:	fa e0       	ldi	r31, 0x0A	; 10
    7ac8:	20 e0       	ldi	r18, 0x00	; 0
    7aca:	30 e0       	ldi	r19, 0x00	; 0
	unsigned int i;
	
	for( i = 0; i < MAX_FIFO_BUFFERS ; i++)
	{
		if ( FIFO_Table[ i ].buffer == NULL )
    7acc:	80 81       	ld	r24, Z
    7ace:	91 81       	ldd	r25, Z+1	; 0x01
    7ad0:	89 2b       	or	r24, r25
    7ad2:	c9 f4       	brne	.+50     	; 0x7b06 <Get_FIFO+0x44>
		{
			FIFO_Table[ i ].buffer = buffer;
    7ad4:	8b e0       	ldi	r24, 0x0B	; 11
    7ad6:	90 e0       	ldi	r25, 0x00	; 0
    7ad8:	28 9f       	mul	r18, r24
    7ada:	f0 01       	movw	r30, r0
    7adc:	29 9f       	mul	r18, r25
    7ade:	f0 0d       	add	r31, r0
    7ae0:	38 9f       	mul	r19, r24
    7ae2:	f0 0d       	add	r31, r0
    7ae4:	11 24       	eor	r1, r1
    7ae6:	ea 59       	subi	r30, 0x9A	; 154
    7ae8:	f5 4f       	sbci	r31, 0xF5	; 245
    7aea:	51 83       	std	Z+1, r21	; 0x01
    7aec:	40 83       	st	Z, r20
			FIFO_Table[ i ].bufferlenght = bufferlenght;
    7aee:	73 83       	std	Z+3, r23	; 0x03
    7af0:	62 83       	std	Z+2, r22	; 0x02
			FIFO_Table[ i ].readpointer = 0;
    7af2:	17 82       	std	Z+7, r1	; 0x07
    7af4:	16 82       	std	Z+6, r1	; 0x06
			FIFO_Table[ i ].writepointer = 0;
    7af6:	15 82       	std	Z+5, r1	; 0x05
    7af8:	14 82       	std	Z+4, r1	; 0x04
			FIFO_Table[ i ].byteinbuffer = 0;
    7afa:	11 86       	std	Z+9, r1	; 0x09
    7afc:	10 86       	std	Z+8, r1	; 0x08
#ifdef FIFO_BLOCKCOPYSTATS
			FIFO_Table[ i ].Bytecopyhit = 0;
			FIFO_Table[ i ].Blockcopyhit = 0;
#endif
			FIFO_Table[ i ].lock = UNLOCK;
    7afe:	8f ef       	ldi	r24, 0xFF	; 255
    7b00:	82 87       	std	Z+10, r24	; 0x0a
			return( i );
    7b02:	f9 01       	movw	r30, r18
    7b04:	08 c0       	rjmp	.+16     	; 0x7b16 <Get_FIFO+0x54>
/*------------------------------------------------------------------------------------------------------------*/
int Get_FIFO( unsigned char * buffer, int bufferlenght )
{
	unsigned int i;
	
	for( i = 0; i < MAX_FIFO_BUFFERS ; i++)
    7b06:	2f 5f       	subi	r18, 0xFF	; 255
    7b08:	3f 4f       	sbci	r19, 0xFF	; 255
    7b0a:	3b 96       	adiw	r30, 0x0b	; 11
    7b0c:	26 30       	cpi	r18, 0x06	; 6
    7b0e:	31 05       	cpc	r19, r1
    7b10:	e9 f6       	brne	.-70     	; 0x7acc <Get_FIFO+0xa>
    7b12:	ef ef       	ldi	r30, 0xFF	; 255
    7b14:	ff ef       	ldi	r31, 0xFF	; 255
			FIFO_Table[ i ].lock = UNLOCK;
			return( i );
		}
	}
	return( FIFO_ERROR );
}
    7b16:	cf 01       	movw	r24, r30
    7b18:	08 95       	ret

00007b1a <Get_Bytes_in_FIFO>:
 * \param	FIFO		Nummer des FIFO.
 * \return	Returncode	Anzahl der Bytes oder FIFO_ERROR.
 */
/*------------------------------------------------------------------------------------------------------------*/
int Get_Bytes_in_FIFO( int FIFO )
{
    7b1a:	9c 01       	movw	r18, r24
	// FIFO auf g체ltigkeit testen
	if ( ( FIFO < MAX_FIFO_BUFFERS ) && ( FIFO_Table[ FIFO ].lock == UNLOCK ) )
    7b1c:	86 30       	cpi	r24, 0x06	; 6
    7b1e:	91 05       	cpc	r25, r1
    7b20:	8c f4       	brge	.+34     	; 0x7b44 <Get_Bytes_in_FIFO+0x2a>
    7b22:	8b e0       	ldi	r24, 0x0B	; 11
    7b24:	90 e0       	ldi	r25, 0x00	; 0
    7b26:	28 9f       	mul	r18, r24
    7b28:	f0 01       	movw	r30, r0
    7b2a:	29 9f       	mul	r18, r25
    7b2c:	f0 0d       	add	r31, r0
    7b2e:	38 9f       	mul	r19, r24
    7b30:	f0 0d       	add	r31, r0
    7b32:	11 24       	eor	r1, r1
    7b34:	ea 59       	subi	r30, 0x9A	; 154
    7b36:	f5 4f       	sbci	r31, 0xF5	; 245
    7b38:	82 85       	ldd	r24, Z+10	; 0x0a
    7b3a:	8f 3f       	cpi	r24, 0xFF	; 255
    7b3c:	19 f4       	brne	.+6      	; 0x7b44 <Get_Bytes_in_FIFO+0x2a>
	{
		return( FIFO_Table[ FIFO ].byteinbuffer );
    7b3e:	20 85       	ldd	r18, Z+8	; 0x08
    7b40:	31 85       	ldd	r19, Z+9	; 0x09
    7b42:	02 c0       	rjmp	.+4      	; 0x7b48 <Get_Bytes_in_FIFO+0x2e>
    7b44:	2f ef       	ldi	r18, 0xFF	; 255
    7b46:	3f ef       	ldi	r19, 0xFF	; 255
	}
	return( FIFO_ERROR );
}
    7b48:	c9 01       	movw	r24, r18
    7b4a:	08 95       	ret

00007b4c <Put_Byte_in_FIFO>:
 * \retval  FIFO_OK		Ok
 * \retval  FIFO_ERROR	Fehler
 */
/*------------------------------------------------------------------------------------------------------------*/
int Put_Byte_in_FIFO( int FIFO, unsigned char Byte )
{
    7b4c:	ac 01       	movw	r20, r24
	// FIFO auf g체ltigkeit testen
	if ( ( FIFO < MAX_FIFO_BUFFERS ) && ( FIFO_Table[ FIFO ].lock == UNLOCK ) )
    7b4e:	86 30       	cpi	r24, 0x06	; 6
    7b50:	91 05       	cpc	r25, r1
    7b52:	0c f0       	brlt	.+2      	; 0x7b56 <Put_Byte_in_FIFO+0xa>
    7b54:	4c c0       	rjmp	.+152    	; 0x7bee <Put_Byte_in_FIFO+0xa2>
    7b56:	8b e0       	ldi	r24, 0x0B	; 11
    7b58:	90 e0       	ldi	r25, 0x00	; 0
    7b5a:	48 9f       	mul	r20, r24
    7b5c:	d0 01       	movw	r26, r0
    7b5e:	49 9f       	mul	r20, r25
    7b60:	b0 0d       	add	r27, r0
    7b62:	58 9f       	mul	r21, r24
    7b64:	b0 0d       	add	r27, r0
    7b66:	11 24       	eor	r1, r1
    7b68:	aa 59       	subi	r26, 0x9A	; 154
    7b6a:	b5 4f       	sbci	r27, 0xF5	; 245
    7b6c:	1a 96       	adiw	r26, 0x0a	; 10
    7b6e:	8c 91       	ld	r24, X
    7b70:	1a 97       	sbiw	r26, 0x0a	; 10
    7b72:	8f 3f       	cpi	r24, 0xFF	; 255
    7b74:	e1 f5       	brne	.+120    	; 0x7bee <Put_Byte_in_FIFO+0xa2>
	{
		// passen noch byte in den Puffer
		if ( FIFO_Table[ FIFO ].byteinbuffer < FIFO_Table[ FIFO ].bufferlenght )
    7b76:	18 96       	adiw	r26, 0x08	; 8
    7b78:	2d 91       	ld	r18, X+
    7b7a:	3c 91       	ld	r19, X
    7b7c:	19 97       	sbiw	r26, 0x09	; 9
    7b7e:	12 96       	adiw	r26, 0x02	; 2
    7b80:	8d 91       	ld	r24, X+
    7b82:	9c 91       	ld	r25, X
    7b84:	13 97       	sbiw	r26, 0x03	; 3
    7b86:	28 17       	cp	r18, r24
    7b88:	39 07       	cpc	r19, r25
    7b8a:	88 f5       	brcc	.+98     	; 0x7bee <Put_Byte_in_FIFO+0xa2>
		{
			// Byte in Puffer schreiben
			FIFO_Table[ FIFO ].buffer[ FIFO_Table[ FIFO ].writepointer ] = Byte; 
    7b8c:	ed 91       	ld	r30, X+
    7b8e:	fc 91       	ld	r31, X
    7b90:	11 97       	sbiw	r26, 0x01	; 1
    7b92:	14 96       	adiw	r26, 0x04	; 4
    7b94:	8d 91       	ld	r24, X+
    7b96:	9c 91       	ld	r25, X
    7b98:	15 97       	sbiw	r26, 0x05	; 5
    7b9a:	e8 0f       	add	r30, r24
    7b9c:	f9 1f       	adc	r31, r25
    7b9e:	60 83       	st	Z, r22
			
			FIFO_Table[ FIFO ].writepointer++;
    7ba0:	14 96       	adiw	r26, 0x04	; 4
    7ba2:	8d 91       	ld	r24, X+
    7ba4:	9c 91       	ld	r25, X
    7ba6:	15 97       	sbiw	r26, 0x05	; 5
    7ba8:	01 96       	adiw	r24, 0x01	; 1
    7baa:	15 96       	adiw	r26, 0x05	; 5
    7bac:	9c 93       	st	X, r25
    7bae:	8e 93       	st	-X, r24
    7bb0:	14 97       	sbiw	r26, 0x04	; 4
			// writepointer schon das ende erreicht ? und setzen
			if ( FIFO_Table[ FIFO ].writepointer == FIFO_Table[ FIFO ].bufferlenght )
    7bb2:	12 96       	adiw	r26, 0x02	; 2
    7bb4:	2d 91       	ld	r18, X+
    7bb6:	3c 91       	ld	r19, X
    7bb8:	13 97       	sbiw	r26, 0x03	; 3
    7bba:	82 17       	cp	r24, r18
    7bbc:	93 07       	cpc	r25, r19
    7bbe:	21 f4       	brne	.+8      	; 0x7bc8 <Put_Byte_in_FIFO+0x7c>
				FIFO_Table[ FIFO ].writepointer = 0;
    7bc0:	15 96       	adiw	r26, 0x05	; 5
    7bc2:	1c 92       	st	X, r1
    7bc4:	1e 92       	st	-X, r1
    7bc6:	14 97       	sbiw	r26, 0x04	; 4
			
			FIFO_Table[ FIFO ].byteinbuffer++;
    7bc8:	8b e0       	ldi	r24, 0x0B	; 11
    7bca:	90 e0       	ldi	r25, 0x00	; 0
    7bcc:	48 9f       	mul	r20, r24
    7bce:	f0 01       	movw	r30, r0
    7bd0:	49 9f       	mul	r20, r25
    7bd2:	f0 0d       	add	r31, r0
    7bd4:	58 9f       	mul	r21, r24
    7bd6:	f0 0d       	add	r31, r0
    7bd8:	11 24       	eor	r1, r1
    7bda:	ea 59       	subi	r30, 0x9A	; 154
    7bdc:	f5 4f       	sbci	r31, 0xF5	; 245
    7bde:	80 85       	ldd	r24, Z+8	; 0x08
    7be0:	91 85       	ldd	r25, Z+9	; 0x09
    7be2:	01 96       	adiw	r24, 0x01	; 1
    7be4:	91 87       	std	Z+9, r25	; 0x09
    7be6:	80 87       	std	Z+8, r24	; 0x08
    7be8:	20 e0       	ldi	r18, 0x00	; 0
    7bea:	30 e0       	ldi	r19, 0x00	; 0
    7bec:	02 c0       	rjmp	.+4      	; 0x7bf2 <Put_Byte_in_FIFO+0xa6>
			return( FIFO_OK );
    7bee:	2f ef       	ldi	r18, 0xFF	; 255
    7bf0:	3f ef       	ldi	r19, 0xFF	; 255
		}
	}
	return( FIFO_ERROR );
}
    7bf2:	c9 01       	movw	r24, r18
    7bf4:	08 95       	ret

00007bf6 <Get_Byte_from_FIFO>:
 * \return	char
 * \retval  >=0			Das Ausgelesende Byte
 */
/*------------------------------------------------------------------------------------------------------------*/
unsigned char Get_Byte_from_FIFO( int FIFO )
{
    7bf6:	ac 01       	movw	r20, r24
	unsigned char byte;
	
	// FIFO auf g체ltigkeit testen
	if ( ( FIFO < MAX_FIFO_BUFFERS ) && ( FIFO_Table[ FIFO ].lock == UNLOCK ) )
    7bf8:	86 30       	cpi	r24, 0x06	; 6
    7bfa:	91 05       	cpc	r25, r1
    7bfc:	0c f0       	brlt	.+2      	; 0x7c00 <Get_Byte_from_FIFO+0xa>
    7bfe:	41 c0       	rjmp	.+130    	; 0x7c82 <Get_Byte_from_FIFO+0x8c>
    7c00:	8b e0       	ldi	r24, 0x0B	; 11
    7c02:	90 e0       	ldi	r25, 0x00	; 0
    7c04:	48 9f       	mul	r20, r24
    7c06:	d0 01       	movw	r26, r0
    7c08:	49 9f       	mul	r20, r25
    7c0a:	b0 0d       	add	r27, r0
    7c0c:	58 9f       	mul	r21, r24
    7c0e:	b0 0d       	add	r27, r0
    7c10:	11 24       	eor	r1, r1
    7c12:	aa 59       	subi	r26, 0x9A	; 154
    7c14:	b5 4f       	sbci	r27, 0xF5	; 245
    7c16:	1a 96       	adiw	r26, 0x0a	; 10
    7c18:	8c 91       	ld	r24, X
    7c1a:	1a 97       	sbiw	r26, 0x0a	; 10
    7c1c:	8f 3f       	cpi	r24, 0xFF	; 255
    7c1e:	89 f5       	brne	.+98     	; 0x7c82 <Get_Byte_from_FIFO+0x8c>
	{
		// sind noch bytes in den Puffer
		if ( FIFO_Table[ FIFO ].byteinbuffer != 0 )
    7c20:	18 96       	adiw	r26, 0x08	; 8
    7c22:	8d 91       	ld	r24, X+
    7c24:	9c 91       	ld	r25, X
    7c26:	19 97       	sbiw	r26, 0x09	; 9
    7c28:	89 2b       	or	r24, r25
    7c2a:	59 f1       	breq	.+86     	; 0x7c82 <Get_Byte_from_FIFO+0x8c>
		{
			// Byte aus Puffer lesen
			byte = FIFO_Table[ FIFO ].buffer[ FIFO_Table[ FIFO ].readpointer ]; 
    7c2c:	16 96       	adiw	r26, 0x06	; 6
    7c2e:	8d 91       	ld	r24, X+
    7c30:	9c 91       	ld	r25, X
    7c32:	17 97       	sbiw	r26, 0x07	; 7
    7c34:	ed 91       	ld	r30, X+
    7c36:	fc 91       	ld	r31, X
    7c38:	11 97       	sbiw	r26, 0x01	; 1
    7c3a:	e8 0f       	add	r30, r24
    7c3c:	f9 1f       	adc	r31, r25
    7c3e:	60 81       	ld	r22, Z
						
			FIFO_Table[ FIFO ].readpointer++;
    7c40:	01 96       	adiw	r24, 0x01	; 1
    7c42:	17 96       	adiw	r26, 0x07	; 7
    7c44:	9c 93       	st	X, r25
    7c46:	8e 93       	st	-X, r24
    7c48:	16 97       	sbiw	r26, 0x06	; 6
			// readpointer schon das ende erreicht ? und setzen
			if ( FIFO_Table[ FIFO ].readpointer == FIFO_Table[ FIFO ].bufferlenght )
    7c4a:	12 96       	adiw	r26, 0x02	; 2
    7c4c:	2d 91       	ld	r18, X+
    7c4e:	3c 91       	ld	r19, X
    7c50:	13 97       	sbiw	r26, 0x03	; 3
    7c52:	82 17       	cp	r24, r18
    7c54:	93 07       	cpc	r25, r19
    7c56:	21 f4       	brne	.+8      	; 0x7c60 <Get_Byte_from_FIFO+0x6a>
				FIFO_Table[ FIFO ].readpointer = 0;
    7c58:	17 96       	adiw	r26, 0x07	; 7
    7c5a:	1c 92       	st	X, r1
    7c5c:	1e 92       	st	-X, r1
    7c5e:	16 97       	sbiw	r26, 0x06	; 6

			FIFO_Table[ FIFO ].byteinbuffer--;
    7c60:	8b e0       	ldi	r24, 0x0B	; 11
    7c62:	90 e0       	ldi	r25, 0x00	; 0
    7c64:	48 9f       	mul	r20, r24
    7c66:	f0 01       	movw	r30, r0
    7c68:	49 9f       	mul	r20, r25
    7c6a:	f0 0d       	add	r31, r0
    7c6c:	58 9f       	mul	r21, r24
    7c6e:	f0 0d       	add	r31, r0
    7c70:	11 24       	eor	r1, r1
    7c72:	ea 59       	subi	r30, 0x9A	; 154
    7c74:	f5 4f       	sbci	r31, 0xF5	; 245
    7c76:	80 85       	ldd	r24, Z+8	; 0x08
    7c78:	91 85       	ldd	r25, Z+9	; 0x09
    7c7a:	01 97       	sbiw	r24, 0x01	; 1
    7c7c:	91 87       	std	Z+9, r25	; 0x09
    7c7e:	80 87       	std	Z+8, r24	; 0x08
    7c80:	01 c0       	rjmp	.+2      	; 0x7c84 <Get_Byte_from_FIFO+0x8e>
			
			return( byte );
    7c82:	60 e0       	ldi	r22, 0x00	; 0
		}
	}
	return( 0 );
}
    7c84:	86 2f       	mov	r24, r22
    7c86:	08 95       	ret

00007c88 <Flush_FIFO>:
 * \retval  FIFO_OK		OK
 * \retval  FIFO_ERROR  Fehler
 */
/*------------------------------------------------------------------------------------------------------------*/
int Flush_FIFO( int FIFO )
{
    7c88:	9c 01       	movw	r18, r24
	if ( ( FIFO < MAX_FIFO_BUFFERS ) && ( FIFO_Table[ FIFO ].lock == UNLOCK ) )
    7c8a:	86 30       	cpi	r24, 0x06	; 6
    7c8c:	91 05       	cpc	r25, r1
    7c8e:	bc f4       	brge	.+46     	; 0x7cbe <Flush_FIFO+0x36>
    7c90:	8b e0       	ldi	r24, 0x0B	; 11
    7c92:	90 e0       	ldi	r25, 0x00	; 0
    7c94:	28 9f       	mul	r18, r24
    7c96:	f0 01       	movw	r30, r0
    7c98:	29 9f       	mul	r18, r25
    7c9a:	f0 0d       	add	r31, r0
    7c9c:	38 9f       	mul	r19, r24
    7c9e:	f0 0d       	add	r31, r0
    7ca0:	11 24       	eor	r1, r1
    7ca2:	ea 59       	subi	r30, 0x9A	; 154
    7ca4:	f5 4f       	sbci	r31, 0xF5	; 245
    7ca6:	82 85       	ldd	r24, Z+10	; 0x0a
    7ca8:	8f 3f       	cpi	r24, 0xFF	; 255
    7caa:	49 f4       	brne	.+18     	; 0x7cbe <Flush_FIFO+0x36>
	{
		FIFO_Table[ FIFO ].readpointer = 0;
    7cac:	17 82       	std	Z+7, r1	; 0x07
    7cae:	16 82       	std	Z+6, r1	; 0x06
		FIFO_Table[ FIFO ].writepointer = 0;
    7cb0:	15 82       	std	Z+5, r1	; 0x05
    7cb2:	14 82       	std	Z+4, r1	; 0x04
		FIFO_Table[ FIFO ].byteinbuffer = 0;
    7cb4:	11 86       	std	Z+9, r1	; 0x09
    7cb6:	10 86       	std	Z+8, r1	; 0x08
    7cb8:	20 e0       	ldi	r18, 0x00	; 0
    7cba:	30 e0       	ldi	r19, 0x00	; 0
    7cbc:	02 c0       	rjmp	.+4      	; 0x7cc2 <Flush_FIFO+0x3a>
		return( FIFO_OK );
    7cbe:	2f ef       	ldi	r18, 0xFF	; 255
    7cc0:	3f ef       	ldi	r19, 0xFF	; 255
	}
	return( FIFO_ERROR );

}
    7cc2:	c9 01       	movw	r24, r18
    7cc4:	08 95       	ret

00007cc6 <Get_FIFOrestsize>:
 * \retval  >=0			Anzahl der freien Bytes im Puffer.
 * \retval  FIFO_ERROR  Fehler.
 */
/*------------------------------------------------------------------------------------------------------------*/
int Get_FIFOrestsize( int FIFO )
{
    7cc6:	9c 01       	movw	r18, r24
	if ( FIFO < MAX_FIFO_BUFFERS ) 	
    7cc8:	86 30       	cpi	r24, 0x06	; 6
    7cca:	91 05       	cpc	r25, r1
    7ccc:	1c f0       	brlt	.+6      	; 0x7cd4 <Get_FIFOrestsize+0xe>
    7cce:	2f ef       	ldi	r18, 0xFF	; 255
    7cd0:	3f ef       	ldi	r19, 0xFF	; 255
    7cd2:	11 c0       	rjmp	.+34     	; 0x7cf6 <Get_FIFOrestsize+0x30>
		return( FIFO_Table[ FIFO ].bufferlenght - FIFO_Table[ FIFO ].byteinbuffer );
    7cd4:	8b e0       	ldi	r24, 0x0B	; 11
    7cd6:	90 e0       	ldi	r25, 0x00	; 0
    7cd8:	28 9f       	mul	r18, r24
    7cda:	f0 01       	movw	r30, r0
    7cdc:	29 9f       	mul	r18, r25
    7cde:	f0 0d       	add	r31, r0
    7ce0:	38 9f       	mul	r19, r24
    7ce2:	f0 0d       	add	r31, r0
    7ce4:	11 24       	eor	r1, r1
    7ce6:	ea 59       	subi	r30, 0x9A	; 154
    7ce8:	f5 4f       	sbci	r31, 0xF5	; 245
    7cea:	22 81       	ldd	r18, Z+2	; 0x02
    7cec:	33 81       	ldd	r19, Z+3	; 0x03
    7cee:	80 85       	ldd	r24, Z+8	; 0x08
    7cf0:	91 85       	ldd	r25, Z+9	; 0x09
    7cf2:	28 1b       	sub	r18, r24
    7cf4:	39 0b       	sbc	r19, r25
	return( FIFO_ERROR );
}
    7cf6:	c9 01       	movw	r24, r18
    7cf8:	08 95       	ret

00007cfa <Put_Block_in_FIFO>:
 * \retval	>=0		Anzahl der kopierten Bytes.
 * \retval  -1		Fehler
 */
/*------------------------------------------------------------------------------------------------------------*/
int Put_Block_in_FIFO( int FIFO, int bufferlenght, unsigned char * buffer )
{
    7cfa:	a0 e0       	ldi	r26, 0x00	; 0
    7cfc:	b0 e0       	ldi	r27, 0x00	; 0
    7cfe:	e3 e8       	ldi	r30, 0x83	; 131
    7d00:	fe e3       	ldi	r31, 0x3E	; 62
    7d02:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    7d06:	6c 01       	movw	r12, r24
    7d08:	8b 01       	movw	r16, r22
    7d0a:	7a 01       	movw	r14, r20
	unsigned int i;
	unsigned char * bufferpointer;
	// FIFO auf g체ltigkeit testen
	if ( ( FIFO < MAX_FIFO_BUFFERS ) && ( FIFO_Table[ FIFO ].lock == UNLOCK ) )
    7d0c:	86 30       	cpi	r24, 0x06	; 6
    7d0e:	91 05       	cpc	r25, r1
    7d10:	0c f0       	brlt	.+2      	; 0x7d14 <Put_Block_in_FIFO+0x1a>
    7d12:	6d c0       	rjmp	.+218    	; 0x7dee <Put_Block_in_FIFO+0xf4>
    7d14:	8b e0       	ldi	r24, 0x0B	; 11
    7d16:	90 e0       	ldi	r25, 0x00	; 0
    7d18:	c8 9e       	mul	r12, r24
    7d1a:	e0 01       	movw	r28, r0
    7d1c:	c9 9e       	mul	r12, r25
    7d1e:	d0 0d       	add	r29, r0
    7d20:	d8 9e       	mul	r13, r24
    7d22:	d0 0d       	add	r29, r0
    7d24:	11 24       	eor	r1, r1
    7d26:	ca 59       	subi	r28, 0x9A	; 154
    7d28:	d5 4f       	sbci	r29, 0xF5	; 245
    7d2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    7d2c:	8f 3f       	cpi	r24, 0xFF	; 255
    7d2e:	09 f0       	breq	.+2      	; 0x7d32 <Put_Block_in_FIFO+0x38>
    7d30:	5e c0       	rjmp	.+188    	; 0x7dee <Put_Block_in_FIFO+0xf4>
	{
		// passen noch byte in den Puffer
		if ( ( FIFO_Table[ FIFO ].bufferlenght - FIFO_Table[ FIFO ].byteinbuffer ) >= bufferlenght)
    7d32:	be 01       	movw	r22, r28
    7d34:	6e 5f       	subi	r22, 0xFE	; 254
    7d36:	7f 4f       	sbci	r23, 0xFF	; 255
    7d38:	aa 81       	ldd	r26, Y+2	; 0x02
    7d3a:	bb 81       	ldd	r27, Y+3	; 0x03
    7d3c:	88 85       	ldd	r24, Y+8	; 0x08
    7d3e:	99 85       	ldd	r25, Y+9	; 0x09
    7d40:	fd 01       	movw	r30, r26
    7d42:	e8 1b       	sub	r30, r24
    7d44:	f9 0b       	sbc	r31, r25
    7d46:	e0 17       	cp	r30, r16
    7d48:	f1 07       	cpc	r31, r17
    7d4a:	08 f4       	brcc	.+2      	; 0x7d4e <Put_Block_in_FIFO+0x54>
    7d4c:	50 c0       	rjmp	.+160    	; 0x7dee <Put_Block_in_FIFO+0xf4>
		{
			#ifdef _fastcopy_
			// schnelle kopie des puffer wenn bereich in der fifo zuh채ngend ist
			if ( ( FIFO_Table[ FIFO ].writepointer + bufferlenght ) < FIFO_Table[ FIFO ].bufferlenght )
    7d4e:	9e 01       	movw	r18, r28
    7d50:	2c 5f       	subi	r18, 0xFC	; 252
    7d52:	3f 4f       	sbci	r19, 0xFF	; 255
    7d54:	ec 81       	ldd	r30, Y+4	; 0x04
    7d56:	fd 81       	ldd	r31, Y+5	; 0x05
    7d58:	c8 01       	movw	r24, r16
    7d5a:	8e 0f       	add	r24, r30
    7d5c:	9f 1f       	adc	r25, r31
    7d5e:	8a 17       	cp	r24, r26
    7d60:	9b 07       	cpc	r25, r27
    7d62:	28 f0       	brcs	.+10     	; 0x7d6e <Put_Block_in_FIFO+0x74>
    7d64:	40 e0       	ldi	r20, 0x00	; 0
    7d66:	50 e0       	ldi	r21, 0x00	; 0
			{			
			#endif
				for ( i = 0 ; i < bufferlenght ; i++ )
				{
					// Byte in Puffer schreiben
					FIFO_Table[ FIFO ].buffer[ FIFO_Table[ FIFO ].writepointer ] = buffer[i]; 
    7d68:	5e 01       	movw	r10, r28
    7d6a:	e9 01       	movw	r28, r18
    7d6c:	2b c0       	rjmp	.+86     	; 0x7dc4 <Put_Block_in_FIFO+0xca>
			// schnelle kopie des puffer wenn bereich in der fifo zuh채ngend ist
			if ( ( FIFO_Table[ FIFO ].writepointer + bufferlenght ) < FIFO_Table[ FIFO ].bufferlenght )
			{
				// schnelle kopie des puffer
				bufferpointer = FIFO_Table[ FIFO ].buffer + FIFO_Table[ FIFO ].writepointer ;
				memcpy( bufferpointer, buffer, bufferlenght );
    7d6e:	28 81       	ld	r18, Y
    7d70:	39 81       	ldd	r19, Y+1	; 0x01
    7d72:	2e 0f       	add	r18, r30
    7d74:	3f 1f       	adc	r19, r31
    7d76:	c9 01       	movw	r24, r18
    7d78:	ba 01       	movw	r22, r20
    7d7a:	a8 01       	movw	r20, r16
    7d7c:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
				FIFO_Table[ FIFO ].writepointer = FIFO_Table[ FIFO ].writepointer + bufferlenght;
    7d80:	8c 81       	ldd	r24, Y+4	; 0x04
    7d82:	9d 81       	ldd	r25, Y+5	; 0x05
    7d84:	80 0f       	add	r24, r16
    7d86:	91 1f       	adc	r25, r17
    7d88:	9d 83       	std	Y+5, r25	; 0x05
    7d8a:	8c 83       	std	Y+4, r24	; 0x04
    7d8c:	1e c0       	rjmp	.+60     	; 0x7dca <Put_Block_in_FIFO+0xd0>
			{			
			#endif
				for ( i = 0 ; i < bufferlenght ; i++ )
				{
					// Byte in Puffer schreiben
					FIFO_Table[ FIFO ].buffer[ FIFO_Table[ FIFO ].writepointer ] = buffer[i]; 
    7d8e:	f5 01       	movw	r30, r10
    7d90:	a0 81       	ld	r26, Z
    7d92:	b1 81       	ldd	r27, Z+1	; 0x01
    7d94:	88 81       	ld	r24, Y
    7d96:	99 81       	ldd	r25, Y+1	; 0x01
    7d98:	a8 0f       	add	r26, r24
    7d9a:	b9 1f       	adc	r27, r25
    7d9c:	f7 01       	movw	r30, r14
    7d9e:	e4 0f       	add	r30, r20
    7da0:	f5 1f       	adc	r31, r21
    7da2:	80 81       	ld	r24, Z
    7da4:	8c 93       	st	X, r24
					
					FIFO_Table[ FIFO ].writepointer++;
    7da6:	88 81       	ld	r24, Y
    7da8:	99 81       	ldd	r25, Y+1	; 0x01
    7daa:	01 96       	adiw	r24, 0x01	; 1
    7dac:	99 83       	std	Y+1, r25	; 0x01
    7dae:	88 83       	st	Y, r24
					// writepointer schon das ende erreicht ? und setzen
					if ( FIFO_Table[ FIFO ].writepointer == FIFO_Table[ FIFO ].bufferlenght )
    7db0:	fb 01       	movw	r30, r22
    7db2:	20 81       	ld	r18, Z
    7db4:	31 81       	ldd	r19, Z+1	; 0x01
    7db6:	82 17       	cp	r24, r18
    7db8:	93 07       	cpc	r25, r19
    7dba:	11 f4       	brne	.+4      	; 0x7dc0 <Put_Block_in_FIFO+0xc6>
						FIFO_Table[ FIFO ].writepointer = 0;
    7dbc:	19 82       	std	Y+1, r1	; 0x01
    7dbe:	18 82       	st	Y, r1
#endif
			}
			else
			{			
			#endif
				for ( i = 0 ; i < bufferlenght ; i++ )
    7dc0:	4f 5f       	subi	r20, 0xFF	; 255
    7dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    7dc4:	40 17       	cp	r20, r16
    7dc6:	51 07       	cpc	r21, r17
    7dc8:	10 f3       	brcs	.-60     	; 0x7d8e <Put_Block_in_FIFO+0x94>
#endif
			#ifdef _fastcopy_
			}
			#endif
			
			FIFO_Table[ FIFO ].byteinbuffer = FIFO_Table[ FIFO ].byteinbuffer + bufferlenght;
    7dca:	8b e0       	ldi	r24, 0x0B	; 11
    7dcc:	90 e0       	ldi	r25, 0x00	; 0
    7dce:	c8 9e       	mul	r12, r24
    7dd0:	f0 01       	movw	r30, r0
    7dd2:	c9 9e       	mul	r12, r25
    7dd4:	f0 0d       	add	r31, r0
    7dd6:	d8 9e       	mul	r13, r24
    7dd8:	f0 0d       	add	r31, r0
    7dda:	11 24       	eor	r1, r1
    7ddc:	ea 59       	subi	r30, 0x9A	; 154
    7dde:	f5 4f       	sbci	r31, 0xF5	; 245
    7de0:	80 85       	ldd	r24, Z+8	; 0x08
    7de2:	91 85       	ldd	r25, Z+9	; 0x09
    7de4:	80 0f       	add	r24, r16
    7de6:	91 1f       	adc	r25, r17
    7de8:	91 87       	std	Z+9, r25	; 0x09
    7dea:	80 87       	std	Z+8, r24	; 0x08
    7dec:	02 c0       	rjmp	.+4      	; 0x7df2 <Put_Block_in_FIFO+0xf8>

			return( bufferlenght );
    7dee:	0f ef       	ldi	r16, 0xFF	; 255
    7df0:	1f ef       	ldi	r17, 0xFF	; 255
		}
	}
	return( FIFO_ERROR );
}
    7df2:	c8 01       	movw	r24, r16
    7df4:	cd b7       	in	r28, 0x3d	; 61
    7df6:	de b7       	in	r29, 0x3e	; 62
    7df8:	ea e0       	ldi	r30, 0x0A	; 10
    7dfa:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

00007dfe <init>:
		LED_toggle(0);
}
#endif

void init( void )
{
    7dfe:	cf 93       	push	r28
    7e00:	df 93       	push	r29
 	// Interrupts freigeben
	sei();
    7e02:	78 94       	sei

	// RS232 starten und printf auf RS232 verbiegen
	UART_init();
    7e04:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <UART_init>

	STDOUT_INIT ();
    7e08:	0e 94 2b 38 	call	0x7056	; 0x7056 <STDOUT_INIT>
	STDOUT_set( RS232, 0);
    7e0c:	81 e0       	ldi	r24, 0x01	; 1
    7e0e:	60 e0       	ldi	r22, 0x00	; 0
    7e10:	70 e0       	ldi	r23, 0x00	; 0
    7e12:	0e 94 76 38 	call	0x70ec	; 0x70ec <STDOUT_set>
#if defined(LEDTAFEL)
	tafel_init();
#endif

//	printf_P( PSTR("%c[2J"),27 ); // Bildschirm l철schen in Terminalprogram
	printf_P( PSTR("OpenMCP ...\r\n"));
    7e16:	00 d0       	rcall	.+0      	; 0x7e18 <init+0x1a>
    7e18:	8e ef       	ldi	r24, 0xFE	; 254
    7e1a:	92 e0       	ldi	r25, 0x02	; 2
    7e1c:	ed b7       	in	r30, 0x3d	; 61
    7e1e:	fe b7       	in	r31, 0x3e	; 62
    7e20:	92 83       	std	Z+2, r25	; 0x02
    7e22:	81 83       	std	Z+1, r24	; 0x01
    7e24:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	// Uart einrichten
	printf_P( PSTR("UART"));
    7e28:	89 ef       	ldi	r24, 0xF9	; 249
    7e2a:	92 e0       	ldi	r25, 0x02	; 2
    7e2c:	ed b7       	in	r30, 0x3d	; 61
    7e2e:	fe b7       	in	r31, 0x3e	; 62
    7e30:	92 83       	std	Z+2, r25	; 0x02
    7e32:	81 83       	std	Z+1, r24	; 0x01
    7e34:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( config_ok );
    7e38:	cc ea       	ldi	r28, 0xAC	; 172
    7e3a:	d2 e0       	ldi	r29, 0x02	; 2
    7e3c:	ed b7       	in	r30, 0x3d	; 61
    7e3e:	fe b7       	in	r31, 0x3e	; 62
    7e40:	d2 83       	std	Z+2, r29	; 0x02
    7e42:	c1 83       	std	Z+1, r28	; 0x01
    7e44:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	// Standart Out einrichten
	printf_P( PSTR("STDOUT"));
    7e48:	82 ef       	ldi	r24, 0xF2	; 242
    7e4a:	92 e0       	ldi	r25, 0x02	; 2
    7e4c:	ed b7       	in	r30, 0x3d	; 61
    7e4e:	fe b7       	in	r31, 0x3e	; 62
    7e50:	92 83       	std	Z+2, r25	; 0x02
    7e52:	81 83       	std	Z+1, r24	; 0x01
    7e54:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( config_ok );
    7e58:	ed b7       	in	r30, 0x3d	; 61
    7e5a:	fe b7       	in	r31, 0x3e	; 62
    7e5c:	d2 83       	std	Z+2, r29	; 0x02
    7e5e:	c1 83       	std	Z+1, r28	; 0x01
    7e60:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	// Clock starten
	CLOCK_init();
    7e64:	0f 90       	pop	r0
    7e66:	0f 90       	pop	r0
    7e68:	0e 94 c3 1b 	call	0x3786	; 0x3786 <CLOCK_init>
	printf_P( PSTR("CLOCK"));
    7e6c:	00 d0       	rcall	.+0      	; 0x7e6e <init+0x70>
    7e6e:	8c ee       	ldi	r24, 0xEC	; 236
    7e70:	92 e0       	ldi	r25, 0x02	; 2
    7e72:	ed b7       	in	r30, 0x3d	; 61
    7e74:	fe b7       	in	r31, 0x3e	; 62
    7e76:	92 83       	std	Z+2, r25	; 0x02
    7e78:	81 83       	std	Z+1, r24	; 0x01
    7e7a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( config_ok );
    7e7e:	ed b7       	in	r30, 0x3d	; 61
    7e80:	fe b7       	in	r31, 0x3e	; 62
    7e82:	d2 83       	std	Z+2, r29	; 0x02
    7e84:	c1 83       	std	Z+1, r28	; 0x01
    7e86:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
		#endif
	#endif
#endif
	
	// Configmodul initialisieren
	Config_Init ();
    7e8a:	0f 90       	pop	r0
    7e8c:	0f 90       	pop	r0
    7e8e:	0e 94 2b 3d 	call	0x7a56	; 0x7a56 <Config_Init>
	printf_P( PSTR("Config"));
    7e92:	00 d0       	rcall	.+0      	; 0x7e94 <init+0x96>
    7e94:	85 ee       	ldi	r24, 0xE5	; 229
    7e96:	92 e0       	ldi	r25, 0x02	; 2
    7e98:	ed b7       	in	r30, 0x3d	; 61
    7e9a:	fe b7       	in	r31, 0x3e	; 62
    7e9c:	92 83       	std	Z+2, r25	; 0x02
    7e9e:	81 83       	std	Z+1, r24	; 0x01
    7ea0:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( config_ok );
    7ea4:	ed b7       	in	r30, 0x3d	; 61
    7ea6:	fe b7       	in	r31, 0x3e	; 62
    7ea8:	d2 83       	std	Z+2, r29	; 0x02
    7eaa:	c1 83       	std	Z+1, r28	; 0x01
    7eac:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	// Externe Interrupt aktivieren
#if defined(EXTINT)
	EXTINT_init();
    7eb0:	0f 90       	pop	r0
    7eb2:	0f 90       	pop	r0
    7eb4:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <EXTINT_init>
	printf_P( PSTR("EXTINT"));
    7eb8:	00 d0       	rcall	.+0      	; 0x7eba <init+0xbc>
    7eba:	8e ed       	ldi	r24, 0xDE	; 222
    7ebc:	92 e0       	ldi	r25, 0x02	; 2
    7ebe:	ed b7       	in	r30, 0x3d	; 61
    7ec0:	fe b7       	in	r31, 0x3e	; 62
    7ec2:	92 83       	std	Z+2, r25	; 0x02
    7ec4:	81 83       	std	Z+1, r24	; 0x01
    7ec6:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( config_ok );
    7eca:	ed b7       	in	r30, 0x3d	; 61
    7ecc:	fe b7       	in	r31, 0x3e	; 62
    7ece:	d2 83       	std	Z+2, r29	; 0x02
    7ed0:	c1 83       	std	Z+1, r28	; 0x01
    7ed2:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
#endif

	// PinChange Interrupt aktivieren
#if defined(PC_INT)
	PCINT_init();
    7ed6:	0f 90       	pop	r0
    7ed8:	0f 90       	pop	r0
    7eda:	0e 94 32 20 	call	0x4064	; 0x4064 <PCINT_init>
	printf_P( PSTR("PCINT"));
    7ede:	00 d0       	rcall	.+0      	; 0x7ee0 <init+0xe2>
    7ee0:	88 ed       	ldi	r24, 0xD8	; 216
    7ee2:	92 e0       	ldi	r25, 0x02	; 2
    7ee4:	ed b7       	in	r30, 0x3d	; 61
    7ee6:	fe b7       	in	r31, 0x3e	; 62
    7ee8:	92 83       	std	Z+2, r25	; 0x02
    7eea:	81 83       	std	Z+1, r24	; 0x01
    7eec:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( config_ok );
    7ef0:	ed b7       	in	r30, 0x3d	; 61
    7ef2:	fe b7       	in	r31, 0x3e	; 62
    7ef4:	d2 83       	std	Z+2, r29	; 0x02
    7ef6:	c1 83       	std	Z+1, r28	; 0x01
    7ef8:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	
	// MCC-Interface aktivieren
#if defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644__)
	#if defined(myAVR) || defined(AVRNETIO)
		#ifdef MMC
			printf_P( PSTR("MMC/SD"));
    7efc:	81 ed       	ldi	r24, 0xD1	; 209
    7efe:	92 e0       	ldi	r25, 0x02	; 2
    7f00:	ed b7       	in	r30, 0x3d	; 61
    7f02:	fe b7       	in	r31, 0x3e	; 62
    7f04:	92 83       	std	Z+2, r25	; 0x02
    7f06:	81 83       	std	Z+1, r24	; 0x01
    7f08:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
			if(!sd_raw_init())
    7f0c:	0f 90       	pop	r0
    7f0e:	0f 90       	pop	r0
    7f10:	0e 94 c6 5c 	call	0xb98c	; 0xb98c <sd_raw_init>
    7f14:	88 23       	and	r24, r24
    7f16:	a9 f0       	breq	.+42     	; 0x7f42 <init+0x144>
			{
				printf_P( config_error );
			}
			else
			{
				printf_P( config_ok );
    7f18:	00 d0       	rcall	.+0      	; 0x7f1a <init+0x11c>
    7f1a:	ed b7       	in	r30, 0x3d	; 61
    7f1c:	fe b7       	in	r31, 0x3e	; 62
    7f1e:	d2 83       	std	Z+2, r29	; 0x02
    7f20:	c1 83       	std	Z+1, r28	; 0x01
    7f22:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
				printf_P( PSTR("Filesystem"));
    7f26:	86 ec       	ldi	r24, 0xC6	; 198
    7f28:	92 e0       	ldi	r25, 0x02	; 2
    7f2a:	ed b7       	in	r30, 0x3d	; 61
    7f2c:	fe b7       	in	r31, 0x3e	; 62
    7f2e:	92 83       	std	Z+2, r25	; 0x02
    7f30:	81 83       	std	Z+1, r24	; 0x01
    7f32:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
				if ( FILE_init() != FILESYSTEM_OK )
    7f36:	0f 90       	pop	r0
    7f38:	0f 90       	pop	r0
    7f3a:	0e 94 e6 69 	call	0xd3cc	; 0xd3cc <FILE_init>
    7f3e:	89 2b       	or	r24, r25
    7f40:	41 f0       	breq	.+16     	; 0x7f52 <init+0x154>
					printf_P( config_error );
    7f42:	00 d0       	rcall	.+0      	; 0x7f44 <init+0x146>
    7f44:	8d eb       	ldi	r24, 0xBD	; 189
    7f46:	92 e0       	ldi	r25, 0x02	; 2
    7f48:	ed b7       	in	r30, 0x3d	; 61
    7f4a:	fe b7       	in	r31, 0x3e	; 62
    7f4c:	92 83       	std	Z+2, r25	; 0x02
    7f4e:	81 83       	std	Z+1, r24	; 0x01
    7f50:	05 c0       	rjmp	.+10     	; 0x7f5c <init+0x15e>
				else
					printf_P( config_ok );
    7f52:	00 d0       	rcall	.+0      	; 0x7f54 <init+0x156>
    7f54:	ed b7       	in	r30, 0x3d	; 61
    7f56:	fe b7       	in	r31, 0x3e	; 62
    7f58:	d2 83       	std	Z+2, r29	; 0x02
    7f5a:	c1 83       	std	Z+1, r28	; 0x01
    7f5c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    7f60:	0f 90       	pop	r0
    7f62:	0f 90       	pop	r0
		#endif
	#endif	
#endif

	// Threadliste init
	THREAD_init();
    7f64:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <THREAD_init>

	// Netzwerk starten
	network_init();
    7f68:	0e 94 a5 35 	call	0x6b4a	; 0x6b4a <network_init>
	
	can_init(BITRATE_125_KBPS);
    7f6c:	84 e0       	ldi	r24, 0x04	; 4
    7f6e:	0e 94 8e 56 	call	0xad1c	; 0xad1c <can_init>
}
    7f72:	df 91       	pop	r29
    7f74:	cf 91       	pop	r28
    7f76:	08 95       	ret

00007f78 <THREAD_init>:
#include "thread.h"

struct THREAD thread_table[ THREAD_MAX ];

void THREAD_init( void )
{
    7f78:	80 e0       	ldi	r24, 0x00	; 0
    7f7a:	90 e0       	ldi	r25, 0x00	; 0
	int i;

	// Alle eintr채ge auf NULL setzen
	for ( i = 0 ; i < THREAD_MAX ; i ++ )
		thread_table[ i ].thread_function = NULL;		
    7f7c:	fc 01       	movw	r30, r24
    7f7e:	ee 0f       	add	r30, r30
    7f80:	ff 1f       	adc	r31, r31
    7f82:	ee 0f       	add	r30, r30
    7f84:	ff 1f       	adc	r31, r31
    7f86:	e8 55       	subi	r30, 0x58	; 88
    7f88:	f5 4f       	sbci	r31, 0xF5	; 245
    7f8a:	11 82       	std	Z+1, r1	; 0x01
    7f8c:	10 82       	st	Z, r1
void THREAD_init( void )
{
	int i;

	// Alle eintr채ge auf NULL setzen
	for ( i = 0 ; i < THREAD_MAX ; i ++ )
    7f8e:	01 96       	adiw	r24, 0x01	; 1
    7f90:	84 31       	cpi	r24, 0x14	; 20
    7f92:	91 05       	cpc	r25, r1
    7f94:	99 f7       	brne	.-26     	; 0x7f7c <THREAD_init+0x4>
		thread_table[ i ].thread_function = NULL;		
}
    7f96:	08 95       	ret

00007f98 <THREAD_RegisterThread>:

int THREAD_RegisterThread( THREAD_CALLBACK thread_function, const prog_char * thread_name )
{
    7f98:	9c 01       	movw	r18, r24
    7f9a:	e0 e0       	ldi	r30, 0x00	; 0
    7f9c:	f0 e0       	ldi	r31, 0x00	; 0

	// In der Threadtabelle nach einen freien eintrag suchen oder ob er vorhanden ist.
	for ( i = 0 ; i < THREAD_MAX ; i++ )
	{
		// Schon vorhanden ?
		if ( thread_table[ i ].thread_function == thread_function )
    7f9e:	df 01       	movw	r26, r30
    7fa0:	aa 0f       	add	r26, r26
    7fa2:	bb 1f       	adc	r27, r27
    7fa4:	aa 0f       	add	r26, r26
    7fa6:	bb 1f       	adc	r27, r27
    7fa8:	a8 55       	subi	r26, 0x58	; 88
    7faa:	b5 4f       	sbci	r27, 0xF5	; 245
    7fac:	8d 91       	ld	r24, X+
    7fae:	9c 91       	ld	r25, X
    7fb0:	11 97       	sbiw	r26, 0x01	; 1
    7fb2:	82 17       	cp	r24, r18
    7fb4:	93 07       	cpc	r25, r19
    7fb6:	b9 f0       	breq	.+46     	; 0x7fe6 <THREAD_RegisterThread+0x4e>
			break;

		// Freier eintrag, dann eintrag setzen
		if ( thread_table[ i ].thread_function == NULL )
    7fb8:	8d 91       	ld	r24, X+
    7fba:	9c 91       	ld	r25, X
    7fbc:	11 97       	sbiw	r26, 0x01	; 1
    7fbe:	89 2b       	or	r24, r25
    7fc0:	71 f4       	brne	.+28     	; 0x7fde <THREAD_RegisterThread+0x46>
		{
			thread_table[ i ].thread_function = thread_function;			
    7fc2:	11 96       	adiw	r26, 0x01	; 1
    7fc4:	3c 93       	st	X, r19
    7fc6:	2e 93       	st	-X, r18
			thread_table[ i ].thread_name = thread_name;
    7fc8:	ee 0f       	add	r30, r30
    7fca:	ff 1f       	adc	r31, r31
    7fcc:	ee 0f       	add	r30, r30
    7fce:	ff 1f       	adc	r31, r31
    7fd0:	e6 55       	subi	r30, 0x56	; 86
    7fd2:	f5 4f       	sbci	r31, 0xF5	; 245
    7fd4:	71 83       	std	Z+1, r23	; 0x01
    7fd6:	60 83       	st	Z, r22
    7fd8:	20 e0       	ldi	r18, 0x00	; 0
    7fda:	30 e0       	ldi	r19, 0x00	; 0
    7fdc:	06 c0       	rjmp	.+12     	; 0x7fea <THREAD_RegisterThread+0x52>
	int i,retval;

	retval = -1;

	// In der Threadtabelle nach einen freien eintrag suchen oder ob er vorhanden ist.
	for ( i = 0 ; i < THREAD_MAX ; i++ )
    7fde:	31 96       	adiw	r30, 0x01	; 1
    7fe0:	e4 31       	cpi	r30, 0x14	; 20
    7fe2:	f1 05       	cpc	r31, r1
    7fe4:	e1 f6       	brne	.-72     	; 0x7f9e <THREAD_RegisterThread+0x6>
    7fe6:	2f ef       	ldi	r18, 0xFF	; 255
    7fe8:	3f ef       	ldi	r19, 0xFF	; 255
			retval = 0;
			break;
		}
	}
	return( retval );
}
    7fea:	c9 01       	movw	r24, r18
    7fec:	08 95       	ret

00007fee <THREAD_mainloop>:
void THREAD_mainloop( void )
{
	static int i=0;

	// Schon das ende der Threadliste erreicht ? dann i auf i setzen.
	if ( thread_table[ i ].thread_function == NULL )
    7fee:	e0 91 26 02 	lds	r30, 0x0226
    7ff2:	f0 91 27 02 	lds	r31, 0x0227
    7ff6:	ee 0f       	add	r30, r30
    7ff8:	ff 1f       	adc	r31, r31
    7ffa:	ee 0f       	add	r30, r30
    7ffc:	ff 1f       	adc	r31, r31
    7ffe:	e8 55       	subi	r30, 0x58	; 88
    8000:	f5 4f       	sbci	r31, 0xF5	; 245
    8002:	80 81       	ld	r24, Z
    8004:	91 81       	ldd	r25, Z+1	; 0x01
    8006:	89 2b       	or	r24, r25
    8008:	21 f4       	brne	.+8      	; 0x8012 <THREAD_mainloop+0x24>
		i = 0;
    800a:	10 92 27 02 	sts	0x0227, r1
    800e:	10 92 26 02 	sts	0x0226, r1

	// thread ausf체hren
	thread_table[i].thread_function( );
    8012:	e0 91 26 02 	lds	r30, 0x0226
    8016:	f0 91 27 02 	lds	r31, 0x0227
    801a:	ee 0f       	add	r30, r30
    801c:	ff 1f       	adc	r31, r31
    801e:	ee 0f       	add	r30, r30
    8020:	ff 1f       	adc	r31, r31
    8022:	e8 55       	subi	r30, 0x58	; 88
    8024:	f5 4f       	sbci	r31, 0xF5	; 245
    8026:	01 90       	ld	r0, Z+
    8028:	f0 81       	ld	r31, Z
    802a:	e0 2d       	mov	r30, r0
    802c:	09 95       	icall

	i++;
    802e:	80 91 26 02 	lds	r24, 0x0226
    8032:	90 91 27 02 	lds	r25, 0x0227
    8036:	01 96       	adiw	r24, 0x01	; 1
    8038:	90 93 27 02 	sts	0x0227, r25
    803c:	80 93 26 02 	sts	0x0226, r24

	return;
}
    8040:	08 95       	ret

00008042 <strtobin>:
 * \return			R체chgabewert der Funktion.
 * \retval 0		Wandlung war erfolgreich. 
 * \retval -1		Wandlung war nicht erfolgreich. 
 */
char strtobin( char * str, unsigned char * bin, int lenght )
{
    8042:	a0 e0       	ldi	r26, 0x00	; 0
    8044:	b0 e0       	ldi	r27, 0x00	; 0
    8046:	e7 e2       	ldi	r30, 0x27	; 39
    8048:	f0 e4       	ldi	r31, 0x40	; 64
    804a:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    804e:	7c 01       	movw	r14, r24
    8050:	6b 01       	movw	r12, r22
    8052:	8a 01       	movw	r16, r20
  
	i=0;
	
	while (*str)
	{
		if ( i >= (lenght * 2) ) return( -1 );
    8054:	00 0f       	add	r16, r16
    8056:	11 1f       	adc	r17, r17
    8058:	c0 e0       	ldi	r28, 0x00	; 0
    805a:	d0 e0       	ldi	r29, 0x00	; 0
    805c:	47 c0       	rjmp	.+142    	; 0x80ec <strtobin+0xaa>
    805e:	c0 17       	cp	r28, r16
    8060:	d1 07       	cpc	r29, r17
    8062:	0c f0       	brlt	.+2      	; 0x8066 <strtobin+0x24>
    8064:	4d c0       	rjmp	.+154    	; 0x8100 <strtobin+0xbe>
    8066:	32 2f       	mov	r19, r18
    8068:	30 53       	subi	r19, 0x30	; 48
  
        if ( (i%2) == 0 )
    806a:	c0 fd       	sbrc	r28, 0
    806c:	19 c0       	rjmp	.+50     	; 0x80a0 <strtobin+0x5e>
 */
char atoh( char Digit )
{
	char zeichen;
	
    if ( Digit >= '0' && Digit <= '9')
    806e:	83 2f       	mov	r24, r19
    8070:	3a 30       	cpi	r19, 0x0A	; 10
    8072:	68 f0       	brcs	.+26     	; 0x808e <strtobin+0x4c>
		zeichen = ( Digit - '0' );
    else if ( Digit >= 'a' && Digit <= 'f')
    8074:	81 53       	subi	r24, 0x31	; 49
    8076:	86 30       	cpi	r24, 0x06	; 6
    8078:	10 f4       	brcc	.+4      	; 0x807e <strtobin+0x3c>
        zeichen = ( Digit - 'a') + 10;
    807a:	86 5f       	subi	r24, 0xF6	; 246
    807c:	08 c0       	rjmp	.+16     	; 0x808e <strtobin+0x4c>
    else if (Digit >= 'A' && Digit <= 'F')
    807e:	82 2f       	mov	r24, r18
    8080:	81 54       	subi	r24, 0x41	; 65
    8082:	86 30       	cpi	r24, 0x06	; 6
    8084:	10 f0       	brcs	.+4      	; 0x808a <strtobin+0x48>
    8086:	8f ef       	ldi	r24, 0xFF	; 255
    8088:	02 c0       	rjmp	.+4      	; 0x808e <strtobin+0x4c>
        zeichen = ( Digit - 'A' ) + 10;
    808a:	82 2f       	mov	r24, r18
    808c:	87 53       	subi	r24, 0x37	; 55
	{
		if ( i >= (lenght * 2) ) return( -1 );
  
        if ( (i%2) == 0 )
		{
    		bin[ i/2 ] = atoh( *str ) << 4;
    808e:	fe 01       	movw	r30, r28
    8090:	f5 95       	asr	r31
    8092:	e7 95       	ror	r30
    8094:	ec 0d       	add	r30, r12
    8096:	fd 1d       	adc	r31, r13
    8098:	82 95       	swap	r24
    809a:	80 7f       	andi	r24, 0xF0	; 240
    809c:	80 83       	st	Z, r24
    809e:	1c c0       	rjmp	.+56     	; 0x80d8 <strtobin+0x96>
        }
		else
		{
    		bin[ i/2 ] += atoh( *str );
    80a0:	ce 01       	movw	r24, r28
    80a2:	62 e0       	ldi	r22, 0x02	; 2
    80a4:	70 e0       	ldi	r23, 0x00	; 0
    80a6:	0e 94 69 6a 	call	0xd4d2	; 0xd4d2 <__divmodhi4>
    80aa:	fb 01       	movw	r30, r22
    80ac:	ec 0d       	add	r30, r12
    80ae:	fd 1d       	adc	r31, r13
    80b0:	90 81       	ld	r25, Z
 */
char atoh( char Digit )
{
	char zeichen;
	
    if ( Digit >= '0' && Digit <= '9')
    80b2:	83 2f       	mov	r24, r19
    80b4:	3a 30       	cpi	r19, 0x0A	; 10
    80b6:	70 f0       	brcs	.+28     	; 0x80d4 <strtobin+0x92>
		zeichen = ( Digit - '0' );
    else if ( Digit >= 'a' && Digit <= 'f')
    80b8:	82 2f       	mov	r24, r18
    80ba:	81 56       	subi	r24, 0x61	; 97
    80bc:	86 30       	cpi	r24, 0x06	; 6
    80be:	10 f4       	brcc	.+4      	; 0x80c4 <strtobin+0x82>
        zeichen = ( Digit - 'a') + 10;
    80c0:	86 5f       	subi	r24, 0xF6	; 246
    80c2:	08 c0       	rjmp	.+16     	; 0x80d4 <strtobin+0x92>
    else if (Digit >= 'A' && Digit <= 'F')
    80c4:	82 2f       	mov	r24, r18
    80c6:	81 54       	subi	r24, 0x41	; 65
    80c8:	86 30       	cpi	r24, 0x06	; 6
    80ca:	10 f0       	brcs	.+4      	; 0x80d0 <strtobin+0x8e>
    80cc:	8f ef       	ldi	r24, 0xFF	; 255
    80ce:	02 c0       	rjmp	.+4      	; 0x80d4 <strtobin+0x92>
        zeichen = ( Digit - 'A' ) + 10;
    80d0:	82 2f       	mov	r24, r18
    80d2:	87 53       	subi	r24, 0x37	; 55
		{
    		bin[ i/2 ] = atoh( *str ) << 4;
        }
		else
		{
    		bin[ i/2 ] += atoh( *str );
    80d4:	98 0f       	add	r25, r24
    80d6:	90 83       	st	Z, r25
   		i++;
  
        do
		{ 
			// skip junk
    		str++;
    80d8:	08 94       	sec
    80da:	e1 1c       	adc	r14, r1
    80dc:	f1 1c       	adc	r15, r1
        } while ( *str == ':' || *str == '-' ) ;
    80de:	f7 01       	movw	r30, r14
    80e0:	80 81       	ld	r24, Z
    80e2:	8a 33       	cpi	r24, 0x3A	; 58
    80e4:	c9 f3       	breq	.-14     	; 0x80d8 <strtobin+0x96>
    80e6:	8d 32       	cpi	r24, 0x2D	; 45
    80e8:	b9 f3       	breq	.-18     	; 0x80d8 <strtobin+0x96>
        }
		else
		{
    		bin[ i/2 ] += atoh( *str );
        }
   		i++;
    80ea:	21 96       	adiw	r28, 0x01	; 1
{
	int i,c;
  
	i=0;
	
	while (*str)
    80ec:	f7 01       	movw	r30, r14
    80ee:	20 81       	ld	r18, Z
    80f0:	22 23       	and	r18, r18
    80f2:	09 f0       	breq	.+2      	; 0x80f6 <strtobin+0xb4>
    80f4:	b4 cf       	rjmp	.-152    	; 0x805e <strtobin+0x1c>
			// skip junk
    		str++;
        } while ( *str == ':' || *str == '-' ) ;
	}
  
	if ( i!=(lenght*2) ) return( -1 );
    80f6:	c0 17       	cp	r28, r16
    80f8:	d1 07       	cpc	r29, r17
    80fa:	11 f4       	brne	.+4      	; 0x8100 <strtobin+0xbe>
    80fc:	80 e0       	ldi	r24, 0x00	; 0
    80fe:	01 c0       	rjmp	.+2      	; 0x8102 <strtobin+0xc0>
    8100:	8f ef       	ldi	r24, 0xFF	; 255
	return( 0 );
}
    8102:	cd b7       	in	r28, 0x3d	; 61
    8104:	de b7       	in	r29, 0x3e	; 62
    8106:	e8 e0       	ldi	r30, 0x08	; 8
    8108:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000810c <nano_DB_getfilename>:
 * \param 	FULLNAME			Der vollst채ndige Pfad.
 * \returns	Pointer auf den Filename.
 */
/*------------------------------------------------------------------------------------------------------------*/
char * nano_DB_getfilename( char * FULLNAME )
{
    810c:	9c 01       	movw	r18, r24
	char * filename;

	filename = FULLNAME + strlen( FULLNAME );
    810e:	dc 01       	movw	r26, r24
    8110:	0d 90       	ld	r0, X+
    8112:	00 20       	and	r0, r0
    8114:	e9 f7       	brne	.-6      	; 0x8110 <nano_DB_getfilename+0x4>
    8116:	11 97       	sbiw	r26, 0x01	; 1
    8118:	a8 1b       	sub	r26, r24
    811a:	b9 0b       	sbc	r27, r25
    811c:	a8 0f       	add	r26, r24
    811e:	b9 1f       	adc	r27, r25
    8120:	06 c0       	rjmp	.+12     	; 0x812e <nano_DB_getfilename+0x22>

	while( filename != FULLNAME )
	{
		if ( * filename == '/' )
    8122:	8c 91       	ld	r24, X
    8124:	8f 32       	cpi	r24, 0x2F	; 47
    8126:	11 f4       	brne	.+4      	; 0x812c <nano_DB_getfilename+0x20>
		{
			*filename = '\0';
    8128:	1d 92       	st	X+, r1
    812a:	04 c0       	rjmp	.+8      	; 0x8134 <nano_DB_getfilename+0x28>
			filename++;
			break;
		}
		filename--;
    812c:	11 97       	sbiw	r26, 0x01	; 1
{
	char * filename;

	filename = FULLNAME + strlen( FULLNAME );

	while( filename != FULLNAME )
    812e:	a2 17       	cp	r26, r18
    8130:	b3 07       	cpc	r27, r19
    8132:	b9 f7       	brne	.-18     	; 0x8122 <nano_DB_getfilename+0x16>
			break;
		}
		filename--;
	}
	return( filename );
}
    8134:	cd 01       	movw	r24, r26
    8136:	08 95       	ret

00008138 <nano_DB_getnumbersofDB>:
 * \param	DBlenght			Gr철e des Datensatzes in Bytes.
 * \returns	nanoDB_ERROR if failed, or > 0.
 */
/*------------------------------------------------------------------------------------------------------------*/
int nano_DB_getnumbersofDB( char * FULLNAME, int DBlenght )
{
    8138:	a6 e5       	ldi	r26, 0x56	; 86
    813a:	b0 e0       	ldi	r27, 0x00	; 0
    813c:	e2 ea       	ldi	r30, 0xA2	; 162
    813e:	f0 e4       	ldi	r31, 0x40	; 64
    8140:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    8144:	8c 01       	movw	r16, r24
    8146:	5b 01       	movw	r10, r22
	// returncode auf Fehler setzen
	int returncode = nanoDB_ERROR;
	
	// FULLNAME in Verzeichnissname und Dateiname zerlegen
	directoryname = FULLNAME;
	filename = nano_DB_getfilename( FULLNAME );
    8148:	0e 94 86 40 	call	0x810c	; 0x810c <nano_DB_getfilename>
    814c:	6c 01       	movw	r12, r24

	// Wenn FULLNAME gleich filename, denn Verzeichniss setzen
	if ( FULLNAME == filename )
    814e:	08 17       	cp	r16, r24
    8150:	19 07       	cpc	r17, r25
    8152:	19 f4       	brne	.+6      	; 0x815a <nano_DB_getnumbersofDB+0x22>
    8154:	67 e6       	ldi	r22, 0x67	; 103
    8156:	71 e0       	ldi	r23, 0x01	; 1
    8158:	01 c0       	rjmp	.+2      	; 0x815c <nano_DB_getnumbersofDB+0x24>
    815a:	b8 01       	movw	r22, r16
		directoryname = root ;

	// in Verzeichniss springen
	fat_get_dir_entry_of_path(fs, directoryname , &directory);
    815c:	80 91 ed 0b 	lds	r24, 0x0BED
    8160:	90 91 ee 0b 	lds	r25, 0x0BEE
    8164:	8e 01       	movw	r16, r28
    8166:	0f 5f       	subi	r16, 0xFF	; 255
    8168:	1f 4f       	sbci	r17, 0xFF	; 255
    816a:	a8 01       	movw	r20, r16
    816c:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>

	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
    8170:	80 91 ed 0b 	lds	r24, 0x0BED
    8174:	90 91 ee 0b 	lds	r25, 0x0BEE
    8178:	b8 01       	movw	r22, r16
    817a:	0e 94 c0 66 	call	0xcd80	; 0xcd80 <fat_open_dir>
    817e:	7c 01       	movw	r14, r24
	if(dd)
    8180:	00 97       	sbiw	r24, 0x00	; 0
    8182:	19 f1       	breq	.+70     	; 0x81ca <nano_DB_getnumbersofDB+0x92>
    8184:	19 c0       	rjmp	.+50     	; 0x81b8 <nano_DB_getnumbersofDB+0x80>
	{
		// Verzeichnissinhalt lesen und Datei suchen
		while(fat_read_dir(dd, &dir_entry))
	    {
			// Wenn Datei gefunden, filesize holen und als returncode setzen
	        if(strcmp( dir_entry.long_name, filename ) == 0)
    8186:	c8 01       	movw	r24, r16
    8188:	b6 01       	movw	r22, r12
    818a:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    818e:	00 97       	sbiw	r24, 0x00	; 0
    8190:	b1 f4       	brne	.+44     	; 0x81be <nano_DB_getnumbersofDB+0x86>
	        {
				returncode = dir_entry.file_size / DBlenght ;
    8192:	95 01       	movw	r18, r10
    8194:	44 27       	eor	r20, r20
    8196:	37 fd       	sbrc	r19, 7
    8198:	40 95       	com	r20
    819a:	54 2f       	mov	r21, r20
    819c:	fe 01       	movw	r30, r28
    819e:	e1 5b       	subi	r30, 0xB1	; 177
    81a0:	ff 4f       	sbci	r31, 0xFF	; 255
    81a2:	60 81       	ld	r22, Z
    81a4:	71 81       	ldd	r23, Z+1	; 0x01
    81a6:	82 81       	ldd	r24, Z+2	; 0x02
    81a8:	93 81       	ldd	r25, Z+3	; 0x03
    81aa:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    81ae:	89 01       	movw	r16, r18
	            fat_reset_dir(dd);					
    81b0:	c7 01       	movw	r24, r14
    81b2:	0e 94 bb 5f 	call	0xbf76	; 0xbf76 <fat_reset_dir>
    81b6:	0b c0       	rjmp	.+22     	; 0x81ce <nano_DB_getnumbersofDB+0x96>
	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
	if(dd)
	{
		// Verzeichnissinhalt lesen und Datei suchen
		while(fat_read_dir(dd, &dir_entry))
    81b8:	8e 01       	movw	r16, r28
    81ba:	04 5d       	subi	r16, 0xD4	; 212
    81bc:	1f 4f       	sbci	r17, 0xFF	; 255
    81be:	c7 01       	movw	r24, r14
    81c0:	b8 01       	movw	r22, r16
    81c2:	0e 94 db 60 	call	0xc1b6	; 0xc1b6 <fat_read_dir>
    81c6:	88 23       	and	r24, r24
    81c8:	f1 f6       	brne	.-68     	; 0x8186 <nano_DB_getnumbersofDB+0x4e>
    81ca:	0f ef       	ldi	r16, 0xFF	; 255
    81cc:	1f ef       	ldi	r17, 0xFF	; 255
	            break;
	        }
		}
	}
	// verzeichniss schlieen
	fat_close_dir ( dd );
    81ce:	c7 01       	movw	r24, r14
    81d0:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>

	return( returncode );
}
    81d4:	c8 01       	movw	r24, r16
    81d6:	ca 5a       	subi	r28, 0xAA	; 170
    81d8:	df 4f       	sbci	r29, 0xFF	; 255
    81da:	ea e0       	ldi	r30, 0x0A	; 10
    81dc:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

000081e0 <nano_DB_readDBentry>:
 * \param	DBlenght			Gr철e des Datensatzes in Bytes.
 * \returns	nanoDB_ERROR if failed, nanoDB_OK ist success
 */
/*------------------------------------------------------------------------------------------------------------*/
int nano_DB_readDBentry( char * FULLNAME, long DBentryNumber, void * DB, int DBlenght )
{
    81e0:	ac e5       	ldi	r26, 0x5C	; 92
    81e2:	b0 e0       	ldi	r27, 0x00	; 0
    81e4:	e6 ef       	ldi	r30, 0xF6	; 246
    81e6:	f0 e4       	ldi	r31, 0x40	; 64
    81e8:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    81ec:	7c 01       	movw	r14, r24
    81ee:	1a 01       	movw	r2, r20
    81f0:	2b 01       	movw	r4, r22
    81f2:	6d 96       	adiw	r28, 0x1d	; 29
    81f4:	3f af       	std	Y+63, r19	; 0x3f
    81f6:	2e af       	std	Y+62, r18	; 0x3e
    81f8:	6d 97       	sbiw	r28, 0x1d	; 29
    81fa:	38 01       	movw	r6, r16
	long filesize=-1;

	// returncode auf Fehler setzen
	int returncode = nanoDB_ERROR;

	if ( DBentryNumber >= nano_DB_getnumbersofDB( FULLNAME, DBlenght ) )
    81fc:	b8 01       	movw	r22, r16
    81fe:	0e 94 9c 40 	call	0x8138	; 0x8138 <nano_DB_getnumbersofDB>
    8202:	aa 27       	eor	r26, r26
    8204:	97 fd       	sbrc	r25, 7
    8206:	a0 95       	com	r26
    8208:	ba 2f       	mov	r27, r26
    820a:	28 16       	cp	r2, r24
    820c:	39 06       	cpc	r3, r25
    820e:	4a 06       	cpc	r4, r26
    8210:	5b 06       	cpc	r5, r27
    8212:	1c f0       	brlt	.+6      	; 0x821a <nano_DB_readDBentry+0x3a>
    8214:	0f ef       	ldi	r16, 0xFF	; 255
    8216:	1f ef       	ldi	r17, 0xFF	; 255
    8218:	8c c0       	rjmp	.+280    	; 0x8332 <nano_DB_readDBentry+0x152>
		return( returncode );

	// FULLNAME in Verzeichnissname und Dateiname zerlegen
	directoryname = FULLNAME;
	filename = nano_DB_getfilename( FULLNAME );
    821a:	c7 01       	movw	r24, r14
    821c:	0e 94 86 40 	call	0x810c	; 0x810c <nano_DB_getfilename>
    8220:	6c 01       	movw	r12, r24

	// Wenn FULLNAME gleich filename, denn Verzeichniss setzen
	if ( FULLNAME == filename )
    8222:	e8 16       	cp	r14, r24
    8224:	f9 06       	cpc	r15, r25
    8226:	19 f4       	brne	.+6      	; 0x822e <nano_DB_readDBentry+0x4e>
    8228:	67 e6       	ldi	r22, 0x67	; 103
    822a:	71 e0       	ldi	r23, 0x01	; 1
    822c:	01 c0       	rjmp	.+2      	; 0x8230 <nano_DB_readDBentry+0x50>
    822e:	b7 01       	movw	r22, r14
		directoryname = root ;

	// in Verzeichniss springen
	fat_get_dir_entry_of_path(fs, directoryname , &directory);
    8230:	8e 01       	movw	r16, r28
    8232:	0b 5f       	subi	r16, 0xFB	; 251
    8234:	1f 4f       	sbci	r17, 0xFF	; 255
    8236:	80 91 ed 0b 	lds	r24, 0x0BED
    823a:	90 91 ee 0b 	lds	r25, 0x0BEE
    823e:	a8 01       	movw	r20, r16
    8240:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>

	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
    8244:	80 91 ed 0b 	lds	r24, 0x0BED
    8248:	90 91 ee 0b 	lds	r25, 0x0BEE
    824c:	b8 01       	movw	r22, r16
    824e:	0e 94 c0 66 	call	0xcd80	; 0xcd80 <fat_open_dir>
    8252:	4c 01       	movw	r8, r24
	if(dd)
    8254:	00 97       	sbiw	r24, 0x00	; 0
    8256:	91 f4       	brne	.+36     	; 0x827c <nano_DB_readDBentry+0x9c>
    8258:	67 c0       	rjmp	.+206    	; 0x8328 <nano_DB_readDBentry+0x148>
	{
		// Verzeichniss inhalt lesen und Datei suchen
		while(fat_read_dir(dd, &dir_entry))
	    {
	        if(strcmp( dir_entry.long_name, filename ) == 0)
    825a:	c8 01       	movw	r24, r16
    825c:	b6 01       	movw	r22, r12
    825e:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    8262:	00 97       	sbiw	r24, 0x00	; 0
    8264:	71 f4       	brne	.+28     	; 0x8282 <nano_DB_readDBentry+0xa2>
	        {
				filesize = dir_entry.file_size;
    8266:	fe 01       	movw	r30, r28
    8268:	ed 5a       	subi	r30, 0xAD	; 173
    826a:	ff 4f       	sbci	r31, 0xFF	; 255
    826c:	e0 80       	ld	r14, Z
    826e:	f1 80       	ldd	r15, Z+1	; 0x01
    8270:	02 81       	ldd	r16, Z+2	; 0x02
    8272:	13 81       	ldd	r17, Z+3	; 0x03
	            fat_reset_dir(dd);					
    8274:	c4 01       	movw	r24, r8
    8276:	0e 94 bb 5f 	call	0xbf76	; 0xbf76 <fat_reset_dir>
    827a:	0d c0       	rjmp	.+26     	; 0x8296 <nano_DB_readDBentry+0xb6>
	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
	if(dd)
	{
		// Verzeichniss inhalt lesen und Datei suchen
		while(fat_read_dir(dd, &dir_entry))
    827c:	8e 01       	movw	r16, r28
    827e:	00 5d       	subi	r16, 0xD0	; 208
    8280:	1f 4f       	sbci	r17, 0xFF	; 255
    8282:	c4 01       	movw	r24, r8
    8284:	b8 01       	movw	r22, r16
    8286:	0e 94 db 60 	call	0xc1b6	; 0xc1b6 <fat_read_dir>
    828a:	88 23       	and	r24, r24
    828c:	31 f7       	brne	.-52     	; 0x825a <nano_DB_readDBentry+0x7a>
    828e:	ee 24       	eor	r14, r14
    8290:	ea 94       	dec	r14
    8292:	fe 2c       	mov	r15, r14
    8294:	87 01       	movw	r16, r14
	            fat_reset_dir(dd);					
	            break;
	        }
		}

		if ( ( filesize % DBlenght ) == 0 )
    8296:	53 01       	movw	r10, r6
    8298:	cc 24       	eor	r12, r12
    829a:	b7 fc       	sbrc	r11, 7
    829c:	c0 94       	com	r12
    829e:	dc 2c       	mov	r13, r12
    82a0:	c8 01       	movw	r24, r16
    82a2:	b7 01       	movw	r22, r14
    82a4:	a6 01       	movw	r20, r12
    82a6:	95 01       	movw	r18, r10
    82a8:	0e 94 9e 6a 	call	0xd53c	; 0xd53c <__divmodsi4>
    82ac:	61 15       	cp	r22, r1
    82ae:	71 05       	cpc	r23, r1
    82b0:	81 05       	cpc	r24, r1
    82b2:	91 05       	cpc	r25, r1
    82b4:	c9 f5       	brne	.+114    	; 0x8328 <nano_DB_readDBentry+0x148>
		{
			struct fat_file_struct* fd = fat_open_file(fs, &dir_entry);
    82b6:	80 91 ed 0b 	lds	r24, 0x0BED
    82ba:	90 91 ee 0b 	lds	r25, 0x0BEE
    82be:	be 01       	movw	r22, r28
    82c0:	60 5d       	subi	r22, 0xD0	; 208
    82c2:	7f 4f       	sbci	r23, 0xFF	; 255
    82c4:	0e 94 f4 66 	call	0xcde8	; 0xcde8 <fat_open_file>
    82c8:	7c 01       	movw	r14, r24
			if ( fd )
    82ca:	00 97       	sbiw	r24, 0x00	; 0
    82cc:	69 f1       	breq	.+90     	; 0x8328 <nano_DB_readDBentry+0x148>
			{
				long offset;
				offset = DBentryNumber * DBlenght ;
    82ce:	c6 01       	movw	r24, r12
    82d0:	b5 01       	movw	r22, r10
    82d2:	a2 01       	movw	r20, r4
    82d4:	91 01       	movw	r18, r2
    82d6:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    82da:	69 83       	std	Y+1, r22	; 0x01
    82dc:	7a 83       	std	Y+2, r23	; 0x02
    82de:	8b 83       	std	Y+3, r24	; 0x03
    82e0:	9c 83       	std	Y+4, r25	; 0x04

				if(fat_seek_file(fd, &offset , FAT_SEEK_SET))
    82e2:	c7 01       	movw	r24, r14
    82e4:	be 01       	movw	r22, r28
    82e6:	6f 5f       	subi	r22, 0xFF	; 255
    82e8:	7f 4f       	sbci	r23, 0xFF	; 255
    82ea:	40 e0       	ldi	r20, 0x00	; 0
    82ec:	0e 94 09 65 	call	0xca12	; 0xca12 <fat_seek_file>
    82f0:	88 23       	and	r24, r24
    82f2:	a1 f0       	breq	.+40     	; 0x831c <nano_DB_readDBentry+0x13c>
				{
	                if( !fat_read_file(fd, (uint8_t*) DB, DBlenght ) != DBlenght )
    82f4:	c7 01       	movw	r24, r14
    82f6:	6d 96       	adiw	r28, 0x1d	; 29
    82f8:	6e ad       	ldd	r22, Y+62	; 0x3e
    82fa:	7f ad       	ldd	r23, Y+63	; 0x3f
    82fc:	6d 97       	sbiw	r28, 0x1d	; 29
    82fe:	a3 01       	movw	r20, r6
    8300:	0e 94 9a 5e 	call	0xbd34	; 0xbd34 <fat_read_file>
    8304:	20 e0       	ldi	r18, 0x00	; 0
    8306:	30 e0       	ldi	r19, 0x00	; 0
    8308:	89 2b       	or	r24, r25
    830a:	11 f4       	brne	.+4      	; 0x8310 <nano_DB_readDBentry+0x130>
    830c:	21 e0       	ldi	r18, 0x01	; 1
    830e:	30 e0       	ldi	r19, 0x00	; 0
    8310:	26 15       	cp	r18, r6
    8312:	37 05       	cpc	r19, r7
    8314:	19 f0       	breq	.+6      	; 0x831c <nano_DB_readDBentry+0x13c>
    8316:	00 e0       	ldi	r16, 0x00	; 0
    8318:	10 e0       	ldi	r17, 0x00	; 0
    831a:	02 c0       	rjmp	.+4      	; 0x8320 <nano_DB_readDBentry+0x140>
    831c:	0f ef       	ldi	r16, 0xFF	; 255
    831e:	1f ef       	ldi	r17, 0xFF	; 255
//					else
//						printf_P( PSTR("Kann Datei \"%s\" nicht lesen!\r\n"),filename);
				}
//				else
//					printf_P( PSTR("Fehler beim seeken!\r\n"));
                fat_close_file( fd );				
    8320:	c7 01       	movw	r24, r14
    8322:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <fat_close_file>
    8326:	02 c0       	rjmp	.+4      	; 0x832c <nano_DB_readDBentry+0x14c>
    8328:	0f ef       	ldi	r16, 0xFF	; 255
    832a:	1f ef       	ldi	r17, 0xFF	; 255
//			printf_P( PSTR("Datei \"%s\" kann nicht gefunden werden oder ist korrupt!\r\n"), filename );
	}
//	else
//		printf_P( PSTR("Verzeichniss \"%s\" kann nicht ge철ffnet werden!\r\n"), directoryname);

	fat_close_dir ( dd );
    832c:	c4 01       	movw	r24, r8
    832e:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>

	return( returncode );
}
    8332:	c8 01       	movw	r24, r16
    8334:	c4 5a       	subi	r28, 0xA4	; 164
    8336:	df 4f       	sbci	r29, 0xFF	; 255
    8338:	e2 e1       	ldi	r30, 0x12	; 18
    833a:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000833e <nano_DB_writeDBentry>:
 * \param	DBlenght			Gr철e des Datensatzes in Bytes.
 * \returns	nanoDB_ERROR if failed, nanoDB_OK ist success
 */
/*------------------------------------------------------------------------------------------------------------*/
int nano_DB_writeDBentry( char * FULLNAME, long DBentryNumber, void * DB, int DBlenght )
{
    833e:	ae e5       	ldi	r26, 0x5E	; 94
    8340:	b0 e0       	ldi	r27, 0x00	; 0
    8342:	e5 ea       	ldi	r30, 0xA5	; 165
    8344:	f1 e4       	ldi	r31, 0x41	; 65
    8346:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    834a:	7c 01       	movw	r14, r24
    834c:	6f 96       	adiw	r28, 0x1f	; 31
    834e:	4c af       	std	Y+60, r20	; 0x3c
    8350:	5d af       	std	Y+61, r21	; 0x3d
    8352:	6e af       	std	Y+62, r22	; 0x3e
    8354:	7f af       	std	Y+63, r23	; 0x3f
    8356:	6f 97       	sbiw	r28, 0x1f	; 31
    8358:	19 01       	movw	r2, r18
    835a:	28 01       	movw	r4, r16
	char * filename;
	long filesize=-1;
	
	int returncode = nanoDB_ERROR;

	if ( DBentryNumber > nano_DB_getnumbersofDB( FULLNAME, DBlenght ) )
    835c:	b8 01       	movw	r22, r16
    835e:	0e 94 9c 40 	call	0x8138	; 0x8138 <nano_DB_getnumbersofDB>
    8362:	aa 27       	eor	r26, r26
    8364:	97 fd       	sbrc	r25, 7
    8366:	a0 95       	com	r26
    8368:	ba 2f       	mov	r27, r26
    836a:	6f 96       	adiw	r28, 0x1f	; 31
    836c:	2c ad       	ldd	r18, Y+60	; 0x3c
    836e:	3d ad       	ldd	r19, Y+61	; 0x3d
    8370:	4e ad       	ldd	r20, Y+62	; 0x3e
    8372:	5f ad       	ldd	r21, Y+63	; 0x3f
    8374:	6f 97       	sbiw	r28, 0x1f	; 31
    8376:	82 17       	cp	r24, r18
    8378:	93 07       	cpc	r25, r19
    837a:	a4 07       	cpc	r26, r20
    837c:	b5 07       	cpc	r27, r21
    837e:	1c f4       	brge	.+6      	; 0x8386 <nano_DB_writeDBentry+0x48>
    8380:	0f ef       	ldi	r16, 0xFF	; 255
    8382:	1f ef       	ldi	r17, 0xFF	; 255
    8384:	99 c0       	rjmp	.+306    	; 0x84b8 <nano_DB_writeDBentry+0x17a>
		return( returncode );

	directoryname = FULLNAME;
	filename = nano_DB_getfilename( FULLNAME );
    8386:	c7 01       	movw	r24, r14
    8388:	0e 94 86 40 	call	0x810c	; 0x810c <nano_DB_getfilename>
    838c:	6c 01       	movw	r12, r24

	if ( FULLNAME == filename )
    838e:	e8 16       	cp	r14, r24
    8390:	f9 06       	cpc	r15, r25
    8392:	19 f4       	brne	.+6      	; 0x839a <nano_DB_writeDBentry+0x5c>
    8394:	67 e6       	ldi	r22, 0x67	; 103
    8396:	71 e0       	ldi	r23, 0x01	; 1
    8398:	01 c0       	rjmp	.+2      	; 0x839c <nano_DB_writeDBentry+0x5e>
    839a:	b7 01       	movw	r22, r14
		directoryname = root ;
	
	fat_get_dir_entry_of_path(fs, directoryname , &directory);
    839c:	8e 01       	movw	r16, r28
    839e:	0b 5f       	subi	r16, 0xFB	; 251
    83a0:	1f 4f       	sbci	r17, 0xFF	; 255
    83a2:	80 91 ed 0b 	lds	r24, 0x0BED
    83a6:	90 91 ee 0b 	lds	r25, 0x0BEE
    83aa:	a8 01       	movw	r20, r16
    83ac:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>

	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
    83b0:	80 91 ed 0b 	lds	r24, 0x0BED
    83b4:	90 91 ee 0b 	lds	r25, 0x0BEE
    83b8:	b8 01       	movw	r22, r16
    83ba:	0e 94 c0 66 	call	0xcd80	; 0xcd80 <fat_open_dir>
    83be:	3c 01       	movw	r6, r24
	if(dd)
    83c0:	00 97       	sbiw	r24, 0x00	; 0
    83c2:	91 f4       	brne	.+36     	; 0x83e8 <nano_DB_writeDBentry+0xaa>
    83c4:	74 c0       	rjmp	.+232    	; 0x84ae <nano_DB_writeDBentry+0x170>
	{
		// Verzeichniss inhalt lesen und Datei suchen
		while(fat_read_dir(dd, &dir_entry))
	    {
	        if(strcmp( dir_entry.long_name, filename ) == 0)
    83c6:	c8 01       	movw	r24, r16
    83c8:	b6 01       	movw	r22, r12
    83ca:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    83ce:	00 97       	sbiw	r24, 0x00	; 0
    83d0:	71 f4       	brne	.+28     	; 0x83ee <nano_DB_writeDBentry+0xb0>
	        {
				filesize = dir_entry.file_size;
    83d2:	fe 01       	movw	r30, r28
    83d4:	ed 5a       	subi	r30, 0xAD	; 173
    83d6:	ff 4f       	sbci	r31, 0xFF	; 255
    83d8:	e0 80       	ld	r14, Z
    83da:	f1 80       	ldd	r15, Z+1	; 0x01
    83dc:	02 81       	ldd	r16, Z+2	; 0x02
    83de:	13 81       	ldd	r17, Z+3	; 0x03
	            fat_reset_dir(dd);					
    83e0:	c3 01       	movw	r24, r6
    83e2:	0e 94 bb 5f 	call	0xbf76	; 0xbf76 <fat_reset_dir>
    83e6:	0d c0       	rjmp	.+26     	; 0x8402 <nano_DB_writeDBentry+0xc4>
	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
	if(dd)
	{
		// Verzeichniss inhalt lesen und Datei suchen
		while(fat_read_dir(dd, &dir_entry))
    83e8:	8e 01       	movw	r16, r28
    83ea:	00 5d       	subi	r16, 0xD0	; 208
    83ec:	1f 4f       	sbci	r17, 0xFF	; 255
    83ee:	c3 01       	movw	r24, r6
    83f0:	b8 01       	movw	r22, r16
    83f2:	0e 94 db 60 	call	0xc1b6	; 0xc1b6 <fat_read_dir>
    83f6:	88 23       	and	r24, r24
    83f8:	31 f7       	brne	.-52     	; 0x83c6 <nano_DB_writeDBentry+0x88>
    83fa:	ee 24       	eor	r14, r14
    83fc:	ea 94       	dec	r14
    83fe:	fe 2c       	mov	r15, r14
    8400:	87 01       	movw	r16, r14
	            fat_reset_dir(dd);					
	            break;
	        }
		}

		if ( ( filesize % DBlenght ) == 0 )
    8402:	52 01       	movw	r10, r4
    8404:	cc 24       	eor	r12, r12
    8406:	b7 fc       	sbrc	r11, 7
    8408:	c0 94       	com	r12
    840a:	dc 2c       	mov	r13, r12
    840c:	c8 01       	movw	r24, r16
    840e:	b7 01       	movw	r22, r14
    8410:	a6 01       	movw	r20, r12
    8412:	95 01       	movw	r18, r10
    8414:	0e 94 9e 6a 	call	0xd53c	; 0xd53c <__divmodsi4>
    8418:	61 15       	cp	r22, r1
    841a:	71 05       	cpc	r23, r1
    841c:	81 05       	cpc	r24, r1
    841e:	91 05       	cpc	r25, r1
    8420:	09 f0       	breq	.+2      	; 0x8424 <nano_DB_writeDBentry+0xe6>
    8422:	45 c0       	rjmp	.+138    	; 0x84ae <nano_DB_writeDBentry+0x170>
		{
			struct fat_file_struct* fd = fat_open_file(fs, &dir_entry);
    8424:	80 91 ed 0b 	lds	r24, 0x0BED
    8428:	90 91 ee 0b 	lds	r25, 0x0BEE
    842c:	be 01       	movw	r22, r28
    842e:	60 5d       	subi	r22, 0xD0	; 208
    8430:	7f 4f       	sbci	r23, 0xFF	; 255
    8432:	0e 94 f4 66 	call	0xcde8	; 0xcde8 <fat_open_file>
    8436:	4c 01       	movw	r8, r24
			if ( fd )
    8438:	00 97       	sbiw	r24, 0x00	; 0
    843a:	c9 f1       	breq	.+114    	; 0x84ae <nano_DB_writeDBentry+0x170>
			{
				long offset;
				unsigned char seek = FAT_SEEK_SET;
				offset = DBentryNumber * DBlenght ;
    843c:	c6 01       	movw	r24, r12
    843e:	b5 01       	movw	r22, r10
    8440:	6f 96       	adiw	r28, 0x1f	; 31
    8442:	2c ad       	ldd	r18, Y+60	; 0x3c
    8444:	3d ad       	ldd	r19, Y+61	; 0x3d
    8446:	4e ad       	ldd	r20, Y+62	; 0x3e
    8448:	5f ad       	ldd	r21, Y+63	; 0x3f
    844a:	6f 97       	sbiw	r28, 0x1f	; 31
    844c:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    8450:	69 83       	std	Y+1, r22	; 0x01
    8452:	7a 83       	std	Y+2, r23	; 0x02
    8454:	8b 83       	std	Y+3, r24	; 0x03
    8456:	9c 83       	std	Y+4, r25	; 0x04

				if ( offset > filesize )
    8458:	e6 16       	cp	r14, r22
    845a:	f7 06       	cpc	r15, r23
    845c:	08 07       	cpc	r16, r24
    845e:	19 07       	cpc	r17, r25
    8460:	14 f0       	brlt	.+4      	; 0x8466 <nano_DB_writeDBentry+0x128>
    8462:	40 e0       	ldi	r20, 0x00	; 0
    8464:	05 c0       	rjmp	.+10     	; 0x8470 <nano_DB_writeDBentry+0x132>
				{
					offset = 0;
    8466:	19 82       	std	Y+1, r1	; 0x01
    8468:	1a 82       	std	Y+2, r1	; 0x02
    846a:	1b 82       	std	Y+3, r1	; 0x03
    846c:	1c 82       	std	Y+4, r1	; 0x04
    846e:	42 e0       	ldi	r20, 0x02	; 2
					seek = FAT_SEEK_END;
				}
				
				if(fat_seek_file(fd, &offset , seek))
    8470:	c4 01       	movw	r24, r8
    8472:	be 01       	movw	r22, r28
    8474:	6f 5f       	subi	r22, 0xFF	; 255
    8476:	7f 4f       	sbci	r23, 0xFF	; 255
    8478:	0e 94 09 65 	call	0xca12	; 0xca12 <fat_seek_file>
    847c:	88 23       	and	r24, r24
    847e:	89 f0       	breq	.+34     	; 0x84a2 <nano_DB_writeDBentry+0x164>
				{
	                if( !fat_write_file(fd, (uint8_t*) DB, DBlenght ) != DBlenght )
    8480:	c4 01       	movw	r24, r8
    8482:	b1 01       	movw	r22, r2
    8484:	a2 01       	movw	r20, r4
    8486:	0e 94 5f 65 	call	0xcabe	; 0xcabe <fat_write_file>
    848a:	20 e0       	ldi	r18, 0x00	; 0
    848c:	30 e0       	ldi	r19, 0x00	; 0
    848e:	89 2b       	or	r24, r25
    8490:	11 f4       	brne	.+4      	; 0x8496 <nano_DB_writeDBentry+0x158>
    8492:	21 e0       	ldi	r18, 0x01	; 1
    8494:	30 e0       	ldi	r19, 0x00	; 0
    8496:	24 15       	cp	r18, r4
    8498:	35 05       	cpc	r19, r5
    849a:	19 f0       	breq	.+6      	; 0x84a2 <nano_DB_writeDBentry+0x164>
    849c:	00 e0       	ldi	r16, 0x00	; 0
    849e:	10 e0       	ldi	r17, 0x00	; 0
    84a0:	02 c0       	rjmp	.+4      	; 0x84a6 <nano_DB_writeDBentry+0x168>
    84a2:	0f ef       	ldi	r16, 0xFF	; 255
    84a4:	1f ef       	ldi	r17, 0xFF	; 255
//					else
//						printf_P( PSTR("Kann nicht in Datei \"%s\" schreiben!\r\n"),filename);
				}
//				else
//					printf_P( PSTR("Fehler beim seeken!\r\n"));
                fat_close_file( fd );				
    84a6:	c4 01       	movw	r24, r8
    84a8:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <fat_close_file>
    84ac:	02 c0       	rjmp	.+4      	; 0x84b2 <nano_DB_writeDBentry+0x174>
    84ae:	0f ef       	ldi	r16, 0xFF	; 255
    84b0:	1f ef       	ldi	r17, 0xFF	; 255
//			printf_P( PSTR("Datei \"%s\" kann nicht gefunden werden oder ist korrupt!\r\n"), filename );
	}
//	else
//		printf_P( PSTR("Verzeichniss \"%s\" kann nicht ge철ffnet werden!\r\n"), directoryname);

	fat_close_dir ( dd );
    84b2:	c3 01       	movw	r24, r6
    84b4:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>

	return( returncode );
}
    84b8:	c8 01       	movw	r24, r16
    84ba:	c2 5a       	subi	r28, 0xA2	; 162
    84bc:	df 4f       	sbci	r29, 0xFF	; 255
    84be:	e2 e1       	ldi	r30, 0x12	; 18
    84c0:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

000084c4 <nano_DB_makeDB>:
 * \param 	FULLNAME			Der vollst채ndige Pfad zur Datei der angelegt werden soll.
 * \returns	nanoDB_ERROR if failed, nanoDB_OK ist success
 */
/*------------------------------------------------------------------------------------------------------------*/
int nano_DB_makeDB( char * FULLNAME )
{
    84c4:	a6 e5       	ldi	r26, 0x56	; 86
    84c6:	b0 e0       	ldi	r27, 0x00	; 0
    84c8:	e8 e6       	ldi	r30, 0x68	; 104
    84ca:	f2 e4       	ldi	r31, 0x42	; 66
    84cc:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    84d0:	8c 01       	movw	r16, r24
	char * directoryname;

	int returncode = nanoDB_ERROR;

	directoryname = FULLNAME ;
	filename = nano_DB_getfilename( FULLNAME );
    84d2:	0e 94 86 40 	call	0x810c	; 0x810c <nano_DB_getfilename>
    84d6:	6c 01       	movw	r12, r24

	if ( FULLNAME == filename )
    84d8:	08 17       	cp	r16, r24
    84da:	19 07       	cpc	r17, r25
    84dc:	19 f4       	brne	.+6      	; 0x84e4 <nano_DB_makeDB+0x20>
    84de:	67 e6       	ldi	r22, 0x67	; 103
    84e0:	71 e0       	ldi	r23, 0x01	; 1
    84e2:	01 c0       	rjmp	.+2      	; 0x84e6 <nano_DB_makeDB+0x22>
    84e4:	b8 01       	movw	r22, r16
		directoryname = root ;

	fat_get_dir_entry_of_path(fs, directoryname , &directory);
    84e6:	80 91 ed 0b 	lds	r24, 0x0BED
    84ea:	90 91 ee 0b 	lds	r25, 0x0BEE
    84ee:	8e 01       	movw	r16, r28
    84f0:	0f 5f       	subi	r16, 0xFF	; 255
    84f2:	1f 4f       	sbci	r17, 0xFF	; 255
    84f4:	a8 01       	movw	r20, r16
    84f6:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>

	// Verzeichbnis 철ffnen
	dd = fat_open_dir(fs, &directory);
    84fa:	80 91 ed 0b 	lds	r24, 0x0BED
    84fe:	90 91 ee 0b 	lds	r25, 0x0BEE
    8502:	b8 01       	movw	r22, r16
    8504:	0e 94 c0 66 	call	0xcd80	; 0xcd80 <fat_open_dir>
    8508:	7c 01       	movw	r14, r24
	if(dd)
    850a:	00 97       	sbiw	r24, 0x00	; 0
    850c:	59 f0       	breq	.+22     	; 0x8524 <nano_DB_makeDB+0x60>
	{
 		if ( fat_create_file( dd , filename, &dir_entry ) )
    850e:	b6 01       	movw	r22, r12
    8510:	ae 01       	movw	r20, r28
    8512:	44 5d       	subi	r20, 0xD4	; 212
    8514:	5f 4f       	sbci	r21, 0xFF	; 255
    8516:	0e 94 b2 63 	call	0xc764	; 0xc764 <fat_create_file>
    851a:	88 23       	and	r24, r24
    851c:	19 f0       	breq	.+6      	; 0x8524 <nano_DB_makeDB+0x60>
    851e:	00 e0       	ldi	r16, 0x00	; 0
    8520:	10 e0       	ldi	r17, 0x00	; 0
    8522:	02 c0       	rjmp	.+4      	; 0x8528 <nano_DB_makeDB+0x64>
    8524:	0f ef       	ldi	r16, 0xFF	; 255
    8526:	1f ef       	ldi	r17, 0xFF	; 255
			returncode = nanoDB_OK;
	}
	fat_close_dir ( dd );
    8528:	c7 01       	movw	r24, r14
    852a:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>

	return( returncode );
}
    852e:	c8 01       	movw	r24, r16
    8530:	ca 5a       	subi	r28, 0xAA	; 170
    8532:	df 4f       	sbci	r29, 0xFF	; 255
    8534:	e8 e0       	ldi	r30, 0x08	; 8
    8536:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000853a <httpd_thread>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void httpd_thread( void )
{
    853a:	af e0       	ldi	r26, 0x0F	; 15
    853c:	b0 e0       	ldi	r27, 0x00	; 0
    853e:	e3 ea       	ldi	r30, 0xA3	; 163
    8540:	f2 e4       	ldi	r31, 0x42	; 66
    8542:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	char Data;
	
	struct STDOUT oldstream;
	
	// keine alte Verbindung offen?
	if ( http_request.HTTP_SOCKET == SOCKET_ERROR )
    8546:	80 91 a5 04 	lds	r24, 0x04A5
    854a:	90 91 a6 04 	lds	r25, 0x04A6
    854e:	2f ef       	ldi	r18, 0xFF	; 255
    8550:	8f 3f       	cpi	r24, 0xFF	; 255
    8552:	92 07       	cpc	r25, r18
    8554:	e9 f4       	brne	.+58     	; 0x8590 <httpd_thread+0x56>
	{ 	
		// auf neue Verbindung testen
		http_request.HTTP_SOCKET = CheckPortRequest( HTTP_PORT );
    8556:	80 e5       	ldi	r24, 0x50	; 80
    8558:	90 e0       	ldi	r25, 0x00	; 0
    855a:	0e 94 14 26 	call	0x4c28	; 0x4c28 <CheckPortRequest>
    855e:	9c 01       	movw	r18, r24
    8560:	90 93 a6 04 	sts	0x04A6, r25
    8564:	80 93 a5 04 	sts	0x04A5, r24
		if ( http_request.HTTP_SOCKET != SOCKET_ERROR )
    8568:	2f 5f       	subi	r18, 0xFF	; 255
    856a:	3f 4f       	sbci	r19, 0xFF	; 255
    856c:	09 f4       	brne	.+2      	; 0x8570 <httpd_thread+0x36>
    856e:	db c0       	rjmp	.+438    	; 0x8726 <httpd_thread+0x1ec>
		{	
			http_request.STATE = CONNECTED;
    8570:	81 e0       	ldi	r24, 0x01	; 1
    8572:	80 93 6a 04 	sts	0x046A, r24
			http_request.HTTP_POS = 0;
    8576:	10 92 a0 04 	sts	0x04A0, r1
    857a:	10 92 9f 04 	sts	0x049F, r1
			http_request.HTTP_LINEBUFFER[ 0 ] = '\0';
    857e:	10 92 aa 03 	sts	0x03AA, r1
			http_request.GET_FILE[ 0 ] = '\0';
    8582:	10 92 28 02 	sts	0x0228, r1
			http_request.GET_DATA[ 0 ] = '\0';
    8586:	10 92 e9 02 	sts	0x02E9, r1
			http_request.argc = 0 ;
    858a:	10 92 6e 04 	sts	0x046E, r1
    858e:	cb c0       	rjmp	.+406    	; 0x8726 <httpd_thread+0x1ec>
		}
	}
	else
	{
		// checken ob noch offen ist
		if( CheckSocketState( http_request.HTTP_SOCKET ) == SOCKET_NOT_USE )
    8590:	0e 94 01 26 	call	0x4c02	; 0x4c02 <CheckSocketState>
    8594:	88 23       	and	r24, r24
    8596:	79 f4       	brne	.+30     	; 0x85b6 <httpd_thread+0x7c>
		{
			CloseTCPSocket( http_request.HTTP_SOCKET );
    8598:	80 91 a5 04 	lds	r24, 0x04A5
    859c:	90 91 a6 04 	lds	r25, 0x04A6
    85a0:	0e 94 10 2a 	call	0x5420	; 0x5420 <CloseTCPSocket>
			http_request.HTTP_SOCKET = SOCKET_ERROR;
    85a4:	8f ef       	ldi	r24, 0xFF	; 255
    85a6:	9f ef       	ldi	r25, 0xFF	; 255
    85a8:	90 93 a6 04 	sts	0x04A6, r25
    85ac:	80 93 a5 04 	sts	0x04A5, r24
			http_request.STATE = DISCONNECT;
    85b0:	10 92 6a 04 	sts	0x046A, r1
    85b4:	b8 c0       	rjmp	.+368    	; 0x8726 <httpd_thread+0x1ec>
		}
		else
		{			
			if ( http_request.STATE == CONNECTED )
    85b6:	80 91 6a 04 	lds	r24, 0x046A
    85ba:	81 30       	cpi	r24, 0x01	; 1
    85bc:	09 f0       	breq	.+2      	; 0x85c0 <httpd_thread+0x86>
    85be:	7d c0       	rjmp	.+250    	; 0x86ba <httpd_thread+0x180>
    85c0:	6f c0       	rjmp	.+222    	; 0x86a0 <httpd_thread+0x166>
			{	
				while( GetBytesInSocketData( http_request.HTTP_SOCKET ) >= 1 )
				{
					Data = ( GetByteFromSocketData ( http_request.HTTP_SOCKET ) );
    85c2:	80 91 a5 04 	lds	r24, 0x04A5
    85c6:	90 91 a6 04 	lds	r25, 0x04A6
    85ca:	0e 94 ae 28 	call	0x515c	; 0x515c <GetByteFromSocketData>
					if ( Data != 0x0a )
    85ce:	8a 30       	cpi	r24, 0x0A	; 10
    85d0:	09 f4       	brne	.+2      	; 0x85d4 <httpd_thread+0x9a>
    85d2:	68 c0       	rjmp	.+208    	; 0x86a4 <httpd_thread+0x16a>
					{
						// Daten im Puffer sichern
						if ( http_request.HTTP_POS < ( REQUEST_BUFFERLEN - 1 ) )
    85d4:	20 91 9f 04 	lds	r18, 0x049F
    85d8:	30 91 a0 04 	lds	r19, 0x04A0
    85dc:	2f 3b       	cpi	r18, 0xBF	; 191
    85de:	31 05       	cpc	r19, r1
    85e0:	6c f4       	brge	.+26     	; 0x85fc <httpd_thread+0xc2>
						{
							http_request.HTTP_LINEBUFFER[ http_request.HTTP_POS++ ] = Data;
    85e2:	f9 01       	movw	r30, r18
    85e4:	e6 55       	subi	r30, 0x56	; 86
    85e6:	fc 4f       	sbci	r31, 0xFC	; 252
    85e8:	80 83       	st	Z, r24
    85ea:	f9 01       	movw	r30, r18
    85ec:	31 96       	adiw	r30, 0x01	; 1
    85ee:	f0 93 a0 04 	sts	0x04A0, r31
    85f2:	e0 93 9f 04 	sts	0x049F, r30
							http_request.HTTP_LINEBUFFER[ http_request.HTTP_POS ] = '\0';
    85f6:	e6 55       	subi	r30, 0x56	; 86
    85f8:	fc 4f       	sbci	r31, 0xFC	; 252
    85fa:	10 82       	st	Z, r1
						}
						
						// Zeilenende erreicht?
						if ( Data == 0x0d )
    85fc:	8d 30       	cpi	r24, 0x0D	; 13
    85fe:	09 f0       	breq	.+2      	; 0x8602 <httpd_thread+0xc8>
    8600:	51 c0       	rjmp	.+162    	; 0x86a4 <httpd_thread+0x16a>
						{
							// Steht was im Puffer, wenn ja pharsen
							if ( http_request.HTTP_POS != 0 )
    8602:	80 91 9f 04 	lds	r24, 0x049F
    8606:	90 91 a0 04 	lds	r25, 0x04A0
    860a:	89 2b       	or	r24, r25
    860c:	c1 f1       	breq	.+112    	; 0x867e <httpd_thread+0x144>
							{
								http_request.HTTP_POS = 0;
    860e:	10 92 a0 04 	sts	0x04A0, r1
    8612:	10 92 9f 04 	sts	0x049F, r1
								if ( !memcmp( &http_request.HTTP_LINEBUFFER [0] , "GET" , 3 ) )
    8616:	8a ea       	ldi	r24, 0xAA	; 170
    8618:	93 e0       	ldi	r25, 0x03	; 3
    861a:	6a e0       	ldi	r22, 0x0A	; 10
    861c:	71 e0       	ldi	r23, 0x01	; 1
    861e:	43 e0       	ldi	r20, 0x03	; 3
    8620:	50 e0       	ldi	r21, 0x00	; 0
    8622:	0e 94 10 14 	call	0x2820	; 0x2820 <memcmp>
    8626:	00 97       	sbiw	r24, 0x00	; 0
    8628:	39 f4       	brne	.+14     	; 0x8638 <httpd_thread+0xfe>
								{
									http_request.REQUEST_TYPE = GET_REQUEST;
    862a:	10 92 6b 04 	sts	0x046B, r1
									PharseGetData( &http_request );
    862e:	88 e2       	ldi	r24, 0x28	; 40
    8630:	92 e0       	ldi	r25, 0x02	; 2
    8632:	0e 94 f8 43 	call	0x87f0	; 0x87f0 <PharseGetData>
    8636:	0c c0       	rjmp	.+24     	; 0x8650 <httpd_thread+0x116>
									PharseGetFile( &http_request ); 
								}
								else if ( !memcmp( &http_request.HTTP_LINEBUFFER [0] , "POST" , 4 ) )
    8638:	8a ea       	ldi	r24, 0xAA	; 170
    863a:	93 e0       	ldi	r25, 0x03	; 3
    863c:	6e e0       	ldi	r22, 0x0E	; 14
    863e:	71 e0       	ldi	r23, 0x01	; 1
    8640:	44 e0       	ldi	r20, 0x04	; 4
    8642:	50 e0       	ldi	r21, 0x00	; 0
    8644:	0e 94 10 14 	call	0x2820	; 0x2820 <memcmp>
    8648:	00 97       	sbiw	r24, 0x00	; 0
    864a:	39 f4       	brne	.+14     	; 0x865a <httpd_thread+0x120>
								{
									http_request.REQUEST_TYPE = POST_REQUEST;
    864c:	10 93 6b 04 	sts	0x046B, r17
									PharseGetFile( &http_request ); 
    8650:	88 e2       	ldi	r24, 0x28	; 40
    8652:	92 e0       	ldi	r25, 0x02	; 2
    8654:	0e 94 0f 45 	call	0x8a1e	; 0x8a1e <PharseGetFile>
    8658:	12 c0       	rjmp	.+36     	; 0x867e <httpd_thread+0x144>
								}
								else if ( !memcmp( &http_request.HTTP_LINEBUFFER [0] , "Content-Length: " , 16 ) )
    865a:	8a ea       	ldi	r24, 0xAA	; 170
    865c:	93 e0       	ldi	r25, 0x03	; 3
    865e:	63 e1       	ldi	r22, 0x13	; 19
    8660:	71 e0       	ldi	r23, 0x01	; 1
    8662:	40 e1       	ldi	r20, 0x10	; 16
    8664:	50 e0       	ldi	r21, 0x00	; 0
    8666:	0e 94 10 14 	call	0x2820	; 0x2820 <memcmp>
    866a:	00 97       	sbiw	r24, 0x00	; 0
    866c:	41 f4       	brne	.+16     	; 0x867e <httpd_thread+0x144>
								{
									http_request.REQUEST_LEN = atoi( &http_request.HTTP_LINEBUFFER [16] );
    866e:	8a eb       	ldi	r24, 0xBA	; 186
    8670:	93 e0       	ldi	r25, 0x03	; 3
    8672:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    8676:	90 93 6d 04 	sts	0x046D, r25
    867a:	80 93 6c 04 	sts	0x046C, r24
								}								
							}
				
							// Ist es eine Leerzeile, dann ist der Request zu ende und die verarbeitung kann beginnen
							if ( http_request.HTTP_LINEBUFFER[ 0 ] == 0x0d )
    867e:	80 91 aa 03 	lds	r24, 0x03AA
    8682:	8d 30       	cpi	r24, 0x0D	; 13
    8684:	79 f4       	brne	.+30     	; 0x86a4 <httpd_thread+0x16a>
							{
								if ( http_request.REQUEST_TYPE == GET_REQUEST )
    8686:	80 91 6b 04 	lds	r24, 0x046B
    868a:	88 23       	and	r24, r24
    868c:	31 f4       	brne	.+12     	; 0x869a <httpd_thread+0x160>
									FlushSocketData( http_request.HTTP_SOCKET );
    868e:	80 91 a5 04 	lds	r24, 0x04A5
    8692:	90 91 a6 04 	lds	r25, 0x04A6
    8696:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <FlushSocketData>
								http_request.STATE =  REQUEST_END;
    869a:	00 93 6a 04 	sts	0x046A, r16
    869e:	02 c0       	rjmp	.+4      	; 0x86a4 <httpd_thread+0x16a>
    86a0:	03 e0       	ldi	r16, 0x03	; 3
									PharseGetData( &http_request );
									PharseGetFile( &http_request ); 
								}
								else if ( !memcmp( &http_request.HTTP_LINEBUFFER [0] , "POST" , 4 ) )
								{
									http_request.REQUEST_TYPE = POST_REQUEST;
    86a2:	11 e0       	ldi	r17, 0x01	; 1
		}
		else
		{			
			if ( http_request.STATE == CONNECTED )
			{	
				while( GetBytesInSocketData( http_request.HTTP_SOCKET ) >= 1 )
    86a4:	80 91 a5 04 	lds	r24, 0x04A5
    86a8:	90 91 a6 04 	lds	r25, 0x04A6
    86ac:	0e 94 6f 26 	call	0x4cde	; 0x4cde <GetBytesInSocketData>
    86b0:	18 16       	cp	r1, r24
    86b2:	19 06       	cpc	r1, r25
    86b4:	0c f4       	brge	.+2      	; 0x86b8 <httpd_thread+0x17e>
    86b6:	85 cf       	rjmp	.-246    	; 0x85c2 <httpd_thread+0x88>
    86b8:	36 c0       	rjmp	.+108    	; 0x8726 <httpd_thread+0x1ec>
							}
						}
					}
				}
			}
			else if (http_request.STATE == REQUEST_END )
    86ba:	83 30       	cpi	r24, 0x03	; 3
    86bc:	a1 f5       	brne	.+104    	; 0x8726 <httpd_thread+0x1ec>
			{
				STDOUT_save( &oldstream );
    86be:	ce 01       	movw	r24, r28
    86c0:	01 96       	adiw	r24, 0x01	; 1
    86c2:	0e 94 a4 38 	call	0x7148	; 0x7148 <STDOUT_save>
				STDOUT_set( _TCP, http_request.HTTP_SOCKET );
    86c6:	60 91 a5 04 	lds	r22, 0x04A5
    86ca:	70 91 a6 04 	lds	r23, 0x04A6
    86ce:	82 e0       	ldi	r24, 0x02	; 2
    86d0:	0e 94 76 38 	call	0x70ec	; 0x70ec <STDOUT_set>

				if ( check_cgibin ( &http_request ) == 1 )
    86d4:	88 e2       	ldi	r24, 0x28	; 40
    86d6:	92 e0       	ldi	r25, 0x02	; 2
    86d8:	0e 94 e6 45 	call	0x8bcc	; 0x8bcc <check_cgibin>
    86dc:	01 97       	sbiw	r24, 0x01	; 1
    86de:	89 f0       	breq	.+34     	; 0x8702 <httpd_thread+0x1c8>
				{
				}
				else if ( check_files ( &http_request ) == 1 )
    86e0:	88 e2       	ldi	r24, 0x28	; 40
    86e2:	92 e0       	ldi	r25, 0x02	; 2
    86e4:	0e 94 25 46 	call	0x8c4a	; 0x8c4a <check_files>
    86e8:	01 97       	sbiw	r24, 0x01	; 1
    86ea:	59 f0       	breq	.+22     	; 0x8702 <httpd_thread+0x1c8>
				{
				}
				else
				{	
					printf_P( PSTR(	"HTTP/1.0 403\r\n"
    86ec:	00 d0       	rcall	.+0      	; 0x86ee <httpd_thread+0x1b4>
    86ee:	8c e0       	ldi	r24, 0x0C	; 12
    86f0:	93 e0       	ldi	r25, 0x03	; 3
    86f2:	ed b7       	in	r30, 0x3d	; 61
    86f4:	fe b7       	in	r31, 0x3e	; 62
    86f6:	92 83       	std	Z+2, r25	; 0x02
    86f8:	81 83       	std	Z+1, r24	; 0x01
    86fa:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    86fe:	0f 90       	pop	r0
    8700:	0f 90       	pop	r0
									"403 File not found!"
									"</BODY>\r\n"
									"</HTML>\r\n\r\n"));
				}

				STDOUT_Flush();
    8702:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
				STDOUT_restore( &oldstream );
    8706:	ce 01       	movw	r24, r28
    8708:	01 96       	adiw	r24, 0x01	; 1
    870a:	0e 94 8e 38 	call	0x711c	; 0x711c <STDOUT_restore>
				
				CloseTCPSocket( http_request.HTTP_SOCKET );
    870e:	80 91 a5 04 	lds	r24, 0x04A5
    8712:	90 91 a6 04 	lds	r25, 0x04A6
    8716:	0e 94 10 2a 	call	0x5420	; 0x5420 <CloseTCPSocket>
				http_request.HTTP_SOCKET = SOCKET_ERROR;
    871a:	8f ef       	ldi	r24, 0xFF	; 255
    871c:	9f ef       	ldi	r25, 0xFF	; 255
    871e:	90 93 a6 04 	sts	0x04A6, r25
    8722:	80 93 a5 04 	sts	0x04A5, r24
			}
		}
	}
}
    8726:	2f 96       	adiw	r28, 0x0f	; 15
    8728:	e4 e0       	ldi	r30, 0x04	; 4
    872a:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

0000872e <httpd_init>:
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void httpd_init( void )
	{
		cgi_init();
    872e:	0e 94 93 45 	call	0x8b26	; 0x8b26 <cgi_init>
		RegisterTCPPort( HTTP_PORT );
    8732:	80 e5       	ldi	r24, 0x50	; 80
    8734:	90 e0       	ldi	r25, 0x00	; 0
    8736:	0e 94 e7 25 	call	0x4bce	; 0x4bce <RegisterTCPPort>
		http_request.HTTP_SOCKET == SOCKET_ERROR;
		printf_P( PSTR("HTTP-Server gestartet auf Port %d.\r\n") , HTTP_PORT);
    873a:	00 d0       	rcall	.+0      	; 0x873c <httpd_init+0xe>
    873c:	00 d0       	rcall	.+0      	; 0x873e <httpd_init+0x10>
    873e:	8b eb       	ldi	r24, 0xBB	; 187
    8740:	93 e0       	ldi	r25, 0x03	; 3
    8742:	ed b7       	in	r30, 0x3d	; 61
    8744:	fe b7       	in	r31, 0x3e	; 62
    8746:	92 83       	std	Z+2, r25	; 0x02
    8748:	81 83       	std	Z+1, r24	; 0x01
    874a:	80 e5       	ldi	r24, 0x50	; 80
    874c:	90 e0       	ldi	r25, 0x00	; 0
    874e:	94 83       	std	Z+4, r25	; 0x04
    8750:	83 83       	std	Z+3, r24	; 0x03
    8752:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
		THREAD_RegisterThread( httpd_thread, PSTR("httpd"));
    8756:	0f 90       	pop	r0
    8758:	0f 90       	pop	r0
    875a:	0f 90       	pop	r0
    875c:	0f 90       	pop	r0
    875e:	8d e9       	ldi	r24, 0x9D	; 157
    8760:	92 e4       	ldi	r25, 0x42	; 66
    8762:	65 eb       	ldi	r22, 0xB5	; 181
    8764:	73 e0       	ldi	r23, 0x03	; 3
    8766:	0e 94 cc 3f 	call	0x7f98	; 0x7f98 <THREAD_RegisterThread>
	}
    876a:	08 95       	ret

0000876c <PharseCheckName_P>:
 * \param	ArgName	 Pointer auf einen String im Flash der den Namen enth채lt.
 * \return			 0 wenn gefunden, sonst -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
char PharseCheckName_P( void * pStruct , char * ArgName )
{
    876c:	a0 e0       	ldi	r26, 0x00	; 0
    876e:	b0 e0       	ldi	r27, 0x00	; 0
    8770:	ec eb       	ldi	r30, 0xBC	; 188
    8772:	f3 e4       	ldi	r31, 0x43	; 67
    8774:	0c 94 c4 6a 	jmp	0xd588	; 0xd588 <__prologue_saves__+0x16>
    8778:	7b 01       	movw	r14, r22
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    877a:	fc 01       	movw	r30, r24
	
	char ReturnCode = 0, i ;
	
	for ( i = 0 ; i < http_request->argc ; i++ )
    877c:	ea 5b       	subi	r30, 0xBA	; 186
    877e:	fd 4f       	sbci	r31, 0xFD	; 253
    8780:	d1 90       	ld	r13, Z+
    8782:	ef 01       	movw	r28, r30
    8784:	00 e0       	ldi	r16, 0x00	; 0
    8786:	10 e0       	ldi	r17, 0x00	; 0
    8788:	0a c0       	rjmp	.+20     	; 0x879e <PharseCheckName_P+0x32>
	{
		if ( !strcmp_P( http_request->argname[ i ] , ArgName ) ) ReturnCode = -1 ;
    878a:	88 81       	ld	r24, Y
    878c:	99 81       	ldd	r25, Y+1	; 0x01
    878e:	b7 01       	movw	r22, r14
    8790:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    8794:	89 2b       	or	r24, r25
    8796:	09 f4       	brne	.+2      	; 0x879a <PharseCheckName_P+0x2e>
    8798:	0f ef       	ldi	r16, 0xFF	; 255
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
	
	char ReturnCode = 0, i ;
	
	for ( i = 0 ; i < http_request->argc ; i++ )
    879a:	1f 5f       	subi	r17, 0xFF	; 255
    879c:	22 96       	adiw	r28, 0x02	; 2
    879e:	1d 15       	cp	r17, r13
    87a0:	a0 f3       	brcs	.-24     	; 0x878a <PharseCheckName_P+0x1e>
	{
		if ( !strcmp_P( http_request->argname[ i ] , ArgName ) ) ReturnCode = -1 ;
	}
	return( ReturnCode );	
}
    87a2:	80 2f       	mov	r24, r16
    87a4:	cd b7       	in	r28, 0x3d	; 61
    87a6:	de b7       	in	r29, 0x3e	; 62
    87a8:	e7 e0       	ldi	r30, 0x07	; 7
    87aa:	0c 94 e0 6a 	jmp	0xd5c0	; 0xd5c0 <__epilogue_restores__+0x16>

000087ae <PharseGetValue_P>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
char PharseGetValue_P( void * pStruct , char * ArgName )
{
    87ae:	a0 e0       	ldi	r26, 0x00	; 0
    87b0:	b0 e0       	ldi	r27, 0x00	; 0
    87b2:	ed ed       	ldi	r30, 0xDD	; 221
    87b4:	f3 e4       	ldi	r31, 0x43	; 67
    87b6:	0c 94 c4 6a 	jmp	0xd588	; 0xd588 <__prologue_saves__+0x16>
    87ba:	7b 01       	movw	r14, r22
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    87bc:	fc 01       	movw	r30, r24
	
	char ReturnCode = -1, i ;
	
	for ( i = 0 ; i < http_request->argc ; i++ )
    87be:	ea 5b       	subi	r30, 0xBA	; 186
    87c0:	fd 4f       	sbci	r31, 0xFD	; 253
    87c2:	d1 90       	ld	r13, Z+
    87c4:	ef 01       	movw	r28, r30
    87c6:	0f ef       	ldi	r16, 0xFF	; 255
    87c8:	10 e0       	ldi	r17, 0x00	; 0
    87ca:	0a c0       	rjmp	.+20     	; 0x87e0 <PharseGetValue_P+0x32>
	{
		if ( !strcmp_P( http_request->argname[ i ] , ArgName ) ) ReturnCode = i ;
    87cc:	88 81       	ld	r24, Y
    87ce:	99 81       	ldd	r25, Y+1	; 0x01
    87d0:	b7 01       	movw	r22, r14
    87d2:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    87d6:	89 2b       	or	r24, r25
    87d8:	09 f4       	brne	.+2      	; 0x87dc <PharseGetValue_P+0x2e>
    87da:	01 2f       	mov	r16, r17
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
	
	char ReturnCode = -1, i ;
	
	for ( i = 0 ; i < http_request->argc ; i++ )
    87dc:	1f 5f       	subi	r17, 0xFF	; 255
    87de:	22 96       	adiw	r28, 0x02	; 2
    87e0:	1d 15       	cp	r17, r13
    87e2:	a0 f3       	brcs	.-24     	; 0x87cc <PharseGetValue_P+0x1e>
	{
		if ( !strcmp_P( http_request->argname[ i ] , ArgName ) ) ReturnCode = i ;
	}
	return( ReturnCode );	
}
    87e4:	80 2f       	mov	r24, r16
    87e6:	cd b7       	in	r28, 0x3d	; 61
    87e8:	de b7       	in	r29, 0x3e	; 62
    87ea:	e7 e0       	ldi	r30, 0x07	; 7
    87ec:	0c 94 e0 6a 	jmp	0xd5c0	; 0xd5c0 <__epilogue_restores__+0x16>

000087f0 <PharseGetData>:
 * \param 	pStruct	Pointer auf die Struktur die die HTTP zur체ck gibt
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void PharseGetData( void * pStruct )
{
    87f0:	a5 e0       	ldi	r26, 0x05	; 5
    87f2:	b0 e0       	ldi	r27, 0x00	; 0
    87f4:	ee ef       	ldi	r30, 0xFE	; 254
    87f6:	f3 e4       	ldi	r31, 0x43	; 67
    87f8:	0c 94 ba 6a 	jmp	0xd574	; 0xd574 <__prologue_saves__+0x2>
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    87fc:	8c 01       	movw	r16, r24
    87fe:	fc 01       	movw	r30, r24
    8800:	ee 57       	subi	r30, 0x7E	; 126
    8802:	fe 4f       	sbci	r31, 0xFE	; 254
    8804:	20 e0       	ldi	r18, 0x00	; 0
    8806:	30 e0       	ldi	r19, 0x00	; 0
	
	int i , x = 0, size;
	char * endp;
	
	for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
		if ( http_request->HTTP_LINEBUFFER[ i ] == '?' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
    8808:	80 81       	ld	r24, Z
    880a:	8f 33       	cpi	r24, 0x3F	; 63
    880c:	49 f0       	breq	.+18     	; 0x8820 <PharseGetData+0x30>
    880e:	88 23       	and	r24, r24
    8810:	39 f0       	breq	.+14     	; 0x8820 <PharseGetData+0x30>
	char buffer[3]= "00";
	
	int i , x = 0, size;
	char * endp;
	
	for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
    8812:	2f 5f       	subi	r18, 0xFF	; 255
    8814:	3f 4f       	sbci	r19, 0xFF	; 255
    8816:	31 96       	adiw	r30, 0x01	; 1
    8818:	20 3c       	cpi	r18, 0xC0	; 192
    881a:	31 05       	cpc	r19, r1
    881c:	a9 f7       	brne	.-22     	; 0x8808 <PharseGetData+0x18>
    881e:	fb c0       	rjmp	.+502    	; 0x8a16 <PharseGetData+0x226>
		if ( http_request->HTTP_LINEBUFFER[ i ] == '?' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
			break;
	
	if ( i == REQUEST_BUFFERLEN || http_request->HTTP_LINEBUFFER[ i ] == '\0' ) return;
    8820:	f8 01       	movw	r30, r16
    8822:	e2 0f       	add	r30, r18
    8824:	f3 1f       	adc	r31, r19
    8826:	ee 57       	subi	r30, 0x7E	; 126
    8828:	fe 4f       	sbci	r31, 0xFE	; 254
    882a:	80 81       	ld	r24, Z
    882c:	88 23       	and	r24, r24
    882e:	09 f4       	brne	.+2      	; 0x8832 <PharseGetData+0x42>
    8830:	f2 c0       	rjmp	.+484    	; 0x8a16 <PharseGetData+0x226>
void PharseGetData( void * pStruct )
{
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;

	char buffer[3]= "00";
    8832:	de 01       	movw	r26, r28
    8834:	13 96       	adiw	r26, 0x03	; 3
    8836:	e4 e2       	ldi	r30, 0x24	; 36
    8838:	f1 e0       	ldi	r31, 0x01	; 1
    883a:	83 e0       	ldi	r24, 0x03	; 3
    883c:	01 90       	ld	r0, Z+
    883e:	0d 92       	st	X+, r0
    8840:	81 50       	subi	r24, 0x01	; 1
    8842:	e1 f7       	brne	.-8      	; 0x883c <PharseGetData+0x4c>
		if ( http_request->HTTP_LINEBUFFER[ i ] == '?' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
			break;
	
	if ( i == REQUEST_BUFFERLEN || http_request->HTTP_LINEBUFFER[ i ] == '\0' ) return;
	
	i++;
    8844:	79 01       	movw	r14, r18
    8846:	08 94       	sec
    8848:	e1 1c       	adc	r14, r1
    884a:	f1 1c       	adc	r15, r1
 * \param 	pStruct	Pointer auf die Struktur die die HTTP zur체ck gibt
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void PharseGetData( void * pStruct )
{
    884c:	e1 ec       	ldi	r30, 0xC1	; 193
    884e:	8e 2e       	mov	r8, r30
    8850:	91 2c       	mov	r9, r1
    8852:	80 0e       	add	r8, r16
    8854:	91 1e       	adc	r9, r17
    8856:	64 01       	movw	r12, r8
    8858:	71 e0       	ldi	r23, 0x01	; 1
    885a:	a7 2e       	mov	r10, r23
    885c:	b1 2c       	mov	r11, r1
			buffer[1] = http_request->HTTP_LINEBUFFER[ i ];
			http_request->GET_DATA[ x++ ] = ( char ) strtol( buffer, &endp , 16 );
		}
		else if ( http_request->HTTP_LINEBUFFER[ i ] == '+' )
		{
			http_request->GET_DATA[ x++ ] = ' ';
    885e:	60 e2       	ldi	r22, 0x20	; 32
    8860:	36 2e       	mov	r3, r22
		{
			i++;
			buffer[0] = http_request->HTTP_LINEBUFFER[ i ];
			i++;
			buffer[1] = http_request->HTTP_LINEBUFFER[ i ];
			http_request->GET_DATA[ x++ ] = ( char ) strtol( buffer, &endp , 16 );
    8862:	53 e0       	ldi	r21, 0x03	; 3
    8864:	45 2e       	mov	r4, r21
    8866:	51 2c       	mov	r5, r1
    8868:	4c 0e       	add	r4, r28
    886a:	5d 1e       	adc	r5, r29
    886c:	3e 01       	movw	r6, r28
    886e:	08 94       	sec
    8870:	61 1c       	adc	r6, r1
    8872:	71 1c       	adc	r7, r1
    8874:	42 c0       	rjmp	.+132    	; 0x88fa <PharseGetData+0x10a>
	
	i++;
	
	for ( ; ( i < REQUEST_BUFFERLEN ) && ( x < REQUEST_BUFFERLEN_DATA ) ; i++)
	{
		if ( http_request->HTTP_LINEBUFFER[ i ] == ' ' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
    8876:	f8 01       	movw	r30, r16
    8878:	ee 0d       	add	r30, r14
    887a:	ff 1d       	adc	r31, r15
    887c:	ee 57       	subi	r30, 0x7E	; 126
    887e:	fe 4f       	sbci	r31, 0xFE	; 254
    8880:	e0 81       	ld	r30, Z
    8882:	e0 32       	cpi	r30, 0x20	; 32
    8884:	11 f0       	breq	.+4      	; 0x888a <PharseGetData+0x9a>
    8886:	ee 23       	and	r30, r30
    8888:	31 f4       	brne	.+12     	; 0x8896 <PharseGetData+0xa6>
		{
			http_request->GET_DATA[ x++ ] = '\0';
    888a:	a0 0f       	add	r26, r16
    888c:	b1 1f       	adc	r27, r17
    888e:	af 53       	subi	r26, 0x3F	; 63
    8890:	bf 4f       	sbci	r27, 0xFF	; 255
    8892:	1c 92       	st	X, r1
    8894:	3d c0       	rjmp	.+122    	; 0x8910 <PharseGetData+0x120>
			break;
		}
		else if ( http_request->HTTP_LINEBUFFER[ i ] == '%' )
    8896:	e5 32       	cpi	r30, 0x25	; 37
    8898:	f1 f4       	brne	.+60     	; 0x88d6 <PharseGetData+0xe6>
		{
			i++;
    889a:	97 01       	movw	r18, r14
    889c:	2f 5f       	subi	r18, 0xFF	; 255
    889e:	3f 4f       	sbci	r19, 0xFF	; 255
			buffer[0] = http_request->HTTP_LINEBUFFER[ i ];
    88a0:	f8 01       	movw	r30, r16
    88a2:	e2 0f       	add	r30, r18
    88a4:	f3 1f       	adc	r31, r19
    88a6:	ee 57       	subi	r30, 0x7E	; 126
    88a8:	fe 4f       	sbci	r31, 0xFE	; 254
    88aa:	80 81       	ld	r24, Z
    88ac:	8b 83       	std	Y+3, r24	; 0x03
			i++;
    88ae:	79 01       	movw	r14, r18
    88b0:	08 94       	sec
    88b2:	e1 1c       	adc	r14, r1
    88b4:	f1 1c       	adc	r15, r1
			buffer[1] = http_request->HTTP_LINEBUFFER[ i ];
    88b6:	f8 01       	movw	r30, r16
    88b8:	ee 0d       	add	r30, r14
    88ba:	ff 1d       	adc	r31, r15
    88bc:	ee 57       	subi	r30, 0x7E	; 126
    88be:	fe 4f       	sbci	r31, 0xFE	; 254
    88c0:	80 81       	ld	r24, Z
    88c2:	8c 83       	std	Y+4, r24	; 0x04
			http_request->GET_DATA[ x++ ] = ( char ) strtol( buffer, &endp , 16 );
    88c4:	c2 01       	movw	r24, r4
    88c6:	b3 01       	movw	r22, r6
    88c8:	40 e1       	ldi	r20, 0x10	; 16
    88ca:	50 e0       	ldi	r21, 0x00	; 0
    88cc:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <strtol>
    88d0:	d6 01       	movw	r26, r12
    88d2:	6c 93       	st	X, r22
    88d4:	09 c0       	rjmp	.+18     	; 0x88e8 <PharseGetData+0xf8>
		}
		else if ( http_request->HTTP_LINEBUFFER[ i ] == '+' )
    88d6:	eb 32       	cpi	r30, 0x2B	; 43
    88d8:	19 f4       	brne	.+6      	; 0x88e0 <PharseGetData+0xf0>
		{
			http_request->GET_DATA[ x++ ] = ' ';
    88da:	f6 01       	movw	r30, r12
    88dc:	30 82       	st	Z, r3
    88de:	04 c0       	rjmp	.+8      	; 0x88e8 <PharseGetData+0xf8>
		}
		else
		{
			http_request->GET_DATA[ x++ ] = http_request->HTTP_LINEBUFFER[ i ];											
    88e0:	d6 01       	movw	r26, r12
    88e2:	ec 93       	st	X, r30
			http_request->GET_DATA[ x ] = '\0';
    88e4:	11 96       	adiw	r26, 0x01	; 1
    88e6:	1c 92       	st	X, r1
	
	if ( i == REQUEST_BUFFERLEN || http_request->HTTP_LINEBUFFER[ i ] == '\0' ) return;
	
	i++;
	
	for ( ; ( i < REQUEST_BUFFERLEN ) && ( x < REQUEST_BUFFERLEN_DATA ) ; i++)
    88e8:	08 94       	sec
    88ea:	e1 1c       	adc	r14, r1
    88ec:	f1 1c       	adc	r15, r1
    88ee:	08 94       	sec
    88f0:	a1 1c       	adc	r10, r1
    88f2:	b1 1c       	adc	r11, r1
    88f4:	08 94       	sec
    88f6:	c1 1c       	adc	r12, r1
    88f8:	d1 1c       	adc	r13, r1
    88fa:	d5 01       	movw	r26, r10
    88fc:	11 97       	sbiw	r26, 0x01	; 1
    88fe:	e0 ec       	ldi	r30, 0xC0	; 192
    8900:	ee 16       	cp	r14, r30
    8902:	f1 04       	cpc	r15, r1
    8904:	2c f4       	brge	.+10     	; 0x8910 <PharseGetData+0x120>
    8906:	f1 ec       	ldi	r31, 0xC1	; 193
    8908:	af 16       	cp	r10, r31
    890a:	b1 04       	cpc	r11, r1
    890c:	09 f0       	breq	.+2      	; 0x8910 <PharseGetData+0x120>
    890e:	b3 cf       	rjmp	.-154    	; 0x8876 <PharseGetData+0x86>
			http_request->GET_DATA[ x++ ] = http_request->HTTP_LINEBUFFER[ i ];											
			http_request->GET_DATA[ x ] = '\0';
		}
	}
	
	http_request->argc = 0;
    8910:	f8 01       	movw	r30, r16
    8912:	ea 5b       	subi	r30, 0xBA	; 186
    8914:	fd 4f       	sbci	r31, 0xFD	; 253
    8916:	10 82       	st	Z, r1
	
	if ( http_request->GET_DATA[ 0 ] != '\0' )
    8918:	0f 53       	subi	r16, 0x3F	; 63
    891a:	1f 4f       	sbci	r17, 0xFF	; 255
    891c:	d8 01       	movw	r26, r16
    891e:	8c 91       	ld	r24, X
    8920:	01 5c       	subi	r16, 0xC1	; 193
    8922:	10 40       	sbci	r17, 0x00	; 0
    8924:	88 23       	and	r24, r24
    8926:	09 f4       	brne	.+2      	; 0x892a <PharseGetData+0x13a>
    8928:	76 c0       	rjmp	.+236    	; 0x8a16 <PharseGetData+0x226>
	{
		http_request->argc = 1;
    892a:	81 e0       	ldi	r24, 0x01	; 1
    892c:	80 83       	st	Z, r24
		http_request->argname[ http_request->argc - 1 ] = &http_request->GET_DATA[ 0 ];
    892e:	09 5b       	subi	r16, 0xB9	; 185
    8930:	1d 4f       	sbci	r17, 0xFD	; 253
    8932:	d8 01       	movw	r26, r16
    8934:	8d 92       	st	X+, r8
    8936:	9c 92       	st	X, r9
		http_request->argvalue[ http_request->argc - 1 ] = &http_request->GET_DATA[ 0 ];
    8938:	08 5e       	subi	r16, 0xE8	; 232
    893a:	1f 4f       	sbci	r17, 0xFF	; 255
    893c:	d8 01       	movw	r26, r16
    893e:	8d 92       	st	X+, r8
    8940:	9c 92       	st	X, r9
    8942:	0f 55       	subi	r16, 0x5F	; 95
    8944:	12 40       	sbci	r17, 0x02	; 2
    8946:	20 e0       	ldi	r18, 0x00	; 0
    8948:	30 e0       	ldi	r19, 0x00	; 0
		for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
		{
			if ( http_request->GET_DATA[ i ] == '&' )
			{
				http_request->GET_DATA[ i ] = '\0';
				if ( http_request->argc < MAX_HTTP_PARAMS )
    894a:	df 01       	movw	r26, r30
		http_request->argname[ http_request->argc - 1 ] = &http_request->GET_DATA[ 0 ];
		http_request->argvalue[ http_request->argc - 1 ] = &http_request->GET_DATA[ 0 ];
		
		for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
		{
			if ( http_request->GET_DATA[ i ] == '&' )
    894c:	f8 01       	movw	r30, r16
    894e:	e2 0f       	add	r30, r18
    8950:	f3 1f       	adc	r31, r19
    8952:	ef 53       	subi	r30, 0x3F	; 63
    8954:	ff 4f       	sbci	r31, 0xFF	; 255
    8956:	80 81       	ld	r24, Z
    8958:	86 32       	cpi	r24, 0x26	; 38
    895a:	e1 f4       	brne	.+56     	; 0x8994 <PharseGetData+0x1a4>
			{
				http_request->GET_DATA[ i ] = '\0';
    895c:	10 82       	st	Z, r1
				if ( http_request->argc < MAX_HTTP_PARAMS )
    895e:	ec 91       	ld	r30, X
    8960:	ec 30       	cpi	r30, 0x0C	; 12
    8962:	c0 f4       	brcc	.+48     	; 0x8994 <PharseGetData+0x1a4>
				{
					http_request->argc++;
    8964:	ef 5f       	subi	r30, 0xFF	; 255
    8966:	ec 93       	st	X, r30
					i++;
    8968:	2f 5f       	subi	r18, 0xFF	; 255
    896a:	3f 4f       	sbci	r19, 0xFF	; 255
					http_request->argname[ http_request->argc - 1 ] = &http_request->GET_DATA[ i ];
    896c:	2f 53       	subi	r18, 0x3F	; 63
    896e:	3f 4f       	sbci	r19, 0xFF	; 255
    8970:	c8 01       	movw	r24, r16
    8972:	82 0f       	add	r24, r18
    8974:	93 1f       	adc	r25, r19
    8976:	21 5c       	subi	r18, 0xC1	; 193
    8978:	30 40       	sbci	r19, 0x00	; 0
    897a:	f0 e0       	ldi	r31, 0x00	; 0
    897c:	31 97       	sbiw	r30, 0x01	; 1
    897e:	ee 0f       	add	r30, r30
    8980:	ff 1f       	adc	r31, r31
    8982:	e0 0f       	add	r30, r16
    8984:	f1 1f       	adc	r31, r17
    8986:	e9 5b       	subi	r30, 0xB9	; 185
    8988:	fd 4f       	sbci	r31, 0xFD	; 253
    898a:	91 83       	std	Z+1, r25	; 0x01
    898c:	80 83       	st	Z, r24
					http_request->argvalue[ http_request->argc - 1 ] = &http_request->GET_DATA[ i ];
    898e:	78 96       	adiw	r30, 0x18	; 24
    8990:	91 83       	std	Z+1, r25	; 0x01
    8992:	80 83       	st	Z, r24
	{
		http_request->argc = 1;
		http_request->argname[ http_request->argc - 1 ] = &http_request->GET_DATA[ 0 ];
		http_request->argvalue[ http_request->argc - 1 ] = &http_request->GET_DATA[ 0 ];
		
		for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
    8994:	2f 5f       	subi	r18, 0xFF	; 255
    8996:	3f 4f       	sbci	r19, 0xFF	; 255
    8998:	20 3c       	cpi	r18, 0xC0	; 192
    899a:	31 05       	cpc	r19, r1
    899c:	bc f2       	brlt	.-82     	; 0x894c <PharseGetData+0x15c>
    899e:	d8 01       	movw	r26, r16
    89a0:	a9 5b       	subi	r26, 0xB9	; 185
    89a2:	bd 4f       	sbci	r27, 0xFD	; 253
    89a4:	60 e0       	ldi	r22, 0x00	; 0
    89a6:	70 e0       	ldi	r23, 0x00	; 0
					http_request->argvalue[ http_request->argc - 1 ] = &http_request->GET_DATA[ i ];
				}
			}
		}
		
		for ( i = 0 ; i < http_request->argc ; i++ )
    89a8:	0a 5b       	subi	r16, 0xBA	; 186
    89aa:	1d 4f       	sbci	r17, 0xFD	; 253
    89ac:	2e c0       	rjmp	.+92     	; 0x8a0a <PharseGetData+0x21a>
		{
			size = strlen( http_request->argname[ i ] );
    89ae:	8c 91       	ld	r24, X
    89b0:	11 96       	adiw	r26, 0x01	; 1
    89b2:	9c 91       	ld	r25, X
    89b4:	11 97       	sbiw	r26, 0x01	; 1
    89b6:	fc 01       	movw	r30, r24
    89b8:	01 90       	ld	r0, Z+
    89ba:	00 20       	and	r0, r0
    89bc:	e9 f7       	brne	.-6      	; 0x89b8 <PharseGetData+0x1c8>
    89be:	af 01       	movw	r20, r30
    89c0:	41 50       	subi	r20, 0x01	; 1
    89c2:	50 40       	sbci	r21, 0x00	; 0
    89c4:	48 1b       	sub	r20, r24
    89c6:	59 0b       	sbc	r21, r25
    89c8:	20 e0       	ldi	r18, 0x00	; 0
    89ca:	30 e0       	ldi	r19, 0x00	; 0
    89cc:	18 c0       	rjmp	.+48     	; 0x89fe <PharseGetData+0x20e>
			for ( x = 0 ; x < size ; x++ )
			{											 
				if ( http_request->argname[ i ][ x ] == '\0'  )
    89ce:	ed 91       	ld	r30, X+
    89d0:	fc 91       	ld	r31, X
    89d2:	11 97       	sbiw	r26, 0x01	; 1
    89d4:	e2 0f       	add	r30, r18
    89d6:	f3 1f       	adc	r31, r19
    89d8:	80 81       	ld	r24, Z
    89da:	88 23       	and	r24, r24
    89dc:	99 f0       	breq	.+38     	; 0x8a04 <PharseGetData+0x214>
					break;	
				else if ( http_request->argname[ i ][ x ] == '=' )
    89de:	8d 33       	cpi	r24, 0x3D	; 61
    89e0:	61 f4       	brne	.+24     	; 0x89fa <PharseGetData+0x20a>
				{
					http_request->argname[ i ][ x++ ] = '\0';
    89e2:	10 82       	st	Z, r1
    89e4:	2f 5f       	subi	r18, 0xFF	; 255
    89e6:	3f 4f       	sbci	r19, 0xFF	; 255
					http_request->argvalue[ i ] = &http_request->argname[ i ][ x ];
    89e8:	8d 91       	ld	r24, X+
    89ea:	9c 91       	ld	r25, X
    89ec:	11 97       	sbiw	r26, 0x01	; 1
    89ee:	82 0f       	add	r24, r18
    89f0:	93 1f       	adc	r25, r19
    89f2:	59 96       	adiw	r26, 0x19	; 25
    89f4:	9c 93       	st	X, r25
    89f6:	8e 93       	st	-X, r24
    89f8:	58 97       	sbiw	r26, 0x18	; 24
		}
		
		for ( i = 0 ; i < http_request->argc ; i++ )
		{
			size = strlen( http_request->argname[ i ] );
			for ( x = 0 ; x < size ; x++ )
    89fa:	2f 5f       	subi	r18, 0xFF	; 255
    89fc:	3f 4f       	sbci	r19, 0xFF	; 255
    89fe:	24 17       	cp	r18, r20
    8a00:	35 07       	cpc	r19, r21
    8a02:	2c f3       	brlt	.-54     	; 0x89ce <PharseGetData+0x1de>
					http_request->argvalue[ http_request->argc - 1 ] = &http_request->GET_DATA[ i ];
				}
			}
		}
		
		for ( i = 0 ; i < http_request->argc ; i++ )
    8a04:	6f 5f       	subi	r22, 0xFF	; 255
    8a06:	7f 4f       	sbci	r23, 0xFF	; 255
    8a08:	12 96       	adiw	r26, 0x02	; 2
    8a0a:	f8 01       	movw	r30, r16
    8a0c:	80 81       	ld	r24, Z
    8a0e:	90 e0       	ldi	r25, 0x00	; 0
    8a10:	68 17       	cp	r22, r24
    8a12:	79 07       	cpc	r23, r25
    8a14:	64 f2       	brlt	.-104    	; 0x89ae <PharseGetData+0x1be>
					http_request->argvalue[ i ] = &http_request->argname[ i ][ x ];
				}
			}	
		}
	}
}
    8a16:	25 96       	adiw	r28, 0x05	; 5
    8a18:	e1 e1       	ldi	r30, 0x11	; 17
    8a1a:	0c 94 d6 6a 	jmp	0xd5ac	; 0xd5ac <__epilogue_restores__+0x2>

00008a1e <PharseGetFile>:
 * \param 	pStruct	Pointer auf die Struktur die die HTTP zur체ck gibt
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void PharseGetFile( void * pStruct )
{
    8a1e:	a5 e0       	ldi	r26, 0x05	; 5
    8a20:	b0 e0       	ldi	r27, 0x00	; 0
    8a22:	e5 e1       	ldi	r30, 0x15	; 21
    8a24:	f5 e4       	ldi	r31, 0x45	; 69
    8a26:	0c 94 bd 6a 	jmp	0xd57a	; 0xd57a <__prologue_saves__+0x8>
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    8a2a:	7c 01       	movw	r14, r24
    8a2c:	fc 01       	movw	r30, r24
    8a2e:	ee 57       	subi	r30, 0x7E	; 126
    8a30:	fe 4f       	sbci	r31, 0xFE	; 254
    8a32:	20 e0       	ldi	r18, 0x00	; 0
    8a34:	30 e0       	ldi	r19, 0x00	; 0
	int i , x = 0;
	char * endp;
	
	
	for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
		if ( http_request->HTTP_LINEBUFFER[ i ] == '/' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
    8a36:	80 81       	ld	r24, Z
    8a38:	8f 32       	cpi	r24, 0x2F	; 47
    8a3a:	49 f0       	breq	.+18     	; 0x8a4e <PharseGetFile+0x30>
    8a3c:	88 23       	and	r24, r24
    8a3e:	39 f0       	breq	.+14     	; 0x8a4e <PharseGetFile+0x30>

	int i , x = 0;
	char * endp;
	
	
	for ( i = 0 ; i < REQUEST_BUFFERLEN ; i++ )
    8a40:	2f 5f       	subi	r18, 0xFF	; 255
    8a42:	3f 4f       	sbci	r19, 0xFF	; 255
    8a44:	31 96       	adiw	r30, 0x01	; 1
    8a46:	20 3c       	cpi	r18, 0xC0	; 192
    8a48:	31 05       	cpc	r19, r1
    8a4a:	a9 f7       	brne	.-22     	; 0x8a36 <PharseGetFile+0x18>
    8a4c:	68 c0       	rjmp	.+208    	; 0x8b1e <PharseGetFile+0x100>
void PharseGetFile( void * pStruct )
{
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
	
	char buffer[3] = "00";
    8a4e:	de 01       	movw	r26, r28
    8a50:	13 96       	adiw	r26, 0x03	; 3
    8a52:	e4 e2       	ldi	r30, 0x24	; 36
    8a54:	f1 e0       	ldi	r31, 0x01	; 1
    8a56:	83 e0       	ldi	r24, 0x03	; 3
    8a58:	01 90       	ld	r0, Z+
    8a5a:	0d 92       	st	X+, r0
    8a5c:	81 50       	subi	r24, 0x01	; 1
    8a5e:	e1 f7       	brne	.-8      	; 0x8a58 <PharseGetFile+0x3a>
		if ( http_request->HTTP_LINEBUFFER[ i ] == '/' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
			break;
	
	if ( i == REQUEST_BUFFERLEN ) return;
	
	i++;
    8a60:	89 01       	movw	r16, r18
    8a62:	0f 5f       	subi	r16, 0xFF	; 255
    8a64:	1f 4f       	sbci	r17, 0xFF	; 255
    8a66:	67 01       	movw	r12, r14
    8a68:	a1 e0       	ldi	r26, 0x01	; 1
    8a6a:	aa 2e       	mov	r10, r26
    8a6c:	b1 2c       	mov	r11, r1
		{
			i++;
			buffer[0] = http_request->HTTP_LINEBUFFER[ i ];
			i++;
			buffer[1] = http_request->HTTP_LINEBUFFER[ i ];
			http_request->GET_FILE[ x++ ] = ( char ) strtol( buffer, &endp , 16 );			
    8a6e:	f3 e0       	ldi	r31, 0x03	; 3
    8a70:	6f 2e       	mov	r6, r31
    8a72:	71 2c       	mov	r7, r1
    8a74:	6c 0e       	add	r6, r28
    8a76:	7d 1e       	adc	r7, r29
    8a78:	4e 01       	movw	r8, r28
    8a7a:	08 94       	sec
    8a7c:	81 1c       	adc	r8, r1
    8a7e:	91 1c       	adc	r9, r1
    8a80:	3b c0       	rjmp	.+118    	; 0x8af8 <PharseGetFile+0xda>
	
	i++;
	
	for ( ; ( i < REQUEST_BUFFERLEN ) && ( x < REQUEST_BUFFERLEN_FILE ) ; i++)
	{
		if ( http_request->HTTP_LINEBUFFER[ i ] == ' ' ||  http_request->HTTP_LINEBUFFER[ i ] == '?' || http_request->HTTP_LINEBUFFER[ i ] == '\0' )
    8a82:	f7 01       	movw	r30, r14
    8a84:	e0 0f       	add	r30, r16
    8a86:	f1 1f       	adc	r31, r17
    8a88:	ee 57       	subi	r30, 0x7E	; 126
    8a8a:	fe 4f       	sbci	r31, 0xFE	; 254
    8a8c:	e0 81       	ld	r30, Z
    8a8e:	e0 32       	cpi	r30, 0x20	; 32
    8a90:	21 f0       	breq	.+8      	; 0x8a9a <PharseGetFile+0x7c>
    8a92:	ef 33       	cpi	r30, 0x3F	; 63
    8a94:	11 f0       	breq	.+4      	; 0x8a9a <PharseGetFile+0x7c>
    8a96:	ee 23       	and	r30, r30
    8a98:	21 f4       	brne	.+8      	; 0x8aa2 <PharseGetFile+0x84>
		{
			http_request->GET_FILE[ x++ ] = '\0';
    8a9a:	ae 0d       	add	r26, r14
    8a9c:	bf 1d       	adc	r27, r15
    8a9e:	1c 92       	st	X, r1
    8aa0:	35 c0       	rjmp	.+106    	; 0x8b0c <PharseGetFile+0xee>
			break;
		}
		else if ( http_request->HTTP_LINEBUFFER[ i ] == '%' )
    8aa2:	e5 32       	cpi	r30, 0x25	; 37
    8aa4:	e9 f4       	brne	.+58     	; 0x8ae0 <PharseGetFile+0xc2>
		{
			i++;
    8aa6:	98 01       	movw	r18, r16
    8aa8:	2f 5f       	subi	r18, 0xFF	; 255
    8aaa:	3f 4f       	sbci	r19, 0xFF	; 255
			buffer[0] = http_request->HTTP_LINEBUFFER[ i ];
    8aac:	f7 01       	movw	r30, r14
    8aae:	e2 0f       	add	r30, r18
    8ab0:	f3 1f       	adc	r31, r19
    8ab2:	ee 57       	subi	r30, 0x7E	; 126
    8ab4:	fe 4f       	sbci	r31, 0xFE	; 254
    8ab6:	80 81       	ld	r24, Z
    8ab8:	8b 83       	std	Y+3, r24	; 0x03
			i++;
    8aba:	89 01       	movw	r16, r18
    8abc:	0f 5f       	subi	r16, 0xFF	; 255
    8abe:	1f 4f       	sbci	r17, 0xFF	; 255
			buffer[1] = http_request->HTTP_LINEBUFFER[ i ];
    8ac0:	f7 01       	movw	r30, r14
    8ac2:	e0 0f       	add	r30, r16
    8ac4:	f1 1f       	adc	r31, r17
    8ac6:	ee 57       	subi	r30, 0x7E	; 126
    8ac8:	fe 4f       	sbci	r31, 0xFE	; 254
    8aca:	80 81       	ld	r24, Z
    8acc:	8c 83       	std	Y+4, r24	; 0x04
			http_request->GET_FILE[ x++ ] = ( char ) strtol( buffer, &endp , 16 );			
    8ace:	c3 01       	movw	r24, r6
    8ad0:	b4 01       	movw	r22, r8
    8ad2:	40 e1       	ldi	r20, 0x10	; 16
    8ad4:	50 e0       	ldi	r21, 0x00	; 0
    8ad6:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <strtol>
    8ada:	d6 01       	movw	r26, r12
    8adc:	6c 93       	st	X, r22
    8ade:	04 c0       	rjmp	.+8      	; 0x8ae8 <PharseGetFile+0xca>
//			http_request->GET_FILE[ x++ ] = ( char ) strtol( &http_request->HTTP_LINEBUFFER[ i ], &endp , 16 );
//			i++;
		}
		else
		{
			http_request->GET_FILE[ x++ ] = http_request->HTTP_LINEBUFFER[ i ];											
    8ae0:	d6 01       	movw	r26, r12
    8ae2:	ec 93       	st	X, r30
			http_request->GET_FILE[ x ] = '\0';
    8ae4:	11 96       	adiw	r26, 0x01	; 1
    8ae6:	1c 92       	st	X, r1
	
	if ( i == REQUEST_BUFFERLEN ) return;
	
	i++;
	
	for ( ; ( i < REQUEST_BUFFERLEN ) && ( x < REQUEST_BUFFERLEN_FILE ) ; i++)
    8ae8:	0f 5f       	subi	r16, 0xFF	; 255
    8aea:	1f 4f       	sbci	r17, 0xFF	; 255
    8aec:	08 94       	sec
    8aee:	a1 1c       	adc	r10, r1
    8af0:	b1 1c       	adc	r11, r1
    8af2:	08 94       	sec
    8af4:	c1 1c       	adc	r12, r1
    8af6:	d1 1c       	adc	r13, r1
    8af8:	d5 01       	movw	r26, r10
    8afa:	11 97       	sbiw	r26, 0x01	; 1
    8afc:	00 3c       	cpi	r16, 0xC0	; 192
    8afe:	11 05       	cpc	r17, r1
    8b00:	2c f4       	brge	.+10     	; 0x8b0c <PharseGetFile+0xee>
    8b02:	e1 ec       	ldi	r30, 0xC1	; 193
    8b04:	ae 16       	cp	r10, r30
    8b06:	b1 04       	cpc	r11, r1
    8b08:	09 f0       	breq	.+2      	; 0x8b0c <PharseGetFile+0xee>
    8b0a:	bb cf       	rjmp	.-138    	; 0x8a82 <PharseGetFile+0x64>
			http_request->GET_FILE[ x++ ] = http_request->HTTP_LINEBUFFER[ i ];											
			http_request->GET_FILE[ x ] = '\0';
		}
	}
	
	if ( http_request->GET_FILE[ 0 ] == '\0' ) strcpy_P( http_request->GET_FILE, PSTR("index.html") );
    8b0c:	d7 01       	movw	r26, r14
    8b0e:	8c 91       	ld	r24, X
    8b10:	88 23       	and	r24, r24
    8b12:	29 f4       	brne	.+10     	; 0x8b1e <PharseGetFile+0x100>
    8b14:	c7 01       	movw	r24, r14
    8b16:	60 ee       	ldi	r22, 0xE0	; 224
    8b18:	73 e0       	ldi	r23, 0x03	; 3
    8b1a:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
}
    8b1e:	25 96       	adiw	r28, 0x05	; 5
    8b20:	ee e0       	ldi	r30, 0x0E	; 14
    8b22:	0c 94 d9 6a 	jmp	0xd5b2	; 0xd5b2 <__epilogue_restores__+0x8>

00008b26 <cgi_init>:
/*------------------------------------------------------------------------------------------------------------*/
/*!\brief Initialisiert das CGI-BIN Modul
 */
/*------------------------------------------------------------------------------------------------------------*/
void cgi_init( void )
{
    8b26:	80 e0       	ldi	r24, 0x00	; 0
    8b28:	90 e0       	ldi	r25, 0x00	; 0
	int i;

	for ( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
	{
		cgi_table[ i ].dyncgi_function = NULL;
    8b2a:	fc 01       	movw	r30, r24
    8b2c:	ee 0f       	add	r30, r30
    8b2e:	ff 1f       	adc	r31, r31
    8b30:	ee 0f       	add	r30, r30
    8b32:	ff 1f       	adc	r31, r31
    8b34:	e8 50       	subi	r30, 0x08	; 8
    8b36:	f5 4f       	sbci	r31, 0xF5	; 245
    8b38:	11 82       	std	Z+1, r1	; 0x01
    8b3a:	10 82       	st	Z, r1
/*------------------------------------------------------------------------------------------------------------*/
void cgi_init( void )
{
	int i;

	for ( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
    8b3c:	01 96       	adiw	r24, 0x01	; 1
    8b3e:	80 31       	cpi	r24, 0x10	; 16
    8b40:	91 05       	cpc	r25, r1
    8b42:	99 f7       	brne	.-26     	; 0x8b2a <cgi_init+0x4>
	{
		cgi_table[ i ].dyncgi_function = NULL;
	}
}
    8b44:	08 95       	ret

00008b46 <cgi_RegisterCGI>:
 * \param	funktionname		Pointer auf den Namen im Flash unter der das CGI aufgerufen wird
 * \returns	-1 Failed, 1 CGI eingtragen
 */
/*------------------------------------------------------------------------------------------------------------*/
int cgi_RegisterCGI( DYN_CGI_CALLBACK dyncgi_function, const prog_char * funktionname )
{
    8b46:	9c 01       	movw	r18, r24
    8b48:	e0 e0       	ldi	r30, 0x00	; 0
    8b4a:	f0 e0       	ldi	r31, 0x00	; 0

	retval = -1;
	
	for ( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
	{
		if ( cgi_table[ i ].dyncgi_function == dyncgi_function )
    8b4c:	df 01       	movw	r26, r30
    8b4e:	aa 0f       	add	r26, r26
    8b50:	bb 1f       	adc	r27, r27
    8b52:	aa 0f       	add	r26, r26
    8b54:	bb 1f       	adc	r27, r27
    8b56:	a8 50       	subi	r26, 0x08	; 8
    8b58:	b5 4f       	sbci	r27, 0xF5	; 245
    8b5a:	8d 91       	ld	r24, X+
    8b5c:	9c 91       	ld	r25, X
    8b5e:	11 97       	sbiw	r26, 0x01	; 1
    8b60:	82 17       	cp	r24, r18
    8b62:	93 07       	cpc	r25, r19
    8b64:	b9 f0       	breq	.+46     	; 0x8b94 <cgi_RegisterCGI+0x4e>
			break;
		
		if ( cgi_table[ i ].dyncgi_function == NULL )
    8b66:	8d 91       	ld	r24, X+
    8b68:	9c 91       	ld	r25, X
    8b6a:	11 97       	sbiw	r26, 0x01	; 1
    8b6c:	89 2b       	or	r24, r25
    8b6e:	71 f4       	brne	.+28     	; 0x8b8c <cgi_RegisterCGI+0x46>
		{
			cgi_table[ i ].dyncgi_function = dyncgi_function;			
    8b70:	11 96       	adiw	r26, 0x01	; 1
    8b72:	3c 93       	st	X, r19
    8b74:	2e 93       	st	-X, r18
			cgi_table[ i ].funktionname = funktionname;
    8b76:	ee 0f       	add	r30, r30
    8b78:	ff 1f       	adc	r31, r31
    8b7a:	ee 0f       	add	r30, r30
    8b7c:	ff 1f       	adc	r31, r31
    8b7e:	e6 50       	subi	r30, 0x06	; 6
    8b80:	f5 4f       	sbci	r31, 0xF5	; 245
    8b82:	71 83       	std	Z+1, r23	; 0x01
    8b84:	60 83       	st	Z, r22
    8b86:	20 e0       	ldi	r18, 0x00	; 0
    8b88:	30 e0       	ldi	r19, 0x00	; 0
    8b8a:	06 c0       	rjmp	.+12     	; 0x8b98 <cgi_RegisterCGI+0x52>
{
	int i,retval;

	retval = -1;
	
	for ( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
    8b8c:	31 96       	adiw	r30, 0x01	; 1
    8b8e:	e0 31       	cpi	r30, 0x10	; 16
    8b90:	f1 05       	cpc	r31, r1
    8b92:	e1 f6       	brne	.-72     	; 0x8b4c <cgi_RegisterCGI+0x6>
    8b94:	2f ef       	ldi	r18, 0xFF	; 255
    8b96:	3f ef       	ldi	r19, 0xFF	; 255
			retval = 0;
			break;
		}
	}
	return( retval );
}
    8b98:	c9 01       	movw	r24, r18
    8b9a:	08 95       	ret

00008b9c <cgi_PrintHttpheaderEnd>:
					"<BODY>"));
}

void cgi_PrintHttpheaderEnd( void )
{
	printf_P( PSTR(	"</BODY>"
    8b9c:	00 d0       	rcall	.+0      	; 0x8b9e <cgi_PrintHttpheaderEnd+0x2>
    8b9e:	8b ee       	ldi	r24, 0xEB	; 235
    8ba0:	93 e0       	ldi	r25, 0x03	; 3
    8ba2:	ed b7       	in	r30, 0x3d	; 61
    8ba4:	fe b7       	in	r31, 0x3e	; 62
    8ba6:	92 83       	std	Z+2, r25	; 0x02
    8ba8:	81 83       	std	Z+1, r24	; 0x01
    8baa:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    8bae:	0f 90       	pop	r0
    8bb0:	0f 90       	pop	r0
					"</HTML>"
					"\r\n\r\n"));
}
    8bb2:	08 95       	ret

00008bb4 <cgi_PrintHttpheaderStart>:
	return( returnvalue );
}	

void cgi_PrintHttpheaderStart( void )
{
	printf_P( PSTR(	"<HTML>"
    8bb4:	00 d0       	rcall	.+0      	; 0x8bb6 <cgi_PrintHttpheaderStart+0x2>
    8bb6:	8e ef       	ldi	r24, 0xFE	; 254
    8bb8:	93 e0       	ldi	r25, 0x03	; 3
    8bba:	ed b7       	in	r30, 0x3d	; 61
    8bbc:	fe b7       	in	r31, 0x3e	; 62
    8bbe:	92 83       	std	Z+2, r25	; 0x02
    8bc0:	81 83       	std	Z+1, r24	; 0x01
    8bc2:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    8bc6:	0f 90       	pop	r0
    8bc8:	0f 90       	pop	r0
					"<HEAD>"
					"</HEAD>"
					"<BODY>"));
}
    8bca:	08 95       	ret

00008bcc <check_cgibin>:
 * \param 	pStruct		Pointer auf Struktur auf den HTTP_Request
 * \returns	-1 Failed, 1 CGI gefunden
 */
/*------------------------------------------------------------------------------------------------------------*/
int check_cgibin( void * pStruct )
{
    8bcc:	ef 92       	push	r14
    8bce:	ff 92       	push	r15
    8bd0:	0f 93       	push	r16
    8bd2:	1f 93       	push	r17
    8bd4:	cf 93       	push	r28
    8bd6:	df 93       	push	r29
    8bd8:	f8 2e       	mov	r15, r24
    8bda:	e9 2e       	mov	r14, r25
	for( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
	{
		if ( cgi_table[ i ].funktionname == NULL )
			break;
		
		if ( !strcmp_P( http_request->GET_FILE, cgi_table[ i ].funktionname ) )
    8bdc:	0a ef       	ldi	r16, 0xFA	; 250
    8bde:	1a e0       	ldi	r17, 0x0A	; 10
    8be0:	c0 e0       	ldi	r28, 0x00	; 0
    8be2:	d0 e0       	ldi	r29, 0x00	; 0
	
	int i, returnvalue = -1;
	
	for( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
	{
		if ( cgi_table[ i ].funktionname == NULL )
    8be4:	f8 01       	movw	r30, r16
    8be6:	60 81       	ld	r22, Z
    8be8:	71 81       	ldd	r23, Z+1	; 0x01
    8bea:	61 15       	cp	r22, r1
    8bec:	71 05       	cpc	r23, r1
    8bee:	29 f1       	breq	.+74     	; 0x8c3a <check_cgibin+0x6e>
			break;
		
		if ( !strcmp_P( http_request->GET_FILE, cgi_table[ i ].funktionname ) )
    8bf0:	8f 2d       	mov	r24, r15
    8bf2:	9e 2d       	mov	r25, r14
    8bf4:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    8bf8:	89 2b       	or	r24, r25
    8bfa:	c9 f4       	brne	.+50     	; 0x8c2e <check_cgibin+0x62>
		{
			printf_P( PSTR(		"HTTP/1.0 200 Document follows\r\n"
    8bfc:	00 d0       	rcall	.+0      	; 0x8bfe <check_cgibin+0x32>
    8bfe:	88 e1       	ldi	r24, 0x18	; 24
    8c00:	94 e0       	ldi	r25, 0x04	; 4
    8c02:	ed b7       	in	r30, 0x3d	; 61
    8c04:	fe b7       	in	r31, 0x3e	; 62
    8c06:	92 83       	std	Z+2, r25	; 0x02
    8c08:	81 83       	std	Z+1, r24	; 0x01
    8c0a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
								"Content-Type: text/html\r\n"
								"Keep-Alive: timeout=1, max=5\r\n"
								"Connection: close\r\n"
								"\r\n"));
//			STDOUT_Flush();
			cgi_table[ i ].dyncgi_function( http_request );
    8c0e:	cc 0f       	add	r28, r28
    8c10:	dd 1f       	adc	r29, r29
    8c12:	cc 0f       	add	r28, r28
    8c14:	dd 1f       	adc	r29, r29
    8c16:	c8 50       	subi	r28, 0x08	; 8
    8c18:	d5 4f       	sbci	r29, 0xF5	; 245
    8c1a:	e8 81       	ld	r30, Y
    8c1c:	f9 81       	ldd	r31, Y+1	; 0x01
    8c1e:	0f 90       	pop	r0
    8c20:	0f 90       	pop	r0
    8c22:	8f 2d       	mov	r24, r15
    8c24:	9e 2d       	mov	r25, r14
    8c26:	09 95       	icall
    8c28:	21 e0       	ldi	r18, 0x01	; 1
    8c2a:	30 e0       	ldi	r19, 0x00	; 0
    8c2c:	08 c0       	rjmp	.+16     	; 0x8c3e <check_cgibin+0x72>
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
	
	int i, returnvalue = -1;
	
	for( i = 0 ; i < MAX_CGI_ENTRYS ; i++ )
    8c2e:	21 96       	adiw	r28, 0x01	; 1
    8c30:	0c 5f       	subi	r16, 0xFC	; 252
    8c32:	1f 4f       	sbci	r17, 0xFF	; 255
    8c34:	c0 31       	cpi	r28, 0x10	; 16
    8c36:	d1 05       	cpc	r29, r1
    8c38:	a9 f6       	brne	.-86     	; 0x8be4 <check_cgibin+0x18>
    8c3a:	2f ef       	ldi	r18, 0xFF	; 255
    8c3c:	3f ef       	ldi	r19, 0xFF	; 255
			returnvalue = 1 ;
			break;
		}
	}
	return( returnvalue );
}	
    8c3e:	c9 01       	movw	r24, r18
    8c40:	cd b7       	in	r28, 0x3d	; 61
    8c42:	de b7       	in	r29, 0x3e	; 62
    8c44:	e6 e0       	ldi	r30, 0x06	; 6
    8c46:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

00008c4a <check_files>:
 * \param 	pStruct		Pointer auf die HTTP Struktur.
 * \return	returncode	-1 Failed, 1 OK, File gefunden
 */
/*------------------------------------------------------------------------------------------------------------*/
int check_files( void * pStruct )
{
    8c4a:	a6 e9       	ldi	r26, 0x96	; 150
    8c4c:	b0 e0       	ldi	r27, 0x00	; 0
    8c4e:	eb e2       	ldi	r30, 0x2B	; 43
    8c50:	f6 e4       	ldi	r31, 0x46	; 70
    8c52:	0c 94 bd 6a 	jmp	0xd57a	; 0xd57a <__prologue_saves__+0x8>
    8c56:	99 2e       	mov	r9, r25

	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    8c58:	c8 2e       	mov	r12, r24
    8c5a:	d9 2e       	mov	r13, r25
		for( i = 0 ; i < MAX_FILES_ENTRYS ; i++ )
		{
			if ( files[ i ].len == 0 )
			break;
			
			if ( !strcmp_P( http_request->GET_FILE, files[ i ].filesname ) )
    8c5c:	78 2e       	mov	r7, r24
    8c5e:	69 2e       	mov	r6, r25
    8c60:	09 e7       	ldi	r16, 0x79	; 121
    8c62:	11 e0       	ldi	r17, 0x01	; 1
    8c64:	ee 24       	eor	r14, r14
    8c66:	ff 24       	eor	r15, r15
	STDOUT_restore( &oldstream );
#endif

		for( i = 0 ; i < MAX_FILES_ENTRYS ; i++ )
		{
			if ( files[ i ].len == 0 )
    8c68:	f8 01       	movw	r30, r16
    8c6a:	a5 80       	ldd	r10, Z+5	; 0x05
    8c6c:	b6 80       	ldd	r11, Z+6	; 0x06
    8c6e:	a1 14       	cp	r10, r1
    8c70:	b1 04       	cpc	r11, r1
    8c72:	09 f4       	brne	.+2      	; 0x8c76 <check_files+0x2c>
    8c74:	6f c0       	rjmp	.+222    	; 0x8d54 <check_files+0x10a>
			break;
			
			if ( !strcmp_P( http_request->GET_FILE, files[ i ].filesname ) )
    8c76:	60 81       	ld	r22, Z
    8c78:	71 81       	ldd	r23, Z+1	; 0x01
    8c7a:	87 2d       	mov	r24, r7
    8c7c:	99 2d       	mov	r25, r9
    8c7e:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    8c82:	89 2b       	or	r24, r25
    8c84:	09 f0       	breq	.+2      	; 0x8c88 <check_files+0x3e>
    8c86:	5c c0       	rjmp	.+184    	; 0x8d40 <check_files+0xf6>
			{
				printf_P( PSTR("HTTP/1.0 200 Document follows\r\n"
    8c88:	00 d0       	rcall	.+0      	; 0x8c8a <check_files+0x40>
    8c8a:	80 ee       	ldi	r24, 0xE0	; 224
    8c8c:	90 e1       	ldi	r25, 0x10	; 16
    8c8e:	ed b7       	in	r30, 0x3d	; 61
    8c90:	fe b7       	in	r31, 0x3e	; 62
    8c92:	92 83       	std	Z+2, r25	; 0x02
    8c94:	81 83       	std	Z+1, r24	; 0x01
    8c96:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
							   "Content-Type: ") );
	
				switch ( files[ i ].filestype )
    8c9a:	0f 90       	pop	r0
    8c9c:	0f 90       	pop	r0
    8c9e:	f7 01       	movw	r30, r14
    8ca0:	43 e0       	ldi	r20, 0x03	; 3
    8ca2:	ee 0f       	add	r30, r30
    8ca4:	ff 1f       	adc	r31, r31
    8ca6:	4a 95       	dec	r20
    8ca8:	e1 f7       	brne	.-8      	; 0x8ca2 <check_files+0x58>
    8caa:	ee 19       	sub	r30, r14
    8cac:	ff 09       	sbc	r31, r15
    8cae:	e7 58       	subi	r30, 0x87	; 135
    8cb0:	fe 4f       	sbci	r31, 0xFE	; 254
    8cb2:	84 81       	ldd	r24, Z+4	; 0x04
    8cb4:	81 30       	cpi	r24, 0x01	; 1
    8cb6:	41 f0       	breq	.+16     	; 0x8cc8 <check_files+0x7e>
    8cb8:	81 30       	cpi	r24, 0x01	; 1
    8cba:	50 f0       	brcs	.+20     	; 0x8cd0 <check_files+0x86>
    8cbc:	82 30       	cpi	r24, 0x02	; 2
    8cbe:	61 f4       	brne	.+24     	; 0x8cd8 <check_files+0x8e>
				{
					case PNG:					printf_P( PSTR("png") );
    8cc0:	00 d0       	rcall	.+0      	; 0x8cc2 <check_files+0x78>
    8cc2:	8c ed       	ldi	r24, 0xDC	; 220
    8cc4:	90 e1       	ldi	r25, 0x10	; 16
    8cc6:	0b c0       	rjmp	.+22     	; 0x8cde <check_files+0x94>
												break;
					case JPEG:					printf_P( PSTR("jpeg") );
    8cc8:	00 d0       	rcall	.+0      	; 0x8cca <check_files+0x80>
    8cca:	87 ed       	ldi	r24, 0xD7	; 215
    8ccc:	90 e1       	ldi	r25, 0x10	; 16
    8cce:	07 c0       	rjmp	.+14     	; 0x8cde <check_files+0x94>
												break;
					case TEXT:					printf_P( PSTR("text/html") );
    8cd0:	00 d0       	rcall	.+0      	; 0x8cd2 <check_files+0x88>
    8cd2:	8d ec       	ldi	r24, 0xCD	; 205
    8cd4:	90 e1       	ldi	r25, 0x10	; 16
    8cd6:	03 c0       	rjmp	.+6      	; 0x8cde <check_files+0x94>
												break;
					default:					printf_P( PSTR("bin") );
    8cd8:	00 d0       	rcall	.+0      	; 0x8cda <check_files+0x90>
    8cda:	89 ec       	ldi	r24, 0xC9	; 201
    8cdc:	90 e1       	ldi	r25, 0x10	; 16
    8cde:	ed b7       	in	r30, 0x3d	; 61
    8ce0:	fe b7       	in	r31, 0x3e	; 62
    8ce2:	92 83       	std	Z+2, r25	; 0x02
    8ce4:	81 83       	std	Z+1, r24	; 0x01
    8ce6:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    8cea:	00 d0       	rcall	.+0      	; 0x8cec <check_files+0xa2>
				}
		
				printf_P( PSTR(	"\r\n"
    8cec:	80 e8       	ldi	r24, 0x80	; 128
    8cee:	90 e1       	ldi	r25, 0x10	; 16
    8cf0:	ed b7       	in	r30, 0x3d	; 61
    8cf2:	fe b7       	in	r31, 0x3e	; 62
    8cf4:	92 83       	std	Z+2, r25	; 0x02
    8cf6:	81 83       	std	Z+1, r24	; 0x01
    8cf8:	b4 82       	std	Z+4, r11	; 0x04
    8cfa:	a3 82       	std	Z+3, r10	; 0x03
    8cfc:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
				               	"Content-Length: %d\r\n"
							    "Cache-Control: max-age=3600\r\n"
								"Connection: close\r\n"
								"\r\n" ), files[ i ].len );
	
				STDOUT_Flush();
    8d00:	0f 90       	pop	r0
    8d02:	0f 90       	pop	r0
    8d04:	0f 90       	pop	r0
    8d06:	0f 90       	pop	r0
    8d08:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
				
				filesize = files[ i ].len;
				PutSocketData_RPE( http_request->HTTP_SOCKET, files[ i ].len, ( void * ) files[ i ].files, FLASH );
    8d0c:	8d e7       	ldi	r24, 0x7D	; 125
    8d0e:	92 e0       	ldi	r25, 0x02	; 2
    8d10:	c8 0e       	add	r12, r24
    8d12:	d9 1e       	adc	r13, r25
    8d14:	f7 01       	movw	r30, r14
    8d16:	33 e0       	ldi	r19, 0x03	; 3
    8d18:	ee 0f       	add	r30, r30
    8d1a:	ff 1f       	adc	r31, r31
    8d1c:	3a 95       	dec	r19
    8d1e:	e1 f7       	brne	.-8      	; 0x8d18 <check_files+0xce>
    8d20:	ee 19       	sub	r30, r14
    8d22:	ff 09       	sbc	r31, r15
    8d24:	e7 58       	subi	r30, 0x87	; 135
    8d26:	fe 4f       	sbci	r31, 0xFE	; 254
    8d28:	42 81       	ldd	r20, Z+2	; 0x02
    8d2a:	53 81       	ldd	r21, Z+3	; 0x03
    8d2c:	f6 01       	movw	r30, r12
    8d2e:	80 81       	ld	r24, Z
    8d30:	91 81       	ldd	r25, Z+1	; 0x01
    8d32:	b5 01       	movw	r22, r10
    8d34:	21 e0       	ldi	r18, 0x01	; 1
    8d36:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <PutSocketData_RPE>
    8d3a:	01 e0       	ldi	r16, 0x01	; 1
    8d3c:	10 e0       	ldi	r17, 0x00	; 0
    8d3e:	e0 c0       	rjmp	.+448    	; 0x8f00 <check_files+0x2b6>
	
	STDOUT_Flush();
	STDOUT_restore( &oldstream );
#endif

		for( i = 0 ; i < MAX_FILES_ENTRYS ; i++ )
    8d40:	08 94       	sec
    8d42:	e1 1c       	adc	r14, r1
    8d44:	f1 1c       	adc	r15, r1
    8d46:	09 5f       	subi	r16, 0xF9	; 249
    8d48:	1f 4f       	sbci	r17, 0xFF	; 255
    8d4a:	f0 e2       	ldi	r31, 0x20	; 32
    8d4c:	ef 16       	cp	r14, r31
    8d4e:	f1 04       	cpc	r15, r1
    8d50:	09 f0       	breq	.+2      	; 0x8d54 <check_files+0x10a>
    8d52:	8a cf       	rjmp	.-236    	; 0x8c68 <check_files+0x1e>
#ifdef MMC
	if ( returnvalue == -1 )
	{

		// Filename und Verzeichniss trennen
		for( i = strlen( http_request->GET_FILE ) ; i > 0 ; i-- )
    8d54:	e7 2d       	mov	r30, r7
    8d56:	f9 2d       	mov	r31, r9
    8d58:	df 01       	movw	r26, r30
    8d5a:	0d 90       	ld	r0, X+
    8d5c:	00 20       	and	r0, r0
    8d5e:	e9 f7       	brne	.-6      	; 0x8d5a <check_files+0x110>
    8d60:	11 97       	sbiw	r26, 0x01	; 1
    8d62:	ae 1b       	sub	r26, r30
    8d64:	bf 0b       	sbc	r27, r31
    8d66:	f6 01       	movw	r30, r12
    8d68:	ea 0f       	add	r30, r26
    8d6a:	fb 1f       	adc	r31, r27
    8d6c:	0f c0       	rjmp	.+30     	; 0x8d8c <check_files+0x142>
		{
			if ( http_request->GET_FILE[ i ] == '/' )
    8d6e:	80 81       	ld	r24, Z
    8d70:	31 97       	sbiw	r30, 0x01	; 1
    8d72:	8f 32       	cpi	r24, 0x2F	; 47
    8d74:	51 f4       	brne	.+20     	; 0x8d8a <check_files+0x140>
			{
				http_request->GET_FILE[ i ] = '\0';
    8d76:	f6 01       	movw	r30, r12
    8d78:	ea 0f       	add	r30, r26
    8d7a:	fb 1f       	adc	r31, r27
    8d7c:	10 82       	st	Z, r1
				filename = &http_request->GET_FILE[ i + 1 ];
    8d7e:	8d 01       	movw	r16, r26
    8d80:	0f 5f       	subi	r16, 0xFF	; 255
    8d82:	1f 4f       	sbci	r17, 0xFF	; 255
    8d84:	0c 0d       	add	r16, r12
    8d86:	1d 1d       	adc	r17, r13
    8d88:	12 c0       	rjmp	.+36     	; 0x8dae <check_files+0x164>
#ifdef MMC
	if ( returnvalue == -1 )
	{

		// Filename und Verzeichniss trennen
		for( i = strlen( http_request->GET_FILE ) ; i > 0 ; i-- )
    8d8a:	11 97       	sbiw	r26, 0x01	; 1
    8d8c:	1a 16       	cp	r1, r26
    8d8e:	1b 06       	cpc	r1, r27
    8d90:	74 f3       	brlt	.-36     	; 0x8d6e <check_files+0x124>
	
	    struct fat_dir_entry_struct directory;
		struct fat_dir_struct* dd;

		// Wenn nur filename dann Stammverzeichniss w채hlen, wenn nicht Verzeichnis w채hlen
		if ( i == 0 )
    8d92:	ab 2b       	or	r26, r27
    8d94:	61 f4       	brne	.+24     	; 0x8dae <check_files+0x164>
		{
        	fat_get_dir_entry_of_path(fs, "/" , &directory);
    8d96:	80 91 ed 0b 	lds	r24, 0x0BED
    8d9a:	90 91 ee 0b 	lds	r25, 0x0BEE
    8d9e:	67 e2       	ldi	r22, 0x27	; 39
    8da0:	71 e0       	ldi	r23, 0x01	; 1
    8da2:	ae 01       	movw	r20, r28
    8da4:	4f 5f       	subi	r20, 0xFF	; 255
    8da6:	5f 4f       	sbci	r21, 0xFF	; 255
    8da8:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>
    8dac:	0d c0       	rjmp	.+26     	; 0x8dc8 <check_files+0x17e>
			filename = http_request->GET_FILE;
		}
		else	
		{
			fat_get_dir_entry_of_path(fs, http_request->GET_FILE , &directory);
    8dae:	80 91 ed 0b 	lds	r24, 0x0BED
    8db2:	90 91 ee 0b 	lds	r25, 0x0BEE
    8db6:	67 2d       	mov	r22, r7
    8db8:	79 2d       	mov	r23, r9
    8dba:	ae 01       	movw	r20, r28
    8dbc:	4f 5f       	subi	r20, 0xFF	; 255
    8dbe:	5f 4f       	sbci	r21, 0xFF	; 255
    8dc0:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>
    8dc4:	70 2e       	mov	r7, r16
    8dc6:	61 2e       	mov	r6, r17
		}

		// Verzeichbnis 철ffnen
		dd = fat_open_dir(fs, &directory);
    8dc8:	80 91 ed 0b 	lds	r24, 0x0BED
    8dcc:	90 91 ee 0b 	lds	r25, 0x0BEE
    8dd0:	be 01       	movw	r22, r28
    8dd2:	6f 5f       	subi	r22, 0xFF	; 255
    8dd4:	7f 4f       	sbci	r23, 0xFF	; 255
    8dd6:	0e 94 c0 66 	call	0xcd80	; 0xcd80 <fat_open_dir>
    8dda:	4c 01       	movw	r8, r24
		if(dd)
    8ddc:	00 97       	sbiw	r24, 0x00	; 0
    8dde:	c9 f4       	brne	.+50     	; 0x8e12 <check_files+0x1c8>
    8de0:	8a c0       	rjmp	.+276    	; 0x8ef6 <check_files+0x2ac>

			struct fat_dir_entry_struct dir_entry;
			// Verzeichniss inhalt lesen und Datei suchen
			while(fat_read_dir(dd, &dir_entry))
		    {
		        if(strcmp( dir_entry.long_name, filename ) == 0)
    8de2:	c5 01       	movw	r24, r10
    8de4:	67 2d       	mov	r22, r7
    8de6:	76 2d       	mov	r23, r6
    8de8:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    8dec:	00 97       	sbiw	r24, 0x00	; 0
    8dee:	b1 f4       	brne	.+44     	; 0x8e1c <check_files+0x1d2>
		        {
					filesize = dir_entry.file_size;
    8df0:	fe 01       	movw	r30, r28
    8df2:	e1 5b       	subi	r30, 0xB1	; 177
    8df4:	ff 4f       	sbci	r31, 0xFF	; 255
    8df6:	e0 80       	ld	r14, Z
    8df8:	f1 80       	ldd	r15, Z+1	; 0x01
    8dfa:	02 81       	ldd	r16, Z+2	; 0x02
    8dfc:	13 81       	ldd	r17, Z+3	; 0x03
		            fat_reset_dir(dd);					
    8dfe:	c4 01       	movw	r24, r8
    8e00:	0e 94 bb 5f 	call	0xbf76	; 0xbf76 <fat_reset_dir>
		            break;
		        }
			}

			// Wenn Datei vorhanden, lesen und ausgeben
			if ( filesize != 0 )
    8e04:	e1 14       	cp	r14, r1
    8e06:	f1 04       	cpc	r15, r1
    8e08:	01 05       	cpc	r16, r1
    8e0a:	11 05       	cpc	r17, r1
    8e0c:	09 f4       	brne	.+2      	; 0x8e10 <check_files+0x1c6>
    8e0e:	73 c0       	rjmp	.+230    	; 0x8ef6 <check_files+0x2ac>
    8e10:	0c c0       	rjmp	.+24     	; 0x8e2a <check_files+0x1e0>
		if(dd)
        {

			struct fat_dir_entry_struct dir_entry;
			// Verzeichniss inhalt lesen und Datei suchen
			while(fat_read_dir(dd, &dir_entry))
    8e12:	2c e2       	ldi	r18, 0x2C	; 44
    8e14:	a2 2e       	mov	r10, r18
    8e16:	b1 2c       	mov	r11, r1
    8e18:	ac 0e       	add	r10, r28
    8e1a:	bd 1e       	adc	r11, r29
    8e1c:	c4 01       	movw	r24, r8
    8e1e:	b5 01       	movw	r22, r10
    8e20:	0e 94 db 60 	call	0xc1b6	; 0xc1b6 <fat_read_dir>
    8e24:	88 23       	and	r24, r24
    8e26:	e9 f6       	brne	.-70     	; 0x8de2 <check_files+0x198>
    8e28:	66 c0       	rjmp	.+204    	; 0x8ef6 <check_files+0x2ac>
			}

			// Wenn Datei vorhanden, lesen und ausgeben
			if ( filesize != 0 )
			{
				struct fat_file_struct* fd = fat_open_file(fs, &dir_entry); // open_file_in_dir(fs, dd, http_request->GET_FILE );
    8e2a:	80 91 ed 0b 	lds	r24, 0x0BED
    8e2e:	90 91 ee 0b 	lds	r25, 0x0BEE
    8e32:	b5 01       	movw	r22, r10
    8e34:	0e 94 f4 66 	call	0xcde8	; 0xcde8 <fat_open_file>
    8e38:	5c 01       	movw	r10, r24

                if( fd )
    8e3a:	00 97       	sbiw	r24, 0x00	; 0
    8e3c:	09 f4       	brne	.+2      	; 0x8e40 <check_files+0x1f6>
    8e3e:	55 c0       	rjmp	.+170    	; 0x8eea <check_files+0x2a0>
                {
					printf_P( PSTR(	"HTTP/1.0 200 Document follows\r\n"
    8e40:	00 d0       	rcall	.+0      	; 0x8e42 <check_files+0x1f8>
    8e42:	00 d0       	rcall	.+0      	; 0x8e44 <check_files+0x1fa>
    8e44:	00 d0       	rcall	.+0      	; 0x8e46 <check_files+0x1fc>
    8e46:	86 e0       	ldi	r24, 0x06	; 6
    8e48:	90 e1       	ldi	r25, 0x10	; 16
    8e4a:	ed b7       	in	r30, 0x3d	; 61
    8e4c:	fe b7       	in	r31, 0x3e	; 62
    8e4e:	92 83       	std	Z+2, r25	; 0x02
    8e50:	81 83       	std	Z+1, r24	; 0x01
    8e52:	e3 82       	std	Z+3, r14	; 0x03
    8e54:	f4 82       	std	Z+4, r15	; 0x04
    8e56:	05 83       	std	Z+5, r16	; 0x05
    8e58:	16 83       	std	Z+6, r17	; 0x06
    8e5a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
									"Connection: close\r\n"
									"\r\n" ), filesize);

					uint8_t buffer[ MAX_TCP_Datalenght ];

					STDOUT_Flush();
    8e5e:	8d b7       	in	r24, 0x3d	; 61
    8e60:	9e b7       	in	r25, 0x3e	; 62
    8e62:	06 96       	adiw	r24, 0x06	; 6
    8e64:	0f b6       	in	r0, 0x3f	; 63
    8e66:	f8 94       	cli
    8e68:	9e bf       	out	0x3e, r25	; 62
    8e6a:	0f be       	out	0x3f, r0	; 63
    8e6c:	8d bf       	out	0x3d, r24	; 61
    8e6e:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
					
					while( 1 )
	                {
						if( ( CheckSocketState( http_request->HTTP_SOCKET ) == SOCKET_NOT_USE ) || ( CheckSocketState( http_request->HTTP_SOCKET ) == SOCKET_ERROR ) )
    8e72:	9d e7       	ldi	r25, 0x7D	; 125
    8e74:	e9 2e       	mov	r14, r25
    8e76:	92 e0       	ldi	r25, 0x02	; 2
    8e78:	f9 2e       	mov	r15, r25
    8e7a:	ec 0c       	add	r14, r12
    8e7c:	fd 1c       	adc	r15, r13
							http_request->STATE = DISCONNECT;
							returnvalue = -1;
							break;
						}

						size = fat_read_file(fd, buffer, sizeof( buffer ));
    8e7e:	87 e5       	ldi	r24, 0x57	; 87
    8e80:	68 2e       	mov	r6, r24
    8e82:	71 2c       	mov	r7, r1
    8e84:	6c 0e       	add	r6, r28
    8e86:	7d 1e       	adc	r7, r29

					STDOUT_Flush();
					
					while( 1 )
	                {
						if( ( CheckSocketState( http_request->HTTP_SOCKET ) == SOCKET_NOT_USE ) || ( CheckSocketState( http_request->HTTP_SOCKET ) == SOCKET_ERROR ) )
    8e88:	f7 01       	movw	r30, r14
    8e8a:	80 81       	ld	r24, Z
    8e8c:	91 81       	ldd	r25, Z+1	; 0x01
    8e8e:	0e 94 01 26 	call	0x4c02	; 0x4c02 <CheckSocketState>
    8e92:	88 23       	and	r24, r24
    8e94:	81 f0       	breq	.+32     	; 0x8eb6 <check_files+0x26c>
    8e96:	f7 01       	movw	r30, r14
    8e98:	80 81       	ld	r24, Z
    8e9a:	91 81       	ldd	r25, Z+1	; 0x01
    8e9c:	0e 94 01 26 	call	0x4c02	; 0x4c02 <CheckSocketState>
							http_request->STATE = DISCONNECT;
							returnvalue = -1;
							break;
						}

						size = fat_read_file(fd, buffer, sizeof( buffer ));
    8ea0:	c5 01       	movw	r24, r10
    8ea2:	b3 01       	movw	r22, r6
    8ea4:	40 e4       	ldi	r20, 0x40	; 64
    8ea6:	50 e0       	ldi	r21, 0x00	; 0
    8ea8:	0e 94 9a 5e 	call	0xbd34	; 0xbd34 <fat_read_file>
    8eac:	8c 01       	movw	r16, r24
						
						if ( size == -1 || size == 0 )
    8eae:	01 96       	adiw	r24, 0x01	; 1
    8eb0:	02 97       	sbiw	r24, 0x02	; 2
    8eb2:	68 f4       	brcc	.+26     	; 0x8ece <check_files+0x284>
    8eb4:	1a c0       	rjmp	.+52     	; 0x8eea <check_files+0x2a0>
					
					while( 1 )
	                {
						if( ( CheckSocketState( http_request->HTTP_SOCKET ) == SOCKET_NOT_USE ) || ( CheckSocketState( http_request->HTTP_SOCKET ) == SOCKET_ERROR ) )
						{
							http_request->HTTP_SOCKET = SOCKET_ERROR;
    8eb6:	8f ef       	ldi	r24, 0xFF	; 255
    8eb8:	9f ef       	ldi	r25, 0xFF	; 255
    8eba:	f7 01       	movw	r30, r14
    8ebc:	91 83       	std	Z+1, r25	; 0x01
    8ebe:	80 83       	st	Z, r24
							http_request->STATE = DISCONNECT;
    8ec0:	82 e4       	ldi	r24, 0x42	; 66
    8ec2:	92 e0       	ldi	r25, 0x02	; 2
    8ec4:	c8 0e       	add	r12, r24
    8ec6:	d9 1e       	adc	r13, r25
    8ec8:	f6 01       	movw	r30, r12
    8eca:	10 82       	st	Z, r1
    8ecc:	0e c0       	rjmp	.+28     	; 0x8eea <check_files+0x2a0>
						{
							returnvalue = -1;
							break;
						}
						
						PutSocketData_RPE( http_request->HTTP_SOCKET, size , buffer , RAM );
    8ece:	f7 01       	movw	r30, r14
    8ed0:	80 81       	ld	r24, Z
    8ed2:	91 81       	ldd	r25, Z+1	; 0x01
    8ed4:	b8 01       	movw	r22, r16
    8ed6:	a3 01       	movw	r20, r6
    8ed8:	20 e0       	ldi	r18, 0x00	; 0
    8eda:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <PutSocketData_RPE>

						if ( size < MAX_TCP_Datalenght )
    8ede:	00 34       	cpi	r16, 0x40	; 64
    8ee0:	11 05       	cpc	r17, r1
    8ee2:	94 f6       	brge	.-92     	; 0x8e88 <check_files+0x23e>
    8ee4:	01 e0       	ldi	r16, 0x01	; 1
    8ee6:	10 e0       	ldi	r17, 0x00	; 0
    8ee8:	02 c0       	rjmp	.+4      	; 0x8eee <check_files+0x2a4>
    8eea:	0f ef       	ldi	r16, 0xFF	; 255
    8eec:	1f ef       	ldi	r17, 0xFF	; 255
							returnvalue = 1;
							break;
	                	}
					}
				}			
                fat_close_file( fd );
    8eee:	c5 01       	movw	r24, r10
    8ef0:	0e 94 bb 66 	call	0xcd76	; 0xcd76 <fat_close_file>
    8ef4:	02 c0       	rjmp	.+4      	; 0x8efa <check_files+0x2b0>
    8ef6:	0f ef       	ldi	r16, 0xFF	; 255
    8ef8:	1f ef       	ldi	r17, 0xFF	; 255
			}
		}
		fat_close_dir ( dd );
    8efa:	c4 01       	movw	r24, r8
    8efc:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>
	STDOUT_Flush();
	STDOUT_restore( &oldstream );
#endif

	return( returnvalue );
} 
    8f00:	c8 01       	movw	r24, r16
    8f02:	ca 56       	subi	r28, 0x6A	; 106
    8f04:	df 4f       	sbci	r29, 0xFF	; 255
    8f06:	ee e0       	ldi	r30, 0x0E	; 14
    8f08:	0c 94 d9 6a 	jmp	0xd5b2	; 0xd5b2 <__epilogue_restores__+0x8>

00008f0c <telnet_RegisterCMD>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int telnet_RegisterCMD( DYN_TELNET_CALLBACK dyntelnet_function, const prog_char * funktionname )
{
    8f0c:	9c 01       	movw	r18, r24
    8f0e:	e0 e0       	ldi	r30, 0x00	; 0
    8f10:	f0 e0       	ldi	r31, 0x00	; 0

	retval = -1;
	
	for ( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
	{
		if ( telnet_cmd_table[ i ].dyntelnet_function == dyntelnet_function )
    8f12:	df 01       	movw	r26, r30
    8f14:	aa 0f       	add	r26, r26
    8f16:	bb 1f       	adc	r27, r27
    8f18:	aa 0f       	add	r26, r26
    8f1a:	bb 1f       	adc	r27, r27
    8f1c:	a8 5c       	subi	r26, 0xC8	; 200
    8f1e:	b4 4f       	sbci	r27, 0xF4	; 244
    8f20:	8d 91       	ld	r24, X+
    8f22:	9c 91       	ld	r25, X
    8f24:	11 97       	sbiw	r26, 0x01	; 1
    8f26:	82 17       	cp	r24, r18
    8f28:	93 07       	cpc	r25, r19
    8f2a:	b9 f0       	breq	.+46     	; 0x8f5a <telnet_RegisterCMD+0x4e>
			break;
		
		if ( telnet_cmd_table[ i ].dyntelnet_function == NULL )
    8f2c:	8d 91       	ld	r24, X+
    8f2e:	9c 91       	ld	r25, X
    8f30:	11 97       	sbiw	r26, 0x01	; 1
    8f32:	89 2b       	or	r24, r25
    8f34:	71 f4       	brne	.+28     	; 0x8f52 <telnet_RegisterCMD+0x46>
		{
			telnet_cmd_table[ i ].dyntelnet_function = dyntelnet_function;			
    8f36:	11 96       	adiw	r26, 0x01	; 1
    8f38:	3c 93       	st	X, r19
    8f3a:	2e 93       	st	-X, r18
			telnet_cmd_table[ i ].functionname = funktionname;
    8f3c:	ee 0f       	add	r30, r30
    8f3e:	ff 1f       	adc	r31, r31
    8f40:	ee 0f       	add	r30, r30
    8f42:	ff 1f       	adc	r31, r31
    8f44:	e6 5c       	subi	r30, 0xC6	; 198
    8f46:	f4 4f       	sbci	r31, 0xF4	; 244
    8f48:	71 83       	std	Z+1, r23	; 0x01
    8f4a:	60 83       	st	Z, r22
    8f4c:	20 e0       	ldi	r18, 0x00	; 0
    8f4e:	30 e0       	ldi	r19, 0x00	; 0
    8f50:	06 c0       	rjmp	.+12     	; 0x8f5e <telnet_RegisterCMD+0x52>
{
	int i,retval;

	retval = -1;
	
	for ( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
    8f52:	31 96       	adiw	r30, 0x01	; 1
    8f54:	ec 30       	cpi	r30, 0x0C	; 12
    8f56:	f1 05       	cpc	r31, r1
    8f58:	e1 f6       	brne	.-72     	; 0x8f12 <telnet_RegisterCMD+0x6>
    8f5a:	2f ef       	ldi	r18, 0xFF	; 255
    8f5c:	3f ef       	ldi	r19, 0xFF	; 255
			retval = 0;
			break;
		}
	}
	return( retval );
}
    8f5e:	c9 01       	movw	r24, r18
    8f60:	08 95       	ret

00008f62 <TELNET_runcmd>:
 * \param 	cmdstring   Kommandostring der ausgef체hrt werden soll.
 * \return	int			0 wenn Kommando gefunden, bei Fehler -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
int TELNET_runcmd( int argc, char ** argv )
{
    8f62:	a0 e0       	ldi	r26, 0x00	; 0
    8f64:	b0 e0       	ldi	r27, 0x00	; 0
    8f66:	e7 eb       	ldi	r30, 0xB7	; 183
    8f68:	f7 e4       	ldi	r31, 0x47	; 71
    8f6a:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    8f6e:	6c 01       	movw	r12, r24
    8f70:	7b 01       	movw	r14, r22
    8f72:	0a e3       	ldi	r16, 0x3A	; 58
    8f74:	1b e0       	ldi	r17, 0x0B	; 11
    8f76:	c0 e0       	ldi	r28, 0x00	; 0
    8f78:	d0 e0       	ldi	r29, 0x00	; 0
	int i, returncode = -1;
	
	for( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
	{
		if ( telnet_cmd_table[ i ].functionname == NULL )
    8f7a:	f8 01       	movw	r30, r16
    8f7c:	60 81       	ld	r22, Z
    8f7e:	71 81       	ldd	r23, Z+1	; 0x01
    8f80:	61 15       	cp	r22, r1
    8f82:	71 05       	cpc	r23, r1
    8f84:	d9 f0       	breq	.+54     	; 0x8fbc <TELNET_runcmd+0x5a>
		{
			break;
		}
		if ( !strcmp_P( argv[0] , telnet_cmd_table[ i ].functionname ) )
    8f86:	f7 01       	movw	r30, r14
    8f88:	80 81       	ld	r24, Z
    8f8a:	91 81       	ldd	r25, Z+1	; 0x01
    8f8c:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    8f90:	89 2b       	or	r24, r25
    8f92:	71 f4       	brne	.+28     	; 0x8fb0 <TELNET_runcmd+0x4e>
		{
			telnet_cmd_table[i].dyntelnet_function( argc, argv );
    8f94:	cc 0f       	add	r28, r28
    8f96:	dd 1f       	adc	r29, r29
    8f98:	cc 0f       	add	r28, r28
    8f9a:	dd 1f       	adc	r29, r29
    8f9c:	c8 5c       	subi	r28, 0xC8	; 200
    8f9e:	d4 4f       	sbci	r29, 0xF4	; 244
    8fa0:	e8 81       	ld	r30, Y
    8fa2:	f9 81       	ldd	r31, Y+1	; 0x01
    8fa4:	c6 01       	movw	r24, r12
    8fa6:	b7 01       	movw	r22, r14
    8fa8:	09 95       	icall
    8faa:	20 e0       	ldi	r18, 0x00	; 0
    8fac:	30 e0       	ldi	r19, 0x00	; 0
    8fae:	08 c0       	rjmp	.+16     	; 0x8fc0 <TELNET_runcmd+0x5e>
/*------------------------------------------------------------------------------------------------------------*/
int TELNET_runcmd( int argc, char ** argv )
{
	int i, returncode = -1;
	
	for( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
    8fb0:	21 96       	adiw	r28, 0x01	; 1
    8fb2:	0c 5f       	subi	r16, 0xFC	; 252
    8fb4:	1f 4f       	sbci	r17, 0xFF	; 255
    8fb6:	cc 30       	cpi	r28, 0x0C	; 12
    8fb8:	d1 05       	cpc	r29, r1
    8fba:	f9 f6       	brne	.-66     	; 0x8f7a <TELNET_runcmd+0x18>
    8fbc:	2f ef       	ldi	r18, 0xFF	; 255
    8fbe:	3f ef       	ldi	r19, 0xFF	; 255
			returncode = 0;
			break;
		}
	}
	return( returncode );
}
    8fc0:	c9 01       	movw	r24, r18
    8fc2:	cd b7       	in	r28, 0x3d	; 61
    8fc4:	de b7       	in	r29, 0x3e	; 62
    8fc6:	e8 e0       	ldi	r30, 0x08	; 8
    8fc8:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

00008fcc <TELNET_pharse>:
 * \param 	cmdstring   Kommandostring der ausgef체hrt werden soll.
 * \return	int			0 wenn Kommando gefunden, bei Fehler -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
int TELNET_pharse( char * BUFFER, char ** argv, int max_argc )
{
    8fcc:	ef 92       	push	r14
    8fce:	ff 92       	push	r15
    8fd0:	0f 93       	push	r16
    8fd2:	1f 93       	push	r17
    8fd4:	cf 93       	push	r28
    8fd6:	df 93       	push	r29
    8fd8:	ec 01       	movw	r28, r24
    8fda:	8b 01       	movw	r16, r22
    8fdc:	7a 01       	movw	r14, r20
		
	int i = 0;
	int _argc = 0;
	char toggle = 0;
	int stringlen = strlen( BUFFER );
    8fde:	dc 01       	movw	r26, r24
    8fe0:	0d 90       	ld	r0, X+
    8fe2:	00 20       	and	r0, r0
    8fe4:	e9 f7       	brne	.-6      	; 0x8fe0 <TELNET_pharse+0x14>
    8fe6:	11 97       	sbiw	r26, 0x01	; 1
    8fe8:	a8 1b       	sub	r26, r24
    8fea:	b9 0b       	sbc	r27, r25
	
	argv[ _argc ] = &BUFFER[ i ]; 
    8fec:	fb 01       	movw	r30, r22
    8fee:	91 83       	std	Z+1, r25	; 0x01
    8ff0:	80 83       	st	Z, r24
    8ff2:	60 e0       	ldi	r22, 0x00	; 0
    8ff4:	70 e0       	ldi	r23, 0x00	; 0
    8ff6:	20 e0       	ldi	r18, 0x00	; 0
    8ff8:	30 e0       	ldi	r19, 0x00	; 0
    8ffa:	40 e0       	ldi	r20, 0x00	; 0
    8ffc:	39 c0       	rjmp	.+114    	; 0x9070 <TELNET_pharse+0xa4>
	
	for( i = 0 ; i < stringlen && _argc < max_argc ; i++ )
	{
		switch( BUFFER[ i ] )
    8ffe:	fe 01       	movw	r30, r28
    9000:	e6 0f       	add	r30, r22
    9002:	f7 1f       	adc	r31, r23
    9004:	80 81       	ld	r24, Z
    9006:	8d 30       	cpi	r24, 0x0D	; 13
    9008:	51 f0       	breq	.+20     	; 0x901e <TELNET_pharse+0x52>
    900a:	8e 30       	cpi	r24, 0x0E	; 14
    900c:	18 f4       	brcc	.+6      	; 0x9014 <TELNET_pharse+0x48>
    900e:	88 23       	and	r24, r24
    9010:	39 f0       	breq	.+14     	; 0x9020 <TELNET_pharse+0x54>
    9012:	2c c0       	rjmp	.+88     	; 0x906c <TELNET_pharse+0xa0>
    9014:	80 32       	cpi	r24, 0x20	; 32
    9016:	c1 f0       	breq	.+48     	; 0x9048 <TELNET_pharse+0x7c>
    9018:	82 32       	cpi	r24, 0x22	; 34
    901a:	41 f5       	brne	.+80     	; 0x906c <TELNET_pharse+0xa0>
    901c:	03 c0       	rjmp	.+6      	; 0x9024 <TELNET_pharse+0x58>
		{
			
		case '\0':		i = stringlen;
						break;
		case 0x0d:		BUFFER[ i ] = '\0';
    901e:	10 82       	st	Z, r1
    9020:	bd 01       	movw	r22, r26
    9022:	24 c0       	rjmp	.+72     	; 0x906c <TELNET_pharse+0xa0>
						i = stringlen;
						break;
		case '\"':		if ( toggle == 0 )
    9024:	44 23       	and	r20, r20
    9026:	69 f4       	brne	.+26     	; 0x9042 <TELNET_pharse+0x76>
						{	
							toggle = 1;
							BUFFER[ i ] = '\0';
    9028:	10 82       	st	Z, r1
							argv[ _argc ] = &BUFFER[ i + 1];
    902a:	f9 01       	movw	r30, r18
    902c:	ee 0f       	add	r30, r30
    902e:	ff 1f       	adc	r31, r31
    9030:	e0 0f       	add	r30, r16
    9032:	f1 1f       	adc	r31, r17
    9034:	cb 01       	movw	r24, r22
    9036:	01 96       	adiw	r24, 0x01	; 1
    9038:	8c 0f       	add	r24, r28
    903a:	9d 1f       	adc	r25, r29
    903c:	91 83       	std	Z+1, r25	; 0x01
    903e:	80 83       	st	Z, r24
    9040:	05 c0       	rjmp	.+10     	; 0x904c <TELNET_pharse+0x80>
						}
						else
						{
							toggle = 0;
							BUFFER[ i ] = '\0';
    9042:	10 82       	st	Z, r1
    9044:	40 e0       	ldi	r20, 0x00	; 0
    9046:	12 c0       	rjmp	.+36     	; 0x906c <TELNET_pharse+0xa0>
						}
						break;
		case ' ':		if ( toggle == 0 )						
    9048:	44 23       	and	r20, r20
    904a:	11 f0       	breq	.+4      	; 0x9050 <TELNET_pharse+0x84>
    904c:	41 e0       	ldi	r20, 0x01	; 1
    904e:	0e c0       	rjmp	.+28     	; 0x906c <TELNET_pharse+0xa0>
						{
							BUFFER[ i ] = '\0';
    9050:	10 82       	st	Z, r1
							_argc++;
    9052:	2f 5f       	subi	r18, 0xFF	; 255
    9054:	3f 4f       	sbci	r19, 0xFF	; 255
							argv[ _argc ] = &BUFFER[ i + 1 ];
    9056:	f9 01       	movw	r30, r18
    9058:	ee 0f       	add	r30, r30
    905a:	ff 1f       	adc	r31, r31
    905c:	e0 0f       	add	r30, r16
    905e:	f1 1f       	adc	r31, r17
    9060:	cb 01       	movw	r24, r22
    9062:	01 96       	adiw	r24, 0x01	; 1
    9064:	8c 0f       	add	r24, r28
    9066:	9d 1f       	adc	r25, r29
    9068:	91 83       	std	Z+1, r25	; 0x01
    906a:	80 83       	st	Z, r24
	char toggle = 0;
	int stringlen = strlen( BUFFER );
	
	argv[ _argc ] = &BUFFER[ i ]; 
	
	for( i = 0 ; i < stringlen && _argc < max_argc ; i++ )
    906c:	6f 5f       	subi	r22, 0xFF	; 255
    906e:	7f 4f       	sbci	r23, 0xFF	; 255
    9070:	6a 17       	cp	r22, r26
    9072:	7b 07       	cpc	r23, r27
    9074:	1c f4       	brge	.+6      	; 0x907c <TELNET_pharse+0xb0>
    9076:	2e 15       	cp	r18, r14
    9078:	3f 05       	cpc	r19, r15
    907a:	0c f2       	brlt	.-126    	; 0x8ffe <TELNET_pharse+0x32>
    907c:	2f 5f       	subi	r18, 0xFF	; 255
    907e:	3f 4f       	sbci	r19, 0xFF	; 255
						}
						break;
		}
	}
	return( _argc + 1 );
}
    9080:	c9 01       	movw	r24, r18
    9082:	cd b7       	in	r28, 0x3d	; 61
    9084:	de b7       	in	r29, 0x3e	; 62
    9086:	e6 e0       	ldi	r30, 0x06	; 6
    9088:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

0000908c <TELNET_runcmdextern_P>:
 * \param 	cmdstring   Kommandostring der ausgef체hrt werden soll der im Flash liegt.
 * \return	int			0 wenn Kommando gefunden, bei Fehler -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
int TELNET_runcmdextern_P( const prog_char * cmdstring_P )
{
    908c:	a8 e4       	ldi	r26, 0x48	; 72
    908e:	b0 e0       	ldi	r27, 0x00	; 0
    9090:	ec e4       	ldi	r30, 0x4C	; 76
    9092:	f8 e4       	ldi	r31, 0x48	; 72
    9094:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
    9098:	bc 01       	movw	r22, r24
	char * argv[ MAX_ARGC ];
	int argc;
	char cmdstring[ TELNET_BUFFER_LEN ];
	
	strcpy_P( cmdstring, cmdstring_P );
    909a:	8e 01       	movw	r16, r28
    909c:	07 5f       	subi	r16, 0xF7	; 247
    909e:	1f 4f       	sbci	r17, 0xFF	; 255
    90a0:	c8 01       	movw	r24, r16
    90a2:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
	
	argc = TELNET_pharse( cmdstring, argv, MAX_ARGC );
    90a6:	c8 01       	movw	r24, r16
    90a8:	8e 01       	movw	r16, r28
    90aa:	0f 5f       	subi	r16, 0xFF	; 255
    90ac:	1f 4f       	sbci	r17, 0xFF	; 255
    90ae:	b8 01       	movw	r22, r16
    90b0:	44 e0       	ldi	r20, 0x04	; 4
    90b2:	50 e0       	ldi	r21, 0x00	; 0
    90b4:	0e 94 e6 47 	call	0x8fcc	; 0x8fcc <TELNET_pharse>
	
	return( TELNET_runcmd( argc, argv ) );
    90b8:	b8 01       	movw	r22, r16
    90ba:	0e 94 b1 47 	call	0x8f62	; 0x8f62 <TELNET_runcmd>
}
    90be:	c8 5b       	subi	r28, 0xB8	; 184
    90c0:	df 4f       	sbci	r29, 0xFF	; 255
    90c2:	e4 e0       	ldi	r30, 0x04	; 4
    90c4:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

000090c8 <TELNET_runcmdextern>:
 * \param 	cmdstring   Kommandostring der ausgef체hrt werden soll.
 * \return	int			0 wenn Kommando gefunden, bei Fehler -1.
 */
/*------------------------------------------------------------------------------------------------------------*/
int TELNET_runcmdextern( char * cmdstring )
{
    90c8:	a8 e0       	ldi	r26, 0x08	; 8
    90ca:	b0 e0       	ldi	r27, 0x00	; 0
    90cc:	ea e6       	ldi	r30, 0x6A	; 106
    90ce:	f8 e4       	ldi	r31, 0x48	; 72
    90d0:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	char * argv[ MAX_ARGC ];
	int argc;
	
	argc = TELNET_pharse( cmdstring, argv, MAX_ARGC );
    90d4:	8e 01       	movw	r16, r28
    90d6:	0f 5f       	subi	r16, 0xFF	; 255
    90d8:	1f 4f       	sbci	r17, 0xFF	; 255
    90da:	b8 01       	movw	r22, r16
    90dc:	44 e0       	ldi	r20, 0x04	; 4
    90de:	50 e0       	ldi	r21, 0x00	; 0
    90e0:	0e 94 e6 47 	call	0x8fcc	; 0x8fcc <TELNET_pharse>
	
	return( TELNET_runcmd( argc, argv ) );
    90e4:	b8 01       	movw	r22, r16
    90e6:	0e 94 b1 47 	call	0x8f62	; 0x8f62 <TELNET_runcmd>
}
    90ea:	28 96       	adiw	r28, 0x08	; 8
    90ec:	e4 e0       	ldi	r30, 0x04	; 4
    90ee:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

000090f2 <telnet_thread>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/	
void telnet_thread()
	{
    90f2:	af e0       	ldi	r26, 0x0F	; 15
    90f4:	b0 e0       	ldi	r27, 0x00	; 0
    90f6:	ef e7       	ldi	r30, 0x7F	; 127
    90f8:	f8 e4       	ldi	r31, 0x48	; 72
    90fa:	0c 94 c5 6a 	jmp	0xd58a	; 0xd58a <__prologue_saves__+0x18>
		struct STDOUT oldstream;
		char Data; 
		int i;
		
		// keine alte Verbindung offen?
		if ( telnet_session.SOCKET == NO_SOCKET_USED )
    90fe:	80 91 a7 04 	lds	r24, 0x04A7
    9102:	90 91 a8 04 	lds	r25, 0x04A8
    9106:	2f ef       	ldi	r18, 0xFF	; 255
    9108:	8f 3f       	cpi	r24, 0xFF	; 255
    910a:	92 07       	cpc	r25, r18
    910c:	c1 f5       	brne	.+112    	; 0x917e <telnet_thread+0x8c>
		{ 	
			// auf neue Verbindung testen
			telnet_session.SOCKET = CheckPortRequest( TELNET_PORT );
    910e:	87 e1       	ldi	r24, 0x17	; 23
    9110:	90 e0       	ldi	r25, 0x00	; 0
    9112:	0e 94 14 26 	call	0x4c28	; 0x4c28 <CheckPortRequest>
    9116:	90 93 a8 04 	sts	0x04A8, r25
    911a:	80 93 a7 04 	sts	0x04A7, r24
			if ( telnet_session.SOCKET != NO_SOCKET_USED )
    911e:	8f 5f       	subi	r24, 0xFF	; 255
    9120:	9f 4f       	sbci	r25, 0xFF	; 255
    9122:	09 f4       	brne	.+2      	; 0x9126 <telnet_thread+0x34>
    9124:	ff c0       	rjmp	.+510    	; 0x9324 <telnet_thread+0x232>
			{	
				STDOUT_save( &oldstream );
    9126:	8e 01       	movw	r16, r28
    9128:	0f 5f       	subi	r16, 0xFF	; 255
    912a:	1f 4f       	sbci	r17, 0xFF	; 255
    912c:	c8 01       	movw	r24, r16
    912e:	0e 94 a4 38 	call	0x7148	; 0x7148 <STDOUT_save>
				STDOUT_set( _TCP, telnet_session.SOCKET );
    9132:	60 91 a7 04 	lds	r22, 0x04A7
    9136:	70 91 a8 04 	lds	r23, 0x04A8
    913a:	82 e0       	ldi	r24, 0x02	; 2
    913c:	0e 94 76 38 	call	0x70ec	; 0x70ec <STDOUT_set>
				// Wenn ja, Startmeldung ausgeben und startzustand herstellen f체r telnet
				printf_P( PSTR( "Welcome on Tiny-Telnetserver 0.2!\r\n"
    9140:	00 d0       	rcall	.+0      	; 0x9142 <telnet_thread+0x50>
    9142:	81 e6       	ldi	r24, 0x61	; 97
    9144:	91 e1       	ldi	r25, 0x11	; 17
    9146:	ed b7       	in	r30, 0x3d	; 61
    9148:	fe b7       	in	r31, 0x3e	; 62
    914a:	92 83       	std	Z+2, r25	; 0x02
    914c:	81 83       	std	Z+1, r24	; 0x01
    914e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
								"Und, los geht's...!!! (\"help\" hilft :-))\r\n> " ));
				STDOUT_restore( &oldstream );
    9152:	0f 90       	pop	r0
    9154:	0f 90       	pop	r0
    9156:	c8 01       	movw	r24, r16
    9158:	0e 94 8e 38 	call	0x711c	; 0x711c <STDOUT_restore>

				// TELNET_BUFFER leeren und auf Ausgangszustand setzen
				telnet_session.STATE = 0;
				telnet_session.POS = 0;
    915c:	10 92 ea 04 	sts	0x04EA, r1
    9160:	10 92 e9 04 	sts	0x04E9, r1
				telnet_session.BUFFER[0] = '\0';
    9164:	10 92 a9 04 	sts	0x04A9, r1
				telnet_session.STATE = 0;
    9168:	10 92 ec 04 	sts	0x04EC, r1
    916c:	10 92 eb 04 	sts	0x04EB, r1
				
				FlushSocketData( telnet_session.SOCKET );
    9170:	80 91 a7 04 	lds	r24, 0x04A7
    9174:	90 91 a8 04 	lds	r25, 0x04A8
    9178:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <FlushSocketData>
    917c:	d3 c0       	rjmp	.+422    	; 0x9324 <telnet_thread+0x232>
		}
		// Wenn alte Verbindung offen hier weiter:
		else
		{
			// checken, ob noch offen ist
			if( CheckSocketState( telnet_session.SOCKET ) == SOCKET_NOT_USE )
    917e:	0e 94 01 26 	call	0x4c02	; 0x4c02 <CheckSocketState>
    9182:	88 23       	and	r24, r24
    9184:	09 f4       	brne	.+2      	; 0x9188 <telnet_thread+0x96>
    9186:	76 c0       	rjmp	.+236    	; 0x9274 <telnet_thread+0x182>
			}

			// Auf neue Daten zum zusammenbauen testen
			// hier wird der TELNET_BUFFER aufgef체llt bis 0x0a oder 0x0d eintreffen. der Puffer ist statisch
			// Wenn ein 0x0a oder 0x0d empfangen wurde, wird der TELNET_STATE auf 1 gesetzt, damit er verarbeitet werden kann
			if ( telnet_session.STATE == 0 )
    9188:	80 91 eb 04 	lds	r24, 0x04EB
    918c:	90 91 ec 04 	lds	r25, 0x04EC
    9190:	89 2b       	or	r24, r25
    9192:	41 f1       	breq	.+80     	; 0x91e4 <telnet_thread+0xf2>
    9194:	30 c0       	rjmp	.+96     	; 0x91f6 <telnet_thread+0x104>
			{	
				
				while( GetBytesInSocketData( telnet_session.SOCKET ) >= 1 )
				{
					Data = ( GetByteFromSocketData ( telnet_session.SOCKET ) );
    9196:	80 91 a7 04 	lds	r24, 0x04A7
    919a:	90 91 a8 04 	lds	r25, 0x04A8
    919e:	0e 94 ae 28 	call	0x515c	; 0x515c <GetByteFromSocketData>
					if ( Data != 0x0a && Data <= 0x7f)
    91a2:	8a 30       	cpi	r24, 0x0A	; 10
    91a4:	f9 f0       	breq	.+62     	; 0x91e4 <telnet_thread+0xf2>
    91a6:	87 fd       	sbrc	r24, 7
    91a8:	1d c0       	rjmp	.+58     	; 0x91e4 <telnet_thread+0xf2>
					{
						if ( telnet_session.POS < TELNET_BUFFER_LEN )
    91aa:	20 91 e9 04 	lds	r18, 0x04E9
    91ae:	30 91 ea 04 	lds	r19, 0x04EA
    91b2:	20 34       	cpi	r18, 0x40	; 64
    91b4:	31 05       	cpc	r19, r1
    91b6:	6c f4       	brge	.+26     	; 0x91d2 <telnet_thread+0xe0>
						{
							telnet_session.BUFFER[ telnet_session.POS++ ] = Data;
    91b8:	f9 01       	movw	r30, r18
    91ba:	e9 55       	subi	r30, 0x59	; 89
    91bc:	fb 4f       	sbci	r31, 0xFB	; 251
    91be:	82 83       	std	Z+2, r24	; 0x02
    91c0:	f9 01       	movw	r30, r18
    91c2:	31 96       	adiw	r30, 0x01	; 1
    91c4:	f0 93 ea 04 	sts	0x04EA, r31
    91c8:	e0 93 e9 04 	sts	0x04E9, r30
							telnet_session.BUFFER[ telnet_session.POS ] = '\0';
    91cc:	e9 55       	subi	r30, 0x59	; 89
    91ce:	fb 4f       	sbci	r31, 0xFB	; 251
    91d0:	12 82       	std	Z+2, r1	; 0x02
						}
						if ( Data == 0x0d )
    91d2:	8d 30       	cpi	r24, 0x0D	; 13
    91d4:	39 f4       	brne	.+14     	; 0x91e4 <telnet_thread+0xf2>
						{
							telnet_session.STATE = 1;
    91d6:	81 e0       	ldi	r24, 0x01	; 1
    91d8:	90 e0       	ldi	r25, 0x00	; 0
    91da:	90 93 ec 04 	sts	0x04EC, r25
    91de:	80 93 eb 04 	sts	0x04EB, r24
    91e2:	09 c0       	rjmp	.+18     	; 0x91f6 <telnet_thread+0x104>
			// hier wird der TELNET_BUFFER aufgef체llt bis 0x0a oder 0x0d eintreffen. der Puffer ist statisch
			// Wenn ein 0x0a oder 0x0d empfangen wurde, wird der TELNET_STATE auf 1 gesetzt, damit er verarbeitet werden kann
			if ( telnet_session.STATE == 0 )
			{	
				
				while( GetBytesInSocketData( telnet_session.SOCKET ) >= 1 )
    91e4:	80 91 a7 04 	lds	r24, 0x04A7
    91e8:	90 91 a8 04 	lds	r25, 0x04A8
    91ec:	0e 94 6f 26 	call	0x4cde	; 0x4cde <GetBytesInSocketData>
    91f0:	18 16       	cp	r1, r24
    91f2:	19 06       	cpc	r1, r25
    91f4:	84 f2       	brlt	.-96     	; 0x9196 <telnet_thread+0xa4>
					}
				}
			}	

			// Wenn TELNET_BUFFER eine Zeile vollst채ndig hat gehts hier weiter
			if ( telnet_session.STATE == 1 )
    91f6:	80 91 eb 04 	lds	r24, 0x04EB
    91fa:	90 91 ec 04 	lds	r25, 0x04EC
    91fe:	01 97       	sbiw	r24, 0x01	; 1
    9200:	09 f0       	breq	.+2      	; 0x9204 <telnet_thread+0x112>
    9202:	90 c0       	rjmp	.+288    	; 0x9324 <telnet_thread+0x232>
			{

				STDOUT_save( &oldstream );
    9204:	ce 01       	movw	r24, r28
    9206:	01 96       	adiw	r24, 0x01	; 1
    9208:	0e 94 a4 38 	call	0x7148	; 0x7148 <STDOUT_save>
				STDOUT_set( _TCP, telnet_session.SOCKET );
    920c:	60 91 a7 04 	lds	r22, 0x04A7
    9210:	70 91 a8 04 	lds	r23, 0x04A8
    9214:	82 e0       	ldi	r24, 0x02	; 2
    9216:	0e 94 76 38 	call	0x70ec	; 0x70ec <STDOUT_set>

				telnet_session.argc = TELNET_pharse( telnet_session.BUFFER, telnet_session.argv, MAX_ARGC );
    921a:	89 ea       	ldi	r24, 0xA9	; 169
    921c:	94 e0       	ldi	r25, 0x04	; 4
    921e:	6f ee       	ldi	r22, 0xEF	; 239
    9220:	74 e0       	ldi	r23, 0x04	; 4
    9222:	44 e0       	ldi	r20, 0x04	; 4
    9224:	50 e0       	ldi	r21, 0x00	; 0
    9226:	0e 94 e6 47 	call	0x8fcc	; 0x8fcc <TELNET_pharse>
    922a:	90 93 ee 04 	sts	0x04EE, r25
    922e:	80 93 ed 04 	sts	0x04ED, r24
				TELNET_runcmd( telnet_session.argc, telnet_session.argv );
    9232:	6f ee       	ldi	r22, 0xEF	; 239
    9234:	74 e0       	ldi	r23, 0x04	; 4
    9236:	0e 94 b1 47 	call	0x8f62	; 0x8f62 <TELNET_runcmd>

				// auf QUIT checken
				if ( !strcmp_P( telnet_session.argv[ 0 ] , PSTR("quit") ) ) 
    923a:	00 91 ef 04 	lds	r16, 0x04EF
    923e:	10 91 f0 04 	lds	r17, 0x04F0
    9242:	c8 01       	movw	r24, r16
    9244:	6c e5       	ldi	r22, 0x5C	; 92
    9246:	71 e1       	ldi	r23, 0x11	; 17
    9248:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    924c:	89 2b       	or	r24, r25
    924e:	f9 f4       	brne	.+62     	; 0x928e <telnet_thread+0x19c>
				{
					// Socket schlieen
					printf_P( PSTR("Verbindung wird geschlossen\r\n") );
    9250:	00 d0       	rcall	.+0      	; 0x9252 <telnet_thread+0x160>
    9252:	8e e3       	ldi	r24, 0x3E	; 62
    9254:	91 e1       	ldi	r25, 0x11	; 17
    9256:	ed b7       	in	r30, 0x3d	; 61
    9258:	fe b7       	in	r31, 0x3e	; 62
    925a:	92 83       	std	Z+2, r25	; 0x02
    925c:	81 83       	std	Z+1, r24	; 0x01
    925e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					STDOUT_Flush();
    9262:	0f 90       	pop	r0
    9264:	0f 90       	pop	r0
    9266:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
					STDOUT_set( RS232, 0);
    926a:	81 e0       	ldi	r24, 0x01	; 1
    926c:	60 e0       	ldi	r22, 0x00	; 0
    926e:	70 e0       	ldi	r23, 0x00	; 0
    9270:	0e 94 76 38 	call	0x70ec	; 0x70ec <STDOUT_set>
					CloseTCPSocket( telnet_session.SOCKET );
    9274:	80 91 a7 04 	lds	r24, 0x04A7
    9278:	90 91 a8 04 	lds	r25, 0x04A8
    927c:	0e 94 10 2a 	call	0x5420	; 0x5420 <CloseTCPSocket>
					telnet_session.SOCKET = NO_SOCKET_USED;
    9280:	8f ef       	ldi	r24, 0xFF	; 255
    9282:	9f ef       	ldi	r25, 0xFF	; 255
    9284:	90 93 a8 04 	sts	0x04A8, r25
    9288:	80 93 a7 04 	sts	0x04A7, r24
    928c:	4b c0       	rjmp	.+150    	; 0x9324 <telnet_thread+0x232>
					return;
				}
				else if( !strcmp_P( telnet_session.argv[ 0 ] , PSTR("help") ) )
    928e:	c8 01       	movw	r24, r16
    9290:	69 e3       	ldi	r22, 0x39	; 57
    9292:	71 e1       	ldi	r23, 0x11	; 17
    9294:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    9298:	89 2b       	or	r24, r25
    929a:	59 f5       	brne	.+86     	; 0x92f2 <telnet_thread+0x200>
				{
					printf_P( PSTR("Folgende Befehle sind vorhanden:\r\n\r\n") );
    929c:	00 d0       	rcall	.+0      	; 0x929e <telnet_thread+0x1ac>
    929e:	84 e1       	ldi	r24, 0x14	; 20
    92a0:	91 e1       	ldi	r25, 0x11	; 17
    92a2:	ed b7       	in	r30, 0x3d	; 61
    92a4:	fe b7       	in	r31, 0x3e	; 62
    92a6:	92 83       	std	Z+2, r25	; 0x02
    92a8:	81 83       	std	Z+1, r24	; 0x01
    92aa:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    92ae:	0a e3       	ldi	r16, 0x3A	; 58
    92b0:	1b e0       	ldi	r17, 0x0B	; 11
    92b2:	0f 90       	pop	r0
    92b4:	0f 90       	pop	r0
					for( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
					{
						if ( telnet_cmd_table[ i ].functionname != NULL )
						{
							printf_P( telnet_cmd_table[ i ].functionname );
							printf_P( PSTR("\r\n") );
    92b6:	91 e1       	ldi	r25, 0x11	; 17
    92b8:	e9 2e       	mov	r14, r25
    92ba:	91 e1       	ldi	r25, 0x11	; 17
    92bc:	f9 2e       	mov	r15, r25
				else if( !strcmp_P( telnet_session.argv[ 0 ] , PSTR("help") ) )
				{
					printf_P( PSTR("Folgende Befehle sind vorhanden:\r\n\r\n") );
					for( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
					{
						if ( telnet_cmd_table[ i ].functionname != NULL )
    92be:	f8 01       	movw	r30, r16
    92c0:	80 81       	ld	r24, Z
    92c2:	91 81       	ldd	r25, Z+1	; 0x01
    92c4:	00 97       	sbiw	r24, 0x00	; 0
    92c6:	79 f0       	breq	.+30     	; 0x92e6 <telnet_thread+0x1f4>
						{
							printf_P( telnet_cmd_table[ i ].functionname );
    92c8:	00 d0       	rcall	.+0      	; 0x92ca <telnet_thread+0x1d8>
    92ca:	ed b7       	in	r30, 0x3d	; 61
    92cc:	fe b7       	in	r31, 0x3e	; 62
    92ce:	92 83       	std	Z+2, r25	; 0x02
    92d0:	81 83       	std	Z+1, r24	; 0x01
    92d2:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
							printf_P( PSTR("\r\n") );
    92d6:	ed b7       	in	r30, 0x3d	; 61
    92d8:	fe b7       	in	r31, 0x3e	; 62
    92da:	f2 82       	std	Z+2, r15	; 0x02
    92dc:	e1 82       	std	Z+1, r14	; 0x01
    92de:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    92e2:	0f 90       	pop	r0
    92e4:	0f 90       	pop	r0
    92e6:	0c 5f       	subi	r16, 0xFC	; 252
    92e8:	1f 4f       	sbci	r17, 0xFF	; 255
					return;
				}
				else if( !strcmp_P( telnet_session.argv[ 0 ] , PSTR("help") ) )
				{
					printf_P( PSTR("Folgende Befehle sind vorhanden:\r\n\r\n") );
					for( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
    92ea:	fb e0       	ldi	r31, 0x0B	; 11
    92ec:	0a 36       	cpi	r16, 0x6A	; 106
    92ee:	1f 07       	cpc	r17, r31
    92f0:	31 f7       	brne	.-52     	; 0x92be <telnet_thread+0x1cc>
							printf_P( PSTR("\r\n") );
						}
					}
				}

				printf_P( PSTR("> ") );
    92f2:	00 d0       	rcall	.+0      	; 0x92f4 <telnet_thread+0x202>
    92f4:	8e e0       	ldi	r24, 0x0E	; 14
    92f6:	91 e1       	ldi	r25, 0x11	; 17
    92f8:	ed b7       	in	r30, 0x3d	; 61
    92fa:	fe b7       	in	r31, 0x3e	; 62
    92fc:	92 83       	std	Z+2, r25	; 0x02
    92fe:	81 83       	std	Z+1, r24	; 0x01
    9300:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
				
				STDOUT_restore( &oldstream );
    9304:	0f 90       	pop	r0
    9306:	0f 90       	pop	r0
    9308:	ce 01       	movw	r24, r28
    930a:	01 96       	adiw	r24, 0x01	; 1
    930c:	0e 94 8e 38 	call	0x711c	; 0x711c <STDOUT_restore>

				telnet_session.STATE = 0;
				telnet_session.POS = 0;
    9310:	10 92 ea 04 	sts	0x04EA, r1
    9314:	10 92 e9 04 	sts	0x04E9, r1
				telnet_session.BUFFER[0] = '\0';
    9318:	10 92 a9 04 	sts	0x04A9, r1
				telnet_session.STATE = 0;
    931c:	10 92 ec 04 	sts	0x04EC, r1
    9320:	10 92 eb 04 	sts	0x04EB, r1
			}
		}
	}
    9324:	2f 96       	adiw	r28, 0x0f	; 15
    9326:	e6 e0       	ldi	r30, 0x06	; 6
    9328:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

0000932c <telnet_init>:
/*------------------------------------------------------------------------------------------------------------*/
void telnet_init()
{
	int i;

	RegisterTCPPort( TELNET_PORT );
    932c:	87 e1       	ldi	r24, 0x17	; 23
    932e:	90 e0       	ldi	r25, 0x00	; 0
    9330:	0e 94 e7 25 	call	0x4bce	; 0x4bce <RegisterTCPPort>
	printf_P( PSTR("Telnet-Server gestartet auf Port %d.\r\n") , TELNET_PORT );
    9334:	00 d0       	rcall	.+0      	; 0x9336 <telnet_init+0xa>
    9336:	00 d0       	rcall	.+0      	; 0x9338 <telnet_init+0xc>
    9338:	88 eb       	ldi	r24, 0xB8	; 184
    933a:	91 e1       	ldi	r25, 0x11	; 17
    933c:	ed b7       	in	r30, 0x3d	; 61
    933e:	fe b7       	in	r31, 0x3e	; 62
    9340:	92 83       	std	Z+2, r25	; 0x02
    9342:	81 83       	std	Z+1, r24	; 0x01
    9344:	87 e1       	ldi	r24, 0x17	; 23
    9346:	90 e0       	ldi	r25, 0x00	; 0
    9348:	94 83       	std	Z+4, r25	; 0x04
    934a:	83 83       	std	Z+3, r24	; 0x03
    934c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9350:	80 e0       	ldi	r24, 0x00	; 0
    9352:	90 e0       	ldi	r25, 0x00	; 0
    9354:	0f 90       	pop	r0
    9356:	0f 90       	pop	r0
    9358:	0f 90       	pop	r0
    935a:	0f 90       	pop	r0

	// Befehlstabelle l철schen
	for ( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
	{
		telnet_cmd_table[ i ].dyntelnet_function = NULL;
    935c:	fc 01       	movw	r30, r24
    935e:	ee 0f       	add	r30, r30
    9360:	ff 1f       	adc	r31, r31
    9362:	ee 0f       	add	r30, r30
    9364:	ff 1f       	adc	r31, r31
    9366:	e8 5c       	subi	r30, 0xC8	; 200
    9368:	f4 4f       	sbci	r31, 0xF4	; 244
    936a:	11 82       	std	Z+1, r1	; 0x01
    936c:	10 82       	st	Z, r1

	RegisterTCPPort( TELNET_PORT );
	printf_P( PSTR("Telnet-Server gestartet auf Port %d.\r\n") , TELNET_PORT );

	// Befehlstabelle l철schen
	for ( i = 0 ; i < MAX_TELNET_ENTRYS ; i++ )
    936e:	01 96       	adiw	r24, 0x01	; 1
    9370:	8c 30       	cpi	r24, 0x0C	; 12
    9372:	91 05       	cpc	r25, r1
    9374:	99 f7       	brne	.-26     	; 0x935c <telnet_init+0x30>
	{
		telnet_cmd_table[ i ].dyntelnet_function = NULL;
	}

	THREAD_RegisterThread( telnet_thread, PSTR("telnet"));
    9376:	89 e7       	ldi	r24, 0x79	; 121
    9378:	98 e4       	ldi	r25, 0x48	; 72
    937a:	61 eb       	ldi	r22, 0xB1	; 177
    937c:	71 e1       	ldi	r23, 0x11	; 17
    937e:	0e 94 cc 3f 	call	0x7f98	; 0x7f98 <THREAD_RegisterThread>
}
    9382:	08 95       	ret

00009384 <CRON_checkhit>:
 * \retval  0			Kein Treffer.
 * \retval  1			Treffer! Cron kann ausgef체hrt werden.
 */
/*------------------------------------------------------------------------------------------------------------*/
int CRON_checkhit( int entry )
{
    9384:	cf 93       	push	r28
    9386:	df 93       	push	r29
    9388:	ec 01       	movw	r28, r24
	int returnval = -1;
	char HHhit = 0;
	char MMhit = 0;
	
	if ( crontable[ entry ].CMD_ENTRY == -1 )
    938a:	9c 01       	movw	r18, r24
    938c:	22 0f       	add	r18, r18
    938e:	33 1f       	adc	r19, r19
    9390:	28 0f       	add	r18, r24
    9392:	39 1f       	adc	r19, r25
    9394:	f9 01       	movw	r30, r18
    9396:	ee 0f       	add	r30, r30
    9398:	ff 1f       	adc	r31, r31
    939a:	e7 58       	subi	r30, 0x87	; 135
    939c:	f4 4f       	sbci	r31, 0xF4	; 244
    939e:	84 81       	ldd	r24, Z+4	; 0x04
    93a0:	95 81       	ldd	r25, Z+5	; 0x05
    93a2:	8f 5f       	subi	r24, 0xFF	; 255
    93a4:	9f 4f       	sbci	r25, 0xFF	; 255
    93a6:	09 f4       	brne	.+2      	; 0x93aa <CRON_checkhit+0x26>
    93a8:	43 c0       	rjmp	.+134    	; 0x9430 <CRON_checkhit+0xac>
		return( 0 );
	
	if ( crontable[ entry ].hh < 0 )
    93aa:	f9 01       	movw	r30, r18
    93ac:	ee 0f       	add	r30, r30
    93ae:	ff 1f       	adc	r31, r31
    93b0:	e5 58       	subi	r30, 0x85	; 133
    93b2:	f4 4f       	sbci	r31, 0xF4	; 244
    93b4:	60 81       	ld	r22, Z
    93b6:	71 81       	ldd	r23, Z+1	; 0x01
    93b8:	77 ff       	sbrs	r23, 7
    93ba:	09 c0       	rjmp	.+18     	; 0x93ce <CRON_checkhit+0x4a>
	{
		if ( lasttime.hh % ( crontable[ entry ].hh*-1 ) == 0 )
    93bc:	80 91 6b 0b 	lds	r24, 0x0B6B
    93c0:	30 e0       	ldi	r19, 0x00	; 0
    93c2:	90 e0       	ldi	r25, 0x00	; 0
    93c4:	0e 94 69 6a 	call	0xd4d2	; 0xd4d2 <__divmodhi4>
    93c8:	89 2b       	or	r24, r25
    93ca:	49 f4       	brne	.+18     	; 0x93de <CRON_checkhit+0x5a>
    93cc:	07 c0       	rjmp	.+14     	; 0x93dc <CRON_checkhit+0x58>
			HHhit = 1 ;
	}
	else if ( crontable[ entry ].hh == lasttime.hh )
    93ce:	80 91 6b 0b 	lds	r24, 0x0B6B
    93d2:	30 e0       	ldi	r19, 0x00	; 0
    93d4:	90 e0       	ldi	r25, 0x00	; 0
    93d6:	68 17       	cp	r22, r24
    93d8:	79 07       	cpc	r23, r25
    93da:	09 f4       	brne	.+2      	; 0x93de <CRON_checkhit+0x5a>
    93dc:	31 e0       	ldi	r19, 0x01	; 1
		HHhit = 1 ;
	
	if ( crontable[ entry ].mm < 0 )
    93de:	fe 01       	movw	r30, r28
    93e0:	ee 0f       	add	r30, r30
    93e2:	ff 1f       	adc	r31, r31
    93e4:	ec 0f       	add	r30, r28
    93e6:	fd 1f       	adc	r31, r29
    93e8:	ee 0f       	add	r30, r30
    93ea:	ff 1f       	adc	r31, r31
    93ec:	e7 58       	subi	r30, 0x87	; 135
    93ee:	f4 4f       	sbci	r31, 0xF4	; 244
    93f0:	60 81       	ld	r22, Z
    93f2:	71 81       	ldd	r23, Z+1	; 0x01
    93f4:	77 ff       	sbrs	r23, 7
    93f6:	09 c0       	rjmp	.+18     	; 0x940a <CRON_checkhit+0x86>
	{
		if ( lasttime.mm % ( crontable[ entry ].mm * -1 ) == 0 )
    93f8:	80 91 6a 0b 	lds	r24, 0x0B6A
    93fc:	20 e0       	ldi	r18, 0x00	; 0
    93fe:	90 e0       	ldi	r25, 0x00	; 0
    9400:	0e 94 69 6a 	call	0xd4d2	; 0xd4d2 <__divmodhi4>
    9404:	89 2b       	or	r24, r25
    9406:	49 f4       	brne	.+18     	; 0x941a <CRON_checkhit+0x96>
    9408:	07 c0       	rjmp	.+14     	; 0x9418 <CRON_checkhit+0x94>
			MMhit = 1 ;
	}
	else if ( crontable[ entry ].mm == lasttime.mm )
    940a:	80 91 6a 0b 	lds	r24, 0x0B6A
    940e:	20 e0       	ldi	r18, 0x00	; 0
    9410:	90 e0       	ldi	r25, 0x00	; 0
    9412:	68 17       	cp	r22, r24
    9414:	79 07       	cpc	r23, r25
    9416:	09 f4       	brne	.+2      	; 0x941a <CRON_checkhit+0x96>
    9418:	21 e0       	ldi	r18, 0x01	; 1
		MMhit = 1 ;

	if ( HHhit == 1 && MMhit == 1 )
    941a:	31 30       	cpi	r19, 0x01	; 1
    941c:	49 f4       	brne	.+18     	; 0x9430 <CRON_checkhit+0xac>
    941e:	90 e0       	ldi	r25, 0x00	; 0
    9420:	21 30       	cpi	r18, 0x01	; 1
    9422:	09 f0       	breq	.+2      	; 0x9426 <CRON_checkhit+0xa2>
    9424:	91 e0       	ldi	r25, 0x01	; 1
    9426:	81 e0       	ldi	r24, 0x01	; 1
    9428:	98 27       	eor	r25, r24
    942a:	29 2f       	mov	r18, r25
    942c:	30 e0       	ldi	r19, 0x00	; 0
    942e:	02 c0       	rjmp	.+4      	; 0x9434 <CRON_checkhit+0xb0>
    9430:	20 e0       	ldi	r18, 0x00	; 0
    9432:	30 e0       	ldi	r19, 0x00	; 0
		return( 1 );
	else
		return( 0 );
}
    9434:	c9 01       	movw	r24, r18
    9436:	df 91       	pop	r29
    9438:	cf 91       	pop	r28
    943a:	08 95       	ret

0000943c <CRON_getentry>:
 * \param 	entry			Eintrag der geholt werden soll.
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
int CRON_getentry( char * cronstring, int entry )
{
    943c:	a0 e2       	ldi	r26, 0x20	; 32
    943e:	b0 e0       	ldi	r27, 0x00	; 0
    9440:	e4 e2       	ldi	r30, 0x24	; 36
    9442:	fa e4       	ldi	r31, 0x4A	; 74
    9444:	0c 94 c5 6a 	jmp	0xd58a	; 0xd58a <__prologue_saves__+0x18>
    9448:	7c 01       	movw	r14, r24
	char string[32];
	
	sprintf_P( string, entrystring, entry );
    944a:	00 d0       	rcall	.+0      	; 0x944c <CRON_getentry+0x10>
    944c:	00 d0       	rcall	.+0      	; 0x944e <CRON_getentry+0x12>
    944e:	00 d0       	rcall	.+0      	; 0x9450 <CRON_getentry+0x14>
    9450:	ed b7       	in	r30, 0x3d	; 61
    9452:	fe b7       	in	r31, 0x3e	; 62
    9454:	31 96       	adiw	r30, 0x01	; 1
    9456:	8e 01       	movw	r16, r28
    9458:	0f 5f       	subi	r16, 0xFF	; 255
    945a:	1f 4f       	sbci	r17, 0xFF	; 255
    945c:	ad b7       	in	r26, 0x3d	; 61
    945e:	be b7       	in	r27, 0x3e	; 62
    9460:	12 96       	adiw	r26, 0x02	; 2
    9462:	1c 93       	st	X, r17
    9464:	0e 93       	st	-X, r16
    9466:	11 97       	sbiw	r26, 0x01	; 1
    9468:	8f ed       	ldi	r24, 0xDF	; 223
    946a:	91 e1       	ldi	r25, 0x11	; 17
    946c:	93 83       	std	Z+3, r25	; 0x03
    946e:	82 83       	std	Z+2, r24	; 0x02
    9470:	75 83       	std	Z+5, r23	; 0x05
    9472:	64 83       	std	Z+4, r22	; 0x04
    9474:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
	return( readConfig( string, cronstring ) );
    9478:	8d b7       	in	r24, 0x3d	; 61
    947a:	9e b7       	in	r25, 0x3e	; 62
    947c:	06 96       	adiw	r24, 0x06	; 6
    947e:	0f b6       	in	r0, 0x3f	; 63
    9480:	f8 94       	cli
    9482:	9e bf       	out	0x3e, r25	; 62
    9484:	0f be       	out	0x3f, r0	; 63
    9486:	8d bf       	out	0x3d, r24	; 61
    9488:	c8 01       	movw	r24, r16
    948a:	b7 01       	movw	r22, r14
    948c:	0e 94 33 3b 	call	0x7666	; 0x7666 <readConfig>
}
    9490:	a0 96       	adiw	r28, 0x20	; 32
    9492:	e6 e0       	ldi	r30, 0x06	; 6
    9494:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

00009498 <CRON_delentry>:
 * \retval  -1			Kein freier Platz vorhanden.
 * \retval  >0			Nummer des freien Speicherplatzes.
 */
/*------------------------------------------------------------------------------------------------------------*/
int CRON_delentry( int entry )
{
    9498:	a0 e2       	ldi	r26, 0x20	; 32
    949a:	b0 e0       	ldi	r27, 0x00	; 0
    949c:	e2 e5       	ldi	r30, 0x52	; 82
    949e:	fa e4       	ldi	r31, 0x4A	; 74
    94a0:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	char string[32];

	sprintf_P( string, entrystring, entry );
    94a4:	00 d0       	rcall	.+0      	; 0x94a6 <CRON_delentry+0xe>
    94a6:	00 d0       	rcall	.+0      	; 0x94a8 <CRON_delentry+0x10>
    94a8:	00 d0       	rcall	.+0      	; 0x94aa <CRON_delentry+0x12>
    94aa:	ed b7       	in	r30, 0x3d	; 61
    94ac:	fe b7       	in	r31, 0x3e	; 62
    94ae:	31 96       	adiw	r30, 0x01	; 1
    94b0:	8e 01       	movw	r16, r28
    94b2:	0f 5f       	subi	r16, 0xFF	; 255
    94b4:	1f 4f       	sbci	r17, 0xFF	; 255
    94b6:	ad b7       	in	r26, 0x3d	; 61
    94b8:	be b7       	in	r27, 0x3e	; 62
    94ba:	12 96       	adiw	r26, 0x02	; 2
    94bc:	1c 93       	st	X, r17
    94be:	0e 93       	st	-X, r16
    94c0:	11 97       	sbiw	r26, 0x01	; 1
    94c2:	2f ed       	ldi	r18, 0xDF	; 223
    94c4:	31 e1       	ldi	r19, 0x11	; 17
    94c6:	33 83       	std	Z+3, r19	; 0x03
    94c8:	22 83       	std	Z+2, r18	; 0x02
    94ca:	95 83       	std	Z+5, r25	; 0x05
    94cc:	84 83       	std	Z+4, r24	; 0x04
    94ce:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
	deleteConfig( string );
    94d2:	8d b7       	in	r24, 0x3d	; 61
    94d4:	9e b7       	in	r25, 0x3e	; 62
    94d6:	06 96       	adiw	r24, 0x06	; 6
    94d8:	0f b6       	in	r0, 0x3f	; 63
    94da:	f8 94       	cli
    94dc:	9e bf       	out	0x3e, r25	; 62
    94de:	0f be       	out	0x3f, r0	; 63
    94e0:	8d bf       	out	0x3d, r24	; 61
    94e2:	c8 01       	movw	r24, r16
    94e4:	0e 94 ba 39 	call	0x7374	; 0x7374 <deleteConfig>
}
    94e8:	a0 96       	adiw	r28, 0x20	; 32
    94ea:	e4 e0       	ldi	r30, 0x04	; 4
    94ec:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

000094f0 <CRON_getfreeentry>:
 * \retval  -1			Kein freier Platz vorhanden.
 * \retval  >0			Nummer des freien Speicherplatzes.
 */
/*------------------------------------------------------------------------------------------------------------*/
int CRON_getfreeentry( void )
{
    94f0:	a0 e2       	ldi	r26, 0x20	; 32
    94f2:	b0 e0       	ldi	r27, 0x00	; 0
    94f4:	ee e7       	ldi	r30, 0x7E	; 126
    94f6:	fa e4       	ldi	r31, 0x4A	; 74
    94f8:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    94fc:	00 e0       	ldi	r16, 0x00	; 0
    94fe:	10 e0       	ldi	r17, 0x00	; 0
	
	int i;
	
	for( i = 0 ; i < MAX_CRON ; i++ )
	{
		sprintf_P( string, entrystring, i );
    9500:	7e 01       	movw	r14, r28
    9502:	08 94       	sec
    9504:	e1 1c       	adc	r14, r1
    9506:	f1 1c       	adc	r15, r1
    9508:	6f ed       	ldi	r22, 0xDF	; 223
    950a:	c6 2e       	mov	r12, r22
    950c:	61 e1       	ldi	r22, 0x11	; 17
    950e:	d6 2e       	mov	r13, r22
    9510:	00 d0       	rcall	.+0      	; 0x9512 <CRON_getfreeentry+0x22>
    9512:	00 d0       	rcall	.+0      	; 0x9514 <CRON_getfreeentry+0x24>
    9514:	00 d0       	rcall	.+0      	; 0x9516 <CRON_getfreeentry+0x26>
    9516:	ed b7       	in	r30, 0x3d	; 61
    9518:	fe b7       	in	r31, 0x3e	; 62
    951a:	31 96       	adiw	r30, 0x01	; 1
    951c:	ad b7       	in	r26, 0x3d	; 61
    951e:	be b7       	in	r27, 0x3e	; 62
    9520:	12 96       	adiw	r26, 0x02	; 2
    9522:	fc 92       	st	X, r15
    9524:	ee 92       	st	-X, r14
    9526:	11 97       	sbiw	r26, 0x01	; 1
    9528:	d3 82       	std	Z+3, r13	; 0x03
    952a:	c2 82       	std	Z+2, r12	; 0x02
    952c:	15 83       	std	Z+5, r17	; 0x05
    952e:	04 83       	std	Z+4, r16	; 0x04
    9530:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
		if ( checkConfigName( string ) == -1 )
    9534:	8d b7       	in	r24, 0x3d	; 61
    9536:	9e b7       	in	r25, 0x3e	; 62
    9538:	06 96       	adiw	r24, 0x06	; 6
    953a:	0f b6       	in	r0, 0x3f	; 63
    953c:	f8 94       	cli
    953e:	9e bf       	out	0x3e, r25	; 62
    9540:	0f be       	out	0x3f, r0	; 63
    9542:	8d bf       	out	0x3d, r24	; 61
    9544:	c7 01       	movw	r24, r14
    9546:	0e 94 16 39 	call	0x722c	; 0x722c <checkConfigName>
    954a:	8f 5f       	subi	r24, 0xFF	; 255
    954c:	9f 4f       	sbci	r25, 0xFF	; 255
    954e:	39 f0       	breq	.+14     	; 0x955e <CRON_getfreeentry+0x6e>
{
	char string[32];
	
	int i;
	
	for( i = 0 ; i < MAX_CRON ; i++ )
    9550:	0f 5f       	subi	r16, 0xFF	; 255
    9552:	1f 4f       	sbci	r17, 0xFF	; 255
    9554:	05 30       	cpi	r16, 0x05	; 5
    9556:	11 05       	cpc	r17, r1
    9558:	d9 f6       	brne	.-74     	; 0x9510 <CRON_getfreeentry+0x20>
    955a:	0f ef       	ldi	r16, 0xFF	; 255
    955c:	1f ef       	ldi	r17, 0xFF	; 255
		sprintf_P( string, entrystring, i );
		if ( checkConfigName( string ) == -1 )
			return( i );
	}
	return( -1 );
}
    955e:	c8 01       	movw	r24, r16
    9560:	a0 96       	adiw	r28, 0x20	; 32
    9562:	e8 e0       	ldi	r30, 0x08	; 8
    9564:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

00009568 <CRON_addentry>:
 * \retval  -1			Kein freier Platz vorhanden.
 * \retval  >0			Nummer des freien Speicherplatzes.
 */
/*------------------------------------------------------------------------------------------------------------*/
int CRON_addentry( char * cronstring )
{
    9568:	a0 e2       	ldi	r26, 0x20	; 32
    956a:	b0 e0       	ldi	r27, 0x00	; 0
    956c:	ea eb       	ldi	r30, 0xBA	; 186
    956e:	fa e4       	ldi	r31, 0x4A	; 74
    9570:	0c 94 c5 6a 	jmp	0xd58a	; 0xd58a <__prologue_saves__+0x18>
    9574:	7c 01       	movw	r14, r24
	char string[32];
	int i;
	
	i = CRON_getfreeentry( );
    9576:	0e 94 78 4a 	call	0x94f0	; 0x94f0 <CRON_getfreeentry>
    957a:	9c 01       	movw	r18, r24
	
	if ( i != -1 )
    957c:	8f ef       	ldi	r24, 0xFF	; 255
    957e:	2f 3f       	cpi	r18, 0xFF	; 255
    9580:	38 07       	cpc	r19, r24
    9582:	19 f1       	breq	.+70     	; 0x95ca <CRON_addentry+0x62>
	{
		sprintf_P( string, entrystring, i );
    9584:	00 d0       	rcall	.+0      	; 0x9586 <CRON_addentry+0x1e>
    9586:	00 d0       	rcall	.+0      	; 0x9588 <CRON_addentry+0x20>
    9588:	00 d0       	rcall	.+0      	; 0x958a <CRON_addentry+0x22>
    958a:	ed b7       	in	r30, 0x3d	; 61
    958c:	fe b7       	in	r31, 0x3e	; 62
    958e:	31 96       	adiw	r30, 0x01	; 1
    9590:	8e 01       	movw	r16, r28
    9592:	0f 5f       	subi	r16, 0xFF	; 255
    9594:	1f 4f       	sbci	r17, 0xFF	; 255
    9596:	ad b7       	in	r26, 0x3d	; 61
    9598:	be b7       	in	r27, 0x3e	; 62
    959a:	12 96       	adiw	r26, 0x02	; 2
    959c:	1c 93       	st	X, r17
    959e:	0e 93       	st	-X, r16
    95a0:	11 97       	sbiw	r26, 0x01	; 1
    95a2:	8f ed       	ldi	r24, 0xDF	; 223
    95a4:	91 e1       	ldi	r25, 0x11	; 17
    95a6:	93 83       	std	Z+3, r25	; 0x03
    95a8:	82 83       	std	Z+2, r24	; 0x02
    95aa:	35 83       	std	Z+5, r19	; 0x05
    95ac:	24 83       	std	Z+4, r18	; 0x04
    95ae:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
		writeConfig( string, cronstring );
    95b2:	8d b7       	in	r24, 0x3d	; 61
    95b4:	9e b7       	in	r25, 0x3e	; 62
    95b6:	06 96       	adiw	r24, 0x06	; 6
    95b8:	0f b6       	in	r0, 0x3f	; 63
    95ba:	f8 94       	cli
    95bc:	9e bf       	out	0x3e, r25	; 62
    95be:	0f be       	out	0x3f, r0	; 63
    95c0:	8d bf       	out	0x3d, r24	; 61
    95c2:	c8 01       	movw	r24, r16
    95c4:	b7 01       	movw	r22, r14
    95c6:	0e 94 41 3a 	call	0x7482	; 0x7482 <writeConfig>
	}	
}
    95ca:	a0 96       	adiw	r28, 0x20	; 32
    95cc:	e6 e0       	ldi	r30, 0x06	; 6
    95ce:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

000095d2 <CRON_exec>:
 * \param 	entry	   Eintrag der ausgef체hrt werden soll.
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void CRON_exec( int entry )
{
    95d2:	a5 e3       	ldi	r26, 0x35	; 53
    95d4:	b0 e0       	ldi	r27, 0x00	; 0
    95d6:	ef ee       	ldi	r30, 0xEF	; 239
    95d8:	fa e4       	ldi	r31, 0x4A	; 74
    95da:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
    95de:	bc 01       	movw	r22, r24

	char string[32];
	int argc;
	char * argv[ MAX_CRON_ARGC ];

	CRON_getentry( string, entry );
    95e0:	8e 01       	movw	r16, r28
    95e2:	0a 5e       	subi	r16, 0xEA	; 234
    95e4:	1f 4f       	sbci	r17, 0xFF	; 255
    95e6:	c8 01       	movw	r24, r16
    95e8:	0e 94 1e 4a 	call	0x943c	; 0x943c <CRON_getentry>
/*------------------------------------------------------------------------------------------------------------*/
int CRON_pharseentry( char * cronstring, char ** argv )
{
	int argc;
	
	argc = TELNET_pharse( cronstring, argv, MAX_CRON_ARGC );
    95ec:	c8 01       	movw	r24, r16
    95ee:	be 01       	movw	r22, r28
    95f0:	6f 5f       	subi	r22, 0xFF	; 255
    95f2:	7f 4f       	sbci	r23, 0xFF	; 255
    95f4:	43 e0       	ldi	r20, 0x03	; 3
    95f6:	50 e0       	ldi	r21, 0x00	; 0
    95f8:	0e 94 e6 47 	call	0x8fcc	; 0x8fcc <TELNET_pharse>

	CRON_getentry( string, entry );

	argc = CRON_pharseentry( string, argv );
	
	STDOUT_save( &oldstream );
    95fc:	8e 01       	movw	r16, r28
    95fe:	09 5f       	subi	r16, 0xF9	; 249
    9600:	1f 4f       	sbci	r17, 0xFF	; 255
    9602:	c8 01       	movw	r24, r16
    9604:	0e 94 a4 38 	call	0x7148	; 0x7148 <STDOUT_save>
	STDOUT_set( NONE, 0 );
    9608:	80 e0       	ldi	r24, 0x00	; 0
    960a:	60 e0       	ldi	r22, 0x00	; 0
    960c:	70 e0       	ldi	r23, 0x00	; 0
    960e:	0e 94 76 38 	call	0x70ec	; 0x70ec <STDOUT_set>

	TELNET_runcmdextern( argv[2] );
    9612:	8d 81       	ldd	r24, Y+5	; 0x05
    9614:	9e 81       	ldd	r25, Y+6	; 0x06
    9616:	0e 94 64 48 	call	0x90c8	; 0x90c8 <TELNET_runcmdextern>

	STDOUT_restore( &oldstream );
    961a:	c8 01       	movw	r24, r16
    961c:	0e 94 8e 38 	call	0x711c	; 0x711c <STDOUT_restore>
}
    9620:	e5 96       	adiw	r28, 0x35	; 53
    9622:	e4 e0       	ldi	r30, 0x04	; 4
    9624:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

00009628 <CRON_thread>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void CRON_thread( void )
{
    9628:	a1 e1       	ldi	r26, 0x11	; 17
    962a:	b0 e0       	ldi	r27, 0x00	; 0
    962c:	ea e1       	ldi	r30, 0x1A	; 26
    962e:	fb e4       	ldi	r31, 0x4B	; 75
    9630:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	int i;
	
	struct TIME nowtime;
	
	CLOCK_GetTime ( &nowtime );
    9634:	ce 01       	movw	r24, r28
    9636:	01 96       	adiw	r24, 0x01	; 1
    9638:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <CLOCK_GetTime>
	
	if ( lasttime.hh != nowtime.hh || lasttime.mm != nowtime.mm )
    963c:	90 91 6b 0b 	lds	r25, 0x0B6B
    9640:	8c 81       	ldd	r24, Y+4	; 0x04
    9642:	98 17       	cp	r25, r24
    9644:	29 f4       	brne	.+10     	; 0x9650 <CRON_thread+0x28>
    9646:	90 91 6a 0b 	lds	r25, 0x0B6A
    964a:	8b 81       	ldd	r24, Y+3	; 0x03
    964c:	98 17       	cp	r25, r24
    964e:	a9 f0       	breq	.+42     	; 0x967a <CRON_thread+0x52>
	{
		lasttime.hh = nowtime.hh;
    9650:	8c 81       	ldd	r24, Y+4	; 0x04
    9652:	80 93 6b 0b 	sts	0x0B6B, r24
		lasttime.mm = nowtime.mm;
    9656:	8b 81       	ldd	r24, Y+3	; 0x03
    9658:	80 93 6a 0b 	sts	0x0B6A, r24
    965c:	00 e0       	ldi	r16, 0x00	; 0
    965e:	10 e0       	ldi	r17, 0x00	; 0
		
		for ( i = 0 ; i < MAX_CRON ; i++ )
		{
			if ( CRON_checkhit( i ) )
    9660:	c8 01       	movw	r24, r16
    9662:	0e 94 c2 49 	call	0x9384	; 0x9384 <CRON_checkhit>
    9666:	89 2b       	or	r24, r25
    9668:	19 f0       	breq	.+6      	; 0x9670 <CRON_thread+0x48>
			{
				CRON_exec( i );
    966a:	c8 01       	movw	r24, r16
    966c:	0e 94 e9 4a 	call	0x95d2	; 0x95d2 <CRON_exec>
	if ( lasttime.hh != nowtime.hh || lasttime.mm != nowtime.mm )
	{
		lasttime.hh = nowtime.hh;
		lasttime.mm = nowtime.mm;
		
		for ( i = 0 ; i < MAX_CRON ; i++ )
    9670:	0f 5f       	subi	r16, 0xFF	; 255
    9672:	1f 4f       	sbci	r17, 0xFF	; 255
    9674:	05 30       	cpi	r16, 0x05	; 5
    9676:	11 05       	cpc	r17, r1
    9678:	99 f7       	brne	.-26     	; 0x9660 <CRON_thread+0x38>
			{
				CRON_exec( i );
			}
		}
	}
}
    967a:	61 96       	adiw	r28, 0x11	; 17
    967c:	e4 e0       	ldi	r30, 0x04	; 4
    967e:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

00009682 <CRON_init>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void CRON_init( void )
{
    9682:	a1 e1       	ldi	r26, 0x11	; 17
    9684:	b0 e0       	ldi	r27, 0x00	; 0
    9686:	e7 e4       	ldi	r30, 0x47	; 71
    9688:	fb e4       	ldi	r31, 0x4B	; 75
    968a:	0c 94 c9 6a 	jmp	0xd592	; 0xd592 <__prologue_saves__+0x20>
	int i;
	struct TIME nowtime;
	
	for ( i = 0 ; i < MAX_CRON ; i++ )
		crontable[ i ].CMD_ENTRY = -1 ;
    968e:	8f ef       	ldi	r24, 0xFF	; 255
    9690:	9f ef       	ldi	r25, 0xFF	; 255
    9692:	90 93 7e 0b 	sts	0x0B7E, r25
    9696:	80 93 7d 0b 	sts	0x0B7D, r24
    969a:	90 93 84 0b 	sts	0x0B84, r25
    969e:	80 93 83 0b 	sts	0x0B83, r24
    96a2:	90 93 8a 0b 	sts	0x0B8A, r25
    96a6:	80 93 89 0b 	sts	0x0B89, r24
    96aa:	90 93 90 0b 	sts	0x0B90, r25
    96ae:	80 93 8f 0b 	sts	0x0B8F, r24
    96b2:	90 93 96 0b 	sts	0x0B96, r25
    96b6:	80 93 95 0b 	sts	0x0B95, r24
		
	CLOCK_GetTime ( &nowtime );
    96ba:	ce 01       	movw	r24, r28
    96bc:	01 96       	adiw	r24, 0x01	; 1
    96be:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <CLOCK_GetTime>

	lasttime.hh = nowtime.hh;
    96c2:	8c 81       	ldd	r24, Y+4	; 0x04
    96c4:	80 93 6b 0b 	sts	0x0B6B, r24
	lasttime.mm = nowtime.mm;
    96c8:	8b 81       	ldd	r24, Y+3	; 0x03
    96ca:	80 93 6a 0b 	sts	0x0B6A, r24

	THREAD_RegisterThread( CRON_thread, PSTR("cron"));
    96ce:	84 e1       	ldi	r24, 0x14	; 20
    96d0:	9b e4       	ldi	r25, 0x4B	; 75
    96d2:	61 e1       	ldi	r22, 0x11	; 17
    96d4:	72 e1       	ldi	r23, 0x12	; 18
    96d6:	0e 94 cc 3f 	call	0x7f98	; 0x7f98 <THREAD_RegisterThread>
}
    96da:	61 96       	adiw	r28, 0x11	; 17
    96dc:	e2 e0       	ldi	r30, 0x02	; 2
    96de:	0c 94 e5 6a 	jmp	0xd5ca	; 0xd5ca <__epilogue_restores__+0x20>

000096e2 <CRON_reloadcrontable>:
 * \param 	NONE
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void CRON_reloadcrontable( void )
{
    96e2:	a6 e2       	ldi	r26, 0x26	; 38
    96e4:	b0 e0       	ldi	r27, 0x00	; 0
    96e6:	e7 e7       	ldi	r30, 0x77	; 119
    96e8:	fb e4       	ldi	r31, 0x4B	; 75
    96ea:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
	char HH;
	char MM;
	int argc;
	char * argv[ MAX_CRON_ARGC ];
	
	CRON_init();
    96ee:	0e 94 41 4b 	call	0x9682	; 0x9682 <CRON_init>
    96f2:	cc 24       	eor	r12, r12
    96f4:	dd 24       	eor	r13, r13
    96f6:	aa 24       	eor	r10, r10
    96f8:	bb 24       	eor	r11, r11
	
	for ( i = 0 ; i < MAX_CRON ; i++ )
	{
		sprintf_P( string, entrystring, i );
    96fa:	87 e0       	ldi	r24, 0x07	; 7
    96fc:	88 2e       	mov	r8, r24
    96fe:	91 2c       	mov	r9, r1
    9700:	8c 0e       	add	r8, r28
    9702:	9d 1e       	adc	r9, r29
    9704:	bf ed       	ldi	r27, 0xDF	; 223
    9706:	4b 2e       	mov	r4, r27
    9708:	b1 e1       	ldi	r27, 0x11	; 17
    970a:	5b 2e       	mov	r5, r27
/*------------------------------------------------------------------------------------------------------------*/
int CRON_pharseentry( char * cronstring, char ** argv )
{
	int argc;
	
	argc = TELNET_pharse( cronstring, argv, MAX_CRON_ARGC );
    970c:	3e 01       	movw	r6, r28
    970e:	08 94       	sec
    9710:	61 1c       	adc	r6, r1
    9712:	71 1c       	adc	r7, r1
	
	CRON_init();
	
	for ( i = 0 ; i < MAX_CRON ; i++ )
	{
		sprintf_P( string, entrystring, i );
    9714:	00 d0       	rcall	.+0      	; 0x9716 <CRON_reloadcrontable+0x34>
    9716:	00 d0       	rcall	.+0      	; 0x9718 <CRON_reloadcrontable+0x36>
    9718:	00 d0       	rcall	.+0      	; 0x971a <CRON_reloadcrontable+0x38>
    971a:	ed b7       	in	r30, 0x3d	; 61
    971c:	fe b7       	in	r31, 0x3e	; 62
    971e:	31 96       	adiw	r30, 0x01	; 1
    9720:	ad b7       	in	r26, 0x3d	; 61
    9722:	be b7       	in	r27, 0x3e	; 62
    9724:	12 96       	adiw	r26, 0x02	; 2
    9726:	9c 92       	st	X, r9
    9728:	8e 92       	st	-X, r8
    972a:	11 97       	sbiw	r26, 0x01	; 1
    972c:	53 82       	std	Z+3, r5	; 0x03
    972e:	42 82       	std	Z+2, r4	; 0x02
    9730:	d5 82       	std	Z+5, r13	; 0x05
    9732:	c4 82       	std	Z+4, r12	; 0x04
    9734:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
		if ( readConfig( string, string ) != -1 )
    9738:	ed b7       	in	r30, 0x3d	; 61
    973a:	fe b7       	in	r31, 0x3e	; 62
    973c:	36 96       	adiw	r30, 0x06	; 6
    973e:	0f b6       	in	r0, 0x3f	; 63
    9740:	f8 94       	cli
    9742:	fe bf       	out	0x3e, r31	; 62
    9744:	0f be       	out	0x3f, r0	; 63
    9746:	ed bf       	out	0x3d, r30	; 61
    9748:	c4 01       	movw	r24, r8
    974a:	b4 01       	movw	r22, r8
    974c:	0e 94 33 3b 	call	0x7666	; 0x7666 <readConfig>
    9750:	8f 5f       	subi	r24, 0xFF	; 255
    9752:	9f 4f       	sbci	r25, 0xFF	; 255
    9754:	69 f1       	breq	.+90     	; 0x97b0 <CRON_reloadcrontable+0xce>
/*------------------------------------------------------------------------------------------------------------*/
int CRON_pharseentry( char * cronstring, char ** argv )
{
	int argc;
	
	argc = TELNET_pharse( cronstring, argv, MAX_CRON_ARGC );
    9756:	c4 01       	movw	r24, r8
    9758:	b3 01       	movw	r22, r6
    975a:	43 e0       	ldi	r20, 0x03	; 3
    975c:	50 e0       	ldi	r21, 0x00	; 0
    975e:	0e 94 e6 47 	call	0x8fcc	; 0x8fcc <TELNET_pharse>
	{
		sprintf_P( string, entrystring, i );
		if ( readConfig( string, string ) != -1 )
		{
			argc = CRON_pharseentry( string, argv );
			if ( argc == MAX_CRON_ARGC )
    9762:	03 97       	sbiw	r24, 0x03	; 3
    9764:	29 f5       	brne	.+74     	; 0x97b0 <CRON_reloadcrontable+0xce>
			{
				crontable[ entry ].CMD_ENTRY = i ;
    9766:	85 01       	movw	r16, r10
    9768:	00 0f       	add	r16, r16
    976a:	11 1f       	adc	r17, r17
    976c:	0a 0d       	add	r16, r10
    976e:	1b 1d       	adc	r17, r11
    9770:	00 0f       	add	r16, r16
    9772:	11 1f       	adc	r17, r17
    9774:	e9 e7       	ldi	r30, 0x79	; 121
    9776:	ee 2e       	mov	r14, r30
    9778:	eb e0       	ldi	r30, 0x0B	; 11
    977a:	fe 2e       	mov	r15, r30
    977c:	e0 0e       	add	r14, r16
    977e:	f1 1e       	adc	r15, r17
    9780:	d7 01       	movw	r26, r14
    9782:	15 96       	adiw	r26, 0x05	; 5
    9784:	dc 92       	st	X, r13
    9786:	ce 92       	st	-X, r12
    9788:	14 97       	sbiw	r26, 0x04	; 4
				crontable[ entry ].hh = atoi( argv[ 0 ] );
    978a:	89 81       	ldd	r24, Y+1	; 0x01
    978c:	9a 81       	ldd	r25, Y+2	; 0x02
    978e:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    9792:	05 58       	subi	r16, 0x85	; 133
    9794:	14 4f       	sbci	r17, 0xF4	; 244
    9796:	f8 01       	movw	r30, r16
    9798:	91 83       	std	Z+1, r25	; 0x01
    979a:	80 83       	st	Z, r24
				crontable[ entry ].mm = atoi( argv[ 1 ] );
    979c:	8b 81       	ldd	r24, Y+3	; 0x03
    979e:	9c 81       	ldd	r25, Y+4	; 0x04
    97a0:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    97a4:	d7 01       	movw	r26, r14
    97a6:	8d 93       	st	X+, r24
    97a8:	9c 93       	st	X, r25
				entry++;
    97aa:	08 94       	sec
    97ac:	a1 1c       	adc	r10, r1
    97ae:	b1 1c       	adc	r11, r1
	int argc;
	char * argv[ MAX_CRON_ARGC ];
	
	CRON_init();
	
	for ( i = 0 ; i < MAX_CRON ; i++ )
    97b0:	08 94       	sec
    97b2:	c1 1c       	adc	r12, r1
    97b4:	d1 1c       	adc	r13, r1
    97b6:	b5 e0       	ldi	r27, 0x05	; 5
    97b8:	cb 16       	cp	r12, r27
    97ba:	d1 04       	cpc	r13, r1
    97bc:	09 f0       	breq	.+2      	; 0x97c0 <CRON_reloadcrontable+0xde>
    97be:	aa cf       	rjmp	.-172    	; 0x9714 <CRON_reloadcrontable+0x32>
				crontable[ entry ].mm = atoi( argv[ 1 ] );
				entry++;
			}
		}		
	}
}
    97c0:	a6 96       	adiw	r28, 0x26	; 38
    97c2:	e0 e1       	ldi	r30, 0x10	; 16
    97c4:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

000097c8 <apps_init>:
#endif

void apps_init( void )
{
	// Cron-Dienst starten
	CRON_init();
    97c8:	0e 94 41 4b 	call	0x9682	; 0x9682 <CRON_init>

	CRON_reloadcrontable();
    97cc:	0e 94 71 4b 	call	0x96e2	; 0x96e2 <CRON_reloadcrontable>

	// Dienste starten
	#ifdef HTTPSERVER
		httpd_init();
    97d0:	0e 94 97 43 	call	0x872e	; 0x872e <httpd_init>
	#endif
	#if defined(TELNETSERVER)
		telnet_init();
    97d4:	0e 94 96 49 	call	0x932c	; 0x932c <telnet_init>
		mp3client_init();
	#endif
	#if defined(myAVR) && defined(LCD)
		LCDINFO_init();
	#endif
	can_relay_init();
    97d8:	0e 94 7f 5a 	call	0xb4fe	; 0xb4fe <can_relay_init>
}
    97dc:	08 95       	ret

000097de <modul_init>:
#include "apps/modules/cmd_temp.h"

void modul_init( void )
{
	// Befehle registrieren
	init_cmd_arp();
    97de:	0e 94 04 4c 	call	0x9808	; 0x9808 <init_cmd_arp>
	init_cmd_dns();
    97e2:	0e 94 83 4f 	call	0x9f06	; 0x9f06 <init_cmd_dns>
	init_cmd_stats();
    97e6:	0e 94 d3 4e 	call	0x9da6	; 0x9da6 <init_cmd_stats>
	init_cmd_ifconfig(),
    97ea:	0e 94 0f 52 	call	0xa41e	; 0xa41e <init_cmd_ifconfig>
    97ee:	0e 94 df 55 	call	0xabbe	; 0xabbe <init_cmd_eemem>
	init_cmd_eemem();
	init_cmd_reset();
    97f2:	0e 94 30 4f 	call	0x9e60	; 0x9e60 <init_cmd_reset>
	init_cmd_cron();
    97f6:	0e 94 3f 55 	call	0xaa7e	; 0xaa7e <init_cmd_cron>
#if defined(NTP)
	init_cmd_ntp();
    97fa:	0e 94 b9 53 	call	0xa772	; 0xa772 <init_cmd_ntp>
#endif
#if defined(DNS)
	init_cmd_dns();
    97fe:	0e 94 83 4f 	call	0x9f06	; 0x9f06 <init_cmd_dns>
	init_cmd_stream();
#endif
#if defined(myAVR) && defined( IMPULSCOUNTER )
	IMPULS_init();
#endif
	init_cmd_temp();
    9802:	0e 94 36 54 	call	0xa86c	; 0xa86c <init_cmd_temp>
	
	//	modul_hal_init();
}
    9806:	08 95       	ret

00009808 <init_cmd_arp>:
void init_cmd_arp( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_arp, PSTR("arp"));
#endif
}
    9808:	08 95       	ret

0000980a <cgi_stats>:
 * \param 	pStruct	Struktur auf den HTTP_Request
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void cgi_stats( void * pStruct )
{	
    980a:	a1 e1       	ldi	r26, 0x11	; 17
    980c:	b0 e0       	ldi	r27, 0x00	; 0
    980e:	eb e0       	ldi	r30, 0x0B	; 11
    9810:	fc e4       	ldi	r31, 0x4C	; 76
    9812:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    9816:	6c 01       	movw	r12, r24

	long time;
	
	struct TIME Time;
	// Zeit holen
	CLOCK_GetTime ( &Time );
    9818:	ce 01       	movw	r24, r28
    981a:	01 96       	adiw	r24, 0x01	; 1
    981c:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <CLOCK_GetTime>
	
	VisitCounter++;
    9820:	80 91 f7 04 	lds	r24, 0x04F7
    9824:	90 91 f8 04 	lds	r25, 0x04F8
    9828:	01 96       	adiw	r24, 0x01	; 1
    982a:	90 93 f8 04 	sts	0x04F8, r25
    982e:	80 93 f7 04 	sts	0x04F7, r24
			

	printf_P( PSTR(	"<HTML>"
    9832:	4c 81       	ldd	r20, Y+4	; 0x04
    9834:	5b 81       	ldd	r21, Y+3	; 0x03
    9836:	6a 81       	ldd	r22, Y+2	; 0x02
    9838:	79 81       	ldd	r23, Y+1	; 0x01
    983a:	0e 81       	ldd	r16, Y+6	; 0x06
    983c:	1f 81       	ldd	r17, Y+7	; 0x07
    983e:	28 85       	ldd	r18, Y+8	; 0x08
    9840:	39 85       	ldd	r19, Y+9	; 0x09
    9842:	8d b7       	in	r24, 0x3d	; 61
    9844:	9e b7       	in	r25, 0x3e	; 62
    9846:	40 97       	sbiw	r24, 0x10	; 16
    9848:	0f b6       	in	r0, 0x3f	; 63
    984a:	f8 94       	cli
    984c:	9e bf       	out	0x3e, r25	; 62
    984e:	0f be       	out	0x3f, r0	; 63
    9850:	8d bf       	out	0x3d, r24	; 61
    9852:	ed b7       	in	r30, 0x3d	; 61
    9854:	fe b7       	in	r31, 0x3e	; 62
    9856:	31 96       	adiw	r30, 0x01	; 1
    9858:	8a ed       	ldi	r24, 0xDA	; 218
    985a:	92 e1       	ldi	r25, 0x12	; 18
    985c:	ad b7       	in	r26, 0x3d	; 61
    985e:	be b7       	in	r27, 0x3e	; 62
    9860:	12 96       	adiw	r26, 0x02	; 2
    9862:	9c 93       	st	X, r25
    9864:	8e 93       	st	-X, r24
    9866:	11 97       	sbiw	r26, 0x01	; 1
    9868:	42 83       	std	Z+2, r20	; 0x02
    986a:	13 82       	std	Z+3, r1	; 0x03
    986c:	54 83       	std	Z+4, r21	; 0x04
    986e:	15 82       	std	Z+5, r1	; 0x05
    9870:	66 83       	std	Z+6, r22	; 0x06
    9872:	17 82       	std	Z+7, r1	; 0x07
    9874:	70 87       	std	Z+8, r23	; 0x08
    9876:	11 86       	std	Z+9, r1	; 0x09
    9878:	02 87       	std	Z+10, r16	; 0x0a
    987a:	13 86       	std	Z+11, r1	; 0x0b
    987c:	14 87       	std	Z+12, r17	; 0x0c
    987e:	15 86       	std	Z+13, r1	; 0x0d
    9880:	37 87       	std	Z+15, r19	; 0x0f
    9882:	26 87       	std	Z+14, r18	; 0x0e
    9884:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					"</HEAD>"
					"<BODY bgcolor=\"#228B22\" text=\"#FFFFFF\">"
					"Zeit: %02d:%02d:%02d.%02d ( %u/%u/%04u )"
					", Uptime: "), Time.hh, Time.mm, Time.ss, Time.ms , Time.DD, Time.MM, Time.YY);
	
	time = Time.uptime / ( 86400l );
    9888:	6a 85       	ldd	r22, Y+10	; 0x0a
    988a:	7b 85       	ldd	r23, Y+11	; 0x0b
    988c:	8c 85       	ldd	r24, Y+12	; 0x0c
    988e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9890:	20 e8       	ldi	r18, 0x80	; 128
    9892:	31 e5       	ldi	r19, 0x51	; 81
    9894:	41 e0       	ldi	r20, 0x01	; 1
    9896:	50 e0       	ldi	r21, 0x00	; 0
    9898:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    989c:	79 01       	movw	r14, r18
    989e:	8a 01       	movw	r16, r20
	if ( time != 0 )
    98a0:	ed b7       	in	r30, 0x3d	; 61
    98a2:	fe b7       	in	r31, 0x3e	; 62
    98a4:	70 96       	adiw	r30, 0x10	; 16
    98a6:	0f b6       	in	r0, 0x3f	; 63
    98a8:	f8 94       	cli
    98aa:	fe bf       	out	0x3e, r31	; 62
    98ac:	0f be       	out	0x3f, r0	; 63
    98ae:	ed bf       	out	0x3d, r30	; 61
    98b0:	e1 14       	cp	r14, r1
    98b2:	f1 04       	cpc	r15, r1
    98b4:	01 05       	cpc	r16, r1
    98b6:	11 05       	cpc	r17, r1
    98b8:	39 f1       	breq	.+78     	; 0x9908 <cgi_stats+0xfe>
		if ( time == 1 ) printf_P(PSTR("%ld tag "), time );
    98ba:	f1 e0       	ldi	r31, 0x01	; 1
    98bc:	ef 16       	cp	r14, r31
    98be:	f1 04       	cpc	r15, r1
    98c0:	01 05       	cpc	r16, r1
    98c2:	11 05       	cpc	r17, r1
    98c4:	31 f4       	brne	.+12     	; 0x98d2 <cgi_stats+0xc8>
    98c6:	00 d0       	rcall	.+0      	; 0x98c8 <cgi_stats+0xbe>
    98c8:	00 d0       	rcall	.+0      	; 0x98ca <cgi_stats+0xc0>
    98ca:	00 d0       	rcall	.+0      	; 0x98cc <cgi_stats+0xc2>
    98cc:	81 ed       	ldi	r24, 0xD1	; 209
    98ce:	92 e1       	ldi	r25, 0x12	; 18
    98d0:	05 c0       	rjmp	.+10     	; 0x98dc <cgi_stats+0xd2>
		else printf_P(PSTR("%ld tage "), time );
    98d2:	00 d0       	rcall	.+0      	; 0x98d4 <cgi_stats+0xca>
    98d4:	00 d0       	rcall	.+0      	; 0x98d6 <cgi_stats+0xcc>
    98d6:	00 d0       	rcall	.+0      	; 0x98d8 <cgi_stats+0xce>
    98d8:	87 ec       	ldi	r24, 0xC7	; 199
    98da:	92 e1       	ldi	r25, 0x12	; 18
    98dc:	ad b7       	in	r26, 0x3d	; 61
    98de:	be b7       	in	r27, 0x3e	; 62
    98e0:	12 96       	adiw	r26, 0x02	; 2
    98e2:	9c 93       	st	X, r25
    98e4:	8e 93       	st	-X, r24
    98e6:	11 97       	sbiw	r26, 0x01	; 1
    98e8:	ed b7       	in	r30, 0x3d	; 61
    98ea:	fe b7       	in	r31, 0x3e	; 62
    98ec:	e3 82       	std	Z+3, r14	; 0x03
    98ee:	f4 82       	std	Z+4, r15	; 0x04
    98f0:	05 83       	std	Z+5, r16	; 0x05
    98f2:	16 83       	std	Z+6, r17	; 0x06
    98f4:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    98f8:	8d b7       	in	r24, 0x3d	; 61
    98fa:	9e b7       	in	r25, 0x3e	; 62
    98fc:	06 96       	adiw	r24, 0x06	; 6
    98fe:	0f b6       	in	r0, 0x3f	; 63
    9900:	f8 94       	cli
    9902:	9e bf       	out	0x3e, r25	; 62
    9904:	0f be       	out	0x3f, r0	; 63
    9906:	8d bf       	out	0x3d, r24	; 61

	time = ( Time.uptime % ( 86400l ) ) / 3600;
    9908:	6a 85       	ldd	r22, Y+10	; 0x0a
    990a:	7b 85       	ldd	r23, Y+11	; 0x0b
    990c:	8c 85       	ldd	r24, Y+12	; 0x0c
    990e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9910:	20 e8       	ldi	r18, 0x80	; 128
    9912:	31 e5       	ldi	r19, 0x51	; 81
    9914:	41 e0       	ldi	r20, 0x01	; 1
    9916:	50 e0       	ldi	r21, 0x00	; 0
    9918:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    991c:	20 e1       	ldi	r18, 0x10	; 16
    991e:	3e e0       	ldi	r19, 0x0E	; 14
    9920:	40 e0       	ldi	r20, 0x00	; 0
    9922:	50 e0       	ldi	r21, 0x00	; 0
    9924:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    9928:	79 01       	movw	r14, r18
    992a:	8a 01       	movw	r16, r20
	if ( time != 0 ) printf_P(PSTR("%ld std "), time );
    992c:	e1 14       	cp	r14, r1
    992e:	f1 04       	cpc	r15, r1
    9930:	01 05       	cpc	r16, r1
    9932:	11 05       	cpc	r17, r1
    9934:	d9 f0       	breq	.+54     	; 0x996c <cgi_stats+0x162>
    9936:	00 d0       	rcall	.+0      	; 0x9938 <cgi_stats+0x12e>
    9938:	00 d0       	rcall	.+0      	; 0x993a <cgi_stats+0x130>
    993a:	00 d0       	rcall	.+0      	; 0x993c <cgi_stats+0x132>
    993c:	8e eb       	ldi	r24, 0xBE	; 190
    993e:	92 e1       	ldi	r25, 0x12	; 18
    9940:	ad b7       	in	r26, 0x3d	; 61
    9942:	be b7       	in	r27, 0x3e	; 62
    9944:	12 96       	adiw	r26, 0x02	; 2
    9946:	9c 93       	st	X, r25
    9948:	8e 93       	st	-X, r24
    994a:	11 97       	sbiw	r26, 0x01	; 1
    994c:	ed b7       	in	r30, 0x3d	; 61
    994e:	fe b7       	in	r31, 0x3e	; 62
    9950:	e3 82       	std	Z+3, r14	; 0x03
    9952:	f4 82       	std	Z+4, r15	; 0x04
    9954:	05 83       	std	Z+5, r16	; 0x05
    9956:	16 83       	std	Z+6, r17	; 0x06
    9958:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    995c:	8d b7       	in	r24, 0x3d	; 61
    995e:	9e b7       	in	r25, 0x3e	; 62
    9960:	06 96       	adiw	r24, 0x06	; 6
    9962:	0f b6       	in	r0, 0x3f	; 63
    9964:	f8 94       	cli
    9966:	9e bf       	out	0x3e, r25	; 62
    9968:	0f be       	out	0x3f, r0	; 63
    996a:	8d bf       	out	0x3d, r24	; 61

	time = ( Time.uptime % 3600 ) / 60;
    996c:	6a 85       	ldd	r22, Y+10	; 0x0a
    996e:	7b 85       	ldd	r23, Y+11	; 0x0b
    9970:	8c 85       	ldd	r24, Y+12	; 0x0c
    9972:	9d 85       	ldd	r25, Y+13	; 0x0d
    9974:	20 e1       	ldi	r18, 0x10	; 16
    9976:	3e e0       	ldi	r19, 0x0E	; 14
    9978:	40 e0       	ldi	r20, 0x00	; 0
    997a:	50 e0       	ldi	r21, 0x00	; 0
    997c:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    9980:	2c e3       	ldi	r18, 0x3C	; 60
    9982:	30 e0       	ldi	r19, 0x00	; 0
    9984:	40 e0       	ldi	r20, 0x00	; 0
    9986:	50 e0       	ldi	r21, 0x00	; 0
    9988:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    998c:	79 01       	movw	r14, r18
    998e:	8a 01       	movw	r16, r20
	if ( time != 0 ) printf_P(PSTR("%ld min "), time );
    9990:	e1 14       	cp	r14, r1
    9992:	f1 04       	cpc	r15, r1
    9994:	01 05       	cpc	r16, r1
    9996:	11 05       	cpc	r17, r1
    9998:	d9 f0       	breq	.+54     	; 0x99d0 <cgi_stats+0x1c6>
    999a:	00 d0       	rcall	.+0      	; 0x999c <cgi_stats+0x192>
    999c:	00 d0       	rcall	.+0      	; 0x999e <cgi_stats+0x194>
    999e:	00 d0       	rcall	.+0      	; 0x99a0 <cgi_stats+0x196>
    99a0:	85 eb       	ldi	r24, 0xB5	; 181
    99a2:	92 e1       	ldi	r25, 0x12	; 18
    99a4:	ad b7       	in	r26, 0x3d	; 61
    99a6:	be b7       	in	r27, 0x3e	; 62
    99a8:	12 96       	adiw	r26, 0x02	; 2
    99aa:	9c 93       	st	X, r25
    99ac:	8e 93       	st	-X, r24
    99ae:	11 97       	sbiw	r26, 0x01	; 1
    99b0:	ed b7       	in	r30, 0x3d	; 61
    99b2:	fe b7       	in	r31, 0x3e	; 62
    99b4:	e3 82       	std	Z+3, r14	; 0x03
    99b6:	f4 82       	std	Z+4, r15	; 0x04
    99b8:	05 83       	std	Z+5, r16	; 0x05
    99ba:	16 83       	std	Z+6, r17	; 0x06
    99bc:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    99c0:	8d b7       	in	r24, 0x3d	; 61
    99c2:	9e b7       	in	r25, 0x3e	; 62
    99c4:	06 96       	adiw	r24, 0x06	; 6
    99c6:	0f b6       	in	r0, 0x3f	; 63
    99c8:	f8 94       	cli
    99ca:	9e bf       	out	0x3e, r25	; 62
    99cc:	0f be       	out	0x3f, r0	; 63
    99ce:	8d bf       	out	0x3d, r24	; 61

	time = Time.uptime % 60;
    99d0:	6a 85       	ldd	r22, Y+10	; 0x0a
    99d2:	7b 85       	ldd	r23, Y+11	; 0x0b
    99d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    99d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    99d8:	2c e3       	ldi	r18, 0x3C	; 60
    99da:	30 e0       	ldi	r19, 0x00	; 0
    99dc:	40 e0       	ldi	r20, 0x00	; 0
    99de:	50 e0       	ldi	r21, 0x00	; 0
    99e0:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    99e4:	9b 01       	movw	r18, r22
    99e6:	ac 01       	movw	r20, r24
	if ( time != 0 ) printf_P(PSTR("%ld sek"), time );
    99e8:	21 15       	cp	r18, r1
    99ea:	31 05       	cpc	r19, r1
    99ec:	41 05       	cpc	r20, r1
    99ee:	51 05       	cpc	r21, r1
    99f0:	d9 f0       	breq	.+54     	; 0x9a28 <cgi_stats+0x21e>
    99f2:	00 d0       	rcall	.+0      	; 0x99f4 <cgi_stats+0x1ea>
    99f4:	00 d0       	rcall	.+0      	; 0x99f6 <cgi_stats+0x1ec>
    99f6:	00 d0       	rcall	.+0      	; 0x99f8 <cgi_stats+0x1ee>
    99f8:	8d ea       	ldi	r24, 0xAD	; 173
    99fa:	92 e1       	ldi	r25, 0x12	; 18
    99fc:	ad b7       	in	r26, 0x3d	; 61
    99fe:	be b7       	in	r27, 0x3e	; 62
    9a00:	12 96       	adiw	r26, 0x02	; 2
    9a02:	9c 93       	st	X, r25
    9a04:	8e 93       	st	-X, r24
    9a06:	11 97       	sbiw	r26, 0x01	; 1
    9a08:	ed b7       	in	r30, 0x3d	; 61
    9a0a:	fe b7       	in	r31, 0x3e	; 62
    9a0c:	23 83       	std	Z+3, r18	; 0x03
    9a0e:	34 83       	std	Z+4, r19	; 0x04
    9a10:	45 83       	std	Z+5, r20	; 0x05
    9a12:	56 83       	std	Z+6, r21	; 0x06
    9a14:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9a18:	8d b7       	in	r24, 0x3d	; 61
    9a1a:	9e b7       	in	r25, 0x3e	; 62
    9a1c:	06 96       	adiw	r24, 0x06	; 6
    9a1e:	0f b6       	in	r0, 0x3f	; 63
    9a20:	f8 94       	cli
    9a22:	9e bf       	out	0x3e, r25	; 62
    9a24:	0f be       	out	0x3f, r0	; 63
    9a26:	8d bf       	out	0x3d, r24	; 61
	
	printf_P( PSTR(	", "
    9a28:	00 d0       	rcall	.+0      	; 0x9a2a <cgi_stats+0x220>
    9a2a:	81 ea       	ldi	r24, 0xA1	; 161
    9a2c:	92 e1       	ldi	r25, 0x12	; 18
    9a2e:	ad b7       	in	r26, 0x3d	; 61
    9a30:	be b7       	in	r27, 0x3e	; 62
    9a32:	12 96       	adiw	r26, 0x02	; 2
    9a34:	9c 93       	st	X, r25
    9a36:	8e 93       	st	-X, r24
    9a38:	11 97       	sbiw	r26, 0x01	; 1
    9a3a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					"Ethernet:") );
	
	if ( ByteCounter < 1024 )
    9a3e:	20 91 3d 0a 	lds	r18, 0x0A3D
    9a42:	30 91 3e 0a 	lds	r19, 0x0A3E
    9a46:	40 91 3f 0a 	lds	r20, 0x0A3F
    9a4a:	50 91 40 0a 	lds	r21, 0x0A40
    9a4e:	0f 90       	pop	r0
    9a50:	0f 90       	pop	r0
    9a52:	20 30       	cpi	r18, 0x00	; 0
    9a54:	b4 e0       	ldi	r27, 0x04	; 4
    9a56:	3b 07       	cpc	r19, r27
    9a58:	b0 e0       	ldi	r27, 0x00	; 0
    9a5a:	4b 07       	cpc	r20, r27
    9a5c:	b0 e0       	ldi	r27, 0x00	; 0
    9a5e:	5b 07       	cpc	r21, r27
    9a60:	b8 f4       	brcc	.+46     	; 0x9a90 <cgi_stats+0x286>
		printf_P( PSTR(" %ld Bytes "), ByteCounter);
    9a62:	00 d0       	rcall	.+0      	; 0x9a64 <cgi_stats+0x25a>
    9a64:	00 d0       	rcall	.+0      	; 0x9a66 <cgi_stats+0x25c>
    9a66:	00 d0       	rcall	.+0      	; 0x9a68 <cgi_stats+0x25e>
    9a68:	85 e9       	ldi	r24, 0x95	; 149
    9a6a:	92 e1       	ldi	r25, 0x12	; 18
    9a6c:	ed b7       	in	r30, 0x3d	; 61
    9a6e:	fe b7       	in	r31, 0x3e	; 62
    9a70:	92 83       	std	Z+2, r25	; 0x02
    9a72:	81 83       	std	Z+1, r24	; 0x01
    9a74:	ad b7       	in	r26, 0x3d	; 61
    9a76:	be b7       	in	r27, 0x3e	; 62
    9a78:	13 96       	adiw	r26, 0x03	; 3
    9a7a:	2d 93       	st	X+, r18
    9a7c:	3d 93       	st	X+, r19
    9a7e:	4d 93       	st	X+, r20
    9a80:	5c 93       	st	X, r21
    9a82:	16 97       	sbiw	r26, 0x06	; 6
    9a84:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9a88:	ed b7       	in	r30, 0x3d	; 61
    9a8a:	fe b7       	in	r31, 0x3e	; 62
    9a8c:	36 96       	adiw	r30, 0x06	; 6
    9a8e:	8c c0       	rjmp	.+280    	; 0x9ba8 <cgi_stats+0x39e>
	else if ( ByteCounter < ( 1024l*1024l ) )
    9a90:	20 30       	cpi	r18, 0x00	; 0
    9a92:	f0 e0       	ldi	r31, 0x00	; 0
    9a94:	3f 07       	cpc	r19, r31
    9a96:	f0 e1       	ldi	r31, 0x10	; 16
    9a98:	4f 07       	cpc	r20, r31
    9a9a:	f0 e0       	ldi	r31, 0x00	; 0
    9a9c:	5f 07       	cpc	r21, r31
    9a9e:	18 f5       	brcc	.+70     	; 0x9ae6 <cgi_stats+0x2dc>
		printf_P( PSTR(" %ld kBytes "), ByteCounter / 1024l );
    9aa0:	00 d0       	rcall	.+0      	; 0x9aa2 <cgi_stats+0x298>
    9aa2:	00 d0       	rcall	.+0      	; 0x9aa4 <cgi_stats+0x29a>
    9aa4:	00 d0       	rcall	.+0      	; 0x9aa6 <cgi_stats+0x29c>
    9aa6:	88 e8       	ldi	r24, 0x88	; 136
    9aa8:	92 e1       	ldi	r25, 0x12	; 18
    9aaa:	ad b7       	in	r26, 0x3d	; 61
    9aac:	be b7       	in	r27, 0x3e	; 62
    9aae:	12 96       	adiw	r26, 0x02	; 2
    9ab0:	9c 93       	st	X, r25
    9ab2:	8e 93       	st	-X, r24
    9ab4:	11 97       	sbiw	r26, 0x01	; 1
    9ab6:	7a e0       	ldi	r23, 0x0A	; 10
    9ab8:	56 95       	lsr	r21
    9aba:	47 95       	ror	r20
    9abc:	37 95       	ror	r19
    9abe:	27 95       	ror	r18
    9ac0:	7a 95       	dec	r23
    9ac2:	d1 f7       	brne	.-12     	; 0x9ab8 <cgi_stats+0x2ae>
    9ac4:	ed b7       	in	r30, 0x3d	; 61
    9ac6:	fe b7       	in	r31, 0x3e	; 62
    9ac8:	23 83       	std	Z+3, r18	; 0x03
    9aca:	34 83       	std	Z+4, r19	; 0x04
    9acc:	45 83       	std	Z+5, r20	; 0x05
    9ace:	56 83       	std	Z+6, r21	; 0x06
    9ad0:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9ad4:	8d b7       	in	r24, 0x3d	; 61
    9ad6:	9e b7       	in	r25, 0x3e	; 62
    9ad8:	06 96       	adiw	r24, 0x06	; 6
    9ada:	0f b6       	in	r0, 0x3f	; 63
    9adc:	f8 94       	cli
    9ade:	9e bf       	out	0x3e, r25	; 62
    9ae0:	0f be       	out	0x3f, r0	; 63
    9ae2:	8d bf       	out	0x3d, r24	; 61
    9ae4:	66 c0       	rjmp	.+204    	; 0x9bb2 <cgi_stats+0x3a8>
	else if ( ByteCounter < (1024l*1024l*1024l) )
    9ae6:	20 30       	cpi	r18, 0x00	; 0
    9ae8:	90 e0       	ldi	r25, 0x00	; 0
    9aea:	39 07       	cpc	r19, r25
    9aec:	90 e0       	ldi	r25, 0x00	; 0
    9aee:	49 07       	cpc	r20, r25
    9af0:	90 e4       	ldi	r25, 0x40	; 64
    9af2:	59 07       	cpc	r21, r25
    9af4:	40 f5       	brcc	.+80     	; 0x9b46 <cgi_stats+0x33c>
		printf_P( PSTR(" %ld.%03ld MBytes "), ByteCounter / ( 1024l * 1024l ), ( ByteCounter % ( 1024l * 1024l ) ) / 1024l  );
    9af6:	ad b7       	in	r26, 0x3d	; 61
    9af8:	be b7       	in	r27, 0x3e	; 62
    9afa:	1a 97       	sbiw	r26, 0x0a	; 10
    9afc:	0f b6       	in	r0, 0x3f	; 63
    9afe:	f8 94       	cli
    9b00:	be bf       	out	0x3e, r27	; 62
    9b02:	0f be       	out	0x3f, r0	; 63
    9b04:	ad bf       	out	0x3d, r26	; 61
    9b06:	ed b7       	in	r30, 0x3d	; 61
    9b08:	fe b7       	in	r31, 0x3e	; 62
    9b0a:	31 96       	adiw	r30, 0x01	; 1
    9b0c:	85 e7       	ldi	r24, 0x75	; 117
    9b0e:	92 e1       	ldi	r25, 0x12	; 18
    9b10:	12 96       	adiw	r26, 0x02	; 2
    9b12:	9c 93       	st	X, r25
    9b14:	8e 93       	st	-X, r24
    9b16:	11 97       	sbiw	r26, 0x01	; 1
    9b18:	da 01       	movw	r26, r20
    9b1a:	c9 01       	movw	r24, r18
    9b1c:	64 e1       	ldi	r22, 0x14	; 20
    9b1e:	b6 95       	lsr	r27
    9b20:	a7 95       	ror	r26
    9b22:	97 95       	ror	r25
    9b24:	87 95       	ror	r24
    9b26:	6a 95       	dec	r22
    9b28:	d1 f7       	brne	.-12     	; 0x9b1e <cgi_stats+0x314>
    9b2a:	82 83       	std	Z+2, r24	; 0x02
    9b2c:	93 83       	std	Z+3, r25	; 0x03
    9b2e:	a4 83       	std	Z+4, r26	; 0x04
    9b30:	b5 83       	std	Z+5, r27	; 0x05
    9b32:	4f 70       	andi	r20, 0x0F	; 15
    9b34:	50 70       	andi	r21, 0x00	; 0
    9b36:	7a e0       	ldi	r23, 0x0A	; 10
    9b38:	56 95       	lsr	r21
    9b3a:	47 95       	ror	r20
    9b3c:	37 95       	ror	r19
    9b3e:	27 95       	ror	r18
    9b40:	7a 95       	dec	r23
    9b42:	d1 f7       	brne	.-12     	; 0x9b38 <cgi_stats+0x32e>
    9b44:	28 c0       	rjmp	.+80     	; 0x9b96 <cgi_stats+0x38c>
	else
		printf_P( PSTR(" %ld.%03ld GBytes "), ByteCounter / ( 1024l * 1024l *1024l ), ( ByteCounter % ( 1024l * 1024l * 1024l ) ) / ( 1024l * 1024l ) );
    9b46:	8d b7       	in	r24, 0x3d	; 61
    9b48:	9e b7       	in	r25, 0x3e	; 62
    9b4a:	0a 97       	sbiw	r24, 0x0a	; 10
    9b4c:	0f b6       	in	r0, 0x3f	; 63
    9b4e:	f8 94       	cli
    9b50:	9e bf       	out	0x3e, r25	; 62
    9b52:	0f be       	out	0x3f, r0	; 63
    9b54:	8d bf       	out	0x3d, r24	; 61
    9b56:	ed b7       	in	r30, 0x3d	; 61
    9b58:	fe b7       	in	r31, 0x3e	; 62
    9b5a:	31 96       	adiw	r30, 0x01	; 1
    9b5c:	82 e6       	ldi	r24, 0x62	; 98
    9b5e:	92 e1       	ldi	r25, 0x12	; 18
    9b60:	ad b7       	in	r26, 0x3d	; 61
    9b62:	be b7       	in	r27, 0x3e	; 62
    9b64:	12 96       	adiw	r26, 0x02	; 2
    9b66:	9c 93       	st	X, r25
    9b68:	8e 93       	st	-X, r24
    9b6a:	11 97       	sbiw	r26, 0x01	; 1
    9b6c:	da 01       	movw	r26, r20
    9b6e:	c9 01       	movw	r24, r18
    9b70:	6e e1       	ldi	r22, 0x1E	; 30
    9b72:	b6 95       	lsr	r27
    9b74:	a7 95       	ror	r26
    9b76:	97 95       	ror	r25
    9b78:	87 95       	ror	r24
    9b7a:	6a 95       	dec	r22
    9b7c:	d1 f7       	brne	.-12     	; 0x9b72 <cgi_stats+0x368>
    9b7e:	82 83       	std	Z+2, r24	; 0x02
    9b80:	93 83       	std	Z+3, r25	; 0x03
    9b82:	a4 83       	std	Z+4, r26	; 0x04
    9b84:	b5 83       	std	Z+5, r27	; 0x05
    9b86:	5f 73       	andi	r21, 0x3F	; 63
    9b88:	84 e1       	ldi	r24, 0x14	; 20
    9b8a:	56 95       	lsr	r21
    9b8c:	47 95       	ror	r20
    9b8e:	37 95       	ror	r19
    9b90:	27 95       	ror	r18
    9b92:	8a 95       	dec	r24
    9b94:	d1 f7       	brne	.-12     	; 0x9b8a <cgi_stats+0x380>
    9b96:	26 83       	std	Z+6, r18	; 0x06
    9b98:	37 83       	std	Z+7, r19	; 0x07
    9b9a:	40 87       	std	Z+8, r20	; 0x08
    9b9c:	51 87       	std	Z+9, r21	; 0x09
    9b9e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9ba2:	ed b7       	in	r30, 0x3d	; 61
    9ba4:	fe b7       	in	r31, 0x3e	; 62
    9ba6:	3a 96       	adiw	r30, 0x0a	; 10
    9ba8:	0f b6       	in	r0, 0x3f	; 63
    9baa:	f8 94       	cli
    9bac:	fe bf       	out	0x3e, r31	; 62
    9bae:	0f be       	out	0x3f, r0	; 63
    9bb0:	ed bf       	out	0x3d, r30	; 61
		
	printf_P( PSTR( "in %ld Packeten ; "
    9bb2:	8d b7       	in	r24, 0x3d	; 61
    9bb4:	9e b7       	in	r25, 0x3e	; 62
    9bb6:	0a 97       	sbiw	r24, 0x0a	; 10
    9bb8:	0f b6       	in	r0, 0x3f	; 63
    9bba:	f8 94       	cli
    9bbc:	9e bf       	out	0x3e, r25	; 62
    9bbe:	0f be       	out	0x3f, r0	; 63
    9bc0:	8d bf       	out	0x3d, r24	; 61
    9bc2:	ed b7       	in	r30, 0x3d	; 61
    9bc4:	fe b7       	in	r31, 0x3e	; 62
    9bc6:	31 96       	adiw	r30, 0x01	; 1
    9bc8:	86 e1       	ldi	r24, 0x16	; 22
    9bca:	92 e1       	ldi	r25, 0x12	; 18
    9bcc:	ad b7       	in	r26, 0x3d	; 61
    9bce:	be b7       	in	r27, 0x3e	; 62
    9bd0:	12 96       	adiw	r26, 0x02	; 2
    9bd2:	9c 93       	st	X, r25
    9bd4:	8e 93       	st	-X, r24
    9bd6:	11 97       	sbiw	r26, 0x01	; 1
    9bd8:	80 91 39 0a 	lds	r24, 0x0A39
    9bdc:	90 91 3a 0a 	lds	r25, 0x0A3A
    9be0:	a0 91 3b 0a 	lds	r26, 0x0A3B
    9be4:	b0 91 3c 0a 	lds	r27, 0x0A3C
    9be8:	82 83       	std	Z+2, r24	; 0x02
    9bea:	93 83       	std	Z+3, r25	; 0x03
    9bec:	a4 83       	std	Z+4, r26	; 0x04
    9bee:	b5 83       	std	Z+5, r27	; 0x05
    9bf0:	80 91 f7 04 	lds	r24, 0x04F7
    9bf4:	90 91 f8 04 	lds	r25, 0x04F8
    9bf8:	97 83       	std	Z+7, r25	; 0x07
    9bfa:	86 83       	std	Z+6, r24	; 0x06
    9bfc:	8d e7       	ldi	r24, 0x7D	; 125
    9bfe:	92 e0       	ldi	r25, 0x02	; 2
    9c00:	c8 0e       	add	r12, r24
    9c02:	d9 1e       	adc	r13, r25
    9c04:	d6 01       	movw	r26, r12
    9c06:	8d 91       	ld	r24, X+
    9c08:	9c 91       	ld	r25, X
    9c0a:	91 87       	std	Z+9, r25	; 0x09
    9c0c:	80 87       	std	Z+8, r24	; 0x08
    9c0e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9c12:	ed b7       	in	r30, 0x3d	; 61
    9c14:	fe b7       	in	r31, 0x3e	; 62
    9c16:	3a 96       	adiw	r30, 0x0a	; 10
    9c18:	0f b6       	in	r0, 0x3f	; 63
    9c1a:	f8 94       	cli
    9c1c:	fe bf       	out	0x3e, r31	; 62
    9c1e:	0f be       	out	0x3f, r0	; 63
    9c20:	ed bf       	out	0x3d, r30	; 61
					"Du bist der %d. Besucher auf Socket %d."
					"</BODY>"
					"</HTML>"
					"\r\n\r\n"), PacketCounter, VisitCounter, http_request->HTTP_SOCKET );

}
    9c22:	61 96       	adiw	r28, 0x11	; 17
    9c24:	e8 e0       	ldi	r30, 0x08	; 8
    9c26:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

00009c2a <cmd_stats>:
	cgi_RegisterCGI( cgi_stats, PSTR("stats.cgi"));
#endif
}

int cmd_stats( int argc, char ** argv )
{
    9c2a:	df 92       	push	r13
    9c2c:	ef 92       	push	r14
    9c2e:	ff 92       	push	r15
    9c30:	0f 93       	push	r16
    9c32:	1f 93       	push	r17
	unsigned int REVID,_PHSTAT1,_PHSTAT2;

	// buffer mit ausgabe vorbereiten & ausgeben
	printf_P( PSTR("Ethernet: %ld Bytes in %ld Packeten\r\n") , ByteCounter, PacketCounter );
    9c34:	8d b7       	in	r24, 0x3d	; 61
    9c36:	9e b7       	in	r25, 0x3e	; 62
    9c38:	0a 97       	sbiw	r24, 0x0a	; 10
    9c3a:	0f b6       	in	r0, 0x3f	; 63
    9c3c:	f8 94       	cli
    9c3e:	9e bf       	out	0x3e, r25	; 62
    9c40:	0f be       	out	0x3f, r0	; 63
    9c42:	8d bf       	out	0x3d, r24	; 61
    9c44:	ed b7       	in	r30, 0x3d	; 61
    9c46:	fe b7       	in	r31, 0x3e	; 62
    9c48:	31 96       	adiw	r30, 0x01	; 1
    9c4a:	87 e3       	ldi	r24, 0x37	; 55
    9c4c:	94 e1       	ldi	r25, 0x14	; 20
    9c4e:	ad b7       	in	r26, 0x3d	; 61
    9c50:	be b7       	in	r27, 0x3e	; 62
    9c52:	12 96       	adiw	r26, 0x02	; 2
    9c54:	9c 93       	st	X, r25
    9c56:	8e 93       	st	-X, r24
    9c58:	11 97       	sbiw	r26, 0x01	; 1
    9c5a:	80 91 3d 0a 	lds	r24, 0x0A3D
    9c5e:	90 91 3e 0a 	lds	r25, 0x0A3E
    9c62:	a0 91 3f 0a 	lds	r26, 0x0A3F
    9c66:	b0 91 40 0a 	lds	r27, 0x0A40
    9c6a:	82 83       	std	Z+2, r24	; 0x02
    9c6c:	93 83       	std	Z+3, r25	; 0x03
    9c6e:	a4 83       	std	Z+4, r26	; 0x04
    9c70:	b5 83       	std	Z+5, r27	; 0x05
    9c72:	80 91 39 0a 	lds	r24, 0x0A39
    9c76:	90 91 3a 0a 	lds	r25, 0x0A3A
    9c7a:	a0 91 3b 0a 	lds	r26, 0x0A3B
    9c7e:	b0 91 3c 0a 	lds	r27, 0x0A3C
    9c82:	86 83       	std	Z+6, r24	; 0x06
    9c84:	97 83       	std	Z+7, r25	; 0x07
    9c86:	a0 87       	std	Z+8, r26	; 0x08
    9c88:	b1 87       	std	Z+9, r27	; 0x09
    9c8a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	#ifdef TCP_with_unsortseq
		printf_P( PSTR("TCP-TX Errors: %d TCP-RX Errors: %d (unsorted %d, oldseq %d)\r\n\r\n"), TXErrorCounter , RXErrorCounter, RXErrorUnsort, RXErrorOldSeq );
    9c8e:	ed b7       	in	r30, 0x3d	; 61
    9c90:	fe b7       	in	r31, 0x3e	; 62
    9c92:	31 96       	adiw	r30, 0x01	; 1
    9c94:	86 ef       	ldi	r24, 0xF6	; 246
    9c96:	93 e1       	ldi	r25, 0x13	; 19
    9c98:	ad b7       	in	r26, 0x3d	; 61
    9c9a:	be b7       	in	r27, 0x3e	; 62
    9c9c:	12 96       	adiw	r26, 0x02	; 2
    9c9e:	9c 93       	st	X, r25
    9ca0:	8e 93       	st	-X, r24
    9ca2:	11 97       	sbiw	r26, 0x01	; 1
    9ca4:	80 91 cf 01 	lds	r24, 0x01CF
    9ca8:	90 91 d0 01 	lds	r25, 0x01D0
    9cac:	93 83       	std	Z+3, r25	; 0x03
    9cae:	82 83       	std	Z+2, r24	; 0x02
    9cb0:	80 91 d1 01 	lds	r24, 0x01D1
    9cb4:	90 91 d2 01 	lds	r25, 0x01D2
    9cb8:	95 83       	std	Z+5, r25	; 0x05
    9cba:	84 83       	std	Z+4, r24	; 0x04
    9cbc:	80 91 d5 01 	lds	r24, 0x01D5
    9cc0:	90 91 d6 01 	lds	r25, 0x01D6
    9cc4:	97 83       	std	Z+7, r25	; 0x07
    9cc6:	86 83       	std	Z+6, r24	; 0x06
    9cc8:	80 91 d3 01 	lds	r24, 0x01D3
    9ccc:	90 91 d4 01 	lds	r25, 0x01D4
    9cd0:	91 87       	std	Z+9, r25	; 0x09
    9cd2:	80 87       	std	Z+8, r24	; 0x08
    9cd4:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	#else
		printf_P( PSTR("TCP-TX Errors: %d TCP-RX Errors: %d (oldseq %d)\r\n\r\n"), TXErrorCounter , RXErrorCounter, RXErrorOldSeq );
	#endif
						
	LockEthernet();
    9cd8:	ed b7       	in	r30, 0x3d	; 61
    9cda:	fe b7       	in	r31, 0x3e	; 62
    9cdc:	3a 96       	adiw	r30, 0x0a	; 10
    9cde:	0f b6       	in	r0, 0x3f	; 63
    9ce0:	f8 94       	cli
    9ce2:	fe bf       	out	0x3e, r31	; 62
    9ce4:	0f be       	out	0x3f, r0	; 63
    9ce6:	ed bf       	out	0x3d, r30	; 61
    9ce8:	0e 94 47 30 	call	0x608e	; 0x608e <LockEthernet>
		
	REVID = enc28j60Read( EREVID );
    9cec:	82 e7       	ldi	r24, 0x72	; 114
    9cee:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <enc28j60Read>
    9cf2:	d8 2e       	mov	r13, r24
	_PHSTAT1 = enc28j60PhyRead( PHSTAT1 );
    9cf4:	81 e0       	ldi	r24, 0x01	; 1
    9cf6:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <enc28j60PhyRead>
    9cfa:	8c 01       	movw	r16, r24
	_PHSTAT2 = enc28j60PhyRead( PHSTAT2 );
    9cfc:	81 e1       	ldi	r24, 0x11	; 17
    9cfe:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <enc28j60PhyRead>
    9d02:	7c 01       	movw	r14, r24
					
	FreeEthernet();
    9d04:	0e 94 41 30 	call	0x6082	; 0x6082 <FreeEthernet>
					
	printf_P( PSTR("ENC28J60:\r\n"));
    9d08:	00 d0       	rcall	.+0      	; 0x9d0a <cmd_stats+0xe0>
    9d0a:	8a ee       	ldi	r24, 0xEA	; 234
    9d0c:	93 e1       	ldi	r25, 0x13	; 19
    9d0e:	ad b7       	in	r26, 0x3d	; 61
    9d10:	be b7       	in	r27, 0x3e	; 62
    9d12:	12 96       	adiw	r26, 0x02	; 2
    9d14:	9c 93       	st	X, r25
    9d16:	8e 93       	st	-X, r24
    9d18:	11 97       	sbiw	r26, 0x01	; 1
    9d1a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR("Reg.    | Wert\r\n"));
    9d1e:	89 ed       	ldi	r24, 0xD9	; 217
    9d20:	93 e1       	ldi	r25, 0x13	; 19
    9d22:	ed b7       	in	r30, 0x3d	; 61
    9d24:	fe b7       	in	r31, 0x3e	; 62
    9d26:	92 83       	std	Z+2, r25	; 0x02
    9d28:	81 83       	std	Z+1, r24	; 0x01
    9d2a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR("--------+--------\r\n"));
    9d2e:	85 ec       	ldi	r24, 0xC5	; 197
    9d30:	93 e1       	ldi	r25, 0x13	; 19
    9d32:	ad b7       	in	r26, 0x3d	; 61
    9d34:	be b7       	in	r27, 0x3e	; 62
    9d36:	12 96       	adiw	r26, 0x02	; 2
    9d38:	9c 93       	st	X, r25
    9d3a:	8e 93       	st	-X, r24
    9d3c:	11 97       	sbiw	r26, 0x01	; 1
    9d3e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR("Rev.ID  |   0x%02X\r\n") , REVID );
    9d42:	00 d0       	rcall	.+0      	; 0x9d44 <cmd_stats+0x11a>
    9d44:	ed b7       	in	r30, 0x3d	; 61
    9d46:	fe b7       	in	r31, 0x3e	; 62
    9d48:	31 96       	adiw	r30, 0x01	; 1
    9d4a:	80 eb       	ldi	r24, 0xB0	; 176
    9d4c:	93 e1       	ldi	r25, 0x13	; 19
    9d4e:	ad b7       	in	r26, 0x3d	; 61
    9d50:	be b7       	in	r27, 0x3e	; 62
    9d52:	12 96       	adiw	r26, 0x02	; 2
    9d54:	9c 93       	st	X, r25
    9d56:	8e 93       	st	-X, r24
    9d58:	11 97       	sbiw	r26, 0x01	; 1
    9d5a:	d2 82       	std	Z+2, r13	; 0x02
    9d5c:	13 82       	std	Z+3, r1	; 0x03
    9d5e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR("PHSTAT1 | 0x%04X\r\n") , _PHSTAT1 );
    9d62:	8d e9       	ldi	r24, 0x9D	; 157
    9d64:	93 e1       	ldi	r25, 0x13	; 19
    9d66:	ed b7       	in	r30, 0x3d	; 61
    9d68:	fe b7       	in	r31, 0x3e	; 62
    9d6a:	92 83       	std	Z+2, r25	; 0x02
    9d6c:	81 83       	std	Z+1, r24	; 0x01
    9d6e:	14 83       	std	Z+4, r17	; 0x04
    9d70:	03 83       	std	Z+3, r16	; 0x03
    9d72:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR("PHSTAT2 | 0x%04X\r\n") , _PHSTAT2 );
    9d76:	8a e8       	ldi	r24, 0x8A	; 138
    9d78:	93 e1       	ldi	r25, 0x13	; 19
    9d7a:	ad b7       	in	r26, 0x3d	; 61
    9d7c:	be b7       	in	r27, 0x3e	; 62
    9d7e:	12 96       	adiw	r26, 0x02	; 2
    9d80:	9c 93       	st	X, r25
    9d82:	8e 93       	st	-X, r24
    9d84:	11 97       	sbiw	r26, 0x01	; 1
    9d86:	14 96       	adiw	r26, 0x04	; 4
    9d88:	fc 92       	st	X, r15
    9d8a:	ee 92       	st	-X, r14
    9d8c:	13 97       	sbiw	r26, 0x03	; 3
    9d8e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9d92:	0f 90       	pop	r0
    9d94:	0f 90       	pop	r0
    9d96:	0f 90       	pop	r0
    9d98:	0f 90       	pop	r0

}
    9d9a:	1f 91       	pop	r17
    9d9c:	0f 91       	pop	r16
    9d9e:	ff 90       	pop	r15
    9da0:	ef 90       	pop	r14
    9da2:	df 90       	pop	r13
    9da4:	08 95       	ret

00009da6 <init_cmd_stats>:
#include "cmd_stats.h"

void init_cmd_stats( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_stats, PSTR("stats"));
    9da6:	85 e1       	ldi	r24, 0x15	; 21
    9da8:	9e e4       	ldi	r25, 0x4E	; 78
    9daa:	67 e6       	ldi	r22, 0x67	; 103
    9dac:	74 e1       	ldi	r23, 0x14	; 20
    9dae:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
#if defined(HTTPSERVER_STATS)
	cgi_RegisterCGI( cgi_stats, PSTR("stats.cgi"));
    9db2:	85 e0       	ldi	r24, 0x05	; 5
    9db4:	9c e4       	ldi	r25, 0x4C	; 76
    9db6:	6d e5       	ldi	r22, 0x5D	; 93
    9db8:	74 e1       	ldi	r23, 0x14	; 20
    9dba:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <cgi_RegisterCGI>
#endif
}
    9dbe:	08 95       	ret

00009dc0 <cgi_reset>:
 * \param 	pStruct	Struktur auf den HTTP_Request
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void cgi_reset( void * pStruct )
{
    9dc0:	cf 93       	push	r28
    9dc2:	df 93       	push	r29
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    9dc4:	ec 01       	movw	r28, r24
						"<HEAD>"
						"<TITLE>Reset</TITLE>"
						"</HEAD>"
						"<BODY>"));
*/
	cgi_PrintHttpheaderStart();
    9dc6:	0e 94 da 45 	call	0x8bb4	; 0x8bb4 <cgi_PrintHttpheaderStart>

	if ( http_request->argc == 0 )
    9dca:	ca 5b       	subi	r28, 0xBA	; 186
    9dcc:	dd 4f       	sbci	r29, 0xFD	; 253
    9dce:	88 81       	ld	r24, Y
    9dd0:	c6 54       	subi	r28, 0x46	; 70
    9dd2:	d2 40       	sbci	r29, 0x02	; 2
    9dd4:	88 23       	and	r24, r24
    9dd6:	61 f4       	brne	.+24     	; 0x9df0 <cgi_reset+0x30>
	{
		printf_P( PSTR(	"<form action=\"reset.cgi\" method=\"get\" accept-charset=\"ISO-8859-1\">"
    9dd8:	00 d0       	rcall	.+0      	; 0x9dda <cgi_reset+0x1a>
    9dda:	87 e9       	ldi	r24, 0x97	; 151
    9ddc:	94 e1       	ldi	r25, 0x14	; 20
    9dde:	ed b7       	in	r30, 0x3d	; 61
    9de0:	fe b7       	in	r31, 0x3e	; 62
    9de2:	92 83       	std	Z+2, r25	; 0x02
    9de4:	81 83       	std	Z+1, r24	; 0x01
    9de6:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9dea:	0f 90       	pop	r0
    9dec:	0f 90       	pop	r0
    9dee:	32 c0       	rjmp	.+100    	; 0x9e54 <cgi_reset+0x94>
						"<p><input type=\"submit\" name=\"reset\" value=\"reset\"></p></form>"
						"</BODY>"
						"</HTML>"
						"\r\n\r\n"));
	}
	else if( PharseCheckName_P( http_request, PSTR("reset") ) )
    9df0:	ce 01       	movw	r24, r28
    9df2:	61 e9       	ldi	r22, 0x91	; 145
    9df4:	74 e1       	ldi	r23, 0x14	; 20
    9df6:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    9dfa:	88 23       	and	r24, r24
    9dfc:	59 f1       	breq	.+86     	; 0x9e54 <cgi_reset+0x94>
	{	
		if ( !strcmp_P( http_request->argvalue[ PharseGetValue_P( http_request, PSTR("reset") ) ] , PSTR("reset") ) )
    9dfe:	ce 01       	movw	r24, r28
    9e00:	6b e8       	ldi	r22, 0x8B	; 139
    9e02:	74 e1       	ldi	r23, 0x14	; 20
    9e04:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    9e08:	e8 2f       	mov	r30, r24
    9e0a:	f0 e0       	ldi	r31, 0x00	; 0
    9e0c:	ee 0f       	add	r30, r30
    9e0e:	ff 1f       	adc	r31, r31
    9e10:	ec 0f       	add	r30, r28
    9e12:	fd 1f       	adc	r31, r29
    9e14:	e1 5a       	subi	r30, 0xA1	; 161
    9e16:	fd 4f       	sbci	r31, 0xFD	; 253
    9e18:	80 81       	ld	r24, Z
    9e1a:	91 81       	ldd	r25, Z+1	; 0x01
    9e1c:	65 e8       	ldi	r22, 0x85	; 133
    9e1e:	74 e1       	ldi	r23, 0x14	; 20
    9e20:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    9e24:	89 2b       	or	r24, r25
    9e26:	b1 f4       	brne	.+44     	; 0x9e54 <cgi_reset+0x94>
		{
			printf_P( PSTR(	"Reset</BODY>"
    9e28:	00 d0       	rcall	.+0      	; 0x9e2a <cgi_reset+0x6a>
    9e2a:	8d e6       	ldi	r24, 0x6D	; 109
    9e2c:	94 e1       	ldi	r25, 0x14	; 20
    9e2e:	ed b7       	in	r30, 0x3d	; 61
    9e30:	fe b7       	in	r31, 0x3e	; 62
    9e32:	92 83       	std	Z+2, r25	; 0x02
    9e34:	81 83       	std	Z+1, r24	; 0x01
    9e36:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
							"</HTML>"
							"\r\n\r\n"));
			STDOUT_Flush();
    9e3a:	0f 90       	pop	r0
    9e3c:	0f 90       	pop	r0
    9e3e:	0e 94 58 38 	call	0x70b0	; 0x70b0 <STDOUT_Flush>
			CloseTCPSocket( http_request->HTTP_SOCKET );
    9e42:	c3 58       	subi	r28, 0x83	; 131
    9e44:	dd 4f       	sbci	r29, 0xFD	; 253
    9e46:	88 81       	ld	r24, Y
    9e48:	99 81       	ldd	r25, Y+1	; 0x01
    9e4a:	0e 94 10 2a 	call	0x5420	; 0x5420 <CloseTCPSocket>
			softreset();
    9e4e:	0e 94 35 3d 	call	0x7a6a	; 0x7a6a <softreset>
    9e52:	ff cf       	rjmp	.-2      	; 0x9e52 <cgi_reset+0x92>
			while(1);
		}
	}
}
    9e54:	df 91       	pop	r29
    9e56:	cf 91       	pop	r28
    9e58:	08 95       	ret

00009e5a <cmd_reset>:
#endif
}

int cmd_reset( int argc, char ** argv )
{
	softreset();
    9e5a:	0e 94 35 3d 	call	0x7a6a	; 0x7a6a <softreset>
}
    9e5e:	08 95       	ret

00009e60 <init_cmd_reset>:
#include "cmd_reset.h"

void init_cmd_reset( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_reset, PSTR("reset"));
    9e60:	8d e2       	ldi	r24, 0x2D	; 45
    9e62:	9f e4       	ldi	r25, 0x4F	; 79
    9e64:	64 e3       	ldi	r22, 0x34	; 52
    9e66:	75 e1       	ldi	r23, 0x15	; 21
    9e68:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
#if defined(HTTPSERVER_RESET)
	cgi_RegisterCGI( cgi_reset, PSTR("reset.cgi"));
    9e6c:	80 ee       	ldi	r24, 0xE0	; 224
    9e6e:	9e e4       	ldi	r25, 0x4E	; 78
    9e70:	6a e2       	ldi	r22, 0x2A	; 42
    9e72:	75 e1       	ldi	r23, 0x15	; 21
    9e74:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <cgi_RegisterCGI>
#endif
}
    9e78:	08 95       	ret

00009e7a <cmd_dns>:
	telnet_RegisterCMD( cmd_dns, PSTR("dns"));
#endif
}

int cmd_dns( int argc, char ** argv )
{
    9e7a:	a4 e1       	ldi	r26, 0x14	; 20
    9e7c:	b0 e0       	ldi	r27, 0x00	; 0
    9e7e:	e3 e4       	ldi	r30, 0x43	; 67
    9e80:	ff e4       	ldi	r31, 0x4F	; 79
    9e82:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
    9e86:	8b 01       	movw	r16, r22
	long ip;
	char ipstr[ 20 ];
	
	if ( argc == 2 )
    9e88:	02 97       	sbiw	r24, 0x02	; 2
    9e8a:	61 f5       	brne	.+88     	; 0x9ee4 <cmd_dns+0x6a>
	{
		ip = DNS_ResolveName( argv[ 1 ] );
    9e8c:	db 01       	movw	r26, r22
    9e8e:	12 96       	adiw	r26, 0x02	; 2
    9e90:	8d 91       	ld	r24, X+
    9e92:	9c 91       	ld	r25, X
    9e94:	13 97       	sbiw	r26, 0x03	; 3
    9e96:	0e 94 e4 34 	call	0x69c8	; 0x69c8 <DNS_ResolveName>
		printf_P( PSTR("IP zu %s = %s\r\n"), argv[ 1 ], iptostr( ip, ipstr ) );
    9e9a:	f8 01       	movw	r30, r16
    9e9c:	02 81       	ldd	r16, Z+2	; 0x02
    9e9e:	13 81       	ldd	r17, Z+3	; 0x03
    9ea0:	ae 01       	movw	r20, r28
    9ea2:	4f 5f       	subi	r20, 0xFF	; 255
    9ea4:	5f 4f       	sbci	r21, 0xFF	; 255
    9ea6:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    9eaa:	00 d0       	rcall	.+0      	; 0x9eac <cmd_dns+0x32>
    9eac:	00 d0       	rcall	.+0      	; 0x9eae <cmd_dns+0x34>
    9eae:	00 d0       	rcall	.+0      	; 0x9eb0 <cmd_dns+0x36>
    9eb0:	ed b7       	in	r30, 0x3d	; 61
    9eb2:	fe b7       	in	r31, 0x3e	; 62
    9eb4:	31 96       	adiw	r30, 0x01	; 1
    9eb6:	2b e4       	ldi	r18, 0x4B	; 75
    9eb8:	35 e1       	ldi	r19, 0x15	; 21
    9eba:	ad b7       	in	r26, 0x3d	; 61
    9ebc:	be b7       	in	r27, 0x3e	; 62
    9ebe:	12 96       	adiw	r26, 0x02	; 2
    9ec0:	3c 93       	st	X, r19
    9ec2:	2e 93       	st	-X, r18
    9ec4:	11 97       	sbiw	r26, 0x01	; 1
    9ec6:	13 83       	std	Z+3, r17	; 0x03
    9ec8:	02 83       	std	Z+2, r16	; 0x02
    9eca:	95 83       	std	Z+5, r25	; 0x05
    9ecc:	84 83       	std	Z+4, r24	; 0x04
    9ece:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9ed2:	ed b7       	in	r30, 0x3d	; 61
    9ed4:	fe b7       	in	r31, 0x3e	; 62
    9ed6:	36 96       	adiw	r30, 0x06	; 6
    9ed8:	0f b6       	in	r0, 0x3f	; 63
    9eda:	f8 94       	cli
    9edc:	fe bf       	out	0x3e, r31	; 62
    9ede:	0f be       	out	0x3f, r0	; 63
    9ee0:	ed bf       	out	0x3d, r30	; 61
    9ee2:	0d c0       	rjmp	.+26     	; 0x9efe <cmd_dns+0x84>
	}
	else
		printf_P( PSTR("dns <hostname>\r\n"));
    9ee4:	00 d0       	rcall	.+0      	; 0x9ee6 <cmd_dns+0x6c>
    9ee6:	8a e3       	ldi	r24, 0x3A	; 58
    9ee8:	95 e1       	ldi	r25, 0x15	; 21
    9eea:	ad b7       	in	r26, 0x3d	; 61
    9eec:	be b7       	in	r27, 0x3e	; 62
    9eee:	12 96       	adiw	r26, 0x02	; 2
    9ef0:	9c 93       	st	X, r25
    9ef2:	8e 93       	st	-X, r24
    9ef4:	11 97       	sbiw	r26, 0x01	; 1
    9ef6:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    9efa:	0f 90       	pop	r0
    9efc:	0f 90       	pop	r0
}
    9efe:	64 96       	adiw	r28, 0x14	; 20
    9f00:	e4 e0       	ldi	r30, 0x04	; 4
    9f02:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

00009f06 <init_cmd_dns>:
#include "cmd_dns.h"

void init_cmd_dns( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_dns, PSTR("dns"));
    9f06:	8d e3       	ldi	r24, 0x3D	; 61
    9f08:	9f e4       	ldi	r25, 0x4F	; 79
    9f0a:	6b e5       	ldi	r22, 0x5B	; 91
    9f0c:	75 e1       	ldi	r23, 0x15	; 21
    9f0e:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
}
    9f12:	08 95       	ret

00009f14 <cmd_ifconfig>:
	cgi_RegisterCGI( cgi_network, PSTR("network.cgi"));
#endif
}

int cmd_ifconfig( int argc, char ** argv )
{
    9f14:	a0 e1       	ldi	r26, 0x10	; 16
    9f16:	b0 e0       	ldi	r27, 0x00	; 0
    9f18:	e0 e9       	ldi	r30, 0x90	; 144
    9f1a:	ff e4       	ldi	r31, 0x4F	; 79
    9f1c:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	unsigned char IP[16];
		
	printf_P( PSTR(	"IP:        %s\r\n") , iptostr ( myIP, IP ) );		
    9f20:	60 91 41 01 	lds	r22, 0x0141
    9f24:	70 91 42 01 	lds	r23, 0x0142
    9f28:	80 91 43 01 	lds	r24, 0x0143
    9f2c:	90 91 44 01 	lds	r25, 0x0144
    9f30:	8e 01       	movw	r16, r28
    9f32:	0f 5f       	subi	r16, 0xFF	; 255
    9f34:	1f 4f       	sbci	r17, 0xFF	; 255
    9f36:	a8 01       	movw	r20, r16
    9f38:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    9f3c:	00 d0       	rcall	.+0      	; 0x9f3e <cmd_ifconfig+0x2a>
    9f3e:	00 d0       	rcall	.+0      	; 0x9f40 <cmd_ifconfig+0x2c>
    9f40:	28 e5       	ldi	r18, 0x58	; 88
    9f42:	3a e1       	ldi	r19, 0x1A	; 26
    9f44:	ad b7       	in	r26, 0x3d	; 61
    9f46:	be b7       	in	r27, 0x3e	; 62
    9f48:	12 96       	adiw	r26, 0x02	; 2
    9f4a:	3c 93       	st	X, r19
    9f4c:	2e 93       	st	-X, r18
    9f4e:	11 97       	sbiw	r26, 0x01	; 1
    9f50:	14 96       	adiw	r26, 0x04	; 4
    9f52:	9c 93       	st	X, r25
    9f54:	8e 93       	st	-X, r24
    9f56:	13 97       	sbiw	r26, 0x03	; 3
    9f58:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR(	"Netmask:   %s\r\n") , 		iptostr ( Netmask, IP ) );
    9f5c:	0f 90       	pop	r0
    9f5e:	0f 90       	pop	r0
    9f60:	0f 90       	pop	r0
    9f62:	0f 90       	pop	r0
    9f64:	60 91 49 01 	lds	r22, 0x0149
    9f68:	70 91 4a 01 	lds	r23, 0x014A
    9f6c:	80 91 4b 01 	lds	r24, 0x014B
    9f70:	90 91 4c 01 	lds	r25, 0x014C
    9f74:	a8 01       	movw	r20, r16
    9f76:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    9f7a:	00 d0       	rcall	.+0      	; 0x9f7c <cmd_ifconfig+0x68>
    9f7c:	00 d0       	rcall	.+0      	; 0x9f7e <cmd_ifconfig+0x6a>
    9f7e:	28 e4       	ldi	r18, 0x48	; 72
    9f80:	3a e1       	ldi	r19, 0x1A	; 26
    9f82:	ed b7       	in	r30, 0x3d	; 61
    9f84:	fe b7       	in	r31, 0x3e	; 62
    9f86:	32 83       	std	Z+2, r19	; 0x02
    9f88:	21 83       	std	Z+1, r18	; 0x01
    9f8a:	94 83       	std	Z+4, r25	; 0x04
    9f8c:	83 83       	std	Z+3, r24	; 0x03
    9f8e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	printf_P( PSTR(	"Gateway:   %s\r\n") , iptostr ( Gateway, IP ) );
    9f92:	0f 90       	pop	r0
    9f94:	0f 90       	pop	r0
    9f96:	0f 90       	pop	r0
    9f98:	0f 90       	pop	r0
    9f9a:	60 91 4d 01 	lds	r22, 0x014D
    9f9e:	70 91 4e 01 	lds	r23, 0x014E
    9fa2:	80 91 4f 01 	lds	r24, 0x014F
    9fa6:	90 91 50 01 	lds	r25, 0x0150
    9faa:	a8 01       	movw	r20, r16
    9fac:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    9fb0:	00 d0       	rcall	.+0      	; 0x9fb2 <cmd_ifconfig+0x9e>
    9fb2:	00 d0       	rcall	.+0      	; 0x9fb4 <cmd_ifconfig+0xa0>
    9fb4:	28 e3       	ldi	r18, 0x38	; 56
    9fb6:	3a e1       	ldi	r19, 0x1A	; 26
    9fb8:	ad b7       	in	r26, 0x3d	; 61
    9fba:	be b7       	in	r27, 0x3e	; 62
    9fbc:	12 96       	adiw	r26, 0x02	; 2
    9fbe:	3c 93       	st	X, r19
    9fc0:	2e 93       	st	-X, r18
    9fc2:	11 97       	sbiw	r26, 0x01	; 1
    9fc4:	14 96       	adiw	r26, 0x04	; 4
    9fc6:	9c 93       	st	X, r25
    9fc8:	8e 93       	st	-X, r24
    9fca:	13 97       	sbiw	r26, 0x03	; 3
    9fcc:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	#ifdef DNS
		printf_P( PSTR(	"DNS:       %s\r\n") , iptostr ( DNSserver, IP ) );
    9fd0:	0f 90       	pop	r0
    9fd2:	0f 90       	pop	r0
    9fd4:	0f 90       	pop	r0
    9fd6:	0f 90       	pop	r0
    9fd8:	60 91 51 01 	lds	r22, 0x0151
    9fdc:	70 91 52 01 	lds	r23, 0x0152
    9fe0:	80 91 53 01 	lds	r24, 0x0153
    9fe4:	90 91 54 01 	lds	r25, 0x0154
    9fe8:	a8 01       	movw	r20, r16
    9fea:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
    9fee:	00 d0       	rcall	.+0      	; 0x9ff0 <cmd_ifconfig+0xdc>
    9ff0:	00 d0       	rcall	.+0      	; 0x9ff2 <cmd_ifconfig+0xde>
    9ff2:	28 e2       	ldi	r18, 0x28	; 40
    9ff4:	3a e1       	ldi	r19, 0x1A	; 26
    9ff6:	ed b7       	in	r30, 0x3d	; 61
    9ff8:	fe b7       	in	r31, 0x3e	; 62
    9ffa:	32 83       	std	Z+2, r19	; 0x02
    9ffc:	21 83       	std	Z+1, r18	; 0x01
    9ffe:	94 83       	std	Z+4, r25	; 0x04
    a000:	83 83       	std	Z+3, r24	; 0x03
    a002:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
	#endif
	printf_P( PSTR( "\r\nHW-Adr: %02x:%02x:%02x:%02x:%02x:%02x\r\n\r\n"),mymac[0],mymac[1],mymac[2],mymac[3],mymac[4],mymac[5]);	
    a006:	8d b7       	in	r24, 0x3d	; 61
    a008:	9e b7       	in	r25, 0x3e	; 62
    a00a:	0a 97       	sbiw	r24, 0x0a	; 10
    a00c:	0f b6       	in	r0, 0x3f	; 63
    a00e:	f8 94       	cli
    a010:	9e bf       	out	0x3e, r25	; 62
    a012:	0f be       	out	0x3f, r0	; 63
    a014:	8d bf       	out	0x3d, r24	; 61
    a016:	ed b7       	in	r30, 0x3d	; 61
    a018:	fe b7       	in	r31, 0x3e	; 62
    a01a:	31 96       	adiw	r30, 0x01	; 1
    a01c:	8c ef       	ldi	r24, 0xFC	; 252
    a01e:	99 e1       	ldi	r25, 0x19	; 25
    a020:	ad b7       	in	r26, 0x3d	; 61
    a022:	be b7       	in	r27, 0x3e	; 62
    a024:	12 96       	adiw	r26, 0x02	; 2
    a026:	9c 93       	st	X, r25
    a028:	8e 93       	st	-X, r24
    a02a:	11 97       	sbiw	r26, 0x01	; 1
    a02c:	80 91 3b 01 	lds	r24, 0x013B
    a030:	82 83       	std	Z+2, r24	; 0x02
    a032:	13 82       	std	Z+3, r1	; 0x03
    a034:	80 91 3c 01 	lds	r24, 0x013C
    a038:	84 83       	std	Z+4, r24	; 0x04
    a03a:	15 82       	std	Z+5, r1	; 0x05
    a03c:	80 91 3d 01 	lds	r24, 0x013D
    a040:	86 83       	std	Z+6, r24	; 0x06
    a042:	17 82       	std	Z+7, r1	; 0x07
    a044:	80 91 3e 01 	lds	r24, 0x013E
    a048:	80 87       	std	Z+8, r24	; 0x08
    a04a:	11 86       	std	Z+9, r1	; 0x09
    a04c:	80 91 3f 01 	lds	r24, 0x013F
    a050:	82 87       	std	Z+10, r24	; 0x0a
    a052:	13 86       	std	Z+11, r1	; 0x0b
    a054:	80 91 40 01 	lds	r24, 0x0140
    a058:	84 87       	std	Z+12, r24	; 0x0c
    a05a:	15 86       	std	Z+13, r1	; 0x0d
    a05c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a060:	ed b7       	in	r30, 0x3d	; 61
    a062:	fe b7       	in	r31, 0x3e	; 62
    a064:	3e 96       	adiw	r30, 0x0e	; 14
    a066:	0f b6       	in	r0, 0x3f	; 63
    a068:	f8 94       	cli
    a06a:	fe bf       	out	0x3e, r31	; 62
    a06c:	0f be       	out	0x3f, r0	; 63
    a06e:	ed bf       	out	0x3d, r30	; 61
}
    a070:	60 96       	adiw	r28, 0x10	; 16
    a072:	e4 e0       	ldi	r30, 0x04	; 4
    a074:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

0000a078 <cgi_network>:
 * \param 	pStruct	Struktur auf den HTTP_Request
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void cgi_network( void * pStruct )
{
    a078:	a0 e2       	ldi	r26, 0x20	; 32
    a07a:	b0 e0       	ldi	r27, 0x00	; 0
    a07c:	e2 e4       	ldi	r30, 0x42	; 66
    a07e:	f0 e5       	ldi	r31, 0x50	; 80
    a080:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    a084:	8c 01       	movw	r16, r24
						"<HEAD>\r\n"
						"<TITLE>network</TITLE>\r\n"
						"</HEAD>\r\n"
						" <BODY>\r\n"));
*/
	cgi_PrintHttpheaderStart();
    a086:	0e 94 da 45 	call	0x8bb4	; 0x8bb4 <cgi_PrintHttpheaderStart>

	if ( http_request->argc == 0 )
    a08a:	0a 5b       	subi	r16, 0xBA	; 186
    a08c:	1d 4f       	sbci	r17, 0xFD	; 253
    a08e:	f8 01       	movw	r30, r16
    a090:	80 81       	ld	r24, Z
    a092:	06 54       	subi	r16, 0x46	; 70
    a094:	12 40       	sbci	r17, 0x02	; 2
    a096:	88 23       	and	r24, r24
    a098:	b9 f4       	brne	.+46     	; 0xa0c8 <cgi_network+0x50>
	{
					   
		printf_P( PSTR( "<pre>\r\n") );
    a09a:	00 d0       	rcall	.+0      	; 0xa09c <cgi_network+0x24>
    a09c:	84 ef       	ldi	r24, 0xF4	; 244
    a09e:	99 e1       	ldi	r25, 0x19	; 25
    a0a0:	ed b7       	in	r30, 0x3d	; 61
    a0a2:	fe b7       	in	r31, 0x3e	; 62
    a0a4:	92 83       	std	Z+2, r25	; 0x02
    a0a6:	81 83       	std	Z+1, r24	; 0x01
    a0a8:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
#ifdef TELNETSERVER
		TELNET_runcmdextern_P( PSTR("ifconfig") );
    a0ac:	0f 90       	pop	r0
    a0ae:	0f 90       	pop	r0
    a0b0:	8b ee       	ldi	r24, 0xEB	; 235
    a0b2:	99 e1       	ldi	r25, 0x19	; 25
    a0b4:	0e 94 46 48 	call	0x908c	; 0x908c <TELNET_runcmdextern_P>
		TELNET_runcmdextern_P( PSTR("stats") );
    a0b8:	85 ee       	ldi	r24, 0xE5	; 229
    a0ba:	99 e1       	ldi	r25, 0x19	; 25
    a0bc:	0e 94 46 48 	call	0x908c	; 0x908c <TELNET_runcmdextern_P>
#endif		
		printf_P( PSTR( "</pre>\r\n") );
    a0c0:	00 d0       	rcall	.+0      	; 0xa0c2 <cgi_network+0x4a>
    a0c2:	8c ed       	ldi	r24, 0xDC	; 220
    a0c4:	99 e1       	ldi	r25, 0x19	; 25
    a0c6:	9d c1       	rjmp	.+826    	; 0xa402 <cgi_network+0x38a>
	}
	else if( PharseCheckName_P( http_request, PSTR("config") ) )
    a0c8:	c8 01       	movw	r24, r16
    a0ca:	65 ed       	ldi	r22, 0xD5	; 213
    a0cc:	79 e1       	ldi	r23, 0x19	; 25
    a0ce:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a0d2:	88 23       	and	r24, r24
    a0d4:	09 f4       	brne	.+2      	; 0xa0d8 <cgi_network+0x60>
    a0d6:	f1 c0       	rjmp	.+482    	; 0xa2ba <cgi_network+0x242>
	{	
		
		printf_P( PSTR(	"<form action=\"network.cgi\">\r"
    a0d8:	00 d0       	rcall	.+0      	; 0xa0da <cgi_network+0x62>
    a0da:	85 e8       	ldi	r24, 0x85	; 133
    a0dc:	99 e1       	ldi	r25, 0x19	; 25
    a0de:	ed b7       	in	r30, 0x3d	; 61
    a0e0:	fe b7       	in	r31, 0x3e	; 62
    a0e2:	92 83       	std	Z+2, r25	; 0x02
    a0e4:	81 83       	std	Z+1, r24	; 0x01
    a0e6:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
		if ( !strcmp_P( IP, PSTR("on") ) )
						printf_P( PSTR("checked"));
		printf_P( PSTR(	"></td>\r"
  						"  </tr>\r") );
#endif
		if ( readConfig_P ( PSTR("IP"), IP ) != 1 )
    a0ea:	0f 90       	pop	r0
    a0ec:	0f 90       	pop	r0
    a0ee:	82 e8       	ldi	r24, 0x82	; 130
    a0f0:	99 e1       	ldi	r25, 0x19	; 25
    a0f2:	8e 01       	movw	r16, r28
    a0f4:	0f 5f       	subi	r16, 0xFF	; 255
    a0f6:	1f 4f       	sbci	r17, 0xFF	; 255
    a0f8:	b8 01       	movw	r22, r16
    a0fa:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a0fe:	01 97       	sbiw	r24, 0x01	; 1
    a100:	59 f0       	breq	.+22     	; 0xa118 <cgi_network+0xa0>
			iptostr ( myIP, IP );
    a102:	60 91 41 01 	lds	r22, 0x0141
    a106:	70 91 42 01 	lds	r23, 0x0142
    a10a:	80 91 43 01 	lds	r24, 0x0143
    a10e:	90 91 44 01 	lds	r25, 0x0144
    a112:	a8 01       	movw	r20, r16
    a114:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
  		printf_P( PSTR(	"  <tr>\r"
    a118:	00 d0       	rcall	.+0      	; 0xa11a <cgi_network+0xa2>
    a11a:	00 d0       	rcall	.+0      	; 0xa11c <cgi_network+0xa4>
    a11c:	81 e0       	ldi	r24, 0x01	; 1
    a11e:	99 e1       	ldi	r25, 0x19	; 25
    a120:	ed b7       	in	r30, 0x3d	; 61
    a122:	fe b7       	in	r31, 0x3e	; 62
    a124:	92 83       	std	Z+2, r25	; 0x02
    a126:	81 83       	std	Z+1, r24	; 0x01
    a128:	8e 01       	movw	r16, r28
    a12a:	0f 5f       	subi	r16, 0xFF	; 255
    a12c:	1f 4f       	sbci	r17, 0xFF	; 255
    a12e:	14 83       	std	Z+4, r17	; 0x04
    a130:	03 83       	std	Z+3, r16	; 0x03
    a132:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					   	"   <td align=\"right\">IP-Adresse</td>"
  						"   <td><input name=\"IP\" type=\"text\" size=\"15\" value=\"%s\" maxlength=\"15\"></td>"
  						"  </tr>\r") , IP );
		if ( readConfig_P ( PSTR("MASK"), IP ) != 1 )
    a136:	0f 90       	pop	r0
    a138:	0f 90       	pop	r0
    a13a:	0f 90       	pop	r0
    a13c:	0f 90       	pop	r0
    a13e:	8c ef       	ldi	r24, 0xFC	; 252
    a140:	98 e1       	ldi	r25, 0x18	; 24
    a142:	b8 01       	movw	r22, r16
    a144:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a148:	01 97       	sbiw	r24, 0x01	; 1
    a14a:	59 f0       	breq	.+22     	; 0xa162 <cgi_network+0xea>
			iptostr ( Netmask, IP );		
    a14c:	60 91 49 01 	lds	r22, 0x0149
    a150:	70 91 4a 01 	lds	r23, 0x014A
    a154:	80 91 4b 01 	lds	r24, 0x014B
    a158:	90 91 4c 01 	lds	r25, 0x014C
    a15c:	a8 01       	movw	r20, r16
    a15e:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
  		printf_P( PSTR(	"  <tr>\r"
    a162:	00 d0       	rcall	.+0      	; 0xa164 <cgi_network+0xec>
    a164:	00 d0       	rcall	.+0      	; 0xa166 <cgi_network+0xee>
    a166:	86 e7       	ldi	r24, 0x76	; 118
    a168:	98 e1       	ldi	r25, 0x18	; 24
    a16a:	ed b7       	in	r30, 0x3d	; 61
    a16c:	fe b7       	in	r31, 0x3e	; 62
    a16e:	92 83       	std	Z+2, r25	; 0x02
    a170:	81 83       	std	Z+1, r24	; 0x01
    a172:	8e 01       	movw	r16, r28
    a174:	0f 5f       	subi	r16, 0xFF	; 255
    a176:	1f 4f       	sbci	r17, 0xFF	; 255
    a178:	14 83       	std	Z+4, r17	; 0x04
    a17a:	03 83       	std	Z+3, r16	; 0x03
    a17c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					   	"   <td align=\"right\">Netzwerkmaske</td>"
  						"   <td><input name=\"MASK\" type=\"text\" size=\"15\" value=\"%s\" maxlength=\"15\"></td>"
  						"  </tr>\r") , IP );
		if ( readConfig_P ( PSTR("GATE"), IP ) != 1 )
    a180:	0f 90       	pop	r0
    a182:	0f 90       	pop	r0
    a184:	0f 90       	pop	r0
    a186:	0f 90       	pop	r0
    a188:	81 e7       	ldi	r24, 0x71	; 113
    a18a:	98 e1       	ldi	r25, 0x18	; 24
    a18c:	b8 01       	movw	r22, r16
    a18e:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a192:	01 97       	sbiw	r24, 0x01	; 1
    a194:	59 f0       	breq	.+22     	; 0xa1ac <cgi_network+0x134>
			iptostr ( Gateway, IP );		
    a196:	60 91 4d 01 	lds	r22, 0x014D
    a19a:	70 91 4e 01 	lds	r23, 0x014E
    a19e:	80 91 4f 01 	lds	r24, 0x014F
    a1a2:	90 91 50 01 	lds	r25, 0x0150
    a1a6:	a8 01       	movw	r20, r16
    a1a8:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
  		printf_P( PSTR(	"  <tr>\r"
    a1ac:	00 d0       	rcall	.+0      	; 0xa1ae <cgi_network+0x136>
    a1ae:	00 d0       	rcall	.+0      	; 0xa1b0 <cgi_network+0x138>
    a1b0:	81 ef       	ldi	r24, 0xF1	; 241
    a1b2:	97 e1       	ldi	r25, 0x17	; 23
    a1b4:	ed b7       	in	r30, 0x3d	; 61
    a1b6:	fe b7       	in	r31, 0x3e	; 62
    a1b8:	92 83       	std	Z+2, r25	; 0x02
    a1ba:	81 83       	std	Z+1, r24	; 0x01
    a1bc:	8e 01       	movw	r16, r28
    a1be:	0f 5f       	subi	r16, 0xFF	; 255
    a1c0:	1f 4f       	sbci	r17, 0xFF	; 255
    a1c2:	14 83       	std	Z+4, r17	; 0x04
    a1c4:	03 83       	std	Z+3, r16	; 0x03
    a1c6:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					   	"   <td align=\"right\">Gateway</td>"
						"   <td><input name=\"GATE\" type=\"text\" size=\"15\" value=\"%s\" maxlength=\"15\"></td>"
  						"  </tr>\r") , IP );
#ifdef DNS
		if ( readConfig_P ( PSTR("DNS"), IP ) != 1 )
    a1ca:	0f 90       	pop	r0
    a1cc:	0f 90       	pop	r0
    a1ce:	0f 90       	pop	r0
    a1d0:	0f 90       	pop	r0
    a1d2:	8d ee       	ldi	r24, 0xED	; 237
    a1d4:	97 e1       	ldi	r25, 0x17	; 23
    a1d6:	b8 01       	movw	r22, r16
    a1d8:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a1dc:	01 97       	sbiw	r24, 0x01	; 1
    a1de:	59 f0       	breq	.+22     	; 0xa1f6 <cgi_network+0x17e>
			iptostr ( DNSserver, IP );		
    a1e0:	60 91 51 01 	lds	r22, 0x0151
    a1e4:	70 91 52 01 	lds	r23, 0x0152
    a1e8:	80 91 53 01 	lds	r24, 0x0153
    a1ec:	90 91 54 01 	lds	r25, 0x0154
    a1f0:	a8 01       	movw	r20, r16
    a1f2:	0e 94 00 33 	call	0x6600	; 0x6600 <iptostr>
		printf_P( PSTR(	"  <tr>\r"
    a1f6:	00 d0       	rcall	.+0      	; 0xa1f8 <cgi_network+0x180>
    a1f8:	00 d0       	rcall	.+0      	; 0xa1fa <cgi_network+0x182>
    a1fa:	8b e6       	ldi	r24, 0x6B	; 107
    a1fc:	97 e1       	ldi	r25, 0x17	; 23
    a1fe:	ed b7       	in	r30, 0x3d	; 61
    a200:	fe b7       	in	r31, 0x3e	; 62
    a202:	92 83       	std	Z+2, r25	; 0x02
    a204:	81 83       	std	Z+1, r24	; 0x01
    a206:	8e 01       	movw	r16, r28
    a208:	0f 5f       	subi	r16, 0xFF	; 255
    a20a:	1f 4f       	sbci	r17, 0xFF	; 255
    a20c:	14 83       	std	Z+4, r17	; 0x04
    a20e:	03 83       	std	Z+3, r16	; 0x03
    a210:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					   	"   <td align=\"right\">DNS-Server</td>"
						"   <td><input name=\"DNS\" type=\"text\" size=\"15\" value=\"%s\" maxlength=\"15\"></td>"
  						"  </tr>\r" ), IP );
#endif
		readConfig_P( PSTR("ETH_FLDX"), IP );
    a214:	0f 90       	pop	r0
    a216:	0f 90       	pop	r0
    a218:	0f 90       	pop	r0
    a21a:	0f 90       	pop	r0
    a21c:	82 e6       	ldi	r24, 0x62	; 98
    a21e:	97 e1       	ldi	r25, 0x17	; 23
    a220:	b8 01       	movw	r22, r16
    a222:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
  		printf_P( PSTR( "  <tr>\r"
    a226:	00 d0       	rcall	.+0      	; 0xa228 <cgi_network+0x1b0>
    a228:	82 ef       	ldi	r24, 0xF2	; 242
    a22a:	96 e1       	ldi	r25, 0x16	; 22
    a22c:	ed b7       	in	r30, 0x3d	; 61
    a22e:	fe b7       	in	r31, 0x3e	; 62
    a230:	92 83       	std	Z+2, r25	; 0x02
    a232:	81 83       	std	Z+1, r24	; 0x01
    a234:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					   	"   <td align=\"right\">Fullduplex aktivieren</td>"
					    "   <td><input type=\"checkbox\" name=\"ETH_FLDX\" value=\"on\" " )); 
		if ( !strcmp_P( IP, PSTR("on") ) )
    a238:	0f 90       	pop	r0
    a23a:	0f 90       	pop	r0
    a23c:	c8 01       	movw	r24, r16
    a23e:	6f ee       	ldi	r22, 0xEF	; 239
    a240:	76 e1       	ldi	r23, 0x16	; 22
    a242:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    a246:	89 2b       	or	r24, r25
    a248:	59 f4       	brne	.+22     	; 0xa260 <cgi_network+0x1e8>
						printf_P( PSTR("checked"));
    a24a:	00 d0       	rcall	.+0      	; 0xa24c <cgi_network+0x1d4>
    a24c:	87 ee       	ldi	r24, 0xE7	; 231
    a24e:	96 e1       	ldi	r25, 0x16	; 22
    a250:	ed b7       	in	r30, 0x3d	; 61
    a252:	fe b7       	in	r31, 0x3e	; 62
    a254:	92 83       	std	Z+2, r25	; 0x02
    a256:	81 83       	std	Z+1, r24	; 0x01
    a258:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a25c:	0f 90       	pop	r0
    a25e:	0f 90       	pop	r0
		printf_P( PSTR(	"></td>\r"
    a260:	00 d0       	rcall	.+0      	; 0xa262 <cgi_network+0x1ea>
    a262:	87 ed       	ldi	r24, 0xD7	; 215
    a264:	96 e1       	ldi	r25, 0x16	; 22
    a266:	ed b7       	in	r30, 0x3d	; 61
    a268:	fe b7       	in	r31, 0x3e	; 62
    a26a:	92 83       	std	Z+2, r25	; 0x02
    a26c:	81 83       	std	Z+1, r24	; 0x01
    a26e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
  						"  </tr>\r") );

		if ( readConfig_P ( PSTR("MAC"), IP ) != 1 )
    a272:	0f 90       	pop	r0
    a274:	0f 90       	pop	r0
    a276:	83 ed       	ldi	r24, 0xD3	; 211
    a278:	96 e1       	ldi	r25, 0x16	; 22
    a27a:	8e 01       	movw	r16, r28
    a27c:	0f 5f       	subi	r16, 0xFF	; 255
    a27e:	1f 4f       	sbci	r17, 0xFF	; 255
    a280:	b8 01       	movw	r22, r16
    a282:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a286:	01 97       	sbiw	r24, 0x01	; 1
    a288:	29 f0       	breq	.+10     	; 0xa294 <cgi_network+0x21c>
			mactostr( mymac, IP );
    a28a:	8b e3       	ldi	r24, 0x3B	; 59
    a28c:	91 e0       	ldi	r25, 0x01	; 1
    a28e:	b8 01       	movw	r22, r16
    a290:	0e 94 06 31 	call	0x620c	; 0x620c <mactostr>
  		printf_P( PSTR(	"  <tr>\r"
    a294:	00 d0       	rcall	.+0      	; 0xa296 <cgi_network+0x21e>
    a296:	00 d0       	rcall	.+0      	; 0xa298 <cgi_network+0x220>
    a298:	8f ed       	ldi	r24, 0xDF	; 223
    a29a:	95 e1       	ldi	r25, 0x15	; 21
    a29c:	ed b7       	in	r30, 0x3d	; 61
    a29e:	fe b7       	in	r31, 0x3e	; 62
    a2a0:	92 83       	std	Z+2, r25	; 0x02
    a2a2:	81 83       	std	Z+1, r24	; 0x01
    a2a4:	ce 01       	movw	r24, r28
    a2a6:	01 96       	adiw	r24, 0x01	; 1
    a2a8:	94 83       	std	Z+4, r25	; 0x04
    a2aa:	83 83       	std	Z+3, r24	; 0x03
    a2ac:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a2b0:	0f 90       	pop	r0
    a2b2:	0f 90       	pop	r0
    a2b4:	0f 90       	pop	r0
    a2b6:	0f 90       	pop	r0
    a2b8:	ac c0       	rjmp	.+344    	; 0xa412 <cgi_network+0x39a>
		if ( PharseCheckName_P( http_request, PSTR("DHCP") ) )
			changeConfig_P( PSTR("DHCP"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("DHCP") ) ] );
		else
			changeConfig_P( PSTR("DHCP"), "off" );
#endif
		if ( PharseCheckName_P( http_request, PSTR("IP") ) )
    a2ba:	c8 01       	movw	r24, r16
    a2bc:	6c ed       	ldi	r22, 0xDC	; 220
    a2be:	75 e1       	ldi	r23, 0x15	; 21
    a2c0:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a2c4:	88 23       	and	r24, r24
    a2c6:	99 f0       	breq	.+38     	; 0xa2ee <cgi_network+0x276>
			changeConfig_P( PSTR("IP"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("IP") ) ] );
    a2c8:	c8 01       	movw	r24, r16
    a2ca:	66 ed       	ldi	r22, 0xD6	; 214
    a2cc:	75 e1       	ldi	r23, 0x15	; 21
    a2ce:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a2d2:	e8 2f       	mov	r30, r24
    a2d4:	f0 e0       	ldi	r31, 0x00	; 0
    a2d6:	ee 0f       	add	r30, r30
    a2d8:	ff 1f       	adc	r31, r31
    a2da:	e0 0f       	add	r30, r16
    a2dc:	f1 1f       	adc	r31, r17
    a2de:	e1 5a       	subi	r30, 0xA1	; 161
    a2e0:	fd 4f       	sbci	r31, 0xFD	; 253
    a2e2:	60 81       	ld	r22, Z
    a2e4:	71 81       	ldd	r23, Z+1	; 0x01
    a2e6:	89 ed       	ldi	r24, 0xD9	; 217
    a2e8:	95 e1       	ldi	r25, 0x15	; 21
    a2ea:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		if ( PharseCheckName_P( http_request, PSTR("MASK") ) )
    a2ee:	c8 01       	movw	r24, r16
    a2f0:	61 ed       	ldi	r22, 0xD1	; 209
    a2f2:	75 e1       	ldi	r23, 0x15	; 21
    a2f4:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a2f8:	88 23       	and	r24, r24
    a2fa:	99 f0       	breq	.+38     	; 0xa322 <cgi_network+0x2aa>
			changeConfig_P( PSTR("MASK"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("MASK") ) ] );
    a2fc:	c8 01       	movw	r24, r16
    a2fe:	67 ec       	ldi	r22, 0xC7	; 199
    a300:	75 e1       	ldi	r23, 0x15	; 21
    a302:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a306:	e8 2f       	mov	r30, r24
    a308:	f0 e0       	ldi	r31, 0x00	; 0
    a30a:	ee 0f       	add	r30, r30
    a30c:	ff 1f       	adc	r31, r31
    a30e:	e0 0f       	add	r30, r16
    a310:	f1 1f       	adc	r31, r17
    a312:	e1 5a       	subi	r30, 0xA1	; 161
    a314:	fd 4f       	sbci	r31, 0xFD	; 253
    a316:	60 81       	ld	r22, Z
    a318:	71 81       	ldd	r23, Z+1	; 0x01
    a31a:	8c ec       	ldi	r24, 0xCC	; 204
    a31c:	95 e1       	ldi	r25, 0x15	; 21
    a31e:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		if ( PharseCheckName_P( http_request, PSTR("GATE") ) )
    a322:	c8 01       	movw	r24, r16
    a324:	62 ec       	ldi	r22, 0xC2	; 194
    a326:	75 e1       	ldi	r23, 0x15	; 21
    a328:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a32c:	88 23       	and	r24, r24
    a32e:	99 f0       	breq	.+38     	; 0xa356 <cgi_network+0x2de>
			changeConfig_P( PSTR("GATE"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("GATE") ) ] );
    a330:	c8 01       	movw	r24, r16
    a332:	68 eb       	ldi	r22, 0xB8	; 184
    a334:	75 e1       	ldi	r23, 0x15	; 21
    a336:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a33a:	e8 2f       	mov	r30, r24
    a33c:	f0 e0       	ldi	r31, 0x00	; 0
    a33e:	ee 0f       	add	r30, r30
    a340:	ff 1f       	adc	r31, r31
    a342:	e0 0f       	add	r30, r16
    a344:	f1 1f       	adc	r31, r17
    a346:	e1 5a       	subi	r30, 0xA1	; 161
    a348:	fd 4f       	sbci	r31, 0xFD	; 253
    a34a:	60 81       	ld	r22, Z
    a34c:	71 81       	ldd	r23, Z+1	; 0x01
    a34e:	8d eb       	ldi	r24, 0xBD	; 189
    a350:	95 e1       	ldi	r25, 0x15	; 21
    a352:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		#ifdef DNS
		if ( PharseCheckName_P( http_request, PSTR("DNS") ) )
    a356:	c8 01       	movw	r24, r16
    a358:	64 eb       	ldi	r22, 0xB4	; 180
    a35a:	75 e1       	ldi	r23, 0x15	; 21
    a35c:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a360:	88 23       	and	r24, r24
    a362:	99 f0       	breq	.+38     	; 0xa38a <cgi_network+0x312>
			changeConfig_P( PSTR("DNS"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("DNS") ) ] );
    a364:	c8 01       	movw	r24, r16
    a366:	6c ea       	ldi	r22, 0xAC	; 172
    a368:	75 e1       	ldi	r23, 0x15	; 21
    a36a:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a36e:	e8 2f       	mov	r30, r24
    a370:	f0 e0       	ldi	r31, 0x00	; 0
    a372:	ee 0f       	add	r30, r30
    a374:	ff 1f       	adc	r31, r31
    a376:	e0 0f       	add	r30, r16
    a378:	f1 1f       	adc	r31, r17
    a37a:	e1 5a       	subi	r30, 0xA1	; 161
    a37c:	fd 4f       	sbci	r31, 0xFD	; 253
    a37e:	60 81       	ld	r22, Z
    a380:	71 81       	ldd	r23, Z+1	; 0x01
    a382:	80 eb       	ldi	r24, 0xB0	; 176
    a384:	95 e1       	ldi	r25, 0x15	; 21
    a386:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		#endif
		if ( PharseCheckName_P( http_request, PSTR("MAC") ) )
    a38a:	c8 01       	movw	r24, r16
    a38c:	68 ea       	ldi	r22, 0xA8	; 168
    a38e:	75 e1       	ldi	r23, 0x15	; 21
    a390:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a394:	88 23       	and	r24, r24
    a396:	99 f0       	breq	.+38     	; 0xa3be <cgi_network+0x346>
			changeConfig_P( PSTR("MAC"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("MAC") ) ] );
    a398:	c8 01       	movw	r24, r16
    a39a:	60 ea       	ldi	r22, 0xA0	; 160
    a39c:	75 e1       	ldi	r23, 0x15	; 21
    a39e:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a3a2:	e8 2f       	mov	r30, r24
    a3a4:	f0 e0       	ldi	r31, 0x00	; 0
    a3a6:	ee 0f       	add	r30, r30
    a3a8:	ff 1f       	adc	r31, r31
    a3aa:	e0 0f       	add	r30, r16
    a3ac:	f1 1f       	adc	r31, r17
    a3ae:	e1 5a       	subi	r30, 0xA1	; 161
    a3b0:	fd 4f       	sbci	r31, 0xFD	; 253
    a3b2:	60 81       	ld	r22, Z
    a3b4:	71 81       	ldd	r23, Z+1	; 0x01
    a3b6:	84 ea       	ldi	r24, 0xA4	; 164
    a3b8:	95 e1       	ldi	r25, 0x15	; 21
    a3ba:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		if ( PharseCheckName_P( http_request, PSTR("ETH_FLDX") ) )
    a3be:	c8 01       	movw	r24, r16
    a3c0:	67 e9       	ldi	r22, 0x97	; 151
    a3c2:	75 e1       	ldi	r23, 0x15	; 21
    a3c4:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a3c8:	88 23       	and	r24, r24
    a3ca:	91 f0       	breq	.+36     	; 0xa3f0 <cgi_network+0x378>
			changeConfig_P( PSTR("ETH_FLDX"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("ETH_FLDX") ) ] );
    a3cc:	c8 01       	movw	r24, r16
    a3ce:	65 e8       	ldi	r22, 0x85	; 133
    a3d0:	75 e1       	ldi	r23, 0x15	; 21
    a3d2:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a3d6:	90 e0       	ldi	r25, 0x00	; 0
    a3d8:	88 0f       	add	r24, r24
    a3da:	99 1f       	adc	r25, r25
    a3dc:	08 0f       	add	r16, r24
    a3de:	19 1f       	adc	r17, r25
    a3e0:	01 5a       	subi	r16, 0xA1	; 161
    a3e2:	1d 4f       	sbci	r17, 0xFD	; 253
    a3e4:	f8 01       	movw	r30, r16
    a3e6:	60 81       	ld	r22, Z
    a3e8:	71 81       	ldd	r23, Z+1	; 0x01
    a3ea:	8e e8       	ldi	r24, 0x8E	; 142
    a3ec:	95 e1       	ldi	r25, 0x15	; 21
    a3ee:	04 c0       	rjmp	.+8      	; 0xa3f8 <cgi_network+0x380>
		else
			changeConfig_P( PSTR("ETH_FLDX"), "off" );
    a3f0:	8c e7       	ldi	r24, 0x7C	; 124
    a3f2:	95 e1       	ldi	r25, 0x15	; 21
    a3f4:	69 e2       	ldi	r22, 0x29	; 41
    a3f6:	71 e0       	ldi	r23, 0x01	; 1
    a3f8:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		printf_P( PSTR("Einstellungen uebernommen!\r\n"));
    a3fc:	00 d0       	rcall	.+0      	; 0xa3fe <cgi_network+0x386>
    a3fe:	8f e5       	ldi	r24, 0x5F	; 95
    a400:	95 e1       	ldi	r25, 0x15	; 21
    a402:	ed b7       	in	r30, 0x3d	; 61
    a404:	fe b7       	in	r31, 0x3e	; 62
    a406:	92 83       	std	Z+2, r25	; 0x02
    a408:	81 83       	std	Z+1, r24	; 0x01
    a40a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a40e:	0f 90       	pop	r0
    a410:	0f 90       	pop	r0
	}
	
	cgi_PrintHttpheaderEnd();
    a412:	0e 94 ce 45 	call	0x8b9c	; 0x8b9c <cgi_PrintHttpheaderEnd>
	
/*	printf_P( PSTR( " </BODY>\r\n"
					"</HTML>\r\n"
					"\r\n"), IP);
*/
}
    a416:	a0 96       	adiw	r28, 0x20	; 32
    a418:	e4 e0       	ldi	r30, 0x04	; 4
    a41a:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

0000a41e <init_cmd_ifconfig>:
#include "cmd_ifconfig.h"

void init_cmd_ifconfig( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_ifconfig, PSTR("ifconfig"));
    a41e:	8a e8       	ldi	r24, 0x8A	; 138
    a420:	9f e4       	ldi	r25, 0x4F	; 79
    a422:	64 e7       	ldi	r22, 0x74	; 116
    a424:	7a e1       	ldi	r23, 0x1A	; 26
    a426:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
#if defined(HTTPSERVER_NETCONFIG)
	cgi_RegisterCGI( cgi_network, PSTR("network.cgi"));
    a42a:	8c e3       	ldi	r24, 0x3C	; 60
    a42c:	90 e5       	ldi	r25, 0x50	; 80
    a42e:	68 e6       	ldi	r22, 0x68	; 104
    a430:	7a e1       	ldi	r23, 0x1A	; 26
    a432:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <cgi_RegisterCGI>
#endif
}
    a436:	08 95       	ret

0000a438 <cgi_ntp>:
 * \param 	pStruct	Struktur auf den HTTP_Request
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void cgi_ntp( void * pStruct )
{
    a438:	a4 e2       	ldi	r26, 0x24	; 36
    a43a:	b0 e0       	ldi	r27, 0x00	; 0
    a43c:	e2 e2       	ldi	r30, 0x22	; 34
    a43e:	f2 e5       	ldi	r31, 0x52	; 82
    a440:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <__prologue_saves__+0x1c>
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    a444:	8c 01       	movw	r16, r24
						"<HEAD>\r\n"
						"<TITLE>SNTP</TITLE>\r\n"
						"</HEAD>\r\n"
						" <BODY>\r\n"));
*/
	cgi_PrintHttpheaderStart();
    a446:	0e 94 da 45 	call	0x8bb4	; 0x8bb4 <cgi_PrintHttpheaderStart>

	// Wenn keine Variablen 체bergeben wurden, dann Config ausgeben,
	// wenn Variablen 체bergeben wurden Config 채ndern
	if ( http_request->argc == 0 )
    a44a:	0a 5b       	subi	r16, 0xBA	; 186
    a44c:	1d 4f       	sbci	r17, 0xFD	; 253
    a44e:	d8 01       	movw	r26, r16
    a450:	8c 91       	ld	r24, X
    a452:	06 54       	subi	r16, 0x46	; 70
    a454:	12 40       	sbci	r17, 0x02	; 2
    a456:	88 23       	and	r24, r24
    a458:	09 f0       	breq	.+2      	; 0xa45c <cgi_ntp+0x24>
    a45a:	7b c0       	rjmp	.+246    	; 0xa552 <cgi_ntp+0x11a>
	{
		readConfig_P( PSTR("NTP"), NTPSERVER );
    a45c:	8e 01       	movw	r16, r28
    a45e:	0b 5f       	subi	r16, 0xFB	; 251
    a460:	1f 4f       	sbci	r17, 0xFF	; 255
    a462:	86 e2       	ldi	r24, 0x26	; 38
    a464:	9d e1       	ldi	r25, 0x1D	; 29
    a466:	b8 01       	movw	r22, r16
    a468:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
		printf_P( PSTR(	"<form action=\"ntp.cgi\">\r"
    a46c:	00 d0       	rcall	.+0      	; 0xa46e <cgi_ntp+0x36>
    a46e:	80 e8       	ldi	r24, 0x80	; 128
    a470:	9c e1       	ldi	r25, 0x1C	; 28
    a472:	ed b7       	in	r30, 0x3d	; 61
    a474:	fe b7       	in	r31, 0x3e	; 62
    a476:	92 83       	std	Z+2, r25	; 0x02
    a478:	81 83       	std	Z+1, r24	; 0x01
    a47a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
					   	"<table border=\"0\" cellpadding=\"5\" cellspacing=\"0\">"
  						"<tr>"
					   	"<td align=\"right\">SNTP aktivieren</td>"
					    "<td><input type=\"checkbox\" name=\"NTP\" value=\"on\" " )); 
		if ( !strcmp_P( NTPSERVER, PSTR("on") ) )
    a47e:	0f 90       	pop	r0
    a480:	0f 90       	pop	r0
    a482:	c8 01       	movw	r24, r16
    a484:	6d e7       	ldi	r22, 0x7D	; 125
    a486:	7c e1       	ldi	r23, 0x1C	; 28
    a488:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    a48c:	89 2b       	or	r24, r25
    a48e:	69 f4       	brne	.+26     	; 0xa4aa <cgi_ntp+0x72>
						printf_P( PSTR("checked"));
    a490:	00 d0       	rcall	.+0      	; 0xa492 <cgi_ntp+0x5a>
    a492:	85 e7       	ldi	r24, 0x75	; 117
    a494:	9c e1       	ldi	r25, 0x1C	; 28
    a496:	ad b7       	in	r26, 0x3d	; 61
    a498:	be b7       	in	r27, 0x3e	; 62
    a49a:	12 96       	adiw	r26, 0x02	; 2
    a49c:	9c 93       	st	X, r25
    a49e:	8e 93       	st	-X, r24
    a4a0:	11 97       	sbiw	r26, 0x01	; 1
    a4a2:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a4a6:	0f 90       	pop	r0
    a4a8:	0f 90       	pop	r0
		printf_P( PSTR(	"></td>"
    a4aa:	00 d0       	rcall	.+0      	; 0xa4ac <cgi_ntp+0x74>
    a4ac:	89 e6       	ldi	r24, 0x69	; 105
    a4ae:	9c e1       	ldi	r25, 0x1C	; 28
    a4b0:	ed b7       	in	r30, 0x3d	; 61
    a4b2:	fe b7       	in	r31, 0x3e	; 62
    a4b4:	92 83       	std	Z+2, r25	; 0x02
    a4b6:	81 83       	std	Z+1, r24	; 0x01
    a4b8:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
  						"</tr>") );
		
		if( checkConfigName_P( PSTR("NTP") ) != -1 )
    a4bc:	0f 90       	pop	r0
    a4be:	0f 90       	pop	r0
    a4c0:	85 e6       	ldi	r24, 0x65	; 101
    a4c2:	9c e1       	ldi	r25, 0x1C	; 28
    a4c4:	0e 94 91 39 	call	0x7322	; 0x7322 <checkConfigName_P>
    a4c8:	be 01       	movw	r22, r28
    a4ca:	6b 5f       	subi	r22, 0xFB	; 251
    a4cc:	7f 4f       	sbci	r23, 0xFF	; 255
    a4ce:	8f 5f       	subi	r24, 0xFF	; 255
    a4d0:	9f 4f       	sbci	r25, 0xFF	; 255
    a4d2:	29 f0       	breq	.+10     	; 0xa4de <cgi_ntp+0xa6>
			readConfig_P ( PSTR("NTPSERVER"), NTPSERVER );
    a4d4:	8b e5       	ldi	r24, 0x5B	; 91
    a4d6:	9c e1       	ldi	r25, 0x1C	; 28
    a4d8:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a4dc:	05 c0       	rjmp	.+10     	; 0xa4e8 <cgi_ntp+0xb0>
  		else
			strcpy_P ( NTPSERVER, PSTR("time.fu-berlin.de"));
    a4de:	cb 01       	movw	r24, r22
    a4e0:	69 e4       	ldi	r22, 0x49	; 73
    a4e2:	7c e1       	ldi	r23, 0x1C	; 28
    a4e4:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
			
		if( checkConfigName_P( PSTR("UTCZONE") ) != -1 )
    a4e8:	81 e4       	ldi	r24, 0x41	; 65
    a4ea:	9c e1       	ldi	r25, 0x1C	; 28
    a4ec:	0e 94 91 39 	call	0x7322	; 0x7322 <checkConfigName_P>
    a4f0:	be 01       	movw	r22, r28
    a4f2:	6f 5f       	subi	r22, 0xFF	; 255
    a4f4:	7f 4f       	sbci	r23, 0xFF	; 255
    a4f6:	8f 5f       	subi	r24, 0xFF	; 255
    a4f8:	9f 4f       	sbci	r25, 0xFF	; 255
    a4fa:	29 f0       	breq	.+10     	; 0xa506 <cgi_ntp+0xce>
			readConfig_P ( PSTR("UTCZONE"), UTCZONE );
    a4fc:	89 e3       	ldi	r24, 0x39	; 57
    a4fe:	9c e1       	ldi	r25, 0x1C	; 28
    a500:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a504:	05 c0       	rjmp	.+10     	; 0xa510 <cgi_ntp+0xd8>
  		else
			strcpy_P ( UTCZONE, PSTR("0"));
    a506:	cb 01       	movw	r24, r22
    a508:	67 e3       	ldi	r22, 0x37	; 55
    a50a:	7c e1       	ldi	r23, 0x1C	; 28
    a50c:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>

		printf_P( PSTR(	"<tr>"
    a510:	00 d0       	rcall	.+0      	; 0xa512 <cgi_ntp+0xda>
    a512:	00 d0       	rcall	.+0      	; 0xa514 <cgi_ntp+0xdc>
    a514:	00 d0       	rcall	.+0      	; 0xa516 <cgi_ntp+0xde>
    a516:	ed b7       	in	r30, 0x3d	; 61
    a518:	fe b7       	in	r31, 0x3e	; 62
    a51a:	31 96       	adiw	r30, 0x01	; 1
    a51c:	80 ee       	ldi	r24, 0xE0	; 224
    a51e:	9a e1       	ldi	r25, 0x1A	; 26
    a520:	ad b7       	in	r26, 0x3d	; 61
    a522:	be b7       	in	r27, 0x3e	; 62
    a524:	12 96       	adiw	r26, 0x02	; 2
    a526:	9c 93       	st	X, r25
    a528:	8e 93       	st	-X, r24
    a52a:	11 97       	sbiw	r26, 0x01	; 1
    a52c:	ce 01       	movw	r24, r28
    a52e:	05 96       	adiw	r24, 0x05	; 5
    a530:	93 83       	std	Z+3, r25	; 0x03
    a532:	82 83       	std	Z+2, r24	; 0x02
    a534:	ce 01       	movw	r24, r28
    a536:	01 96       	adiw	r24, 0x01	; 1
    a538:	95 83       	std	Z+5, r25	; 0x05
    a53a:	84 83       	std	Z+4, r24	; 0x04
    a53c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a540:	ed b7       	in	r30, 0x3d	; 61
    a542:	fe b7       	in	r31, 0x3e	; 62
    a544:	36 96       	adiw	r30, 0x06	; 6
    a546:	0f b6       	in	r0, 0x3f	; 63
    a548:	f8 94       	cli
    a54a:	fe bf       	out	0x3e, r31	; 62
    a54c:	0f be       	out	0x3f, r0	; 63
    a54e:	ed bf       	out	0x3d, r30	; 61
    a550:	5e c0       	rjmp	.+188    	; 0xa60e <cgi_ntp+0x1d6>
					   	"</table>"
						"</form>" ) , NTPSERVER, UTCZONE );
	}
	else
	{
		if ( PharseCheckName_P( http_request, PSTR("NTP") ) )
    a552:	c8 01       	movw	r24, r16
    a554:	6c ed       	ldi	r22, 0xDC	; 220
    a556:	7a e1       	ldi	r23, 0x1A	; 26
    a558:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a55c:	88 23       	and	r24, r24
    a55e:	91 f0       	breq	.+36     	; 0xa584 <cgi_ntp+0x14c>
			changeConfig_P( PSTR("NTP"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("NTP") ) ] );
    a560:	c8 01       	movw	r24, r16
    a562:	64 ed       	ldi	r22, 0xD4	; 212
    a564:	7a e1       	ldi	r23, 0x1A	; 26
    a566:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a56a:	e8 2f       	mov	r30, r24
    a56c:	f0 e0       	ldi	r31, 0x00	; 0
    a56e:	ee 0f       	add	r30, r30
    a570:	ff 1f       	adc	r31, r31
    a572:	e0 0f       	add	r30, r16
    a574:	f1 1f       	adc	r31, r17
    a576:	e1 5a       	subi	r30, 0xA1	; 161
    a578:	fd 4f       	sbci	r31, 0xFD	; 253
    a57a:	60 81       	ld	r22, Z
    a57c:	71 81       	ldd	r23, Z+1	; 0x01
    a57e:	88 ed       	ldi	r24, 0xD8	; 216
    a580:	9a e1       	ldi	r25, 0x1A	; 26
    a582:	04 c0       	rjmp	.+8      	; 0xa58c <cgi_ntp+0x154>
		else
			changeConfig_P( PSTR("NTP"), "off" );	
    a584:	80 ed       	ldi	r24, 0xD0	; 208
    a586:	9a e1       	ldi	r25, 0x1A	; 26
    a588:	6d e2       	ldi	r22, 0x2D	; 45
    a58a:	71 e0       	ldi	r23, 0x01	; 1
    a58c:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		if ( PharseCheckName_P( http_request, PSTR("NTPSERVER") ) )
    a590:	c8 01       	movw	r24, r16
    a592:	66 ec       	ldi	r22, 0xC6	; 198
    a594:	7a e1       	ldi	r23, 0x1A	; 26
    a596:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a59a:	88 23       	and	r24, r24
    a59c:	99 f0       	breq	.+38     	; 0xa5c4 <cgi_ntp+0x18c>
			changeConfig_P( PSTR("NTPSERVER"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("NTPSERVER") ) ] );
    a59e:	c8 01       	movw	r24, r16
    a5a0:	62 eb       	ldi	r22, 0xB2	; 178
    a5a2:	7a e1       	ldi	r23, 0x1A	; 26
    a5a4:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a5a8:	e8 2f       	mov	r30, r24
    a5aa:	f0 e0       	ldi	r31, 0x00	; 0
    a5ac:	ee 0f       	add	r30, r30
    a5ae:	ff 1f       	adc	r31, r31
    a5b0:	e0 0f       	add	r30, r16
    a5b2:	f1 1f       	adc	r31, r17
    a5b4:	e1 5a       	subi	r30, 0xA1	; 161
    a5b6:	fd 4f       	sbci	r31, 0xFD	; 253
    a5b8:	60 81       	ld	r22, Z
    a5ba:	71 81       	ldd	r23, Z+1	; 0x01
    a5bc:	8c eb       	ldi	r24, 0xBC	; 188
    a5be:	9a e1       	ldi	r25, 0x1A	; 26
    a5c0:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		if ( PharseCheckName_P( http_request, PSTR("UTCZONE") ) )
    a5c4:	c8 01       	movw	r24, r16
    a5c6:	6a ea       	ldi	r22, 0xAA	; 170
    a5c8:	7a e1       	ldi	r23, 0x1A	; 26
    a5ca:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a5ce:	88 23       	and	r24, r24
    a5d0:	99 f0       	breq	.+38     	; 0xa5f8 <cgi_ntp+0x1c0>
			changeConfig_P( PSTR("UTCZONE"), http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("UTCZONE") ) ] );
    a5d2:	c8 01       	movw	r24, r16
    a5d4:	6a e9       	ldi	r22, 0x9A	; 154
    a5d6:	7a e1       	ldi	r23, 0x1A	; 26
    a5d8:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a5dc:	90 e0       	ldi	r25, 0x00	; 0
    a5de:	88 0f       	add	r24, r24
    a5e0:	99 1f       	adc	r25, r25
    a5e2:	08 0f       	add	r16, r24
    a5e4:	19 1f       	adc	r17, r25
    a5e6:	01 5a       	subi	r16, 0xA1	; 161
    a5e8:	1d 4f       	sbci	r17, 0xFD	; 253
    a5ea:	d8 01       	movw	r26, r16
    a5ec:	6d 91       	ld	r22, X+
    a5ee:	7c 91       	ld	r23, X
    a5f0:	82 ea       	ldi	r24, 0xA2	; 162
    a5f2:	9a e1       	ldi	r25, 0x1A	; 26
    a5f4:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
		
		printf_P( PSTR("Einstellungen uebernommen!\r\n"));
    a5f8:	00 d0       	rcall	.+0      	; 0xa5fa <cgi_ntp+0x1c2>
    a5fa:	8d e7       	ldi	r24, 0x7D	; 125
    a5fc:	9a e1       	ldi	r25, 0x1A	; 26
    a5fe:	ed b7       	in	r30, 0x3d	; 61
    a600:	fe b7       	in	r31, 0x3e	; 62
    a602:	92 83       	std	Z+2, r25	; 0x02
    a604:	81 83       	std	Z+1, r24	; 0x01
    a606:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a60a:	0f 90       	pop	r0
    a60c:	0f 90       	pop	r0

	}

	cgi_PrintHttpheaderEnd();
    a60e:	0e 94 ce 45 	call	0x8b9c	; 0x8b9c <cgi_PrintHttpheaderEnd>
/*
	 printf_P( PSTR( "</BODY>"
					"</HTML>"
					"\r\n\r\n"));
*/
}
    a612:	a4 96       	adiw	r28, 0x24	; 36
    a614:	e4 e0       	ldi	r30, 0x04	; 4
    a616:	0c 94 e3 6a 	jmp	0xd5c6	; 0xd5c6 <__epilogue_restores__+0x1c>

0000a61a <cmd_ntp>:
	cgi_RegisterCGI( cgi_ntp, PSTR("ntp.cgi"));
#endif
}

int cmd_ntp( int argc, char ** argv )
{ 
    a61a:	a5 e2       	ldi	r26, 0x25	; 37
    a61c:	b0 e0       	ldi	r27, 0x00	; 0
    a61e:	e3 e1       	ldi	r30, 0x13	; 19
    a620:	f3 e5       	ldi	r31, 0x53	; 83
    a622:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    a626:	8b 01       	movw	r16, r22
	long ip;
	char ipstr[ 20 ];

	struct TIME time;
	
	if ( argc == 2 )
    a628:	02 97       	sbiw	r24, 0x02	; 2
    a62a:	09 f0       	breq	.+2      	; 0xa62e <cmd_ntp+0x14>
    a62c:	91 c0       	rjmp	.+290    	; 0xa750 <cmd_ntp+0x136>
	{
		ip = strtoip( argv[1] );
    a62e:	db 01       	movw	r26, r22
    a630:	12 96       	adiw	r26, 0x02	; 2
    a632:	8d 91       	ld	r24, X+
    a634:	9c 91       	ld	r25, X
    a636:	13 97       	sbiw	r26, 0x03	; 3
    a638:	0e 94 31 33 	call	0x6662	; 0x6662 <strtoip>
    a63c:	ac 01       	movw	r20, r24
    a63e:	cb 01       	movw	r24, r22
    a640:	da 01       	movw	r26, r20
    a642:	6c 01       	movw	r12, r24
    a644:	7d 01       	movw	r14, r26

		if ( ip == 0 )
    a646:	c1 14       	cp	r12, r1
    a648:	d1 04       	cpc	r13, r1
    a64a:	e1 04       	cpc	r14, r1
    a64c:	f1 04       	cpc	r15, r1
    a64e:	b9 f4       	brne	.+46     	; 0xa67e <cmd_ntp+0x64>
		{
			ip = DNS_ResolveName( argv[ 1 ] );
    a650:	f8 01       	movw	r30, r16
    a652:	82 81       	ldd	r24, Z+2	; 0x02
    a654:	93 81       	ldd	r25, Z+3	; 0x03
    a656:	0e 94 e4 34 	call	0x69c8	; 0x69c8 <DNS_ResolveName>
    a65a:	ac 01       	movw	r20, r24
    a65c:	cb 01       	movw	r24, r22
    a65e:	da 01       	movw	r26, r20
    a660:	6c 01       	movw	r12, r24
    a662:	7d 01       	movw	r14, r26
			if ( ip == DNS_NO_ANSWER )
    a664:	ff ef       	ldi	r31, 0xFF	; 255
    a666:	cf 16       	cp	r12, r31
    a668:	ff ef       	ldi	r31, 0xFF	; 255
    a66a:	df 06       	cpc	r13, r31
    a66c:	ff ef       	ldi	r31, 0xFF	; 255
    a66e:	ef 06       	cpc	r14, r31
    a670:	ff ef       	ldi	r31, 0xFF	; 255
    a672:	ff 06       	cpc	r15, r31
    a674:	21 f4       	brne	.+8      	; 0xa67e <cmd_ntp+0x64>
			{
				printf_P( PSTR("Fehler\r\n"));
    a676:	00 d0       	rcall	.+0      	; 0xa678 <cmd_ntp+0x5e>
    a678:	84 e8       	ldi	r24, 0x84	; 132
    a67a:	9d e1       	ldi	r25, 0x1D	; 29
    a67c:	62 c0       	rjmp	.+196    	; 0xa742 <cmd_ntp+0x128>
				return( 0 );
			}
		}
		
		printf_P( PSTR("Hole Zeit von %s\r\n"), argv[ 1 ] );
    a67e:	00 d0       	rcall	.+0      	; 0xa680 <cmd_ntp+0x66>
    a680:	00 d0       	rcall	.+0      	; 0xa682 <cmd_ntp+0x68>
    a682:	81 e7       	ldi	r24, 0x71	; 113
    a684:	9d e1       	ldi	r25, 0x1D	; 29
    a686:	ed b7       	in	r30, 0x3d	; 61
    a688:	fe b7       	in	r31, 0x3e	; 62
    a68a:	92 83       	std	Z+2, r25	; 0x02
    a68c:	81 83       	std	Z+1, r24	; 0x01
    a68e:	d8 01       	movw	r26, r16
    a690:	12 96       	adiw	r26, 0x02	; 2
    a692:	8d 91       	ld	r24, X+
    a694:	9c 91       	ld	r25, X
    a696:	13 97       	sbiw	r26, 0x03	; 3
    a698:	94 83       	std	Z+4, r25	; 0x04
    a69a:	83 83       	std	Z+3, r24	; 0x03
    a69c:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
		
		if( checkConfigName_P( PSTR("UTCZONE") ) != -1 )
    a6a0:	0f 90       	pop	r0
    a6a2:	0f 90       	pop	r0
    a6a4:	0f 90       	pop	r0
    a6a6:	0f 90       	pop	r0
    a6a8:	89 e6       	ldi	r24, 0x69	; 105
    a6aa:	9d e1       	ldi	r25, 0x1D	; 29
    a6ac:	0e 94 91 39 	call	0x7322	; 0x7322 <checkConfigName_P>
    a6b0:	8f 5f       	subi	r24, 0xFF	; 255
    a6b2:	9f 4f       	sbci	r25, 0xFF	; 255
    a6b4:	41 f0       	breq	.+16     	; 0xa6c6 <cmd_ntp+0xac>
			readConfig_P ( PSTR("UTCZONE"), ipstr );
    a6b6:	81 e6       	ldi	r24, 0x61	; 97
    a6b8:	9d e1       	ldi	r25, 0x1D	; 29
    a6ba:	be 01       	movw	r22, r28
    a6bc:	6e 5e       	subi	r22, 0xEE	; 238
    a6be:	7f 4f       	sbci	r23, 0xFF	; 255
    a6c0:	0e 94 ba 3b 	call	0x7774	; 0x7774 <readConfig_P>
    a6c4:	01 c0       	rjmp	.+2      	; 0xa6c8 <cmd_ntp+0xae>
		else
			ipstr[0] = '\0';
    a6c6:	1a 8a       	std	Y+18, r1	; 0x12

		if ( NTP_GetTime( ip , 0 , atol( ipstr ) ) != NTP_ERROR )
    a6c8:	ce 01       	movw	r24, r28
    a6ca:	42 96       	adiw	r24, 0x12	; 18
    a6cc:	0e 94 c7 13 	call	0x278e	; 0x278e <atol>
    a6d0:	8b 01       	movw	r16, r22
    a6d2:	9c 01       	movw	r18, r24
    a6d4:	c7 01       	movw	r24, r14
    a6d6:	b6 01       	movw	r22, r12
    a6d8:	40 e0       	ldi	r20, 0x00	; 0
    a6da:	50 e0       	ldi	r21, 0x00	; 0
    a6dc:	0e 94 25 34 	call	0x684a	; 0x684a <NTP_GetTime>
    a6e0:	8f 5f       	subi	r24, 0xFF	; 255
    a6e2:	9f 4f       	sbci	r25, 0xFF	; 255
    a6e4:	59 f1       	breq	.+86     	; 0xa73c <cmd_ntp+0x122>
		{
			CLOCK_GetTime( &time );
    a6e6:	ce 01       	movw	r24, r28
    a6e8:	01 96       	adiw	r24, 0x01	; 1
    a6ea:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <CLOCK_GetTime>
			printf_P( PSTR("Neue Zeit: %02d:%02d:%02d\r\n") , time.hh , time.mm , time.ss );
    a6ee:	2c 81       	ldd	r18, Y+4	; 0x04
    a6f0:	3b 81       	ldd	r19, Y+3	; 0x03
    a6f2:	4a 81       	ldd	r20, Y+2	; 0x02
    a6f4:	8d b7       	in	r24, 0x3d	; 61
    a6f6:	9e b7       	in	r25, 0x3e	; 62
    a6f8:	08 97       	sbiw	r24, 0x08	; 8
    a6fa:	0f b6       	in	r0, 0x3f	; 63
    a6fc:	f8 94       	cli
    a6fe:	9e bf       	out	0x3e, r25	; 62
    a700:	0f be       	out	0x3f, r0	; 63
    a702:	8d bf       	out	0x3d, r24	; 61
    a704:	ed b7       	in	r30, 0x3d	; 61
    a706:	fe b7       	in	r31, 0x3e	; 62
    a708:	31 96       	adiw	r30, 0x01	; 1
    a70a:	85 e4       	ldi	r24, 0x45	; 69
    a70c:	9d e1       	ldi	r25, 0x1D	; 29
    a70e:	ad b7       	in	r26, 0x3d	; 61
    a710:	be b7       	in	r27, 0x3e	; 62
    a712:	12 96       	adiw	r26, 0x02	; 2
    a714:	9c 93       	st	X, r25
    a716:	8e 93       	st	-X, r24
    a718:	11 97       	sbiw	r26, 0x01	; 1
    a71a:	22 83       	std	Z+2, r18	; 0x02
    a71c:	13 82       	std	Z+3, r1	; 0x03
    a71e:	34 83       	std	Z+4, r19	; 0x04
    a720:	15 82       	std	Z+5, r1	; 0x05
    a722:	46 83       	std	Z+6, r20	; 0x06
    a724:	17 82       	std	Z+7, r1	; 0x07
    a726:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a72a:	ed b7       	in	r30, 0x3d	; 61
    a72c:	fe b7       	in	r31, 0x3e	; 62
    a72e:	38 96       	adiw	r30, 0x08	; 8
    a730:	0f b6       	in	r0, 0x3f	; 63
    a732:	f8 94       	cli
    a734:	fe bf       	out	0x3e, r31	; 62
    a736:	0f be       	out	0x3f, r0	; 63
    a738:	ed bf       	out	0x3d, r30	; 61
    a73a:	15 c0       	rjmp	.+42     	; 0xa766 <cmd_ntp+0x14c>
		}
		else
			printf_P( PSTR("Fehler\r\n"));			
    a73c:	00 d0       	rcall	.+0      	; 0xa73e <cmd_ntp+0x124>
    a73e:	8c e3       	ldi	r24, 0x3C	; 60
    a740:	9d e1       	ldi	r25, 0x1D	; 29
    a742:	ad b7       	in	r26, 0x3d	; 61
    a744:	be b7       	in	r27, 0x3e	; 62
    a746:	12 96       	adiw	r26, 0x02	; 2
    a748:	9c 93       	st	X, r25
    a74a:	8e 93       	st	-X, r24
    a74c:	11 97       	sbiw	r26, 0x01	; 1
    a74e:	07 c0       	rjmp	.+14     	; 0xa75e <cmd_ntp+0x144>
	}
	else
		printf_P( PSTR("ntp <ntpserver>\r\n"));
    a750:	00 d0       	rcall	.+0      	; 0xa752 <cmd_ntp+0x138>
    a752:	8a e2       	ldi	r24, 0x2A	; 42
    a754:	9d e1       	ldi	r25, 0x1D	; 29
    a756:	ed b7       	in	r30, 0x3d	; 61
    a758:	fe b7       	in	r31, 0x3e	; 62
    a75a:	92 83       	std	Z+2, r25	; 0x02
    a75c:	81 83       	std	Z+1, r24	; 0x01
    a75e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a762:	0f 90       	pop	r0
    a764:	0f 90       	pop	r0

	return( 0 );
}
    a766:	80 e0       	ldi	r24, 0x00	; 0
    a768:	90 e0       	ldi	r25, 0x00	; 0
    a76a:	a5 96       	adiw	r28, 0x25	; 37
    a76c:	e8 e0       	ldi	r30, 0x08	; 8
    a76e:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000a772 <init_cmd_ntp>:
#include "cmd_ntp.h"

void init_cmd_ntp( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_ntp, PSTR("ntp"));
    a772:	8d e0       	ldi	r24, 0x0D	; 13
    a774:	93 e5       	ldi	r25, 0x53	; 83
    a776:	65 e9       	ldi	r22, 0x95	; 149
    a778:	7d e1       	ldi	r23, 0x1D	; 29
    a77a:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
#if defined(HTTPSERVER_NTP)
	cgi_RegisterCGI( cgi_ntp, PSTR("ntp.cgi"));
    a77e:	8c e1       	ldi	r24, 0x1C	; 28
    a780:	92 e5       	ldi	r25, 0x52	; 82
    a782:	6d e8       	ldi	r22, 0x8D	; 141
    a784:	7d e1       	ldi	r23, 0x1D	; 29
    a786:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <cgi_RegisterCGI>
#endif
}
    a78a:	08 95       	ret

0000a78c <cmd_temp>:
	telnet_RegisterCMD( cmd_temp, PSTR("temp"));
#endif
}

int cmd_temp( int argc, char ** argv )
{	
    a78c:	a4 e6       	ldi	r26, 0x64	; 100
    a78e:	b0 e0       	ldi	r27, 0x00	; 0
    a790:	ec ec       	ldi	r30, 0xCC	; 204
    a792:	f3 e5       	ldi	r31, 0x53	; 83
    a794:	0c 94 c5 6a 	jmp	0xd58a	; 0xd58a <__prologue_saves__+0x18>
    a798:	8b 01       	movw	r16, r22
	char db[100];

	if ( !strcmp_P( argv[1], PSTR("add") ) )
    a79a:	fb 01       	movw	r30, r22
    a79c:	e2 80       	ldd	r14, Z+2	; 0x02
    a79e:	f3 80       	ldd	r15, Z+3	; 0x03
    a7a0:	c7 01       	movw	r24, r14
    a7a2:	6c ec       	ldi	r22, 0xCC	; 204
    a7a4:	7d e1       	ldi	r23, 0x1D	; 29
    a7a6:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    a7aa:	89 2b       	or	r24, r25
    a7ac:	91 f4       	brne	.+36     	; 0xa7d2 <cmd_temp+0x46>
		nano_DB_writeDBentry( argv[2], atol( argv[3] ), db, sizeof( db ) );
    a7ae:	f8 01       	movw	r30, r16
    a7b0:	86 81       	ldd	r24, Z+6	; 0x06
    a7b2:	97 81       	ldd	r25, Z+7	; 0x07
    a7b4:	0e 94 c7 13 	call	0x278e	; 0x278e <atol>
    a7b8:	ab 01       	movw	r20, r22
    a7ba:	bc 01       	movw	r22, r24
    a7bc:	f8 01       	movw	r30, r16
    a7be:	84 81       	ldd	r24, Z+4	; 0x04
    a7c0:	95 81       	ldd	r25, Z+5	; 0x05
    a7c2:	9e 01       	movw	r18, r28
    a7c4:	2f 5f       	subi	r18, 0xFF	; 255
    a7c6:	3f 4f       	sbci	r19, 0xFF	; 255
    a7c8:	04 e6       	ldi	r16, 0x64	; 100
    a7ca:	10 e0       	ldi	r17, 0x00	; 0
    a7cc:	0e 94 9f 41 	call	0x833e	; 0x833e <nano_DB_writeDBentry>
    a7d0:	48 c0       	rjmp	.+144    	; 0xa862 <cmd_temp+0xd6>
	else if ( !strcmp_P( argv[1], PSTR("make") ) )
    a7d2:	c7 01       	movw	r24, r14
    a7d4:	67 ec       	ldi	r22, 0xC7	; 199
    a7d6:	7d e1       	ldi	r23, 0x1D	; 29
    a7d8:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    a7dc:	89 2b       	or	r24, r25
    a7de:	31 f4       	brne	.+12     	; 0xa7ec <cmd_temp+0x60>
		nano_DB_makeDB( argv[2] );
    a7e0:	f8 01       	movw	r30, r16
    a7e2:	84 81       	ldd	r24, Z+4	; 0x04
    a7e4:	95 81       	ldd	r25, Z+5	; 0x05
    a7e6:	0e 94 62 42 	call	0x84c4	; 0x84c4 <nano_DB_makeDB>
    a7ea:	3b c0       	rjmp	.+118    	; 0xa862 <cmd_temp+0xd6>
	else if ( !strcmp_P( argv[1], PSTR("get") ) )
    a7ec:	c7 01       	movw	r24, r14
    a7ee:	63 ec       	ldi	r22, 0xC3	; 195
    a7f0:	7d e1       	ldi	r23, 0x1D	; 29
    a7f2:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    a7f6:	89 2b       	or	r24, r25
    a7f8:	61 f4       	brne	.+24     	; 0xa812 <cmd_temp+0x86>
		printf_P( PSTR("DBentry: %d \r\n") ,nano_DB_getnumbersofDB( argv[2] , sizeof( db ) ) );
    a7fa:	f8 01       	movw	r30, r16
    a7fc:	84 81       	ldd	r24, Z+4	; 0x04
    a7fe:	95 81       	ldd	r25, Z+5	; 0x05
    a800:	64 e6       	ldi	r22, 0x64	; 100
    a802:	70 e0       	ldi	r23, 0x00	; 0
    a804:	0e 94 9c 40 	call	0x8138	; 0x8138 <nano_DB_getnumbersofDB>
    a808:	00 d0       	rcall	.+0      	; 0xa80a <cmd_temp+0x7e>
    a80a:	00 d0       	rcall	.+0      	; 0xa80c <cmd_temp+0x80>
    a80c:	24 eb       	ldi	r18, 0xB4	; 180
    a80e:	3d e1       	ldi	r19, 0x1D	; 29
    a810:	1c c0       	rjmp	.+56     	; 0xa84a <cmd_temp+0xbe>
	else if ( !strcmp_P( argv[1], PSTR("read") ) )
    a812:	c7 01       	movw	r24, r14
    a814:	6f ea       	ldi	r22, 0xAF	; 175
    a816:	7d e1       	ldi	r23, 0x1D	; 29
    a818:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    a81c:	89 2b       	or	r24, r25
    a81e:	09 f5       	brne	.+66     	; 0xa862 <cmd_temp+0xd6>
		printf_P( PSTR("DBentry: %d gelesen\r\n") , nano_DB_readDBentry( argv[2] , atol( argv[3] ), db, sizeof( db ) ) );
    a820:	f8 01       	movw	r30, r16
    a822:	86 81       	ldd	r24, Z+6	; 0x06
    a824:	97 81       	ldd	r25, Z+7	; 0x07
    a826:	0e 94 c7 13 	call	0x278e	; 0x278e <atol>
    a82a:	ab 01       	movw	r20, r22
    a82c:	bc 01       	movw	r22, r24
    a82e:	f8 01       	movw	r30, r16
    a830:	84 81       	ldd	r24, Z+4	; 0x04
    a832:	95 81       	ldd	r25, Z+5	; 0x05
    a834:	9e 01       	movw	r18, r28
    a836:	2f 5f       	subi	r18, 0xFF	; 255
    a838:	3f 4f       	sbci	r19, 0xFF	; 255
    a83a:	04 e6       	ldi	r16, 0x64	; 100
    a83c:	10 e0       	ldi	r17, 0x00	; 0
    a83e:	0e 94 f0 40 	call	0x81e0	; 0x81e0 <nano_DB_readDBentry>
    a842:	00 d0       	rcall	.+0      	; 0xa844 <cmd_temp+0xb8>
    a844:	00 d0       	rcall	.+0      	; 0xa846 <cmd_temp+0xba>
    a846:	29 e9       	ldi	r18, 0x99	; 153
    a848:	3d e1       	ldi	r19, 0x1D	; 29
    a84a:	ed b7       	in	r30, 0x3d	; 61
    a84c:	fe b7       	in	r31, 0x3e	; 62
    a84e:	32 83       	std	Z+2, r19	; 0x02
    a850:	21 83       	std	Z+1, r18	; 0x01
    a852:	94 83       	std	Z+4, r25	; 0x04
    a854:	83 83       	std	Z+3, r24	; 0x03
    a856:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a85a:	0f 90       	pop	r0
    a85c:	0f 90       	pop	r0
    a85e:	0f 90       	pop	r0
    a860:	0f 90       	pop	r0
		printf_P( PSTR("%c%d.%01d C\r\n"), VZ, abs(Temp / 256) , abs((Temp << 8 ) / 6250 )); // 0.1첩C

	}
*/
	
}
    a862:	cc 59       	subi	r28, 0x9C	; 156
    a864:	df 4f       	sbci	r29, 0xFF	; 255
    a866:	e6 e0       	ldi	r30, 0x06	; 6
    a868:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

0000a86c <init_cmd_temp>:
#include "system/nano_DB/nano_db.h"

void init_cmd_temp( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_temp, PSTR("temp"));
    a86c:	86 ec       	ldi	r24, 0xC6	; 198
    a86e:	93 e5       	ldi	r25, 0x53	; 83
    a870:	60 ed       	ldi	r22, 0xD0	; 208
    a872:	7d e1       	ldi	r23, 0x1D	; 29
    a874:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
}
    a878:	08 95       	ret

0000a87a <cgi_cron>:
 * \param 	pStruct	Struktur auf den HTTP_Request
 * \return	NONE
 */
/*------------------------------------------------------------------------------------------------------------*/
void cgi_cron( void * pStruct )
{
    a87a:	a0 e2       	ldi	r26, 0x20	; 32
    a87c:	b0 e0       	ldi	r27, 0x00	; 0
    a87e:	e3 e4       	ldi	r30, 0x43	; 67
    a880:	f4 e5       	ldi	r31, 0x54	; 84
    a882:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
	char string[32];
	int HH, MM;
	
	
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;
    a886:	5c 01       	movw	r10, r24
					"<HEAD>"
					"<TITLE>Cron</TITLE>"
					"</HEAD>\r"
					"<BODY>"));*/

	cgi_PrintHttpheaderStart();
    a888:	0e 94 da 45 	call	0x8bb4	; 0x8bb4 <cgi_PrintHttpheaderStart>

	if ( http_request->argc == 0 )
    a88c:	26 e4       	ldi	r18, 0x46	; 70
    a88e:	32 e0       	ldi	r19, 0x02	; 2
    a890:	a2 0e       	add	r10, r18
    a892:	b3 1e       	adc	r11, r19
    a894:	d5 01       	movw	r26, r10
    a896:	8c 91       	ld	r24, X
    a898:	ea eb       	ldi	r30, 0xBA	; 186
    a89a:	fd ef       	ldi	r31, 0xFD	; 253
    a89c:	ae 0e       	add	r10, r30
    a89e:	bf 1e       	adc	r11, r31
    a8a0:	88 23       	and	r24, r24
    a8a2:	09 f0       	breq	.+2      	; 0xa8a6 <cgi_cron+0x2c>
    a8a4:	40 c0       	rjmp	.+128    	; 0xa926 <cgi_cron+0xac>
	{
		printf_P( PSTR(	"<table border=\"0\" cellpadding=\"5\" cellspacing=\"0\">" ));
    a8a6:	00 d0       	rcall	.+0      	; 0xa8a8 <cgi_cron+0x2e>
    a8a8:	8d e5       	ldi	r24, 0x5D	; 93
    a8aa:	91 e2       	ldi	r25, 0x21	; 33
    a8ac:	ad b7       	in	r26, 0x3d	; 61
    a8ae:	be b7       	in	r27, 0x3e	; 62
    a8b0:	12 96       	adiw	r26, 0x02	; 2
    a8b2:	9c 93       	st	X, r25
    a8b4:	8e 93       	st	-X, r24
    a8b6:	11 97       	sbiw	r26, 0x01	; 1
    a8b8:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a8bc:	00 e0       	ldi	r16, 0x00	; 0
    a8be:	10 e0       	ldi	r17, 0x00	; 0
    a8c0:	0f 90       	pop	r0
    a8c2:	0f 90       	pop	r0
		for( i = 0 ; i < MAX_CRON ; i++ )
		{
			if ( CRON_getentry( string, i) == 1 )
    a8c4:	5e 01       	movw	r10, r28
    a8c6:	08 94       	sec
    a8c8:	a1 1c       	adc	r10, r1
    a8ca:	b1 1c       	adc	r11, r1
			{
				printf_P( PSTR(	"<tr>"
    a8cc:	6b ea       	ldi	r22, 0xAB	; 171
    a8ce:	e6 2e       	mov	r14, r22
    a8d0:	60 e2       	ldi	r22, 0x20	; 32
    a8d2:	f6 2e       	mov	r15, r22
	if ( http_request->argc == 0 )
	{
		printf_P( PSTR(	"<table border=\"0\" cellpadding=\"5\" cellspacing=\"0\">" ));
		for( i = 0 ; i < MAX_CRON ; i++ )
		{
			if ( CRON_getentry( string, i) == 1 )
    a8d4:	c5 01       	movw	r24, r10
    a8d6:	b8 01       	movw	r22, r16
    a8d8:	0e 94 1e 4a 	call	0x943c	; 0x943c <CRON_getentry>
    a8dc:	01 97       	sbiw	r24, 0x01	; 1
    a8de:	d1 f4       	brne	.+52     	; 0xa914 <cgi_cron+0x9a>
			{
				printf_P( PSTR(	"<tr>"
    a8e0:	00 d0       	rcall	.+0      	; 0xa8e2 <cgi_cron+0x68>
    a8e2:	00 d0       	rcall	.+0      	; 0xa8e4 <cgi_cron+0x6a>
    a8e4:	00 d0       	rcall	.+0      	; 0xa8e6 <cgi_cron+0x6c>
    a8e6:	ed b7       	in	r30, 0x3d	; 61
    a8e8:	fe b7       	in	r31, 0x3e	; 62
    a8ea:	31 96       	adiw	r30, 0x01	; 1
    a8ec:	ad b7       	in	r26, 0x3d	; 61
    a8ee:	be b7       	in	r27, 0x3e	; 62
    a8f0:	12 96       	adiw	r26, 0x02	; 2
    a8f2:	fc 92       	st	X, r15
    a8f4:	ee 92       	st	-X, r14
    a8f6:	11 97       	sbiw	r26, 0x01	; 1
    a8f8:	b3 82       	std	Z+3, r11	; 0x03
    a8fa:	a2 82       	std	Z+2, r10	; 0x02
    a8fc:	15 83       	std	Z+5, r17	; 0x05
    a8fe:	04 83       	std	Z+4, r16	; 0x04
    a900:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a904:	ed b7       	in	r30, 0x3d	; 61
    a906:	fe b7       	in	r31, 0x3e	; 62
    a908:	36 96       	adiw	r30, 0x06	; 6
    a90a:	0f b6       	in	r0, 0x3f	; 63
    a90c:	f8 94       	cli
    a90e:	fe bf       	out	0x3e, r31	; 62
    a910:	0f be       	out	0x3f, r0	; 63
    a912:	ed bf       	out	0x3d, r30	; 61
	cgi_PrintHttpheaderStart();

	if ( http_request->argc == 0 )
	{
		printf_P( PSTR(	"<table border=\"0\" cellpadding=\"5\" cellspacing=\"0\">" ));
		for( i = 0 ; i < MAX_CRON ; i++ )
    a914:	0f 5f       	subi	r16, 0xFF	; 255
    a916:	1f 4f       	sbci	r17, 0xFF	; 255
    a918:	05 30       	cpi	r16, 0x05	; 5
    a91a:	11 05       	cpc	r17, r1
    a91c:	d9 f6       	brne	.-74     	; 0xa8d4 <cgi_cron+0x5a>
								"</td>"
  								"</tr>"), string, i );
			}
		}

		printf_P( PSTR(	"<tr>"
    a91e:	00 d0       	rcall	.+0      	; 0xa920 <cgi_cron+0xa6>
    a920:	8f ef       	ldi	r24, 0xFF	; 255
    a922:	9f e1       	ldi	r25, 0x1F	; 31
    a924:	81 c0       	rjmp	.+258    	; 0xaa28 <cgi_cron+0x1ae>
						"</table>\r") );

	}
	else
	{
		if ( PharseCheckName_P( http_request, PSTR("addnew") ) )
    a926:	c5 01       	movw	r24, r10
    a928:	68 ef       	ldi	r22, 0xF8	; 248
    a92a:	7f e1       	ldi	r23, 0x1F	; 31
    a92c:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a930:	88 23       	and	r24, r24
    a932:	61 f0       	breq	.+24     	; 0xa94c <cgi_cron+0xd2>
		{
			printf_P( PSTR(	"<form action=\"cron.cgi\">"
    a934:	00 d0       	rcall	.+0      	; 0xa936 <cgi_cron+0xbc>
    a936:	83 e1       	ldi	r24, 0x13	; 19
    a938:	9e e1       	ldi	r25, 0x1E	; 30
    a93a:	ed b7       	in	r30, 0x3d	; 61
    a93c:	fe b7       	in	r31, 0x3e	; 62
    a93e:	92 83       	std	Z+2, r25	; 0x02
    a940:	81 83       	std	Z+1, r24	; 0x01
    a942:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    a946:	0f 90       	pop	r0
    a948:	0f 90       	pop	r0
    a94a:	93 c0       	rjmp	.+294    	; 0xaa72 <cgi_cron+0x1f8>
   							"<td></td><td><input type=\"submit\" value=\" Eintrag sichern \"></td>"
  							"</tr>"
						   	"</table>"
							"</form>\r" ) );
		}
		else if ( PharseCheckName_P( http_request, PSTR("CMD") ) )
    a94c:	c5 01       	movw	r24, r10
    a94e:	6f e0       	ldi	r22, 0x0F	; 15
    a950:	7e e1       	ldi	r23, 0x1E	; 30
    a952:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    a956:	88 23       	and	r24, r24
    a958:	09 f4       	brne	.+2      	; 0xa95c <cgi_cron+0xe2>
    a95a:	6d c0       	rjmp	.+218    	; 0xaa36 <cgi_cron+0x1bc>
		{
			HH = atoi( http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("HH") ) ] );
    a95c:	c5 01       	movw	r24, r10
    a95e:	6c e0       	ldi	r22, 0x0C	; 12
    a960:	7e e1       	ldi	r23, 0x1E	; 30
    a962:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a966:	e8 2f       	mov	r30, r24
    a968:	f0 e0       	ldi	r31, 0x00	; 0
    a96a:	ee 0f       	add	r30, r30
    a96c:	ff 1f       	adc	r31, r31
    a96e:	ea 0d       	add	r30, r10
    a970:	fb 1d       	adc	r31, r11
    a972:	e1 5a       	subi	r30, 0xA1	; 161
    a974:	fd 4f       	sbci	r31, 0xFD	; 253
    a976:	80 81       	ld	r24, Z
    a978:	91 81       	ldd	r25, Z+1	; 0x01
    a97a:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    a97e:	6c 01       	movw	r12, r24
			MM = atoi( http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("MM") ) ] );
    a980:	c5 01       	movw	r24, r10
    a982:	69 e0       	ldi	r22, 0x09	; 9
    a984:	7e e1       	ldi	r23, 0x1E	; 30
    a986:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a98a:	e8 2f       	mov	r30, r24
    a98c:	f0 e0       	ldi	r31, 0x00	; 0
    a98e:	ee 0f       	add	r30, r30
    a990:	ff 1f       	adc	r31, r31
    a992:	ea 0d       	add	r30, r10
    a994:	fb 1d       	adc	r31, r11
    a996:	e1 5a       	subi	r30, 0xA1	; 161
    a998:	fd 4f       	sbci	r31, 0xFD	; 253
    a99a:	80 81       	ld	r24, Z
    a99c:	91 81       	ldd	r25, Z+1	; 0x01
    a99e:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    a9a2:	7c 01       	movw	r14, r24
			sprintf_P( string, PSTR("%d %d \"%s\""), HH, MM, http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("CMD") ) ] );
    a9a4:	c5 01       	movw	r24, r10
    a9a6:	6a ef       	ldi	r22, 0xFA	; 250
    a9a8:	7d e1       	ldi	r23, 0x1D	; 29
    a9aa:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    a9ae:	2d b7       	in	r18, 0x3d	; 61
    a9b0:	3e b7       	in	r19, 0x3e	; 62
    a9b2:	2a 50       	subi	r18, 0x0A	; 10
    a9b4:	30 40       	sbci	r19, 0x00	; 0
    a9b6:	0f b6       	in	r0, 0x3f	; 63
    a9b8:	f8 94       	cli
    a9ba:	3e bf       	out	0x3e, r19	; 62
    a9bc:	0f be       	out	0x3f, r0	; 63
    a9be:	2d bf       	out	0x3d, r18	; 61
    a9c0:	ed b7       	in	r30, 0x3d	; 61
    a9c2:	fe b7       	in	r31, 0x3e	; 62
    a9c4:	31 96       	adiw	r30, 0x01	; 1
    a9c6:	8e 01       	movw	r16, r28
    a9c8:	0f 5f       	subi	r16, 0xFF	; 255
    a9ca:	1f 4f       	sbci	r17, 0xFF	; 255
    a9cc:	ad b7       	in	r26, 0x3d	; 61
    a9ce:	be b7       	in	r27, 0x3e	; 62
    a9d0:	12 96       	adiw	r26, 0x02	; 2
    a9d2:	1c 93       	st	X, r17
    a9d4:	0e 93       	st	-X, r16
    a9d6:	11 97       	sbiw	r26, 0x01	; 1
    a9d8:	2e ef       	ldi	r18, 0xFE	; 254
    a9da:	3d e1       	ldi	r19, 0x1D	; 29
    a9dc:	33 83       	std	Z+3, r19	; 0x03
    a9de:	22 83       	std	Z+2, r18	; 0x02
    a9e0:	d5 82       	std	Z+5, r13	; 0x05
    a9e2:	c4 82       	std	Z+4, r12	; 0x04
    a9e4:	f7 82       	std	Z+7, r15	; 0x07
    a9e6:	e6 82       	std	Z+6, r14	; 0x06
    a9e8:	90 e0       	ldi	r25, 0x00	; 0
    a9ea:	88 0f       	add	r24, r24
    a9ec:	99 1f       	adc	r25, r25
    a9ee:	a8 0e       	add	r10, r24
    a9f0:	b9 1e       	adc	r11, r25
    a9f2:	2f e5       	ldi	r18, 0x5F	; 95
    a9f4:	32 e0       	ldi	r19, 0x02	; 2
    a9f6:	a2 0e       	add	r10, r18
    a9f8:	b3 1e       	adc	r11, r19
    a9fa:	d5 01       	movw	r26, r10
    a9fc:	8d 91       	ld	r24, X+
    a9fe:	9c 91       	ld	r25, X
    aa00:	91 87       	std	Z+9, r25	; 0x09
    aa02:	80 87       	std	Z+8, r24	; 0x08
    aa04:	0e 94 c8 14 	call	0x2990	; 0x2990 <sprintf_P>
			CRON_addentry( string );
    aa08:	ed b7       	in	r30, 0x3d	; 61
    aa0a:	fe b7       	in	r31, 0x3e	; 62
    aa0c:	3a 96       	adiw	r30, 0x0a	; 10
    aa0e:	0f b6       	in	r0, 0x3f	; 63
    aa10:	f8 94       	cli
    aa12:	fe bf       	out	0x3e, r31	; 62
    aa14:	0f be       	out	0x3f, r0	; 63
    aa16:	ed bf       	out	0x3d, r30	; 61
    aa18:	c8 01       	movw	r24, r16
    aa1a:	0e 94 b4 4a 	call	0x9568	; 0x9568 <CRON_addentry>
			CRON_reloadcrontable();
    aa1e:	0e 94 71 4b 	call	0x96e2	; 0x96e2 <CRON_reloadcrontable>
			printf_P( PSTR("Einstellungen uebernommen!\r\n"));
    aa22:	00 d0       	rcall	.+0      	; 0xaa24 <cgi_cron+0x1aa>
    aa24:	8d ed       	ldi	r24, 0xDD	; 221
    aa26:	9d e1       	ldi	r25, 0x1D	; 29
    aa28:	ad b7       	in	r26, 0x3d	; 61
    aa2a:	be b7       	in	r27, 0x3e	; 62
    aa2c:	12 96       	adiw	r26, 0x02	; 2
    aa2e:	9c 93       	st	X, r25
    aa30:	8e 93       	st	-X, r24
    aa32:	11 97       	sbiw	r26, 0x01	; 1
    aa34:	86 cf       	rjmp	.-244    	; 0xa942 <cgi_cron+0xc8>

		}
		else if ( PharseCheckName_P( http_request, PSTR("del") ) )
    aa36:	c5 01       	movw	r24, r10
    aa38:	69 ed       	ldi	r22, 0xD9	; 217
    aa3a:	7d e1       	ldi	r23, 0x1D	; 29
    aa3c:	0e 94 b6 43 	call	0x876c	; 0x876c <PharseCheckName_P>
    aa40:	88 23       	and	r24, r24
    aa42:	b9 f0       	breq	.+46     	; 0xaa72 <cgi_cron+0x1f8>
		{
			CRON_delentry( atoi( http_request->argvalue[ PharseGetValue_P ( http_request, PSTR("del") ) ] ) );
    aa44:	c5 01       	movw	r24, r10
    aa46:	65 ed       	ldi	r22, 0xD5	; 213
    aa48:	7d e1       	ldi	r23, 0x1D	; 29
    aa4a:	0e 94 d7 43 	call	0x87ae	; 0x87ae <PharseGetValue_P>
    aa4e:	90 e0       	ldi	r25, 0x00	; 0
    aa50:	88 0f       	add	r24, r24
    aa52:	99 1f       	adc	r25, r25
    aa54:	a8 0e       	add	r10, r24
    aa56:	b9 1e       	adc	r11, r25
    aa58:	ef e5       	ldi	r30, 0x5F	; 95
    aa5a:	f2 e0       	ldi	r31, 0x02	; 2
    aa5c:	ae 0e       	add	r10, r30
    aa5e:	bf 1e       	adc	r11, r31
    aa60:	d5 01       	movw	r26, r10
    aa62:	8d 91       	ld	r24, X+
    aa64:	9c 91       	ld	r25, X
    aa66:	0e 94 a9 13 	call	0x2752	; 0x2752 <atoi>
    aa6a:	0e 94 4c 4a 	call	0x9498	; 0x9498 <CRON_delentry>
			CRON_reloadcrontable();
    aa6e:	0e 94 71 4b 	call	0x96e2	; 0x96e2 <CRON_reloadcrontable>
		}
	}

	cgi_PrintHttpheaderEnd();
    aa72:	0e 94 ce 45 	call	0x8b9c	; 0x8b9c <cgi_PrintHttpheaderEnd>

/*	printf_P( PSTR( " </BODY>"
					"</HTML>\r\n"
					"\r\n")); */

}
    aa76:	a0 96       	adiw	r28, 0x20	; 32
    aa78:	ea e0       	ldi	r30, 0x0A	; 10
    aa7a:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

0000aa7e <init_cmd_cron>:
#include "cmd_cron.h"

void init_cmd_cron( void )
{
#if defined(HTTPSERVER_CRON)
	cgi_RegisterCGI( cgi_cron, PSTR("cron.cgi"));
    aa7e:	8d e3       	ldi	r24, 0x3D	; 61
    aa80:	94 e5       	ldi	r25, 0x54	; 84
    aa82:	60 e9       	ldi	r22, 0x90	; 144
    aa84:	71 e2       	ldi	r23, 0x21	; 33
    aa86:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <cgi_RegisterCGI>
#endif
}
    aa8a:	08 95       	ret

0000aa8c <cgi_eemem>:
void cgi_eemem( void * pStruct )
{
	struct HTTP_REQUEST * http_request;
	http_request = (struct HTTP_REQUEST *) pStruct;

	cgi_PrintHttpheaderStart();
    aa8c:	0e 94 da 45 	call	0x8bb4	; 0x8bb4 <cgi_PrintHttpheaderStart>

	printf_P( PSTR(	"<pre>"));
    aa90:	00 d0       	rcall	.+0      	; 0xaa92 <cgi_eemem+0x6>
    aa92:	80 ea       	ldi	r24, 0xA0	; 160
    aa94:	91 e2       	ldi	r25, 0x21	; 33
    aa96:	ed b7       	in	r30, 0x3d	; 61
    aa98:	fe b7       	in	r31, 0x3e	; 62
    aa9a:	92 83       	std	Z+2, r25	; 0x02
    aa9c:	81 83       	std	Z+1, r24	; 0x01
    aa9e:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	PrintConfig ();
    aaa2:	0f 90       	pop	r0
    aaa4:	0f 90       	pop	r0
    aaa6:	0e 94 1d 3c 	call	0x783a	; 0x783a <PrintConfig>

	printf_P( PSTR( "</pre>" ));
    aaaa:	00 d0       	rcall	.+0      	; 0xaaac <cgi_eemem+0x20>
    aaac:	89 e9       	ldi	r24, 0x99	; 153
    aaae:	91 e2       	ldi	r25, 0x21	; 33
    aab0:	ed b7       	in	r30, 0x3d	; 61
    aab2:	fe b7       	in	r31, 0x3e	; 62
    aab4:	92 83       	std	Z+2, r25	; 0x02
    aab6:	81 83       	std	Z+1, r24	; 0x01
    aab8:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	cgi_PrintHttpheaderEnd();
    aabc:	0f 90       	pop	r0
    aabe:	0f 90       	pop	r0
    aac0:	0e 94 ce 45 	call	0x8b9c	; 0x8b9c <cgi_PrintHttpheaderEnd>

}
    aac4:	08 95       	ret

0000aac6 <cmd_eemem>:
	cgi_RegisterCGI( cgi_eemem, PSTR("eemem.cgi"));
#endif
}

int cmd_eemem( int argc, char ** argv )
{
    aac6:	a0 e2       	ldi	r26, 0x20	; 32
    aac8:	b0 e0       	ldi	r27, 0x00	; 0
    aaca:	e9 e6       	ldi	r30, 0x69	; 105
    aacc:	f5 e5       	ldi	r31, 0x55	; 85
    aace:	0c 94 c5 6a 	jmp	0xd58a	; 0xd58a <__prologue_saves__+0x18>
    aad2:	7b 01       	movw	r14, r22
	int ERROR = -1;
	char string[ 32 ];

	
	if ( argc == 2 )
    aad4:	02 97       	sbiw	r24, 0x02	; 2
    aad6:	09 f0       	breq	.+2      	; 0xaada <cmd_eemem+0x14>
    aad8:	63 c0       	rjmp	.+198    	; 0xaba0 <cmd_eemem+0xda>
	{
		if ( !strcmp_P( argv[1], PSTR("protect") ) )
    aada:	fb 01       	movw	r30, r22
    aadc:	82 81       	ldd	r24, Z+2	; 0x02
    aade:	93 81       	ldd	r25, Z+3	; 0x03
    aae0:	6b e1       	ldi	r22, 0x1B	; 27
    aae2:	72 e2       	ldi	r23, 0x22	; 34
    aae4:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    aae8:	89 2b       	or	r24, r25
    aaea:	19 f0       	breq	.+6      	; 0xaaf2 <cmd_eemem+0x2c>
    aaec:	0f ef       	ldi	r16, 0xFF	; 255
    aaee:	1f ef       	ldi	r17, 0xFF	; 255
    aaf0:	13 c0       	rjmp	.+38     	; 0xab18 <cmd_eemem+0x52>
		{
			strcpy_P( string, PSTR("ON"));
    aaf2:	8e 01       	movw	r16, r28
    aaf4:	0f 5f       	subi	r16, 0xFF	; 255
    aaf6:	1f 4f       	sbci	r17, 0xFF	; 255
    aaf8:	c8 01       	movw	r24, r16
    aafa:	68 e1       	ldi	r22, 0x18	; 24
    aafc:	72 e2       	ldi	r23, 0x22	; 34
    aafe:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
			changeConfig_P( PSTR("WRITE_PROTECT"), string );
    ab02:	8a e0       	ldi	r24, 0x0A	; 10
    ab04:	92 e2       	ldi	r25, 0x22	; 34
    ab06:	b8 01       	movw	r22, r16
    ab08:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
			setprotectConfig( PROTECT );
    ab0c:	81 e0       	ldi	r24, 0x01	; 1
    ab0e:	90 e0       	ldi	r25, 0x00	; 0
    ab10:	0e 94 11 39 	call	0x7222	; 0x7222 <setprotectConfig>
    ab14:	00 e0       	ldi	r16, 0x00	; 0
    ab16:	10 e0       	ldi	r17, 0x00	; 0
			ERROR = 0; 
		}
		if ( !strcmp_P( argv[1], PSTR("unprotect") ) )
    ab18:	f7 01       	movw	r30, r14
    ab1a:	82 81       	ldd	r24, Z+2	; 0x02
    ab1c:	93 81       	ldd	r25, Z+3	; 0x03
    ab1e:	60 e0       	ldi	r22, 0x00	; 0
    ab20:	72 e2       	ldi	r23, 0x22	; 34
    ab22:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    ab26:	89 2b       	or	r24, r25
    ab28:	f1 f4       	brne	.+60     	; 0xab66 <cmd_eemem+0xa0>
		{
			setprotectConfig( UNPROTECT );
    ab2a:	80 e0       	ldi	r24, 0x00	; 0
    ab2c:	90 e0       	ldi	r25, 0x00	; 0
    ab2e:	0e 94 11 39 	call	0x7222	; 0x7222 <setprotectConfig>
			strcpy_P( string, PSTR("OFF"));
    ab32:	8e 01       	movw	r16, r28
    ab34:	0f 5f       	subi	r16, 0xFF	; 255
    ab36:	1f 4f       	sbci	r17, 0xFF	; 255
    ab38:	c8 01       	movw	r24, r16
    ab3a:	6c ef       	ldi	r22, 0xFC	; 252
    ab3c:	71 e2       	ldi	r23, 0x21	; 33
    ab3e:	0e 94 00 14 	call	0x2800	; 0x2800 <strcpy_P>
			changeConfig_P( PSTR("WRITE_PROTECT"), string );
    ab42:	8e ee       	ldi	r24, 0xEE	; 238
    ab44:	91 e2       	ldi	r25, 0x21	; 33
    ab46:	b8 01       	movw	r22, r16
    ab48:	0e 94 08 3b 	call	0x7610	; 0x7610 <changeConfig_P>
			printf_P( PSTR("unprotectet\r\n"));
    ab4c:	00 d0       	rcall	.+0      	; 0xab4e <cmd_eemem+0x88>
    ab4e:	80 ee       	ldi	r24, 0xE0	; 224
    ab50:	91 e2       	ldi	r25, 0x21	; 33
    ab52:	ed b7       	in	r30, 0x3d	; 61
    ab54:	fe b7       	in	r31, 0x3e	; 62
    ab56:	92 83       	std	Z+2, r25	; 0x02
    ab58:	81 83       	std	Z+1, r24	; 0x01
    ab5a:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    ab5e:	00 e0       	ldi	r16, 0x00	; 0
    ab60:	10 e0       	ldi	r17, 0x00	; 0
    ab62:	0f 90       	pop	r0
    ab64:	0f 90       	pop	r0
			ERROR = 0; 
		}
		if ( !strcmp_P( argv[1], PSTR("print") ) )
    ab66:	f7 01       	movw	r30, r14
    ab68:	82 81       	ldd	r24, Z+2	; 0x02
    ab6a:	93 81       	ldd	r25, Z+3	; 0x03
    ab6c:	6a ed       	ldi	r22, 0xDA	; 218
    ab6e:	71 e2       	ldi	r23, 0x21	; 33
    ab70:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    ab74:	89 2b       	or	r24, r25
    ab76:	21 f4       	brne	.+8      	; 0xab80 <cmd_eemem+0xba>
		{
			PrintConfig();
    ab78:	0e 94 1d 3c 	call	0x783a	; 0x783a <PrintConfig>
    ab7c:	00 e0       	ldi	r16, 0x00	; 0
    ab7e:	10 e0       	ldi	r17, 0x00	; 0
			ERROR = 0; 
		}
		if ( !strcmp_P( argv[1], PSTR("clean") ) )
    ab80:	f7 01       	movw	r30, r14
    ab82:	82 81       	ldd	r24, Z+2	; 0x02
    ab84:	93 81       	ldd	r25, Z+3	; 0x03
    ab86:	64 ed       	ldi	r22, 0xD4	; 212
    ab88:	71 e2       	ldi	r23, 0x21	; 33
    ab8a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <strcmp_P>
    ab8e:	89 2b       	or	r24, r25
    ab90:	19 f4       	brne	.+6      	; 0xab98 <cmd_eemem+0xd2>
		{
			makeConfig();
    ab92:	0e 94 e5 3b 	call	0x77ca	; 0x77ca <makeConfig>
    ab96:	0f c0       	rjmp	.+30     	; 0xabb6 <cmd_eemem+0xf0>
			ERROR = 0; 
		}
	}

	if ( ERROR == -1 )
    ab98:	ff ef       	ldi	r31, 0xFF	; 255
    ab9a:	0f 3f       	cpi	r16, 0xFF	; 255
    ab9c:	1f 07       	cpc	r17, r31
    ab9e:	59 f4       	brne	.+22     	; 0xabb6 <cmd_eemem+0xf0>
		printf_P( PSTR("eemem <protect>|<unprotect> <print> <clean>\r\n"));
    aba0:	00 d0       	rcall	.+0      	; 0xaba2 <cmd_eemem+0xdc>
    aba2:	86 ea       	ldi	r24, 0xA6	; 166
    aba4:	91 e2       	ldi	r25, 0x21	; 33
    aba6:	ed b7       	in	r30, 0x3d	; 61
    aba8:	fe b7       	in	r31, 0x3e	; 62
    abaa:	92 83       	std	Z+2, r25	; 0x02
    abac:	81 83       	std	Z+1, r24	; 0x01
    abae:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>
    abb2:	0f 90       	pop	r0
    abb4:	0f 90       	pop	r0
}
    abb6:	a0 96       	adiw	r28, 0x20	; 32
    abb8:	e6 e0       	ldi	r30, 0x06	; 6
    abba:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

0000abbe <init_cmd_eemem>:
#include "cmd_eemem.h"

void init_cmd_eemem( void )
{
#if defined(TELNETSERVER)
	telnet_RegisterCMD( cmd_eemem, PSTR("eemem"));
    abbe:	83 e6       	ldi	r24, 0x63	; 99
    abc0:	95 e5       	ldi	r25, 0x55	; 85
    abc2:	6d e2       	ldi	r22, 0x2D	; 45
    abc4:	72 e2       	ldi	r23, 0x22	; 34
    abc6:	0e 94 86 47 	call	0x8f0c	; 0x8f0c <telnet_RegisterCMD>
#endif
#if defined(HTTPSERVER_EEMEM)
	cgi_RegisterCGI( cgi_eemem, PSTR("eemem.cgi"));
    abca:	86 e4       	ldi	r24, 0x46	; 70
    abcc:	95 e5       	ldi	r25, 0x55	; 85
    abce:	63 e2       	ldi	r22, 0x23	; 35
    abd0:	72 e2       	ldi	r23, 0x22	; 34
    abd2:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <cgi_RegisterCGI>
#endif
}
    abd6:	08 95       	ret

0000abd8 <mcp2515_read_status>:
	} ;
}

// ----------------------------------------------------------------------------
uint8_t mcp2515_read_status(uint8_t IF, uint8_t type)
{
    abd8:	1f 93       	push	r17
    abda:	18 2f       	mov	r17, r24
	uint8_t data;
	
	if (IF==0) {	
    abdc:	88 23       	and	r24, r24
    abde:	11 f4       	brne	.+4      	; 0xabe4 <mcp2515_read_status+0xc>
		RESET(MCP2515_CS_1);
    abe0:	13 98       	cbi	0x02, 3	; 2
    abe2:	01 c0       	rjmp	.+2      	; 0xabe6 <mcp2515_read_status+0xe>
	} else {
		RESET(MCP2515_CS_2);
    abe4:	43 98       	cbi	0x08, 3	; 8
	} ;
	
	spi_putc(IF,type);
    abe6:	81 2f       	mov	r24, r17
    abe8:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	data = spi_putc(IF,0xff);
    abec:	81 2f       	mov	r24, r17
    abee:	6f ef       	ldi	r22, 0xFF	; 255
    abf0:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	
	if (IF==0) {	
    abf4:	11 23       	and	r17, r17
    abf6:	11 f4       	brne	.+4      	; 0xabfc <mcp2515_read_status+0x24>
		SET(MCP2515_CS_1);
    abf8:	13 9a       	sbi	0x02, 3	; 2
    abfa:	01 c0       	rjmp	.+2      	; 0xabfe <mcp2515_read_status+0x26>
	} else {
		SET(MCP2515_CS_2);
    abfc:	43 9a       	sbi	0x08, 3	; 8
	} ;
	
	return data;
}
    abfe:	1f 91       	pop	r17
    ac00:	08 95       	ret

0000ac02 <mcp2515_bit_modify>:
	return data;
}

// -------------------------------------------------------------------------
void mcp2515_bit_modify(uint8_t IF, uint8_t adress, uint8_t mask, uint8_t data)
{
    ac02:	ef 92       	push	r14
    ac04:	ff 92       	push	r15
    ac06:	0f 93       	push	r16
    ac08:	1f 93       	push	r17
    ac0a:	18 2f       	mov	r17, r24
    ac0c:	06 2f       	mov	r16, r22
    ac0e:	f4 2e       	mov	r15, r20
    ac10:	e2 2e       	mov	r14, r18
	if (IF==0) {	
    ac12:	88 23       	and	r24, r24
    ac14:	11 f4       	brne	.+4      	; 0xac1a <mcp2515_bit_modify+0x18>
		RESET(MCP2515_CS_1);
    ac16:	13 98       	cbi	0x02, 3	; 2
    ac18:	01 c0       	rjmp	.+2      	; 0xac1c <mcp2515_bit_modify+0x1a>
	} else {
		RESET(MCP2515_CS_2);
    ac1a:	43 98       	cbi	0x08, 3	; 8
	} ;
	
	spi_putc(IF,SPI_BIT_MODIFY);
    ac1c:	81 2f       	mov	r24, r17
    ac1e:	65 e0       	ldi	r22, 0x05	; 5
    ac20:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(IF,adress);
    ac24:	81 2f       	mov	r24, r17
    ac26:	60 2f       	mov	r22, r16
    ac28:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(IF,mask);
    ac2c:	81 2f       	mov	r24, r17
    ac2e:	6f 2d       	mov	r22, r15
    ac30:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(IF,data);
    ac34:	81 2f       	mov	r24, r17
    ac36:	6e 2d       	mov	r22, r14
    ac38:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	
	if (IF==0) {	
    ac3c:	11 23       	and	r17, r17
    ac3e:	11 f4       	brne	.+4      	; 0xac44 <mcp2515_bit_modify+0x42>
		SET(MCP2515_CS_1);
    ac40:	13 9a       	sbi	0x02, 3	; 2
    ac42:	01 c0       	rjmp	.+2      	; 0xac46 <mcp2515_bit_modify+0x44>
	} else {
		SET(MCP2515_CS_2);
    ac44:	43 9a       	sbi	0x08, 3	; 8
	} ;
}
    ac46:	1f 91       	pop	r17
    ac48:	0f 91       	pop	r16
    ac4a:	ff 90       	pop	r15
    ac4c:	ef 90       	pop	r14
    ac4e:	08 95       	ret

0000ac50 <mcp2515_read_register>:
	} ;
}

// -------------------------------------------------------------------------
uint8_t mcp2515_read_register(uint8_t IF, uint8_t adress)
{
    ac50:	0f 93       	push	r16
    ac52:	1f 93       	push	r17
    ac54:	18 2f       	mov	r17, r24
    ac56:	06 2f       	mov	r16, r22
	uint8_t data;
	
	if (IF==0) {	
    ac58:	88 23       	and	r24, r24
    ac5a:	11 f4       	brne	.+4      	; 0xac60 <mcp2515_read_register+0x10>
		RESET(MCP2515_CS_1);
    ac5c:	13 98       	cbi	0x02, 3	; 2
    ac5e:	01 c0       	rjmp	.+2      	; 0xac62 <mcp2515_read_register+0x12>
	} else {
		RESET(MCP2515_CS_2);
    ac60:	43 98       	cbi	0x08, 3	; 8
	} ;
	
	spi_putc(IF,SPI_READ);
    ac62:	81 2f       	mov	r24, r17
    ac64:	63 e0       	ldi	r22, 0x03	; 3
    ac66:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(IF,adress);
    ac6a:	81 2f       	mov	r24, r17
    ac6c:	60 2f       	mov	r22, r16
    ac6e:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	
	data = spi_putc(IF,0xff);	
    ac72:	81 2f       	mov	r24, r17
    ac74:	6f ef       	ldi	r22, 0xFF	; 255
    ac76:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	
	if (IF==0) {	
    ac7a:	11 23       	and	r17, r17
    ac7c:	11 f4       	brne	.+4      	; 0xac82 <mcp2515_read_register+0x32>
		SET(MCP2515_CS_1);
    ac7e:	13 9a       	sbi	0x02, 3	; 2
    ac80:	01 c0       	rjmp	.+2      	; 0xac84 <mcp2515_read_register+0x34>
	} else {
		SET(MCP2515_CS_2);
    ac82:	43 9a       	sbi	0x08, 3	; 8
	} ;
	
	return data;
}
    ac84:	1f 91       	pop	r17
    ac86:	0f 91       	pop	r16
    ac88:	08 95       	ret

0000ac8a <mcp2515_write_register>:
};


// -------------------------------------------------------------------------
void mcp2515_write_register( uint8_t IF, uint8_t adress, uint8_t data )
{
    ac8a:	ff 92       	push	r15
    ac8c:	0f 93       	push	r16
    ac8e:	1f 93       	push	r17
    ac90:	18 2f       	mov	r17, r24
    ac92:	06 2f       	mov	r16, r22
    ac94:	f4 2e       	mov	r15, r20
	if (IF==0) {	
    ac96:	88 23       	and	r24, r24
    ac98:	11 f4       	brne	.+4      	; 0xac9e <mcp2515_write_register+0x14>
		RESET(MCP2515_CS_1);
    ac9a:	13 98       	cbi	0x02, 3	; 2
    ac9c:	01 c0       	rjmp	.+2      	; 0xaca0 <mcp2515_write_register+0x16>
	} else {
		RESET(MCP2515_CS_2);
    ac9e:	43 98       	cbi	0x08, 3	; 8
	} ;
	spi_putc(IF,SPI_WRITE);
    aca0:	81 2f       	mov	r24, r17
    aca2:	62 e0       	ldi	r22, 0x02	; 2
    aca4:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(IF, adress);
    aca8:	81 2f       	mov	r24, r17
    acaa:	60 2f       	mov	r22, r16
    acac:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(IF, data);
    acb0:	81 2f       	mov	r24, r17
    acb2:	6f 2d       	mov	r22, r15
    acb4:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	
	if (IF==0) {	
    acb8:	11 23       	and	r17, r17
    acba:	11 f4       	brne	.+4      	; 0xacc0 <mcp2515_write_register+0x36>
		SET(MCP2515_CS_1);
    acbc:	13 9a       	sbi	0x02, 3	; 2
    acbe:	01 c0       	rjmp	.+2      	; 0xacc2 <mcp2515_write_register+0x38>
	} else {
		SET(MCP2515_CS_2);
    acc0:	43 9a       	sbi	0x08, 3	; 8
	} ;
}
    acc2:	1f 91       	pop	r17
    acc4:	0f 91       	pop	r16
    acc6:	ff 90       	pop	r15
    acc8:	08 95       	ret

0000acca <Can_Int>:
extern int CAN_Socket ;
extern char *CAN_SendBuffer ;

void Can_Int (void) 
{
	if (!IS_SET(MCP2515_INT_1)) {
    acca:	35 99       	sbic	0x06, 5	; 6
    accc:	12 c0       	rjmp	.+36     	; 0xacf2 <Can_Int+0x28>
		// Pin is low on bus 0 //

		
		if (can_check_message(0)) {
    acce:	80 e0       	ldi	r24, 0x00	; 0
    acd0:	0e 94 6d 57 	call	0xaeda	; 0xaeda <can_check_message>
    acd4:	88 23       	and	r24, r24
    acd6:	41 f0       	breq	.+16     	; 0xace8 <Can_Int+0x1e>
			/* Message is here */
			can_get_message(0,&RXMessage0);
    acd8:	80 e0       	ldi	r24, 0x00	; 0
    acda:	69 e9       	ldi	r22, 0x99	; 153
    acdc:	7b e0       	ldi	r23, 0x0B	; 11
    acde:	0e 94 76 57 	call	0xaeec	; 0xaeec <can_get_message>
			CanRX0 = 1 ;
    ace2:	81 e0       	ldi	r24, 0x01	; 1
    ace4:	80 93 f9 04 	sts	0x04F9, r24
		}
		/* INT zurcksetzen - brutale Methode */
		mcp2515_write_register(0,CANINTF,0x00) ;
    ace8:	80 e0       	ldi	r24, 0x00	; 0
    acea:	6c e2       	ldi	r22, 0x2C	; 44
    acec:	40 e0       	ldi	r20, 0x00	; 0
    acee:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>

	} ;

	if (!IS_SET(MCP2515_INT_2)) {
    acf2:	34 99       	sbic	0x06, 4	; 6
    acf4:	12 c0       	rjmp	.+36     	; 0xad1a <Can_Int+0x50>
			// Pin is low on bus 1 //

		
		if (can_check_message(1)) {
    acf6:	81 e0       	ldi	r24, 0x01	; 1
    acf8:	0e 94 6d 57 	call	0xaeda	; 0xaeda <can_check_message>
    acfc:	88 23       	and	r24, r24
    acfe:	41 f0       	breq	.+16     	; 0xad10 <Can_Int+0x46>
			/* Message is here */
			can_get_message(1,&RXMessage1);
    ad00:	81 e0       	ldi	r24, 0x01	; 1
    ad02:	67 ea       	ldi	r22, 0xA7	; 167
    ad04:	7b e0       	ldi	r23, 0x0B	; 11
    ad06:	0e 94 76 57 	call	0xaeec	; 0xaeec <can_get_message>
			CanRX1 = 1 ;
    ad0a:	81 e0       	ldi	r24, 0x01	; 1
    ad0c:	80 93 fa 04 	sts	0x04FA, r24
		}
		/* INT zurcksetzen - brutale Methode */
		mcp2515_write_register(1,CANINTF,0x00) ;
    ad10:	81 e0       	ldi	r24, 0x01	; 1
    ad12:	6c e2       	ldi	r22, 0x2C	; 44
    ad14:	40 e0       	ldi	r20, 0x00	; 0
    ad16:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
    ad1a:	08 95       	ret

0000ad1c <can_init>:
} 


// -------------------------------------------------------------------------
bool mcp2515_init(uint8_t bitrate)
{
    ad1c:	ff 92       	push	r15
    ad1e:	0f 93       	push	r16
    ad20:	1f 93       	push	r17
    ad22:	cf 93       	push	r28
    ad24:	df 93       	push	r29
    ad26:	f8 2e       	mov	r15, r24
	if (bitrate >= 8)
    ad28:	87 e0       	ldi	r24, 0x07	; 7
    ad2a:	8f 15       	cp	r24, r15
    ad2c:	08 f4       	brcc	.+2      	; 0xad30 <can_init+0x14>
    ad2e:	cf c0       	rjmp	.+414    	; 0xaece <can_init+0x1b2>
		return false;

	SET(MCP2515_CS_1);
    ad30:	13 9a       	sbi	0x02, 3	; 2
	SET_OUTPUT(MCP2515_CS_1);
    ad32:	0b 9a       	sbi	0x01, 3	; 1
	SET(MCP2515_CS_2);
    ad34:	43 9a       	sbi	0x08, 3	; 8
	SET_OUTPUT(MCP2515_CS_2);
    ad36:	3b 9a       	sbi	0x07, 3	; 7
	
	// Aktivieren der Pins fuer das SPI Interface
	RESET(P_SCK_1);
    ad38:	10 98       	cbi	0x02, 0	; 2
	RESET(P_MOSI_1);
    ad3a:	11 98       	cbi	0x02, 1	; 2
	RESET(P_MISO_1);
    ad3c:	12 98       	cbi	0x02, 2	; 2
	RESET(P_SCK_2);
    ad3e:	40 98       	cbi	0x08, 0	; 8
	RESET(P_MOSI_2);
    ad40:	41 98       	cbi	0x08, 1	; 8
	RESET(P_MISO_2);
    ad42:	42 98       	cbi	0x08, 2	; 8
	
	SET_OUTPUT(P_SCK_1);
    ad44:	08 9a       	sbi	0x01, 0	; 1
	SET_OUTPUT(P_MOSI_1);
    ad46:	09 9a       	sbi	0x01, 1	; 1
	SET_INPUT(P_MISO_1);
    ad48:	0a 98       	cbi	0x01, 2	; 1
	SET_OUTPUT(P_SCK_2);
    ad4a:	38 9a       	sbi	0x07, 0	; 7
	SET_OUTPUT(P_MOSI_2);
    ad4c:	39 9a       	sbi	0x07, 1	; 7
	SET_INPUT(P_MISO_2);
    ad4e:	3a 98       	cbi	0x07, 2	; 7

	SET(MCP_RESET) ;
    ad50:	47 9a       	sbi	0x08, 7	; 8
	SET_OUTPUT(MCP_RESET) ;
    ad52:	3f 9a       	sbi	0x07, 7	; 7
	RESET(MCP_RESET) ;
    ad54:	47 98       	cbi	0x08, 7	; 8
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    ad56:	80 e9       	ldi	r24, 0x90	; 144
    ad58:	91 e0       	ldi	r25, 0x01	; 1
    ad5a:	01 97       	sbiw	r24, 0x01	; 1
    ad5c:	f1 f7       	brne	.-4      	; 0xad5a <can_init+0x3e>
	_delay_us(100) ;
	SET(MCP_RESET) ;
    ad5e:	47 9a       	sbi	0x08, 7	; 8
	
	// SPI Einstellung setzen
	mcp2515_spi_init();
    ad60:	0e 94 15 59 	call	0xb22a	; 0xb22a <mcp2515_spi_init>
	
	// MCP2515 per Software Reset zuruecksetzten,
	// danach ist er automatisch im Konfigurations Modus
	RESET(MCP2515_CS_1);
    ad64:	13 98       	cbi	0x02, 3	; 2
	spi_putc(0,SPI_RESET);
    ad66:	80 e0       	ldi	r24, 0x00	; 0
    ad68:	60 ec       	ldi	r22, 0xC0	; 192
    ad6a:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    ad6e:	00 ea       	ldi	r16, 0xA0	; 160
    ad70:	1f e0       	ldi	r17, 0x0F	; 15
    ad72:	c8 01       	movw	r24, r16
    ad74:	01 97       	sbiw	r24, 0x01	; 1
    ad76:	f1 f7       	brne	.-4      	; 0xad74 <can_init+0x58>
	
	_delay_ms(1);
	
	SET(MCP2515_CS_1);
    ad78:	13 9a       	sbi	0x02, 3	; 2

	RESET(MCP2515_CS_2);
    ad7a:	43 98       	cbi	0x08, 3	; 8
	spi_putc(1,SPI_RESET);
    ad7c:	81 e0       	ldi	r24, 0x01	; 1
    ad7e:	60 ec       	ldi	r22, 0xC0	; 192
    ad80:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    ad84:	c8 01       	movw	r24, r16
    ad86:	01 97       	sbiw	r24, 0x01	; 1
    ad88:	f1 f7       	brne	.-4      	; 0xad86 <can_init+0x6a>
	
	_delay_ms(1);
	
	SET(MCP2515_CS_2);
    ad8a:	43 9a       	sbi	0x08, 3	; 8
    ad8c:	80 e4       	ldi	r24, 0x40	; 64
    ad8e:	9c e9       	ldi	r25, 0x9C	; 156
    ad90:	01 97       	sbiw	r24, 0x01	; 1
    ad92:	f1 f7       	brne	.-4      	; 0xad90 <can_init+0x74>
	
	// ein bisschen warten bis der MCP2515 sich neu gestartet hat
	_delay_ms(10);
	
	// CNF1..3 Register laden (Bittiming)
	RESET(MCP2515_CS_1);
    ad94:	13 98       	cbi	0x02, 3	; 2
	
	spi_putc(0,SPI_WRITE);
    ad96:	80 e0       	ldi	r24, 0x00	; 0
    ad98:	62 e0       	ldi	r22, 0x02	; 2
    ad9a:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(0,CNF3);
    ad9e:	80 e0       	ldi	r24, 0x00	; 0
    ada0:	68 e2       	ldi	r22, 0x28	; 40
    ada2:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	for (uint8_t i=0; i<3 ;i++ ) {
		spi_putc(0,pgm_read_byte(&_mcp2515_cnf[bitrate][i]));
    ada6:	83 e0       	ldi	r24, 0x03	; 3
    ada8:	f8 9e       	mul	r15, r24
    adaa:	e0 01       	movw	r28, r0
    adac:	11 24       	eor	r1, r1
    adae:	fe 01       	movw	r30, r28
    adb0:	ed 5a       	subi	r30, 0xAD	; 173
    adb2:	fd 4d       	sbci	r31, 0xDD	; 221
    adb4:	f4 90       	lpm	r15, Z+
    adb6:	80 e0       	ldi	r24, 0x00	; 0
    adb8:	6f 2d       	mov	r22, r15
    adba:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    adbe:	fe 01       	movw	r30, r28
    adc0:	ec 5a       	subi	r30, 0xAC	; 172
    adc2:	fd 4d       	sbci	r31, 0xDD	; 221
    adc4:	04 91       	lpm	r16, Z+
    adc6:	80 e0       	ldi	r24, 0x00	; 0
    adc8:	60 2f       	mov	r22, r16
    adca:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    adce:	cb 5a       	subi	r28, 0xAB	; 171
    add0:	dd 4d       	sbci	r29, 0xDD	; 221
    add2:	fe 01       	movw	r30, r28
    add4:	14 91       	lpm	r17, Z+
    add6:	80 e0       	ldi	r24, 0x00	; 0
    add8:	61 2f       	mov	r22, r17
    adda:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	}
	// aktivieren/deaktivieren der Interrupts
	spi_putc(0,MCP2515_INTERRUPTS);
    adde:	80 e0       	ldi	r24, 0x00	; 0
    ade0:	63 e0       	ldi	r22, 0x03	; 3
    ade2:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	SET(MCP2515_CS_1);
    ade6:	13 9a       	sbi	0x02, 3	; 2

	RESET(MCP2515_CS_2);
    ade8:	43 98       	cbi	0x08, 3	; 8

	spi_putc(1,SPI_WRITE);
    adea:	81 e0       	ldi	r24, 0x01	; 1
    adec:	62 e0       	ldi	r22, 0x02	; 2
    adee:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	spi_putc(1,CNF3);
    adf2:	81 e0       	ldi	r24, 0x01	; 1
    adf4:	68 e2       	ldi	r22, 0x28	; 40
    adf6:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	for (uint8_t i=0; i<3 ;i++ ) {
		spi_putc(1,pgm_read_byte(&_mcp2515_cnf[bitrate][i]));
    adfa:	81 e0       	ldi	r24, 0x01	; 1
    adfc:	6f 2d       	mov	r22, r15
    adfe:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    ae02:	81 e0       	ldi	r24, 0x01	; 1
    ae04:	60 2f       	mov	r22, r16
    ae06:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    ae0a:	81 e0       	ldi	r24, 0x01	; 1
    ae0c:	61 2f       	mov	r22, r17
    ae0e:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	}
	// aktivieren/deaktivieren der Interrupts
	spi_putc(1,MCP2515_INTERRUPTS);
    ae12:	81 e0       	ldi	r24, 0x01	; 1
    ae14:	63 e0       	ldi	r22, 0x03	; 3
    ae16:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	SET(MCP2515_CS_2);
    ae1a:	43 9a       	sbi	0x08, 3	; 8

	
	// TXnRTS Bits als Inputs schalten
	mcp2515_write_register(0,TXRTSCTRL, 0);
    ae1c:	80 e0       	ldi	r24, 0x00	; 0
    ae1e:	6d e0       	ldi	r22, 0x0D	; 13
    ae20:	40 e0       	ldi	r20, 0x00	; 0
    ae22:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
	mcp2515_write_register(1,TXRTSCTRL, 0);
    ae26:	81 e0       	ldi	r24, 0x01	; 1
    ae28:	6d e0       	ldi	r22, 0x0D	; 13
    ae2a:	40 e0       	ldi	r20, 0x00	; 0
    ae2c:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
	
	SET_INPUT(MCP2515_INT_1);
    ae30:	3d 98       	cbi	0x07, 5	; 7
	SET(MCP2515_INT_1);
    ae32:	45 9a       	sbi	0x08, 5	; 8
	SET_INPUT(MCP2515_INT_2);
    ae34:	3c 98       	cbi	0x07, 4	; 7
	SET(MCP2515_INT_2);
    ae36:	44 9a       	sbi	0x08, 4	; 8

	// Deaktivieren der Pins RXnBF Pins (High Impedance State)
	mcp2515_write_register(0,BFPCTRL, 0);
    ae38:	80 e0       	ldi	r24, 0x00	; 0
    ae3a:	6c e0       	ldi	r22, 0x0C	; 12
    ae3c:	40 e0       	ldi	r20, 0x00	; 0
    ae3e:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
	mcp2515_write_register(1,BFPCTRL, 0);
    ae42:	81 e0       	ldi	r24, 0x01	; 1
    ae44:	6c e0       	ldi	r22, 0x0C	; 12
    ae46:	40 e0       	ldi	r20, 0x00	; 0
    ae48:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
	
	// Testen ob das auf die beschreibenen Register zugegriffen werden kann
	// (=> ist der Chip ueberhaupt ansprechbar?)
	bool error = false;
	if (mcp2515_read_register(0,CNF2) != pgm_read_byte(&_mcp2515_cnf[bitrate][1])) {
    ae4c:	80 e0       	ldi	r24, 0x00	; 0
    ae4e:	69 e2       	ldi	r22, 0x29	; 41
    ae50:	0e 94 28 56 	call	0xac50	; 0xac50 <mcp2515_read_register>
    ae54:	18 2f       	mov	r17, r24
		error = true;
	}
	if (mcp2515_read_register(1,CNF2) != pgm_read_byte(&_mcp2515_cnf[bitrate][1])) {
    ae56:	81 e0       	ldi	r24, 0x01	; 1
    ae58:	69 e2       	ldi	r22, 0x29	; 41
    ae5a:	0e 94 28 56 	call	0xac50	; 0xac50 <mcp2515_read_register>
    ae5e:	80 17       	cp	r24, r16
    ae60:	11 f4       	brne	.+4      	; 0xae66 <can_init+0x14a>
	mcp2515_write_register(1,BFPCTRL, 0);
	
	// Testen ob das auf die beschreibenen Register zugegriffen werden kann
	// (=> ist der Chip ueberhaupt ansprechbar?)
	bool error = false;
	if (mcp2515_read_register(0,CNF2) != pgm_read_byte(&_mcp2515_cnf[bitrate][1])) {
    ae62:	00 e0       	ldi	r16, 0x00	; 0
    ae64:	18 13       	cpse	r17, r24
    ae66:	01 e0       	ldi	r16, 0x01	; 1
		error = true;
	}

	// Device zurueck in den normalen Modus versetzten
	// und aktivieren/deaktivieren des Clkout-Pins
	mcp2515_write_register(0,CANCTRL, CLKOUT_PRESCALER_);
    ae68:	80 e0       	ldi	r24, 0x00	; 0
    ae6a:	6f e0       	ldi	r22, 0x0F	; 15
    ae6c:	40 e0       	ldi	r20, 0x00	; 0
    ae6e:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
	mcp2515_write_register(1,CANCTRL, CLKOUT_PRESCALER_);
    ae72:	81 e0       	ldi	r24, 0x01	; 1
    ae74:	6f e0       	ldi	r22, 0x0F	; 15
    ae76:	40 e0       	ldi	r20, 0x00	; 0
    ae78:	0e 94 45 56 	call	0xac8a	; 0xac8a <mcp2515_write_register>
	
	if (error) {
    ae7c:	00 23       	and	r16, r16
    ae7e:	39 f5       	brne	.+78     	; 0xaece <can_init+0x1b2>
		return false;
	}
	else
	{
		while ((mcp2515_read_register(0,CANSTAT) & 0xe0) != 0) {
    ae80:	80 e0       	ldi	r24, 0x00	; 0
    ae82:	6e e0       	ldi	r22, 0x0E	; 14
    ae84:	0e 94 28 56 	call	0xac50	; 0xac50 <mcp2515_read_register>
    ae88:	80 7e       	andi	r24, 0xE0	; 224
    ae8a:	d1 f7       	brne	.-12     	; 0xae80 <can_init+0x164>
			// warten bis der neue Modus uebernommen wurde
		}
		
		while ((mcp2515_read_register(1,CANSTAT) & 0xe0) != 0) {
    ae8c:	81 e0       	ldi	r24, 0x01	; 1
    ae8e:	6e e0       	ldi	r22, 0x0E	; 14
    ae90:	0e 94 28 56 	call	0xac50	; 0xac50 <mcp2515_read_register>
    ae94:	80 7e       	andi	r24, 0xE0	; 224
    ae96:	d1 f7       	brne	.-12     	; 0xae8c <can_init+0x170>
    ae98:	88 ee       	ldi	r24, 0xE8	; 232
    ae9a:	93 e0       	ldi	r25, 0x03	; 3
    ae9c:	20 e9       	ldi	r18, 0x90	; 144
    ae9e:	31 e0       	ldi	r19, 0x01	; 1
    aea0:	f9 01       	movw	r30, r18
    aea2:	31 97       	sbiw	r30, 0x01	; 1
    aea4:	f1 f7       	brne	.-4      	; 0xaea2 <can_init+0x186>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    aea6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    aea8:	d9 f7       	brne	.-10     	; 0xaea0 <can_init+0x184>
	
//	can_static_filter(0,can_filter);
//	can_static_filter(1,can_filter);
	_delay_ms(100) ;
	
	PCINT_set( PCIE2, Can_Int );
    aeaa:	82 e0       	ldi	r24, 0x02	; 2
    aeac:	65 e6       	ldi	r22, 0x65	; 101
    aeae:	76 e5       	ldi	r23, 0x56	; 86
    aeb0:	0e 94 46 20 	call	0x408c	; 0x408c <PCINT_set>
	PCINT_enablePIN(PCINT20,PCIE2) ;
    aeb4:	84 e0       	ldi	r24, 0x04	; 4
    aeb6:	62 e0       	ldi	r22, 0x02	; 2
    aeb8:	0e 94 63 20 	call	0x40c6	; 0x40c6 <PCINT_enablePIN>
	PCINT_enablePIN(PCINT21,PCIE2) ;	
    aebc:	85 e0       	ldi	r24, 0x05	; 5
    aebe:	62 e0       	ldi	r22, 0x02	; 2
    aec0:	0e 94 63 20 	call	0x40c6	; 0x40c6 <PCINT_enablePIN>
	PCINT_enablePCINT(PCIE2) ;
    aec4:	82 e0       	ldi	r24, 0x02	; 2
    aec6:	0e 94 54 20 	call	0x40a8	; 0x40a8 <PCINT_enablePCINT>

	Can_Int() ; //Abarbeiten eines eventuell schon vorhandenen Paketes.
    aeca:	0e 94 65 56 	call	0xacca	; 0xacca <Can_Int>

} 
    aece:	80 e0       	ldi	r24, 0x00	; 0
    aed0:	cd b7       	in	r28, 0x3d	; 61
    aed2:	de b7       	in	r29, 0x3e	; 62
    aed4:	e5 e0       	ldi	r30, 0x05	; 5
    aed6:	0c 94 e2 6a 	jmp	0xd5c4	; 0xd5c4 <__epilogue_restores__+0x1a>

0000aeda <can_check_message>:
			return ((!IS_SET(MCP2515_INT_1)) ? true : false);
		} else {
			return ((!IS_SET(MCP2515_INT_2)) ? true : false);
		} ;
	#else
		return ((mcp2515_read_status(IF,SPI_RX_STATUS) & 0xC0) ? true : false);
    aeda:	60 eb       	ldi	r22, 0xB0	; 176
    aedc:	0e 94 ec 55 	call	0xabd8	; 0xabd8 <mcp2515_read_status>
    aee0:	90 e0       	ldi	r25, 0x00	; 0
    aee2:	80 7c       	andi	r24, 0xC0	; 192
    aee4:	09 f0       	breq	.+2      	; 0xaee8 <can_check_message+0xe>
    aee6:	91 e0       	ldi	r25, 0x01	; 1
	#endif
}
    aee8:	89 2f       	mov	r24, r25
    aeea:	08 95       	ret

0000aeec <can_get_message>:
#include "mcp2515_private.h"

// ----------------------------------------------------------------------------

uint8_t mcp2515_get_message(uint8_t IF, can_t *msg)
{
    aeec:	a0 e0       	ldi	r26, 0x00	; 0
    aeee:	b0 e0       	ldi	r27, 0x00	; 0
    aef0:	ec e7       	ldi	r30, 0x7C	; 124
    aef2:	f7 e5       	ldi	r31, 0x57	; 87
    aef4:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    aef8:	f8 2e       	mov	r15, r24
    aefa:	eb 01       	movw	r28, r22
	uint8_t addr;
	
	// read status
	uint8_t status = mcp2515_read_status(IF,SPI_RX_STATUS);
    aefc:	60 eb       	ldi	r22, 0xB0	; 176
    aefe:	0e 94 ec 55 	call	0xabd8	; 0xabd8 <mcp2515_read_status>
    af02:	e8 2e       	mov	r14, r24
		
	if (_bit_is_set(status,6)) {
    af04:	08 2f       	mov	r16, r24
    af06:	10 e0       	ldi	r17, 0x00	; 0
    af08:	20 e4       	ldi	r18, 0x40	; 64
    af0a:	c2 2e       	mov	r12, r18
    af0c:	d1 2c       	mov	r13, r1
    af0e:	c0 22       	and	r12, r16
    af10:	d1 22       	and	r13, r17
    af12:	86 ff       	sbrs	r24, 6
    af14:	02 c0       	rjmp	.+4      	; 0xaf1a <can_get_message+0x2e>
    af16:	60 e9       	ldi	r22, 0x90	; 144
    af18:	05 c0       	rjmp	.+10     	; 0xaf24 <can_get_message+0x38>
		// message in buffer 0
		addr = SPI_READ_RX;
	}
	else if (_bit_is_set(status,7)) {
    af1a:	87 fd       	sbrc	r24, 7
    af1c:	02 c0       	rjmp	.+4      	; 0xaf22 <can_get_message+0x36>
    af1e:	80 e0       	ldi	r24, 0x00	; 0
    af20:	47 c0       	rjmp	.+142    	; 0xafb0 <can_get_message+0xc4>
    af22:	64 e9       	ldi	r22, 0x94	; 148
	else {
		// Error: no message available
		return 0;
	}
	
	if (IF==0) {
    af24:	ff 20       	and	r15, r15
    af26:	11 f4       	brne	.+4      	; 0xaf2c <can_get_message+0x40>
		RESET(MCP2515_CS_1);
    af28:	13 98       	cbi	0x02, 3	; 2
    af2a:	01 c0       	rjmp	.+2      	; 0xaf2e <can_get_message+0x42>
	} else {
		RESET(MCP2515_CS_2);
    af2c:	43 98       	cbi	0x08, 3	; 8
	} ;
	spi_putc(IF,addr);
    af2e:	8f 2d       	mov	r24, r15
    af30:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	
	// CAN ID auslesen und ueberpruefen
	uint8_t tmp = mcp2515_read_id(IF,&msg->id);
    af34:	8f 2d       	mov	r24, r15
    af36:	be 01       	movw	r22, r28
    af38:	0e 94 95 58 	call	0xb12a	; 0xb12a <mcp2515_read_id>
	msg->flags.extended = tmp & 0x01;
    af3c:	81 70       	andi	r24, 0x01	; 1
    af3e:	88 0f       	add	r24, r24
    af40:	9c 81       	ldd	r25, Y+4	; 0x04
    af42:	9d 7f       	andi	r25, 0xFD	; 253
    af44:	98 2b       	or	r25, r24
    af46:	9c 83       	std	Y+4, r25	; 0x04
	
	// read DLC
	uint8_t length = spi_putc(IF,0xff);
    af48:	8f 2d       	mov	r24, r15
    af4a:	6f ef       	ldi	r22, 0xFF	; 255
    af4c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	msg->flags.rtr = (_bit_is_set(status, 3)) ? 1 : 0;
    af50:	93 e0       	ldi	r25, 0x03	; 3
    af52:	16 95       	lsr	r17
    af54:	07 95       	ror	r16
    af56:	9a 95       	dec	r25
    af58:	e1 f7       	brne	.-8      	; 0xaf52 <can_get_message+0x66>
    af5a:	20 2f       	mov	r18, r16
    af5c:	21 70       	andi	r18, 0x01	; 1
    af5e:	9c 81       	ldd	r25, Y+4	; 0x04
    af60:	9e 7f       	andi	r25, 0xFE	; 254
    af62:	92 2b       	or	r25, r18
    af64:	9c 83       	std	Y+4, r25	; 0x04
	
	length &= 0x0f;
    af66:	08 2f       	mov	r16, r24
    af68:	0f 70       	andi	r16, 0x0F	; 15
	msg->length = length;
    af6a:	0d 83       	std	Y+5, r16	; 0x05
    af6c:	10 e0       	ldi	r17, 0x00	; 0
    af6e:	09 c0       	rjmp	.+18     	; 0xaf82 <can_get_message+0x96>
	// read data
	for (uint8_t i=0;i<length;i++) {
		msg->data[i] = spi_putc(IF,0xff);
    af70:	8f 2d       	mov	r24, r15
    af72:	6f ef       	ldi	r22, 0xFF	; 255
    af74:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    af78:	fe 01       	movw	r30, r28
    af7a:	e1 0f       	add	r30, r17
    af7c:	f1 1d       	adc	r31, r1
    af7e:	86 83       	std	Z+6, r24	; 0x06
	msg->flags.rtr = (_bit_is_set(status, 3)) ? 1 : 0;
	
	length &= 0x0f;
	msg->length = length;
	// read data
	for (uint8_t i=0;i<length;i++) {
    af80:	1f 5f       	subi	r17, 0xFF	; 255
    af82:	10 17       	cp	r17, r16
    af84:	a8 f3       	brcs	.-22     	; 0xaf70 <can_get_message+0x84>
		msg->data[i] = spi_putc(IF,0xff);
	}
	if (IF==0) {
    af86:	ff 20       	and	r15, r15
    af88:	11 f4       	brne	.+4      	; 0xaf8e <can_get_message+0xa2>
		SET(MCP2515_CS_1);
    af8a:	13 9a       	sbi	0x02, 3	; 2
    af8c:	01 c0       	rjmp	.+2      	; 0xaf90 <can_get_message+0xa4>
	} else {
		SET(MCP2515_CS_2);
    af8e:	43 9a       	sbi	0x08, 3	; 8
	} ;
	
	// clear interrupt flag
	if (_bit_is_set(status, 6))
    af90:	c1 14       	cp	r12, r1
    af92:	d1 04       	cpc	r13, r1
    af94:	21 f0       	breq	.+8      	; 0xaf9e <can_get_message+0xb2>
		mcp2515_bit_modify(IF,CANINTF, (1<<RX0IF), 0);
    af96:	8f 2d       	mov	r24, r15
    af98:	6c e2       	ldi	r22, 0x2C	; 44
    af9a:	41 e0       	ldi	r20, 0x01	; 1
    af9c:	03 c0       	rjmp	.+6      	; 0xafa4 <can_get_message+0xb8>
	else
		mcp2515_bit_modify(IF,CANINTF, (1<<RX1IF), 0);
    af9e:	8f 2d       	mov	r24, r15
    afa0:	6c e2       	ldi	r22, 0x2C	; 44
    afa2:	42 e0       	ldi	r20, 0x02	; 2
    afa4:	20 e0       	ldi	r18, 0x00	; 0
    afa6:	0e 94 01 56 	call	0xac02	; 0xac02 <mcp2515_bit_modify>
	
	CAN_INDICATE_RX_TRAFFIC_FUNCTION;
	
	return (status & 0x07) + 1;
    afaa:	8e 2d       	mov	r24, r14
    afac:	87 70       	andi	r24, 0x07	; 7
    afae:	8f 5f       	subi	r24, 0xFF	; 255
}
    afb0:	cd b7       	in	r28, 0x3d	; 61
    afb2:	de b7       	in	r29, 0x3e	; 62
    afb4:	e8 e0       	ldi	r30, 0x08	; 8
    afb6:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000afba <can_send_message>:

#include <util/delay.h>

// ----------------------------------------------------------------------------
uint8_t mcp2515_send_message(uint8_t IF,const can_t *msg)
{
    afba:	ef 92       	push	r14
    afbc:	ff 92       	push	r15
    afbe:	0f 93       	push	r16
    afc0:	1f 93       	push	r17
    afc2:	cf 93       	push	r28
    afc4:	df 93       	push	r29
    afc6:	f8 2e       	mov	r15, r24
    afc8:	eb 01       	movw	r28, r22
	// Status des MCP2515 auslesen
	uint8_t status = mcp2515_read_status(IF,SPI_READ_STATUS);
    afca:	60 ea       	ldi	r22, 0xA0	; 160
    afcc:	0e 94 ec 55 	call	0xabd8	; 0xabd8 <mcp2515_read_status>
	 *  2	TXB0CNTRL.TXREQ
	 *  4	TXB1CNTRL.TXREQ
	 *  6	TXB2CNTRL.TXREQ
	 */
	uint8_t address;
	if (_bit_is_clear(status, 2)) {
    afd0:	82 fd       	sbrc	r24, 2
    afd2:	02 c0       	rjmp	.+4      	; 0xafd8 <can_send_message+0x1e>
    afd4:	ee 24       	eor	r14, r14
    afd6:	0b c0       	rjmp	.+22     	; 0xafee <can_send_message+0x34>
		address = 0x00;
	}
	else if (_bit_is_clear(status, 4)) {
    afd8:	84 fd       	sbrc	r24, 4
    afda:	03 c0       	rjmp	.+6      	; 0xafe2 <can_send_message+0x28>
    afdc:	92 e0       	ldi	r25, 0x02	; 2
    afde:	e9 2e       	mov	r14, r25
    afe0:	06 c0       	rjmp	.+12     	; 0xafee <can_send_message+0x34>
		address = 0x02;
	} 
	else if (_bit_is_clear(status, 6)) {
    afe2:	86 ff       	sbrs	r24, 6
    afe4:	02 c0       	rjmp	.+4      	; 0xafea <can_send_message+0x30>
    afe6:	ee 24       	eor	r14, r14
    afe8:	49 c0       	rjmp	.+146    	; 0xb07c <can_send_message+0xc2>
    afea:	84 e0       	ldi	r24, 0x04	; 4
    afec:	e8 2e       	mov	r14, r24
		// Alle Puffer sind belegt,
		// Nachricht kann nicht verschickt werden
		return 0;
	}
	
	if (IF==0) {
    afee:	ff 20       	and	r15, r15
    aff0:	11 f4       	brne	.+4      	; 0xaff6 <can_send_message+0x3c>
		RESET(MCP2515_CS_1);
    aff2:	13 98       	cbi	0x02, 3	; 2
    aff4:	01 c0       	rjmp	.+2      	; 0xaff8 <can_send_message+0x3e>
	} else {
		RESET(MCP2515_CS_2);
    aff6:	43 98       	cbi	0x08, 3	; 8
	} ;
	spi_putc(IF,SPI_WRITE_TX | address);
    aff8:	6e 2d       	mov	r22, r14
    affa:	60 64       	ori	r22, 0x40	; 64
    affc:	8f 2d       	mov	r24, r15
    affe:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	mcp2515_write_id(IF,&msg->id, msg->flags.extended);
    b002:	4c 81       	ldd	r20, Y+4	; 0x04
    b004:	46 95       	lsr	r20
    b006:	41 70       	andi	r20, 0x01	; 1
    b008:	8f 2d       	mov	r24, r15
    b00a:	be 01       	movw	r22, r28
    b00c:	0e 94 44 58 	call	0xb088	; 0xb088 <mcp2515_write_id>
	uint8_t length = msg->length & 0x0f;
    b010:	1d 81       	ldd	r17, Y+5	; 0x05
    b012:	1f 70       	andi	r17, 0x0F	; 15
	
	// Ist die Nachricht ein "Remote Transmit Request" ?
	if (msg->flags.rtr)
    b014:	8c 81       	ldd	r24, Y+4	; 0x04
    b016:	80 ff       	sbrs	r24, 0
    b018:	06 c0       	rjmp	.+12     	; 0xb026 <can_send_message+0x6c>
	{
		// Ein RTR hat zwar eine Laenge,
		// enthaelt aber keine Daten
		
		// Nachrichten Laenge + RTR einstellen
		spi_putc(IF,(1<<RTR) | length);
    b01a:	10 64       	ori	r17, 0x40	; 64
    b01c:	8f 2d       	mov	r24, r15
    b01e:	61 2f       	mov	r22, r17
    b020:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b024:	10 c0       	rjmp	.+32     	; 0xb046 <can_send_message+0x8c>
	}
	else
	{
		// Nachrichten Laenge einstellen
		spi_putc(IF,length);
    b026:	8f 2d       	mov	r24, r15
    b028:	61 2f       	mov	r22, r17
    b02a:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b02e:	00 e0       	ldi	r16, 0x00	; 0
    b030:	08 c0       	rjmp	.+16     	; 0xb042 <can_send_message+0x88>
		
		// Daten
		for (uint8_t i=0;i<length;i++) {
			spi_putc(IF,msg->data[i]);
    b032:	fe 01       	movw	r30, r28
    b034:	e0 0f       	add	r30, r16
    b036:	f1 1d       	adc	r31, r1
    b038:	8f 2d       	mov	r24, r15
    b03a:	66 81       	ldd	r22, Z+6	; 0x06
    b03c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	{
		// Nachrichten Laenge einstellen
		spi_putc(IF,length);
		
		// Daten
		for (uint8_t i=0;i<length;i++) {
    b040:	0f 5f       	subi	r16, 0xFF	; 255
    b042:	01 17       	cp	r16, r17
    b044:	b0 f3       	brcs	.-20     	; 0xb032 <can_send_message+0x78>
			spi_putc(IF,msg->data[i]);
		}
	}
	if (IF==0) {
    b046:	ff 20       	and	r15, r15
    b048:	11 f4       	brne	.+4      	; 0xb04e <can_send_message+0x94>
		SET(MCP2515_CS_1);
    b04a:	13 9a       	sbi	0x02, 3	; 2
    b04c:	01 c0       	rjmp	.+2      	; 0xb050 <can_send_message+0x96>
	} else {
		SET(MCP2515_CS_2);
    b04e:	43 9a       	sbi	0x08, 3	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    b050:	85 e0       	ldi	r24, 0x05	; 5
    b052:	8a 95       	dec	r24
    b054:	f1 f7       	brne	.-4      	; 0xb052 <can_send_message+0x98>
	_delay_us(1);
	
	// CAN Nachricht verschicken
	// die letzten drei Bit im RTS Kommando geben an welcher
	// Puffer gesendet werden soll.
	if (IF==0) {
    b056:	ff 20       	and	r15, r15
    b058:	11 f4       	brne	.+4      	; 0xb05e <can_send_message+0xa4>
		RESET(MCP2515_CS_1);
    b05a:	13 98       	cbi	0x02, 3	; 2
    b05c:	01 c0       	rjmp	.+2      	; 0xb060 <can_send_message+0xa6>
	} else {
		RESET(MCP2515_CS_2);
    b05e:	43 98       	cbi	0x08, 3	; 8
	} ;
	address = (address == 0) ? 1 : address;
    b060:	ee 20       	and	r14, r14
    b062:	11 f4       	brne	.+4      	; 0xb068 <can_send_message+0xae>
    b064:	ee 24       	eor	r14, r14
    b066:	e3 94       	inc	r14
	spi_putc(IF,SPI_RTS | address);
    b068:	6e 2d       	mov	r22, r14
    b06a:	60 68       	ori	r22, 0x80	; 128
    b06c:	8f 2d       	mov	r24, r15
    b06e:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	if (IF==0) {
    b072:	ff 20       	and	r15, r15
    b074:	11 f4       	brne	.+4      	; 0xb07a <can_send_message+0xc0>
		SET(MCP2515_CS_1);
    b076:	13 9a       	sbi	0x02, 3	; 2
    b078:	01 c0       	rjmp	.+2      	; 0xb07c <can_send_message+0xc2>
	} else {
		SET(MCP2515_CS_2);
    b07a:	43 9a       	sbi	0x08, 3	; 8
	} ;
	
	CAN_INDICATE_TX_TRAFFIC_FUNCTION;
	
	return address;
}
    b07c:	8e 2d       	mov	r24, r14
    b07e:	cd b7       	in	r28, 0x3d	; 61
    b080:	de b7       	in	r29, 0x3e	; 62
    b082:	e6 e0       	ldi	r30, 0x06	; 6
    b084:	0c 94 e1 6a 	jmp	0xd5c2	; 0xd5c2 <__epilogue_restores__+0x18>

0000b088 <mcp2515_write_id>:
 *	}
 */


void mcp2515_write_id(uint8_t IF, const uint32_t *id, uint8_t extended)
{
    b088:	ff 92       	push	r15
    b08a:	0f 93       	push	r16
    b08c:	1f 93       	push	r17
    b08e:	cf 93       	push	r28
    b090:	df 93       	push	r29
    b092:	f8 2e       	mov	r15, r24
    b094:	8b 01       	movw	r16, r22
    b096:	c8 2f       	mov	r28, r24
    b098:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t tmp;
	
	if (extended) {
    b09a:	44 23       	and	r20, r20
    b09c:	19 f1       	breq	.+70     	; 0xb0e4 <mcp2515_write_id+0x5c>
// ----------------------------------------------------------------------------

uint8_t usi_interface_spi_temp[2];

extern __attribute__ ((gnu_inline)) inline void spi_start(uint8_t IF, uint8_t data) {
	usi_interface_spi_temp[IF] = spi_putc(IF,data);
    b09e:	fb 01       	movw	r30, r22
    b0a0:	62 81       	ldd	r22, Z+2	; 0x02
    b0a2:	73 81       	ldd	r23, Z+3	; 0x03
    b0a4:	95 e0       	ldi	r25, 0x05	; 5
    b0a6:	76 95       	lsr	r23
    b0a8:	67 95       	ror	r22
    b0aa:	9a 95       	dec	r25
    b0ac:	e1 f7       	brne	.-8      	; 0xb0a6 <mcp2515_write_id+0x1e>
    b0ae:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b0b2:	c9 56       	subi	r28, 0x69	; 105
    b0b4:	d4 4f       	sbci	r29, 0xF4	; 244
    b0b6:	88 83       	st	Y, r24
		spi_start(IF,*((uint16_t *) id + 1) >> 5);
		
		// naechsten Werte berechnen
		tmp  = (*((uint8_t *) id + 2) << 3) & 0xe0;
    b0b8:	f8 01       	movw	r30, r16
    b0ba:	82 81       	ldd	r24, Z+2	; 0x02
    b0bc:	68 2f       	mov	r22, r24
    b0be:	66 0f       	add	r22, r22
    b0c0:	66 0f       	add	r22, r22
    b0c2:	66 0f       	add	r22, r22
    b0c4:	60 7e       	andi	r22, 0xE0	; 224
		tmp |= (1 << IDE);
		tmp |= (*((uint8_t *) id + 2)) & 0x03;
    b0c6:	68 60       	ori	r22, 0x08	; 8
    b0c8:	83 70       	andi	r24, 0x03	; 3
    b0ca:	68 2b       	or	r22, r24
		
		// warten bis der vorherige Werte geschrieben wurde
		spi_wait(IF);
		
		// restliche Werte schreiben
		spi_putc(IF,tmp);
    b0cc:	8f 2d       	mov	r24, r15
    b0ce:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
		spi_putc(IF,*((uint8_t *) id + 1));
    b0d2:	8f 2d       	mov	r24, r15
    b0d4:	f8 01       	movw	r30, r16
    b0d6:	61 81       	ldd	r22, Z+1	; 0x01
    b0d8:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
		spi_putc(IF,*((uint8_t *) id));
    b0dc:	8f 2d       	mov	r24, r15
    b0de:	f8 01       	movw	r30, r16
    b0e0:	60 81       	ld	r22, Z
    b0e2:	1c c0       	rjmp	.+56     	; 0xb11c <mcp2515_write_id+0x94>
    b0e4:	fb 01       	movw	r30, r22
    b0e6:	60 81       	ld	r22, Z
    b0e8:	71 81       	ldd	r23, Z+1	; 0x01
    b0ea:	83 e0       	ldi	r24, 0x03	; 3
    b0ec:	76 95       	lsr	r23
    b0ee:	67 95       	ror	r22
    b0f0:	8a 95       	dec	r24
    b0f2:	e1 f7       	brne	.-8      	; 0xb0ec <mcp2515_write_id+0x64>
    b0f4:	8f 2d       	mov	r24, r15
    b0f6:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b0fa:	c9 56       	subi	r28, 0x69	; 105
    b0fc:	d4 4f       	sbci	r29, 0xF4	; 244
    b0fe:	88 83       	st	Y, r24
		
		// naechsten Werte berechnen
		tmp = *((uint8_t *) id) << 5;
		spi_wait(IF);
		
		spi_putc(IF,tmp);
    b100:	f8 01       	movw	r30, r16
    b102:	60 81       	ld	r22, Z
    b104:	62 95       	swap	r22
    b106:	66 0f       	add	r22, r22
    b108:	60 7e       	andi	r22, 0xE0	; 224
    b10a:	8f 2d       	mov	r24, r15
    b10c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
		spi_putc(IF,0);
    b110:	8f 2d       	mov	r24, r15
    b112:	60 e0       	ldi	r22, 0x00	; 0
    b114:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
		spi_putc(IF,0);
    b118:	8f 2d       	mov	r24, r15
    b11a:	60 e0       	ldi	r22, 0x00	; 0
    b11c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
	}
}
    b120:	cd b7       	in	r28, 0x3d	; 61
    b122:	de b7       	in	r29, 0x3e	; 62
    b124:	e5 e0       	ldi	r30, 0x05	; 5
    b126:	0c 94 e2 6a 	jmp	0xd5c4	; 0xd5c4 <__epilogue_restores__+0x1a>

0000b12a <mcp2515_read_id>:
// ----------------------------------------------------------------------------
// Liest eine ID aus dem Registern des MCP2515 (siehe auch mcp2515_write_id())


uint8_t mcp2515_read_id(uint8_t IF, uint32_t *id)
{
    b12a:	8f 92       	push	r8
    b12c:	9f 92       	push	r9
    b12e:	af 92       	push	r10
    b130:	bf 92       	push	r11
    b132:	df 92       	push	r13
    b134:	ef 92       	push	r14
    b136:	ff 92       	push	r15
    b138:	0f 93       	push	r16
    b13a:	1f 93       	push	r17
    b13c:	df 93       	push	r29
    b13e:	cf 93       	push	r28
    b140:	00 d0       	rcall	.+0      	; 0xb142 <mcp2515_read_id+0x18>
    b142:	cd b7       	in	r28, 0x3d	; 61
    b144:	de b7       	in	r29, 0x3e	; 62
    b146:	d8 2e       	mov	r13, r24
    b148:	7b 01       	movw	r14, r22
	uint8_t first;
	uint8_t tmp;
	
	first = spi_putc(IF,0xff);
    b14a:	6f ef       	ldi	r22, 0xFF	; 255
    b14c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b150:	18 2f       	mov	r17, r24
	tmp   = spi_putc(IF,0xff);
    b152:	8d 2d       	mov	r24, r13
    b154:	6f ef       	ldi	r22, 0xFF	; 255
    b156:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b15a:	08 2f       	mov	r16, r24
    b15c:	ad 2c       	mov	r10, r13
    b15e:	bb 24       	eor	r11, r11
    b160:	81 2e       	mov	r8, r17
    b162:	99 24       	eor	r9, r9
	
	if (tmp & (1 << IDE)) {
    b164:	83 ff       	sbrs	r24, 3
    b166:	31 c0       	rjmp	.+98     	; 0xb1ca <mcp2515_read_id+0xa0>
    b168:	8d 2d       	mov	r24, r13
    b16a:	6f ef       	ldi	r22, 0xFF	; 255
    b16c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b170:	95 01       	movw	r18, r10
    b172:	29 56       	subi	r18, 0x69	; 105
    b174:	34 4f       	sbci	r19, 0xF4	; 244
    b176:	3a 83       	std	Y+2, r19	; 0x02
    b178:	29 83       	std	Y+1, r18	; 0x01
    b17a:	f9 01       	movw	r30, r18
    b17c:	80 83       	st	Z, r24
		spi_start(IF,0xff);
		
		*((uint16_t *) id + 1)  = (uint16_t) first << 5;
    b17e:	95 e0       	ldi	r25, 0x05	; 5
    b180:	88 0c       	add	r8, r8
    b182:	99 1c       	adc	r9, r9
    b184:	9a 95       	dec	r25
    b186:	e1 f7       	brne	.-8      	; 0xb180 <mcp2515_read_id+0x56>
    b188:	f7 01       	movw	r30, r14
    b18a:	93 82       	std	Z+3, r9	; 0x03
    b18c:	82 82       	std	Z+2, r8	; 0x02
		*((uint8_t *)  id + 1)  = spi_wait(IF);
    b18e:	e9 81       	ldd	r30, Y+1	; 0x01
    b190:	fa 81       	ldd	r31, Y+2	; 0x02
    b192:	80 81       	ld	r24, Z
    b194:	f7 01       	movw	r30, r14
    b196:	81 83       	std	Z+1, r24	; 0x01
    b198:	8d 2d       	mov	r24, r13
    b19a:	6f ef       	ldi	r22, 0xFF	; 255
    b19c:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b1a0:	e9 81       	ldd	r30, Y+1	; 0x01
    b1a2:	fa 81       	ldd	r31, Y+2	; 0x02
    b1a4:	80 83       	st	Z, r24
		spi_start(IF,0xff);
		
		*((uint8_t *)  id + 2) |= (tmp >> 3) & 0x1C;
		*((uint8_t *)  id + 2) |=  tmp & 0x03;
    b1a6:	80 2f       	mov	r24, r16
    b1a8:	83 70       	andi	r24, 0x03	; 3
    b1aa:	f7 01       	movw	r30, r14
    b1ac:	92 81       	ldd	r25, Z+2	; 0x02
    b1ae:	89 2b       	or	r24, r25
    b1b0:	06 95       	lsr	r16
    b1b2:	06 95       	lsr	r16
    b1b4:	06 95       	lsr	r16
    b1b6:	0c 71       	andi	r16, 0x1C	; 28
    b1b8:	80 2b       	or	r24, r16
    b1ba:	82 83       	std	Z+2, r24	; 0x02
		
		*((uint8_t *)  id)      = spi_wait(IF);
    b1bc:	e9 81       	ldd	r30, Y+1	; 0x01
    b1be:	fa 81       	ldd	r31, Y+2	; 0x02
    b1c0:	80 81       	ld	r24, Z
    b1c2:	f7 01       	movw	r30, r14
    b1c4:	80 83       	st	Z, r24
    b1c6:	81 e0       	ldi	r24, 0x01	; 1
    b1c8:	22 c0       	rjmp	.+68     	; 0xb20e <mcp2515_read_id+0xe4>
    b1ca:	8d 2d       	mov	r24, r13
    b1cc:	6f ef       	ldi	r22, 0xFF	; 255
    b1ce:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b1d2:	27 e9       	ldi	r18, 0x97	; 151
    b1d4:	3b e0       	ldi	r19, 0x0B	; 11
    b1d6:	a2 0e       	add	r10, r18
    b1d8:	b3 1e       	adc	r11, r19
    b1da:	f5 01       	movw	r30, r10
    b1dc:	80 83       	st	Z, r24
		return TRUE;
	}
	else {
		spi_start(IF,0xff);
		
		*((uint8_t *)  id + 3) = 0;
    b1de:	f7 01       	movw	r30, r14
    b1e0:	13 82       	std	Z+3, r1	; 0x03
		*((uint8_t *)  id + 2) = 0;
    b1e2:	12 82       	std	Z+2, r1	; 0x02
		
		*((uint16_t *) id) = (uint16_t) first << 3;
    b1e4:	83 e0       	ldi	r24, 0x03	; 3
    b1e6:	88 0c       	add	r8, r8
    b1e8:	99 1c       	adc	r9, r9
    b1ea:	8a 95       	dec	r24
    b1ec:	e1 f7       	brne	.-8      	; 0xb1e6 <mcp2515_read_id+0xbc>
    b1ee:	91 82       	std	Z+1, r9	; 0x01
    b1f0:	80 82       	st	Z, r8
    b1f2:	8d 2d       	mov	r24, r13
    b1f4:	6f ef       	ldi	r22, 0xFF	; 255
    b1f6:	0e 94 16 59 	call	0xb22c	; 0xb22c <spi_putc>
    b1fa:	f5 01       	movw	r30, r10
    b1fc:	80 83       	st	Z, r24
		
		spi_wait(IF);
		spi_start(IF,0xff);
		
		*((uint8_t *) id) |= tmp >> 5;
    b1fe:	02 95       	swap	r16
    b200:	06 95       	lsr	r16
    b202:	07 70       	andi	r16, 0x07	; 7
    b204:	f7 01       	movw	r30, r14
    b206:	80 81       	ld	r24, Z
    b208:	80 2b       	or	r24, r16
    b20a:	80 83       	st	Z, r24
    b20c:	80 e0       	ldi	r24, 0x00	; 0
		
		spi_wait(IF);
		
		return FALSE;
	}
}
    b20e:	0f 90       	pop	r0
    b210:	0f 90       	pop	r0
    b212:	cf 91       	pop	r28
    b214:	df 91       	pop	r29
    b216:	1f 91       	pop	r17
    b218:	0f 91       	pop	r16
    b21a:	ff 90       	pop	r15
    b21c:	ef 90       	pop	r14
    b21e:	df 90       	pop	r13
    b220:	bf 90       	pop	r11
    b222:	af 90       	pop	r10
    b224:	9f 90       	pop	r9
    b226:	8f 90       	pop	r8
    b228:	08 95       	ret

0000b22a <mcp2515_spi_init>:
	#define usart_write(format, args...)   usart_write_P(PSTR(format) , ## args)

// ----------------------------------------------------------------------------
void mcp2515_spi_init(void)
{
}
    b22a:	08 95       	ret

0000b22c <spi_putc>:
	uint8_t data_in = 0;
	uint8_t data_b ;
	
	data_b = data ;
	
	if (IF==0) {
    b22c:	88 23       	and	r24, r24
    b22e:	89 f4       	brne	.+34     	; 0xb252 <spi_putc+0x26>
		RESET(P_SCK_1);
    b230:	10 98       	cbi	0x02, 0	; 2
    b232:	90 e0       	ldi	r25, 0x00	; 0
		for (uint8_t i=0;i<8;i++)
		{
			data_in <<= 1;
    b234:	88 0f       	add	r24, r24
		
			if (data & 0x80)
    b236:	67 ff       	sbrs	r22, 7
    b238:	02 c0       	rjmp	.+4      	; 0xb23e <spi_putc+0x12>
				SET(P_MOSI_1);
    b23a:	11 9a       	sbi	0x02, 1	; 2
    b23c:	01 c0       	rjmp	.+2      	; 0xb240 <spi_putc+0x14>
			else
				RESET(P_MOSI_1);
    b23e:	11 98       	cbi	0x02, 1	; 2
				
//			_delay_us(1);
			SET(P_SCK_1);
    b240:	10 9a       	sbi	0x02, 0	; 2
//			_delay_us(1);

			if (IS_SET(P_MISO_1))
    b242:	02 99       	sbic	0x00, 2	; 0
			data_in |= 1;
    b244:	81 60       	ori	r24, 0x01	; 1
				
			data <<= 1;
			
//			_delay_us(1);
			RESET(P_SCK_1);
    b246:	10 98       	cbi	0x02, 0	; 2
	
	data_b = data ;
	
	if (IF==0) {
		RESET(P_SCK_1);
		for (uint8_t i=0;i<8;i++)
    b248:	9f 5f       	subi	r25, 0xFF	; 255
    b24a:	98 30       	cpi	r25, 0x08	; 8
    b24c:	a1 f0       	breq	.+40     	; 0xb276 <spi_putc+0x4a>
//			_delay_us(1);

			if (IS_SET(P_MISO_1))
			data_in |= 1;
				
			data <<= 1;
    b24e:	66 0f       	add	r22, r22
    b250:	f1 cf       	rjmp	.-30     	; 0xb234 <spi_putc+0x8>
			RESET(P_SCK_1);
//			_delay_us(1);
		}
	
	} else {
		RESET(P_SCK_2);
    b252:	40 98       	cbi	0x08, 0	; 8
    b254:	80 e0       	ldi	r24, 0x00	; 0
    b256:	90 e0       	ldi	r25, 0x00	; 0
		for (uint8_t i=0;i<8;i++)
		{
			data_in <<= 1;
    b258:	88 0f       	add	r24, r24
		
			if (data & 0x80)
    b25a:	67 ff       	sbrs	r22, 7
    b25c:	02 c0       	rjmp	.+4      	; 0xb262 <spi_putc+0x36>
				SET(P_MOSI_2);
    b25e:	41 9a       	sbi	0x08, 1	; 8
    b260:	01 c0       	rjmp	.+2      	; 0xb264 <spi_putc+0x38>
			else
				RESET(P_MOSI_2);
    b262:	41 98       	cbi	0x08, 1	; 8
			
//			_delay_us(1);
			SET(P_SCK_2);
    b264:	40 9a       	sbi	0x08, 0	; 8
//			_delay_us(1);
			
			if (IS_SET(P_MISO_2))
    b266:	32 99       	sbic	0x06, 2	; 6
				data_in |= 1;
    b268:	81 60       	ori	r24, 0x01	; 1
		
			data <<= 1;
			
//			_delay_us(1);
			RESET(P_SCK_2);
    b26a:	40 98       	cbi	0x08, 0	; 8
//			_delay_us(1);
		}
	
	} else {
		RESET(P_SCK_2);
		for (uint8_t i=0;i<8;i++)
    b26c:	9f 5f       	subi	r25, 0xFF	; 255
    b26e:	98 30       	cpi	r25, 0x08	; 8
    b270:	11 f0       	breq	.+4      	; 0xb276 <spi_putc+0x4a>
//			_delay_us(1);
			
			if (IS_SET(P_MISO_2))
				data_in |= 1;
		
			data <<= 1;
    b272:	66 0f       	add	r22, r22
    b274:	f1 cf       	rjmp	.-30     	; 0xb258 <spi_putc+0x2c>
	
//	_delay_ms(50) ;

	return data_in;

}
    b276:	08 95       	ret

0000b278 <CANtoUDP>:

void CANtoUDP (can_t *InMessage, char* Buffer)
{
    b278:	cf 93       	push	r28
    b27a:	df 93       	push	r29
    b27c:	fc 01       	movw	r30, r24
    b27e:	db 01       	movw	r26, r22
	char *CANIDP;
	int i ;
	
	CANIDP = (char*)&(InMessage->id) ;
	
	for (i=0;i<4;i++) Buffer[i] = CANIDP[i] ;
    b280:	80 81       	ld	r24, Z
    b282:	8c 93       	st	X, r24
    b284:	81 81       	ldd	r24, Z+1	; 0x01
    b286:	11 96       	adiw	r26, 0x01	; 1
    b288:	8c 93       	st	X, r24
    b28a:	11 97       	sbiw	r26, 0x01	; 1
    b28c:	82 81       	ldd	r24, Z+2	; 0x02
    b28e:	12 96       	adiw	r26, 0x02	; 2
    b290:	8c 93       	st	X, r24
    b292:	12 97       	sbiw	r26, 0x02	; 2
    b294:	83 81       	ldd	r24, Z+3	; 0x03
    b296:	13 96       	adiw	r26, 0x03	; 3
    b298:	8c 93       	st	X, r24
    b29a:	13 97       	sbiw	r26, 0x03	; 3
	Buffer[4] = InMessage->length ;
    b29c:	85 81       	ldd	r24, Z+5	; 0x05
    b29e:	14 96       	adiw	r26, 0x04	; 4
    b2a0:	8c 93       	st	X, r24
    b2a2:	14 97       	sbiw	r26, 0x04	; 4
    b2a4:	af 01       	movw	r20, r30
    b2a6:	20 e0       	ldi	r18, 0x00	; 0
    b2a8:	30 e0       	ldi	r19, 0x00	; 0
    b2aa:	06 c0       	rjmp	.+12     	; 0xb2b8 <CANtoUDP+0x40>
	for (i=0;i<InMessage->length;i++) Buffer[i+5] = InMessage->data[i] ;
    b2ac:	ea 01       	movw	r28, r20
    b2ae:	8d 81       	ldd	r24, Y+5	; 0x05
    b2b0:	eb 01       	movw	r28, r22
    b2b2:	8c 83       	std	Y+4, r24	; 0x04
    b2b4:	2f 5f       	subi	r18, 0xFF	; 255
    b2b6:	3f 4f       	sbci	r19, 0xFF	; 255
    b2b8:	4f 5f       	subi	r20, 0xFF	; 255
    b2ba:	5f 4f       	sbci	r21, 0xFF	; 255
    b2bc:	6f 5f       	subi	r22, 0xFF	; 255
    b2be:	7f 4f       	sbci	r23, 0xFF	; 255
    b2c0:	85 81       	ldd	r24, Z+5	; 0x05
    b2c2:	90 e0       	ldi	r25, 0x00	; 0
    b2c4:	28 17       	cp	r18, r24
    b2c6:	39 07       	cpc	r19, r25
    b2c8:	8c f3       	brlt	.-30     	; 0xb2ac <CANtoUDP+0x34>
    b2ca:	fd 01       	movw	r30, r26
    b2cc:	e2 0f       	add	r30, r18
    b2ce:	f3 1f       	adc	r31, r19
    b2d0:	03 c0       	rjmp	.+6      	; 0xb2d8 <CANtoUDP+0x60>
	for (;i<8;i++) Buffer[i+5]=0 ;
    b2d2:	14 82       	std	Z+4, r1	; 0x04
    b2d4:	2f 5f       	subi	r18, 0xFF	; 255
    b2d6:	3f 4f       	sbci	r19, 0xFF	; 255
    b2d8:	31 96       	adiw	r30, 0x01	; 1
    b2da:	28 30       	cpi	r18, 0x08	; 8
    b2dc:	31 05       	cpc	r19, r1
    b2de:	cc f3       	brlt	.-14     	; 0xb2d2 <CANtoUDP+0x5a>
}
    b2e0:	df 91       	pop	r29
    b2e2:	cf 91       	pop	r28
    b2e4:	08 95       	ret

0000b2e6 <UDPtoCAN>:

void UDPtoCAN (char *Buffer, can_t *OutMessage)
{
    b2e6:	cf 93       	push	r28
    b2e8:	df 93       	push	r29
    b2ea:	fc 01       	movw	r30, r24
    b2ec:	db 01       	movw	r26, r22
	char *CANIDP ;
	int i ;
	
	CANIDP = (char*)&(OutMessage->id) ;
	for (i=0;i<4;i++) CANIDP[i] = Buffer[i] ;
    b2ee:	80 81       	ld	r24, Z
    b2f0:	8c 93       	st	X, r24
    b2f2:	81 81       	ldd	r24, Z+1	; 0x01
    b2f4:	11 96       	adiw	r26, 0x01	; 1
    b2f6:	8c 93       	st	X, r24
    b2f8:	11 97       	sbiw	r26, 0x01	; 1
    b2fa:	82 81       	ldd	r24, Z+2	; 0x02
    b2fc:	12 96       	adiw	r26, 0x02	; 2
    b2fe:	8c 93       	st	X, r24
    b300:	12 97       	sbiw	r26, 0x02	; 2
    b302:	83 81       	ldd	r24, Z+3	; 0x03
    b304:	13 96       	adiw	r26, 0x03	; 3
    b306:	8c 93       	st	X, r24
    b308:	13 97       	sbiw	r26, 0x03	; 3
	OutMessage->length=Buffer[4];
    b30a:	84 81       	ldd	r24, Z+4	; 0x04
    b30c:	15 96       	adiw	r26, 0x05	; 5
    b30e:	8c 93       	st	X, r24
    b310:	15 97       	sbiw	r26, 0x05	; 5
    b312:	ef 01       	movw	r28, r30
    b314:	fb 01       	movw	r30, r22
    b316:	20 e0       	ldi	r18, 0x00	; 0
    b318:	30 e0       	ldi	r19, 0x00	; 0
    b31a:	04 c0       	rjmp	.+8      	; 0xb324 <UDPtoCAN+0x3e>
	for (i=0;i<OutMessage->length;i++) OutMessage->data[i]=Buffer[i+5];
    b31c:	8c 81       	ldd	r24, Y+4	; 0x04
    b31e:	85 83       	std	Z+5, r24	; 0x05
    b320:	2f 5f       	subi	r18, 0xFF	; 255
    b322:	3f 4f       	sbci	r19, 0xFF	; 255
    b324:	21 96       	adiw	r28, 0x01	; 1
    b326:	31 96       	adiw	r30, 0x01	; 1
    b328:	15 96       	adiw	r26, 0x05	; 5
    b32a:	8c 91       	ld	r24, X
    b32c:	15 97       	sbiw	r26, 0x05	; 5
    b32e:	90 e0       	ldi	r25, 0x00	; 0
    b330:	28 17       	cp	r18, r24
    b332:	39 07       	cpc	r19, r25
    b334:	9c f3       	brlt	.-26     	; 0xb31c <UDPtoCAN+0x36>
    b336:	2a 5f       	subi	r18, 0xFA	; 250
    b338:	3f 4f       	sbci	r19, 0xFF	; 255
    b33a:	fd 01       	movw	r30, r26
    b33c:	e2 0f       	add	r30, r18
    b33e:	f3 1f       	adc	r31, r19
    b340:	26 50       	subi	r18, 0x06	; 6
    b342:	30 40       	sbci	r19, 0x00	; 0
    b344:	03 c0       	rjmp	.+6      	; 0xb34c <UDPtoCAN+0x66>
	for (;i<8;i++) OutMessage->data[i]=0 ;
    b346:	11 92       	st	Z+, r1
    b348:	2f 5f       	subi	r18, 0xFF	; 255
    b34a:	3f 4f       	sbci	r19, 0xFF	; 255
    b34c:	28 30       	cpi	r18, 0x08	; 8
    b34e:	31 05       	cpc	r19, r1
    b350:	d4 f3       	brlt	.-12     	; 0xb346 <UDPtoCAN+0x60>
}
    b352:	df 91       	pop	r29
    b354:	cf 91       	pop	r28
    b356:	08 95       	ret

0000b358 <can_relay_thread>:
	static int a=0 ;
	char Data; 
	int i;		
	
	
	if ( UDP_GetSocketState( CAN_Socket ) == UDP_SOCKET_BUSY ) { // UDP recheived
    b358:	80 91 b5 0b 	lds	r24, 0x0BB5
    b35c:	90 91 b6 0b 	lds	r25, 0x0BB6
    b360:	0e 94 90 22 	call	0x4520	; 0x4520 <UDP_GetSocketState>
    b364:	80 97       	sbiw	r24, 0x20	; 32
    b366:	e1 f5       	brne	.+120    	; 0xb3e0 <can_relay_thread+0x88>
		UDPtoCAN(CAN_ReceiveBuffer,&SendMessage) ;
    b368:	89 ed       	ldi	r24, 0xD9	; 217
    b36a:	9b e0       	ldi	r25, 0x0B	; 11
    b36c:	67 eb       	ldi	r22, 0xB7	; 183
    b36e:	7b e0       	ldi	r23, 0x0B	; 11
    b370:	0e 94 73 59 	call	0xb2e6	; 0xb2e6 <UDPtoCAN>
		UDP_FreeBuffer(CAN_Socket) ;
    b374:	80 91 b5 0b 	lds	r24, 0x0BB5
    b378:	90 91 b6 0b 	lds	r25, 0x0BB6
    b37c:	0e 94 bd 22 	call	0x457a	; 0x457a <UDP_FreeBuffer>

uint8_t CANRouting (uint32_t CAN_ID)
{
	uint8_t Linie ;
	
	Linie = (CAN_ID>>10)&0xf ;
    b380:	80 91 b7 0b 	lds	r24, 0x0BB7
    b384:	90 91 b8 0b 	lds	r25, 0x0BB8
    b388:	a0 91 b9 0b 	lds	r26, 0x0BB9
    b38c:	b0 91 ba 0b 	lds	r27, 0x0BBA
    b390:	6a e0       	ldi	r22, 0x0A	; 10
    b392:	b6 95       	lsr	r27
    b394:	a7 95       	ror	r26
    b396:	97 95       	ror	r25
    b398:	87 95       	ror	r24
    b39a:	6a 95       	dec	r22
    b39c:	d1 f7       	brne	.-12     	; 0xb392 <can_relay_thread+0x3a>
    b39e:	8f 70       	andi	r24, 0x0F	; 15
  
	if (Linie==0x1) {
    b3a0:	81 30       	cpi	r24, 0x01	; 1
    b3a2:	29 f0       	breq	.+10     	; 0xb3ae <can_relay_thread+0x56>
		return (0) ;
	} else if (Linie==0x2) {
    b3a4:	82 30       	cpi	r24, 0x02	; 2
    b3a6:	19 f0       	breq	.+6      	; 0xb3ae <can_relay_thread+0x56>
		return (1) ;
	} else if (Linie==0x3) {
    b3a8:	83 30       	cpi	r24, 0x03	; 3
    b3aa:	09 f4       	brne	.+2      	; 0xb3ae <can_relay_thread+0x56>
    b3ac:	8f c0       	rjmp	.+286    	; 0xb4cc <can_relay_thread+0x174>

uint8_t CANRouting (uint32_t CAN_ID)
{
	uint8_t Linie ;
	
	Linie = (CAN_ID>>10)&0xf ;
    b3ae:	80 91 b7 0b 	lds	r24, 0x0BB7
    b3b2:	90 91 b8 0b 	lds	r25, 0x0BB8
    b3b6:	a0 91 b9 0b 	lds	r26, 0x0BB9
    b3ba:	b0 91 ba 0b 	lds	r27, 0x0BBA
    b3be:	5a e0       	ldi	r21, 0x0A	; 10
    b3c0:	b6 95       	lsr	r27
    b3c2:	a7 95       	ror	r26
    b3c4:	97 95       	ror	r25
    b3c6:	87 95       	ror	r24
    b3c8:	5a 95       	dec	r21
    b3ca:	d1 f7       	brne	.-12     	; 0xb3c0 <can_relay_thread+0x68>
    b3cc:	8f 70       	andi	r24, 0x0F	; 15
  
	if (Linie==0x1) {
    b3ce:	81 30       	cpi	r24, 0x01	; 1
    b3d0:	39 f0       	breq	.+14     	; 0xb3e0 <can_relay_thread+0x88>
		return (0) ;
	} else if (Linie==0x2) {
    b3d2:	82 30       	cpi	r24, 0x02	; 2
    b3d4:	29 f0       	breq	.+10     	; 0xb3e0 <can_relay_thread+0x88>
		return (1) ;
	} else if (Linie==0x3) {
    b3d6:	83 30       	cpi	r24, 0x03	; 3
    b3d8:	19 f0       	breq	.+6      	; 0xb3e0 <can_relay_thread+0x88>
		return (2) ;
	} else if (Linie==0x4) {
    b3da:	84 30       	cpi	r24, 0x04	; 4
    b3dc:	09 f4       	brne	.+2      	; 0xb3e0 <can_relay_thread+0x88>
    b3de:	7c c0       	rjmp	.+248    	; 0xb4d8 <can_relay_thread+0x180>
			can_send_message(1,&SendMessage) ;
		} ;
	}


	SendMessage.id = 0 ;
    b3e0:	10 92 b7 0b 	sts	0x0BB7, r1
    b3e4:	10 92 b8 0b 	sts	0x0BB8, r1
    b3e8:	10 92 b9 0b 	sts	0x0BB9, r1
    b3ec:	10 92 ba 0b 	sts	0x0BBA, r1
		
	if (CanRX0!=0) { // CAN 0 Received 
    b3f0:	80 91 f9 04 	lds	r24, 0x04F9
    b3f4:	88 23       	and	r24, r24
    b3f6:	31 f1       	breq	.+76     	; 0xb444 <can_relay_thread+0xec>
			// Copy complete CAN Message
		cli() ; // Sichern des Interrupts nicht notwendig, da wir sonst nicht in den Threads w채hren.
    b3f8:	f8 94       	cli
		SendMessage = RXMessage0 ;
    b3fa:	a7 eb       	ldi	r26, 0xB7	; 183
    b3fc:	bb e0       	ldi	r27, 0x0B	; 11
    b3fe:	e9 e9       	ldi	r30, 0x99	; 153
    b400:	fb e0       	ldi	r31, 0x0B	; 11
    b402:	8e e0       	ldi	r24, 0x0E	; 14
    b404:	01 90       	ld	r0, Z+
    b406:	0d 92       	st	X+, r0
    b408:	81 50       	subi	r24, 0x01	; 1
    b40a:	e1 f7       	brne	.-8      	; 0xb404 <can_relay_thread+0xac>
		sei() ;
    b40c:	78 94       	sei

uint8_t CANRouting (uint32_t CAN_ID)
{
	uint8_t Linie ;
	
	Linie = (CAN_ID>>10)&0xf ;
    b40e:	80 91 b7 0b 	lds	r24, 0x0BB7
    b412:	90 91 b8 0b 	lds	r25, 0x0BB8
    b416:	a0 91 b9 0b 	lds	r26, 0x0BB9
    b41a:	b0 91 ba 0b 	lds	r27, 0x0BBA
    b41e:	4a e0       	ldi	r20, 0x0A	; 10
    b420:	b6 95       	lsr	r27
    b422:	a7 95       	ror	r26
    b424:	97 95       	ror	r25
    b426:	87 95       	ror	r24
    b428:	4a 95       	dec	r20
    b42a:	d1 f7       	brne	.-12     	; 0xb420 <can_relay_thread+0xc8>
    b42c:	8f 70       	andi	r24, 0x0F	; 15
  
	if (Linie==0x1) {
    b42e:	81 30       	cpi	r24, 0x01	; 1
    b430:	39 f0       	breq	.+14     	; 0xb440 <can_relay_thread+0xe8>
		return (0) ;
	} else if (Linie==0x2) {
    b432:	82 30       	cpi	r24, 0x02	; 2
    b434:	29 f0       	breq	.+10     	; 0xb440 <can_relay_thread+0xe8>
		return (1) ;
	} else if (Linie==0x3) {
    b436:	83 30       	cpi	r24, 0x03	; 3
    b438:	19 f0       	breq	.+6      	; 0xb440 <can_relay_thread+0xe8>
		return (2) ;
	} else if (Linie==0x4) {
    b43a:	84 30       	cpi	r24, 0x04	; 4
    b43c:	09 f4       	brne	.+2      	; 0xb440 <can_relay_thread+0xe8>
    b43e:	52 c0       	rjmp	.+164    	; 0xb4e4 <can_relay_thread+0x18c>
		SendMessage = RXMessage0 ;
		sei() ;
		if (CANRouting (SendMessage.id)==3) { // Send it also to the other CAN
			can_send_message(1,&SendMessage) ; // und an das andere Interface
		} ;
		CanRX0 = 0 ;
    b440:	10 92 f9 04 	sts	0x04F9, r1
	} ;
	if (CanRX1!=0) { // CAN 1 Received 
    b444:	80 91 fa 04 	lds	r24, 0x04FA
    b448:	88 23       	and	r24, r24
    b44a:	19 f1       	breq	.+70     	; 0xb492 <can_relay_thread+0x13a>
		cli() ; // Sichern des Interrupts nicht notwendig, da wir sonst nicht in den Threads w채hren.
    b44c:	f8 94       	cli
		SendMessage = RXMessage1 ;
    b44e:	a7 eb       	ldi	r26, 0xB7	; 183
    b450:	bb e0       	ldi	r27, 0x0B	; 11
    b452:	e7 ea       	ldi	r30, 0xA7	; 167
    b454:	fb e0       	ldi	r31, 0x0B	; 11
    b456:	8e e0       	ldi	r24, 0x0E	; 14
    b458:	01 90       	ld	r0, Z+
    b45a:	0d 92       	st	X+, r0
    b45c:	81 50       	subi	r24, 0x01	; 1
    b45e:	e1 f7       	brne	.-8      	; 0xb458 <can_relay_thread+0x100>
		sei() ;
    b460:	78 94       	sei

uint8_t CANRouting (uint32_t CAN_ID)
{
	uint8_t Linie ;
	
	Linie = (CAN_ID>>10)&0xf ;
    b462:	80 91 b7 0b 	lds	r24, 0x0BB7
    b466:	90 91 b8 0b 	lds	r25, 0x0BB8
    b46a:	a0 91 b9 0b 	lds	r26, 0x0BB9
    b46e:	b0 91 ba 0b 	lds	r27, 0x0BBA
    b472:	3a e0       	ldi	r19, 0x0A	; 10
    b474:	b6 95       	lsr	r27
    b476:	a7 95       	ror	r26
    b478:	97 95       	ror	r25
    b47a:	87 95       	ror	r24
    b47c:	3a 95       	dec	r19
    b47e:	d1 f7       	brne	.-12     	; 0xb474 <can_relay_thread+0x11c>
    b480:	8f 70       	andi	r24, 0x0F	; 15
  
	if (Linie==0x1) {
    b482:	81 30       	cpi	r24, 0x01	; 1
    b484:	21 f0       	breq	.+8      	; 0xb48e <can_relay_thread+0x136>
		return (0) ;
	} else if (Linie==0x2) {
    b486:	82 30       	cpi	r24, 0x02	; 2
    b488:	11 f0       	breq	.+4      	; 0xb48e <can_relay_thread+0x136>
		return (1) ;
	} else if (Linie==0x3) {
    b48a:	83 30       	cpi	r24, 0x03	; 3
    b48c:	89 f1       	breq	.+98     	; 0xb4f0 <can_relay_thread+0x198>
		SendMessage = RXMessage1 ;
		sei() ;
		if (CANRouting (SendMessage.id)==2) { // Send it also to the other CAN
			can_send_message(0,&SendMessage) ; // und an das andrere Interface
		} ;							
		CanRX1 = 0 ;
    b48e:	10 92 fa 04 	sts	0x04FA, r1
	} ;
		
	if (SendMessage.id !=0) { // Es wurde etwas empfangen, also auf UDP herausgeben.
    b492:	80 91 b7 0b 	lds	r24, 0x0BB7
    b496:	90 91 b8 0b 	lds	r25, 0x0BB8
    b49a:	a0 91 b9 0b 	lds	r26, 0x0BB9
    b49e:	b0 91 ba 0b 	lds	r27, 0x0BBA
    b4a2:	00 97       	sbiw	r24, 0x00	; 0
    b4a4:	a1 05       	cpc	r26, r1
    b4a6:	b1 05       	cpc	r27, r1
    b4a8:	49 f1       	breq	.+82     	; 0xb4fc <can_relay_thread+0x1a4>
		CANtoUDP(&SendMessage,CAN_SendBuffer);
    b4aa:	87 eb       	ldi	r24, 0xB7	; 183
    b4ac:	9b e0       	ldi	r25, 0x0B	; 11
    b4ae:	65 ec       	ldi	r22, 0xC5	; 197
    b4b0:	7b e0       	ldi	r23, 0x0B	; 11
    b4b2:	0e 94 3c 59 	call	0xb278	; 0xb278 <CANtoUDP>
		UDP_SendPacket (CAN_Socket,13,CAN_SendBuffer) ;		
    b4b6:	80 91 b5 0b 	lds	r24, 0x0BB5
    b4ba:	90 91 b6 0b 	lds	r25, 0x0BB6
    b4be:	6d e0       	ldi	r22, 0x0D	; 13
    b4c0:	70 e0       	ldi	r23, 0x00	; 0
    b4c2:	45 ec       	ldi	r20, 0xC5	; 197
    b4c4:	5b e0       	ldi	r21, 0x0B	; 11
    b4c6:	0e 94 4e 24 	call	0x489c	; 0x489c <UDP_SendPacket>
    b4ca:	08 95       	ret
	
	if ( UDP_GetSocketState( CAN_Socket ) == UDP_SOCKET_BUSY ) { // UDP recheived
		UDPtoCAN(CAN_ReceiveBuffer,&SendMessage) ;
		UDP_FreeBuffer(CAN_Socket) ;
		if (CANRouting(SendMessage.id)==2) {
			can_send_message(0,&SendMessage) ;
    b4cc:	80 e0       	ldi	r24, 0x00	; 0
    b4ce:	67 eb       	ldi	r22, 0xB7	; 183
    b4d0:	7b e0       	ldi	r23, 0x0B	; 11
    b4d2:	0e 94 dd 57 	call	0xafba	; 0xafba <can_send_message>
    b4d6:	6b cf       	rjmp	.-298    	; 0xb3ae <can_relay_thread+0x56>
		} ;
		if (CANRouting(SendMessage.id)==3) {
			can_send_message(1,&SendMessage) ;
    b4d8:	81 e0       	ldi	r24, 0x01	; 1
    b4da:	67 eb       	ldi	r22, 0xB7	; 183
    b4dc:	7b e0       	ldi	r23, 0x0B	; 11
    b4de:	0e 94 dd 57 	call	0xafba	; 0xafba <can_send_message>
    b4e2:	7e cf       	rjmp	.-260    	; 0xb3e0 <can_relay_thread+0x88>
			// Copy complete CAN Message
		cli() ; // Sichern des Interrupts nicht notwendig, da wir sonst nicht in den Threads w채hren.
		SendMessage = RXMessage0 ;
		sei() ;
		if (CANRouting (SendMessage.id)==3) { // Send it also to the other CAN
			can_send_message(1,&SendMessage) ; // und an das andere Interface
    b4e4:	81 e0       	ldi	r24, 0x01	; 1
    b4e6:	67 eb       	ldi	r22, 0xB7	; 183
    b4e8:	7b e0       	ldi	r23, 0x0B	; 11
    b4ea:	0e 94 dd 57 	call	0xafba	; 0xafba <can_send_message>
    b4ee:	a8 cf       	rjmp	.-176    	; 0xb440 <can_relay_thread+0xe8>
	if (CanRX1!=0) { // CAN 1 Received 
		cli() ; // Sichern des Interrupts nicht notwendig, da wir sonst nicht in den Threads w채hren.
		SendMessage = RXMessage1 ;
		sei() ;
		if (CANRouting (SendMessage.id)==2) { // Send it also to the other CAN
			can_send_message(0,&SendMessage) ; // und an das andrere Interface
    b4f0:	80 e0       	ldi	r24, 0x00	; 0
    b4f2:	67 eb       	ldi	r22, 0xB7	; 183
    b4f4:	7b e0       	ldi	r23, 0x0B	; 11
    b4f6:	0e 94 dd 57 	call	0xafba	; 0xafba <can_send_message>
    b4fa:	c9 cf       	rjmp	.-110    	; 0xb48e <can_relay_thread+0x136>
    b4fc:	08 95       	ret

0000b4fe <can_relay_init>:
/*------------------------------------------------------------------------------------------------------------*/

extern unsigned long myBroadcast ;

void can_relay_init()
{
    b4fe:	0f 93       	push	r16
    b500:	1f 93       	push	r17
	int i;

	CAN_Socket = UDP_RegisterSocket(myBroadcast,CAN_RELAY_PORT,CAN_RELAY_BUFFER_LEN,CAN_ReceiveBuffer );
    b502:	60 91 45 01 	lds	r22, 0x0145
    b506:	70 91 46 01 	lds	r23, 0x0146
    b50a:	80 91 47 01 	lds	r24, 0x0147
    b50e:	90 91 48 01 	lds	r25, 0x0148
    b512:	4f eb       	ldi	r20, 0xBF	; 191
    b514:	53 e3       	ldi	r21, 0x33	; 51
    b516:	24 e1       	ldi	r18, 0x14	; 20
    b518:	30 e0       	ldi	r19, 0x00	; 0
    b51a:	09 ed       	ldi	r16, 0xD9	; 217
    b51c:	1b e0       	ldi	r17, 0x0B	; 11
    b51e:	0e 94 bc 24 	call	0x4978	; 0x4978 <UDP_RegisterSocket>
    b522:	90 93 b6 0b 	sts	0x0BB6, r25
    b526:	80 93 b5 0b 	sts	0x0BB5, r24
	printf_P( PSTR("CAN-Relay-Server gestartet auf Port %d.\r\n") , CAN_RELAY_PORT );
    b52a:	00 d0       	rcall	.+0      	; 0xb52c <can_relay_init+0x2e>
    b52c:	00 d0       	rcall	.+0      	; 0xb52e <can_relay_init+0x30>
    b52e:	85 e7       	ldi	r24, 0x75	; 117
    b530:	92 e2       	ldi	r25, 0x22	; 34
    b532:	ed b7       	in	r30, 0x3d	; 61
    b534:	fe b7       	in	r31, 0x3e	; 62
    b536:	92 83       	std	Z+2, r25	; 0x02
    b538:	81 83       	std	Z+1, r24	; 0x01
    b53a:	8f eb       	ldi	r24, 0xBF	; 191
    b53c:	93 e3       	ldi	r25, 0x33	; 51
    b53e:	94 83       	std	Z+4, r25	; 0x04
    b540:	83 83       	std	Z+3, r24	; 0x03
    b542:	0e 94 a2 14 	call	0x2944	; 0x2944 <printf_P>

	if (CAN_Socket!=UDP_SOCKET_ERROR) {	
    b546:	0f 90       	pop	r0
    b548:	0f 90       	pop	r0
    b54a:	0f 90       	pop	r0
    b54c:	0f 90       	pop	r0
    b54e:	80 91 b5 0b 	lds	r24, 0x0BB5
    b552:	90 91 b6 0b 	lds	r25, 0x0BB6
    b556:	8f 5f       	subi	r24, 0xFF	; 255
    b558:	9f 4f       	sbci	r25, 0xFF	; 255
    b55a:	31 f0       	breq	.+12     	; 0xb568 <can_relay_init+0x6a>
		THREAD_RegisterThread( can_relay_thread, PSTR("can_relay"));
    b55c:	8c ea       	ldi	r24, 0xAC	; 172
    b55e:	99 e5       	ldi	r25, 0x59	; 89
    b560:	6b e6       	ldi	r22, 0x6B	; 107
    b562:	72 e2       	ldi	r23, 0x22	; 34
    b564:	0e 94 cc 3f 	call	0x7f98	; 0x7f98 <THREAD_RegisterThread>
	} ;
}
    b568:	1f 91       	pop	r17
    b56a:	0f 91       	pop	r16
    b56c:	08 95       	ret

0000b56e <sd_raw_send_command>:
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
uint8_t sd_raw_send_command(uint8_t command, uint32_t arg)
{
    b56e:	df 92       	push	r13
    b570:	ef 92       	push	r14
    b572:	ff 92       	push	r15
    b574:	0f 93       	push	r16
    b576:	1f 93       	push	r17
    b578:	d8 2e       	mov	r13, r24
    b57a:	7a 01       	movw	r14, r20
    b57c:	8b 01       	movw	r16, r22
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b57e:	81 e0       	ldi	r24, 0x01	; 1
    b580:	90 e0       	ldi	r25, 0x00	; 0
    b582:	6f ef       	ldi	r22, 0xFF	; 255
    b584:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(uint8_t b)
{	
	SPI_ReadWrite( spi_bus_num, b );
    b588:	6d 2d       	mov	r22, r13
    b58a:	60 64       	ori	r22, 0x40	; 64
    b58c:	81 e0       	ldi	r24, 0x01	; 1
    b58e:	90 e0       	ldi	r25, 0x00	; 0
    b590:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    switch(command)
    b594:	21 2f       	mov	r18, r17
    b596:	33 27       	eor	r19, r19
    b598:	44 27       	eor	r20, r20
    b59a:	55 27       	eor	r21, r21
    b59c:	81 e0       	ldi	r24, 0x01	; 1
    b59e:	90 e0       	ldi	r25, 0x00	; 0
    b5a0:	62 2f       	mov	r22, r18
    b5a2:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b5a6:	98 01       	movw	r18, r16
    b5a8:	44 27       	eor	r20, r20
    b5aa:	55 27       	eor	r21, r21
    b5ac:	81 e0       	ldi	r24, 0x01	; 1
    b5ae:	90 e0       	ldi	r25, 0x00	; 0
    b5b0:	62 2f       	mov	r22, r18
    b5b2:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b5b6:	55 27       	eor	r21, r21
    b5b8:	41 2f       	mov	r20, r17
    b5ba:	30 2f       	mov	r19, r16
    b5bc:	2f 2d       	mov	r18, r15
    b5be:	81 e0       	ldi	r24, 0x01	; 1
    b5c0:	90 e0       	ldi	r25, 0x00	; 0
    b5c2:	62 2f       	mov	r22, r18
    b5c4:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b5c8:	81 e0       	ldi	r24, 0x01	; 1
    b5ca:	90 e0       	ldi	r25, 0x00	; 0
    b5cc:	6e 2d       	mov	r22, r14
    b5ce:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b5d2:	dd 20       	and	r13, r13
    b5d4:	21 f0       	breq	.+8      	; 0xb5de <sd_raw_send_command+0x70>
    b5d6:	88 e0       	ldi	r24, 0x08	; 8
    b5d8:	d8 16       	cp	r13, r24
    b5da:	49 f4       	brne	.+18     	; 0xb5ee <sd_raw_send_command+0x80>
    b5dc:	04 c0       	rjmp	.+8      	; 0xb5e6 <sd_raw_send_command+0x78>
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(uint8_t b)
{	
	SPI_ReadWrite( spi_bus_num, b );
    b5de:	81 e0       	ldi	r24, 0x01	; 1
    b5e0:	90 e0       	ldi	r25, 0x00	; 0
    b5e2:	65 e9       	ldi	r22, 0x95	; 149
    b5e4:	07 c0       	rjmp	.+14     	; 0xb5f4 <sd_raw_send_command+0x86>
    sd_raw_send_byte((arg >> 0) & 0xff);
    switch(command)
    {
        case CMD_GO_IDLE_STATE:
           sd_raw_send_byte(0x95);
           break;
    b5e6:	81 e0       	ldi	r24, 0x01	; 1
    b5e8:	90 e0       	ldi	r25, 0x00	; 0
    b5ea:	67 e8       	ldi	r22, 0x87	; 135
    b5ec:	03 c0       	rjmp	.+6      	; 0xb5f4 <sd_raw_send_command+0x86>
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(uint8_t b)
{	
	SPI_ReadWrite( spi_bus_num, b );
    b5ee:	81 e0       	ldi	r24, 0x01	; 1
    b5f0:	90 e0       	ldi	r25, 0x00	; 0
    b5f2:	6f ef       	ldi	r22, 0xFF	; 255
    b5f4:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b5f8:	10 e0       	ldi	r17, 0x00	; 0
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b5fa:	81 e0       	ldi	r24, 0x01	; 1
    b5fc:	90 e0       	ldi	r25, 0x00	; 0
    b5fe:	6f ef       	ldi	r22, 0xFF	; 255
    b600:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    
    /* receive response */
    for(uint8_t i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
        if(response != 0xff)
    b604:	8f 3f       	cpi	r24, 0xFF	; 255
    b606:	19 f4       	brne	.+6      	; 0xb60e <sd_raw_send_command+0xa0>
           sd_raw_send_byte(0xff);
           break;
    }
    
    /* receive response */
    for(uint8_t i = 0; i < 10; ++i)
    b608:	1f 5f       	subi	r17, 0xFF	; 255
    b60a:	1a 30       	cpi	r17, 0x0A	; 10
    b60c:	b1 f7       	brne	.-20     	; 0xb5fa <sd_raw_send_command+0x8c>
        if(response != 0xff)
            break;
    }

   return response;
}
    b60e:	1f 91       	pop	r17
    b610:	0f 91       	pop	r16
    b612:	ff 90       	pop	r15
    b614:	ef 90       	pop	r14
    b616:	df 90       	pop	r13
    b618:	08 95       	ret

0000b61a <sd_raw_read>:
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write, sd_raw_write_interval
 */
uint8_t sd_raw_read(offset_t offset, uint8_t* buffer, uintptr_t length)
{
    b61a:	a0 e0       	ldi	r26, 0x00	; 0
    b61c:	b0 e0       	ldi	r27, 0x00	; 0
    b61e:	e3 e1       	ldi	r30, 0x13	; 19
    b620:	fb e5       	ldi	r31, 0x5B	; 91
    b622:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    b626:	2b 01       	movw	r4, r22
    b628:	3c 01       	movw	r6, r24
    b62a:	5a 01       	movw	r10, r20
    b62c:	19 01       	movw	r2, r18
    b62e:	73 c0       	rjmp	.+230    	; 0xb716 <sd_raw_read+0xfc>
    uint16_t block_offset;
    uint16_t read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_offset = offset & 0x01ff;
    b630:	ff ef       	ldi	r31, 0xFF	; 255
    b632:	8f 2e       	mov	r8, r31
    b634:	f1 e0       	ldi	r31, 0x01	; 1
    b636:	9f 2e       	mov	r9, r31
    b638:	84 20       	and	r8, r4
    b63a:	95 20       	and	r9, r5
        block_address = offset - block_offset;
    b63c:	c4 01       	movw	r24, r8
    b63e:	a0 e0       	ldi	r26, 0x00	; 0
    b640:	b0 e0       	ldi	r27, 0x00	; 0
    b642:	73 01       	movw	r14, r6
    b644:	62 01       	movw	r12, r4
    b646:	c8 1a       	sub	r12, r24
    b648:	d9 0a       	sbc	r13, r25
    b64a:	ea 0a       	sbc	r14, r26
    b64c:	fb 0a       	sbc	r15, r27
        read_length = 512 - block_offset; /* read up to block border */
    b64e:	00 e0       	ldi	r16, 0x00	; 0
    b650:	12 e0       	ldi	r17, 0x02	; 2
    b652:	08 19       	sub	r16, r8
    b654:	19 09       	sbc	r17, r9
    b656:	20 16       	cp	r2, r16
    b658:	31 06       	cpc	r3, r17
    b65a:	08 f4       	brcc	.+2      	; 0xb65e <sd_raw_read+0x44>
    b65c:	81 01       	movw	r16, r2
        if(read_length > length)
            read_length = length;
        
#if !SD_RAW_SAVE_RAM
        /* check if the requested data is cached */
        if(block_address != raw_block_address)
    b65e:	80 91 fb 06 	lds	r24, 0x06FB
    b662:	90 91 fc 06 	lds	r25, 0x06FC
    b666:	a0 91 fd 06 	lds	r26, 0x06FD
    b66a:	b0 91 fe 06 	lds	r27, 0x06FE
    b66e:	c8 16       	cp	r12, r24
    b670:	d9 06       	cpc	r13, r25
    b672:	ea 06       	cpc	r14, r26
    b674:	fb 06       	cpc	r15, r27
    b676:	e1 f1       	breq	.+120    	; 0xb6f0 <sd_raw_read+0xd6>
	{	
		test = 1;
		LockEthernet();
	}
#endif
	ss_PORT &= ~(1<<ss_PIN);
    b678:	5b 98       	cbi	0x0b, 3	; 11

            /* send single block request */
#if SD_RAW_SDHC
            if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) ? block_address / 512 : block_address)))
#else
            if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, block_address))
    b67a:	81 e1       	ldi	r24, 0x11	; 17
    b67c:	b7 01       	movw	r22, r14
    b67e:	a6 01       	movw	r20, r12
    b680:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
    b684:	88 23       	and	r24, r24
    b686:	19 f0       	breq	.+6      	; 0xb68e <sd_raw_read+0x74>
	ss_PORT &= ~(1<<ss_PIN);
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    b688:	5b 9a       	sbi	0x0b, 3	; 11
    b68a:	80 e0       	ldi	r24, 0x00	; 0
    b68c:	49 c0       	rjmp	.+146    	; 0xb720 <sd_raw_read+0x106>
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b68e:	81 e0       	ldi	r24, 0x01	; 1
    b690:	90 e0       	ldi	r25, 0x00	; 0
    b692:	6f ef       	ldi	r22, 0xFF	; 255
    b694:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
                unselect_card();
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
    b698:	8e 3f       	cpi	r24, 0xFE	; 254
    b69a:	c9 f7       	brne	.-14     	; 0xb68e <sd_raw_read+0x74>
    b69c:	cb ef       	ldi	r28, 0xFB	; 251
    b69e:	d4 e0       	ldi	r29, 0x04	; 4
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b6a0:	81 e0       	ldi	r24, 0x01	; 1
    b6a2:	90 e0       	ldi	r25, 0x00	; 0
    b6a4:	6f ef       	ldi	r22, 0xFF	; 255
    b6a6:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
#else
            /* read byte block */
            uint8_t* cache = raw_block;

            for(uint16_t i = 0; i < 512; ++i)
                *cache++ = sd_raw_rec_byte();
    b6aa:	89 93       	st	Y+, r24
            }
#else
            /* read byte block */
            uint8_t* cache = raw_block;

            for(uint16_t i = 0; i < 512; ++i)
    b6ac:	86 e0       	ldi	r24, 0x06	; 6
    b6ae:	cb 3f       	cpi	r28, 0xFB	; 251
    b6b0:	d8 07       	cpc	r29, r24
    b6b2:	b1 f7       	brne	.-20     	; 0xb6a0 <sd_raw_read+0x86>
                *cache++ = sd_raw_rec_byte();
			
            raw_block_address = block_address;
    b6b4:	c0 92 fb 06 	sts	0x06FB, r12
    b6b8:	d0 92 fc 06 	sts	0x06FC, r13
    b6bc:	e0 92 fd 06 	sts	0x06FD, r14
    b6c0:	f0 92 fe 06 	sts	0x06FE, r15

            memcpy(buffer, raw_block + block_offset, read_length);
    b6c4:	94 01       	movw	r18, r8
    b6c6:	25 50       	subi	r18, 0x05	; 5
    b6c8:	3b 4f       	sbci	r19, 0xFB	; 251
    b6ca:	c5 01       	movw	r24, r10
    b6cc:	b9 01       	movw	r22, r18
    b6ce:	a8 01       	movw	r20, r16
    b6d0:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
            buffer += read_length;
    b6d4:	a0 0e       	add	r10, r16
    b6d6:	b1 1e       	adc	r11, r17
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b6d8:	81 e0       	ldi	r24, 0x01	; 1
    b6da:	90 e0       	ldi	r25, 0x00	; 0
    b6dc:	6f ef       	ldi	r22, 0xFF	; 255
    b6de:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	ss_PORT &= ~(1<<ss_PIN);
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    b6e2:	81 e0       	ldi	r24, 0x01	; 1
    b6e4:	90 e0       	ldi	r25, 0x00	; 0
    b6e6:	6f ef       	ldi	r22, 0xFF	; 255
    b6e8:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b6ec:	5b 9a       	sbi	0x0b, 3	; 11
    b6ee:	0a c0       	rjmp	.+20     	; 0xb704 <sd_raw_read+0xea>
		}
#if !SD_RAW_SAVE_RAM
        else
        {
            /* use cached data */
            memcpy(buffer, raw_block + block_offset, read_length);
    b6f0:	94 01       	movw	r18, r8
    b6f2:	25 50       	subi	r18, 0x05	; 5
    b6f4:	3b 4f       	sbci	r19, 0xFB	; 251
    b6f6:	c5 01       	movw	r24, r10
    b6f8:	b9 01       	movw	r22, r18
    b6fa:	a8 01       	movw	r20, r16
    b6fc:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
            buffer += read_length;
    b700:	a0 0e       	add	r10, r16
    b702:	b1 1e       	adc	r11, r17
        }
#endif

        length -= read_length;
    b704:	20 1a       	sub	r2, r16
    b706:	31 0a       	sbc	r3, r17
        offset += read_length;
    b708:	c8 01       	movw	r24, r16
    b70a:	a0 e0       	ldi	r26, 0x00	; 0
    b70c:	b0 e0       	ldi	r27, 0x00	; 0
    b70e:	48 0e       	add	r4, r24
    b710:	59 1e       	adc	r5, r25
    b712:	6a 1e       	adc	r6, r26
    b714:	7b 1e       	adc	r7, r27
uint8_t sd_raw_read(offset_t offset, uint8_t* buffer, uintptr_t length)
{
	offset_t block_address;
    uint16_t block_offset;
    uint16_t read_length;
    while(length > 0)
    b716:	21 14       	cp	r2, r1
    b718:	31 04       	cpc	r3, r1
    b71a:	09 f0       	breq	.+2      	; 0xb71e <sd_raw_read+0x104>
    b71c:	89 cf       	rjmp	.-238    	; 0xb630 <sd_raw_read+0x16>
    b71e:	81 e0       	ldi	r24, 0x01	; 1
        length -= read_length;
        offset += read_length;
    }

    return 1;
}
    b720:	cd b7       	in	r28, 0x3d	; 61
    b722:	de b7       	in	r29, 0x3e	; 62
    b724:	e2 e1       	ldi	r30, 0x12	; 18
    b726:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000b72a <sd_raw_read_interval>:
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_write_interval, sd_raw_read, sd_raw_write
 */
uint8_t sd_raw_read_interval(offset_t offset, uint8_t* buffer, uintptr_t interval, uintptr_t length, sd_raw_read_interval_handler_t callback, void* p)
{
    b72a:	a4 e0       	ldi	r26, 0x04	; 4
    b72c:	b0 e0       	ldi	r27, 0x00	; 0
    b72e:	eb e9       	ldi	r30, 0x9B	; 155
    b730:	fb e5       	ldi	r31, 0x5B	; 91
    b732:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    b736:	4b 01       	movw	r8, r22
    b738:	5c 01       	movw	r10, r24
    b73a:	3a 01       	movw	r6, r20
    b73c:	3c 83       	std	Y+4, r19	; 0x04
    b73e:	2b 83       	std	Y+3, r18	; 0x03
    b740:	27 01       	movw	r4, r14
    b742:	da 82       	std	Y+2, r13	; 0x02
    b744:	c9 82       	std	Y+1, r12	; 0x01


    if(!buffer || interval == 0 || length < interval || !callback)
    b746:	41 15       	cp	r20, r1
    b748:	51 05       	cpc	r21, r1
    b74a:	a9 f1       	breq	.+106    	; 0xb7b6 <sd_raw_read_interval+0x8c>
    b74c:	21 15       	cp	r18, r1
    b74e:	31 05       	cpc	r19, r1
    b750:	91 f1       	breq	.+100    	; 0xb7b6 <sd_raw_read_interval+0x8c>
    b752:	02 17       	cp	r16, r18
    b754:	13 07       	cpc	r17, r19
    b756:	78 f1       	brcs	.+94     	; 0xb7b6 <sd_raw_read_interval+0x8c>
    b758:	e1 14       	cp	r14, r1
    b75a:	f1 04       	cpc	r15, r1
    b75c:	61 f1       	breq	.+88     	; 0xb7b6 <sd_raw_read_interval+0x8c>
    b75e:	19 01       	movw	r2, r18
    b760:	30 94       	com	r3
    b762:	21 94       	neg	r2
    b764:	31 08       	sbc	r3, r1
    b766:	33 94       	inc	r3
    b768:	02 1b       	sub	r16, r18
    b76a:	13 0b       	sbc	r17, r19
	{
        return 0;
	}
	
#if !SD_RAW_SAVE_RAM
    while(length >= interval)
    b76c:	69 01       	movw	r12, r18
    b76e:	ee 24       	eor	r14, r14
    b770:	ff 24       	eor	r15, r15
    {
        /* as reading is now buffered, we directly
         * hand over the request to sd_raw_read()
         */
        if(!sd_raw_read(offset, buffer, interval))
    b772:	c5 01       	movw	r24, r10
    b774:	b4 01       	movw	r22, r8
    b776:	a3 01       	movw	r20, r6
    b778:	2b 81       	ldd	r18, Y+3	; 0x03
    b77a:	3c 81       	ldd	r19, Y+4	; 0x04
    b77c:	0e 94 0d 5b 	call	0xb61a	; 0xb61a <sd_raw_read>
    b780:	88 23       	and	r24, r24
    b782:	c9 f0       	breq	.+50     	; 0xb7b6 <sd_raw_read_interval+0x8c>
		{
            return 0;
		}
        if(!callback(buffer, offset, p))
    b784:	c3 01       	movw	r24, r6
    b786:	b5 01       	movw	r22, r10
    b788:	a4 01       	movw	r20, r8
    b78a:	29 81       	ldd	r18, Y+1	; 0x01
    b78c:	3a 81       	ldd	r19, Y+2	; 0x02
    b78e:	f2 01       	movw	r30, r4
    b790:	09 95       	icall
    b792:	88 23       	and	r24, r24
    b794:	91 f0       	breq	.+36     	; 0xb7ba <sd_raw_read_interval+0x90>
            break;
    b796:	02 0d       	add	r16, r2
    b798:	13 1d       	adc	r17, r3
	{
        return 0;
	}
	
#if !SD_RAW_SAVE_RAM
    while(length >= interval)
    b79a:	8b 81       	ldd	r24, Y+3	; 0x03
    b79c:	9c 81       	ldd	r25, Y+4	; 0x04
    b79e:	80 0f       	add	r24, r16
    b7a0:	91 1f       	adc	r25, r17
    b7a2:	2b 81       	ldd	r18, Y+3	; 0x03
    b7a4:	3c 81       	ldd	r19, Y+4	; 0x04
    b7a6:	82 17       	cp	r24, r18
    b7a8:	93 07       	cpc	r25, r19
    b7aa:	38 f0       	brcs	.+14     	; 0xb7ba <sd_raw_read_interval+0x90>
    b7ac:	8c 0c       	add	r8, r12
    b7ae:	9d 1c       	adc	r9, r13
    b7b0:	ae 1c       	adc	r10, r14
    b7b2:	bf 1c       	adc	r11, r15
    b7b4:	de cf       	rjmp	.-68     	; 0xb772 <sd_raw_read_interval+0x48>
    b7b6:	80 e0       	ldi	r24, 0x00	; 0
    b7b8:	01 c0       	rjmp	.+2      	; 0xb7bc <sd_raw_read_interval+0x92>
    b7ba:	81 e0       	ldi	r24, 0x01	; 1

//	SREG = sreg_tmp;
	
    return 1;
#endif
}
    b7bc:	24 96       	adiw	r28, 0x04	; 4
    b7be:	e2 e1       	ldi	r30, 0x12	; 18
    b7c0:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000b7c4 <sd_raw_write>:
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write_interval, sd_raw_read, sd_raw_read_interval
 */
uint8_t sd_raw_write(offset_t offset, const uint8_t* buffer, uintptr_t length)
{
    b7c4:	a0 e0       	ldi	r26, 0x00	; 0
    b7c6:	b0 e0       	ldi	r27, 0x00	; 0
    b7c8:	e8 ee       	ldi	r30, 0xE8	; 232
    b7ca:	fb e5       	ldi	r31, 0x5B	; 91
    b7cc:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    b7d0:	4b 01       	movw	r8, r22
    b7d2:	5c 01       	movw	r10, r24
    b7d4:	2a 01       	movw	r4, r20
    b7d6:	39 01       	movw	r6, r18

	if(sd_raw_locked())
    b7d8:	1b 9b       	sbis	0x03, 3	; 3
    b7da:	84 c0       	rjmp	.+264    	; 0xb8e4 <sd_raw_write+0x120>
    b7dc:	8c c0       	rjmp	.+280    	; 0xb8f6 <sd_raw_write+0x132>
    uint16_t block_offset;
    uint16_t write_length;
    while(length > 0)
    {
        /* determine byte count to write at once */
        block_offset = offset & 0x01ff;
    b7de:	e4 01       	movw	r28, r8
    b7e0:	d1 70       	andi	r29, 0x01	; 1
        block_address = offset - block_offset;
    b7e2:	ce 01       	movw	r24, r28
    b7e4:	a0 e0       	ldi	r26, 0x00	; 0
    b7e6:	b0 e0       	ldi	r27, 0x00	; 0
    b7e8:	85 01       	movw	r16, r10
    b7ea:	74 01       	movw	r14, r8
    b7ec:	e8 1a       	sub	r14, r24
    b7ee:	f9 0a       	sbc	r15, r25
    b7f0:	0a 0b       	sbc	r16, r26
    b7f2:	1b 0b       	sbc	r17, r27
        write_length = 512 - block_offset; /* write up to block border */
    b7f4:	61 01       	movw	r12, r2
    b7f6:	cc 1a       	sub	r12, r28
    b7f8:	dd 0a       	sbc	r13, r29
    b7fa:	6c 14       	cp	r6, r12
    b7fc:	7d 04       	cpc	r7, r13
    b7fe:	08 f4       	brcc	.+2      	; 0xb802 <sd_raw_write+0x3e>
    b800:	63 01       	movw	r12, r6
            write_length = length;
        
        /* Merge the data to write with the content of the block.
         * Use the cached block if available.
         */
        if(block_address != raw_block_address)
    b802:	80 91 fb 06 	lds	r24, 0x06FB
    b806:	90 91 fc 06 	lds	r25, 0x06FC
    b80a:	a0 91 fd 06 	lds	r26, 0x06FD
    b80e:	b0 91 fe 06 	lds	r27, 0x06FE
    b812:	e8 16       	cp	r14, r24
    b814:	f9 06       	cpc	r15, r25
    b816:	0a 07       	cpc	r16, r26
    b818:	1b 07       	cpc	r17, r27
    b81a:	d1 f0       	breq	.+52     	; 0xb850 <sd_raw_write+0x8c>
			{
               return 0;
			}
#endif

            if(block_offset || write_length < 512)
    b81c:	20 97       	sbiw	r28, 0x00	; 0
    b81e:	29 f4       	brne	.+10     	; 0xb82a <sd_raw_write+0x66>
    b820:	80 e0       	ldi	r24, 0x00	; 0
    b822:	c8 16       	cp	r12, r24
    b824:	82 e0       	ldi	r24, 0x02	; 2
    b826:	d8 06       	cpc	r13, r24
    b828:	58 f4       	brcc	.+22     	; 0xb840 <sd_raw_write+0x7c>
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
    b82a:	c8 01       	movw	r24, r16
    b82c:	b7 01       	movw	r22, r14
    b82e:	4b ef       	ldi	r20, 0xFB	; 251
    b830:	54 e0       	ldi	r21, 0x04	; 4
    b832:	20 e0       	ldi	r18, 0x00	; 0
    b834:	32 e0       	ldi	r19, 0x02	; 2
    b836:	0e 94 0d 5b 	call	0xb61a	; 0xb61a <sd_raw_read>
    b83a:	88 23       	and	r24, r24
    b83c:	09 f4       	brne	.+2      	; 0xb840 <sd_raw_write+0x7c>
    b83e:	5b c0       	rjmp	.+182    	; 0xb8f6 <sd_raw_write+0x132>
				{
 				   	return 0;
				}
            }
            raw_block_address = block_address;
    b840:	e0 92 fb 06 	sts	0x06FB, r14
    b844:	f0 92 fc 06 	sts	0x06FC, r15
    b848:	00 93 fd 06 	sts	0x06FD, r16
    b84c:	10 93 fe 06 	sts	0x06FE, r17
        }

        if(buffer != raw_block)
    b850:	8b ef       	ldi	r24, 0xFB	; 251
    b852:	48 16       	cp	r4, r24
    b854:	84 e0       	ldi	r24, 0x04	; 4
    b856:	58 06       	cpc	r5, r24
    b858:	41 f0       	breq	.+16     	; 0xb86a <sd_raw_write+0xa6>
        {
            memcpy(raw_block + block_offset, buffer, write_length);
    b85a:	9e 01       	movw	r18, r28
    b85c:	25 50       	subi	r18, 0x05	; 5
    b85e:	3b 4f       	sbci	r19, 0xFB	; 251
    b860:	c9 01       	movw	r24, r18
    b862:	b2 01       	movw	r22, r4
    b864:	a6 01       	movw	r20, r12
    b866:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
	{	
		test = 1;
		LockEthernet();
	}
#endif
	ss_PORT &= ~(1<<ss_PIN);
    b86a:	5b 98       	cbi	0x0b, 3	; 11

        /* send single block request */
#if SD_RAW_SDHC
        if(sd_raw_send_command(CMD_WRITE_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) ? block_address / 512 : block_address)))
#else
        if(sd_raw_send_command(CMD_WRITE_SINGLE_BLOCK, block_address))
    b86c:	88 e1       	ldi	r24, 0x18	; 24
    b86e:	b8 01       	movw	r22, r16
    b870:	a7 01       	movw	r20, r14
    b872:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
    b876:	88 23       	and	r24, r24
    b878:	11 f0       	breq	.+4      	; 0xb87e <sd_raw_write+0xba>
	ss_PORT &= ~(1<<ss_PIN);
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    b87a:	5b 9a       	sbi	0x0b, 3	; 11
    b87c:	3c c0       	rjmp	.+120    	; 0xb8f6 <sd_raw_write+0x132>
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(uint8_t b)
{	
	SPI_ReadWrite( spi_bus_num, b );
    b87e:	81 e0       	ldi	r24, 0x01	; 1
    b880:	90 e0       	ldi	r25, 0x00	; 0
    b882:	6e ef       	ldi	r22, 0xFE	; 254
    b884:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b888:	cb ef       	ldi	r28, 0xFB	; 251
    b88a:	d4 e0       	ldi	r29, 0x04	; 4
        sd_raw_send_byte(0xfe);

        /* write byte block */
        uint8_t* cache = raw_block;
        for(uint16_t i = 0; i < 512; ++i)
            sd_raw_send_byte(*cache++);
    b88c:	69 91       	ld	r22, Y+
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(uint8_t b)
{	
	SPI_ReadWrite( spi_bus_num, b );
    b88e:	81 e0       	ldi	r24, 0x01	; 1
    b890:	90 e0       	ldi	r25, 0x00	; 0
    b892:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
        /* send start byte */
        sd_raw_send_byte(0xfe);

        /* write byte block */
        uint8_t* cache = raw_block;
        for(uint16_t i = 0; i < 512; ++i)
    b896:	86 e0       	ldi	r24, 0x06	; 6
    b898:	cb 3f       	cpi	r28, 0xFB	; 251
    b89a:	d8 07       	cpc	r29, r24
    b89c:	b9 f7       	brne	.-18     	; 0xb88c <sd_raw_write+0xc8>
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(uint8_t b)
{	
	SPI_ReadWrite( spi_bus_num, b );
    b89e:	81 e0       	ldi	r24, 0x01	; 1
    b8a0:	90 e0       	ldi	r25, 0x00	; 0
    b8a2:	6f ef       	ldi	r22, 0xFF	; 255
    b8a4:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b8a8:	81 e0       	ldi	r24, 0x01	; 1
    b8aa:	90 e0       	ldi	r25, 0x00	; 0
    b8ac:	6f ef       	ldi	r22, 0xFF	; 255
    b8ae:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
    b8b2:	81 e0       	ldi	r24, 0x01	; 1
    b8b4:	90 e0       	ldi	r25, 0x00	; 0
    b8b6:	6f ef       	ldi	r22, 0xFF	; 255
    b8b8:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
        /* write dummy crc16 */
        sd_raw_send_byte(0xff);
        sd_raw_send_byte(0xff);

        /* wait while card is busy */
        while(sd_raw_rec_byte() != 0xff);
    b8bc:	8f 3f       	cpi	r24, 0xFF	; 255
    b8be:	c9 f7       	brne	.-14     	; 0xb8b2 <sd_raw_write+0xee>
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b8c0:	81 e0       	ldi	r24, 0x01	; 1
    b8c2:	90 e0       	ldi	r25, 0x00	; 0
    b8c4:	6f ef       	ldi	r22, 0xFF	; 255
    b8c6:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	ss_PORT &= ~(1<<ss_PIN);
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    b8ca:	5b 9a       	sbi	0x0b, 3	; 11
        sd_raw_rec_byte();

        /* deaddress card */
        unselect_card();

        buffer += write_length;
    b8cc:	4c 0c       	add	r4, r12
    b8ce:	5d 1c       	adc	r5, r13
        offset += write_length;
    b8d0:	c6 01       	movw	r24, r12
    b8d2:	a0 e0       	ldi	r26, 0x00	; 0
    b8d4:	b0 e0       	ldi	r27, 0x00	; 0
    b8d6:	88 0e       	add	r8, r24
    b8d8:	99 1e       	adc	r9, r25
    b8da:	aa 1e       	adc	r10, r26
    b8dc:	bb 1e       	adc	r11, r27
        length -= write_length;
    b8de:	6c 18       	sub	r6, r12
    b8e0:	7d 08       	sbc	r7, r13
    b8e2:	03 c0       	rjmp	.+6      	; 0xb8ea <sd_raw_write+0x126>
    while(length > 0)
    {
        /* determine byte count to write at once */
        block_offset = offset & 0x01ff;
        block_address = offset - block_offset;
        write_length = 512 - block_offset; /* write up to block border */
    b8e4:	21 2c       	mov	r2, r1
    b8e6:	a2 e0       	ldi	r26, 0x02	; 2
    b8e8:	3a 2e       	mov	r3, r26
	}

	offset_t block_address;
    uint16_t block_offset;
    uint16_t write_length;
    while(length > 0)
    b8ea:	61 14       	cp	r6, r1
    b8ec:	71 04       	cpc	r7, r1
    b8ee:	09 f0       	breq	.+2      	; 0xb8f2 <sd_raw_write+0x12e>
    b8f0:	76 cf       	rjmp	.-276    	; 0xb7de <sd_raw_write+0x1a>
    b8f2:	81 e0       	ldi	r24, 0x01	; 1
    b8f4:	01 c0       	rjmp	.+2      	; 0xb8f8 <sd_raw_write+0x134>
    b8f6:	80 e0       	ldi	r24, 0x00	; 0
        raw_block_written = 1;
#endif
    }

   return 1;
}
    b8f8:	cd b7       	in	r28, 0x3d	; 61
    b8fa:	de b7       	in	r29, 0x3e	; 62
    b8fc:	e2 e1       	ldi	r30, 0x12	; 18
    b8fe:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000b902 <sd_raw_write_interval>:
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read_interval, sd_raw_write, sd_raw_read
 */
uint8_t sd_raw_write_interval(offset_t offset, uint8_t* buffer, uintptr_t length, sd_raw_write_interval_handler_t callback, void* p)
{
    b902:	a0 e0       	ldi	r26, 0x00	; 0
    b904:	b0 e0       	ldi	r27, 0x00	; 0
    b906:	e7 e8       	ldi	r30, 0x87	; 135
    b908:	fc e5       	ldi	r31, 0x5C	; 92
    b90a:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    b90e:	5b 01       	movw	r10, r22
    b910:	6c 01       	movw	r12, r24
    b912:	4a 01       	movw	r8, r20
    b914:	e9 01       	movw	r28, r18
    b916:	38 01       	movw	r6, r16
    b918:	27 01       	movw	r4, r14
	
#if SD_RAW_SAVE_RAM
    #error "SD_RAW_WRITE_SUPPORT is not supported together with SD_RAW_SAVE_RAM"
#endif

    if(!buffer || !callback)
    b91a:	41 15       	cp	r20, r1
    b91c:	51 05       	cpc	r21, r1
    b91e:	71 f1       	breq	.+92     	; 0xb97c <sd_raw_write_interval+0x7a>
    b920:	01 15       	cp	r16, r1
    b922:	11 05       	cpc	r17, r1
    b924:	59 f1       	breq	.+86     	; 0xb97c <sd_raw_write_interval+0x7a>
	{	
       return 0;
	}
	
    uint8_t endless = (length == 0);
    b926:	ff 24       	eor	r15, r15
    b928:	21 15       	cp	r18, r1
    b92a:	31 05       	cpc	r19, r1
    b92c:	11 f5       	brne	.+68     	; 0xb972 <sd_raw_write_interval+0x70>
    b92e:	ff 24       	eor	r15, r15
    b930:	f3 94       	inc	r15
    b932:	1f c0       	rjmp	.+62     	; 0xb972 <sd_raw_write_interval+0x70>
    while(endless || length > 0)
    {
        uint16_t bytes_to_write = callback(buffer, offset, p);
    b934:	c4 01       	movw	r24, r8
    b936:	b6 01       	movw	r22, r12
    b938:	a5 01       	movw	r20, r10
    b93a:	92 01       	movw	r18, r4
    b93c:	f3 01       	movw	r30, r6
    b93e:	09 95       	icall
    b940:	8c 01       	movw	r16, r24
        if(!bytes_to_write)
    b942:	00 97       	sbiw	r24, 0x00	; 0
    b944:	e9 f0       	breq	.+58     	; 0xb980 <sd_raw_write_interval+0x7e>
            break;
        if(!endless && bytes_to_write > length)
    b946:	ff 20       	and	r15, r15
    b948:	19 f4       	brne	.+6      	; 0xb950 <sd_raw_write_interval+0x4e>
    b94a:	c8 17       	cp	r28, r24
    b94c:	d9 07       	cpc	r29, r25
    b94e:	b0 f0       	brcs	.+44     	; 0xb97c <sd_raw_write_interval+0x7a>
		}
		
        /* as writing is always buffered, we directly
         * hand over the request to sd_raw_write()
         */
        if(!sd_raw_write(offset, buffer, bytes_to_write))
    b950:	c6 01       	movw	r24, r12
    b952:	b5 01       	movw	r22, r10
    b954:	a4 01       	movw	r20, r8
    b956:	98 01       	movw	r18, r16
    b958:	0e 94 e2 5b 	call	0xb7c4	; 0xb7c4 <sd_raw_write>
    b95c:	88 23       	and	r24, r24
    b95e:	71 f0       	breq	.+28     	; 0xb97c <sd_raw_write_interval+0x7a>
		{
           return 0;
		}
        offset += bytes_to_write;
    b960:	c8 01       	movw	r24, r16
    b962:	a0 e0       	ldi	r26, 0x00	; 0
    b964:	b0 e0       	ldi	r27, 0x00	; 0
    b966:	a8 0e       	add	r10, r24
    b968:	b9 1e       	adc	r11, r25
    b96a:	ca 1e       	adc	r12, r26
    b96c:	db 1e       	adc	r13, r27
        length -= bytes_to_write;
    b96e:	c0 1b       	sub	r28, r16
    b970:	d1 0b       	sbc	r29, r17
	{	
       return 0;
	}
	
    uint8_t endless = (length == 0);
    while(endless || length > 0)
    b972:	ff 20       	and	r15, r15
    b974:	f9 f6       	brne	.-66     	; 0xb934 <sd_raw_write_interval+0x32>
    b976:	20 97       	sbiw	r28, 0x00	; 0
    b978:	e9 f6       	brne	.-70     	; 0xb934 <sd_raw_write_interval+0x32>
    b97a:	02 c0       	rjmp	.+4      	; 0xb980 <sd_raw_write_interval+0x7e>
    b97c:	80 e0       	ldi	r24, 0x00	; 0
    b97e:	01 c0       	rjmp	.+2      	; 0xb982 <sd_raw_write_interval+0x80>
    b980:	81 e0       	ldi	r24, 0x01	; 1
        offset += bytes_to_write;
        length -= bytes_to_write;
    }

	return 1;
}
    b982:	cd b7       	in	r28, 0x3d	; 61
    b984:	de b7       	in	r29, 0x3e	; 62
    b986:	e0 e1       	ldi	r30, 0x10	; 16
    b988:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

0000b98c <sd_raw_init>:
 * Initializes memory card communication.
 *
 * \returns 0 on failure, 1 on success.
 */
uint8_t sd_raw_init()
{
    b98c:	1f 93       	push	r17
    b98e:	cf 93       	push	r28
    b990:	df 93       	push	r29

#if defined(__AVR_ATmega644__)
	#if defined(AVRNETIO)
	/* enable inputs for reading card status */
    configure_pin_available();
    b992:	56 98       	cbi	0x0a, 6	; 10
    configure_pin_locked();
    b994:	23 98       	cbi	0x04, 3	; 4
	configure_pin_available_pullup();
    b996:	5e 9a       	sbi	0x0b, 6	; 11
	configure_pin_locked_pullup();
    b998:	2b 9a       	sbi	0x05, 3	; 5
	#endif
#endif	

	/* Configure Chip-Select Pin*/
    configure_pin_ss();
    b99a:	53 9a       	sbi	0x0a, 3	; 10
	{	
		test = 1;
		LockEthernet();
	}
#endif
	ss_PORT &= ~(1<<ss_PIN);
    b99c:	5b 98       	cbi	0x0b, 3	; 11
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    b99e:	5b 9a       	sbi	0x0b, 3	; 11
	/* unselect MMC-Card */
    select_card();
    unselect_card();

	/* SPI-Bus Init */
	SPI_init( spi_bus_num );
    b9a0:	81 e0       	ldi	r24, 0x01	; 1
    b9a2:	90 e0       	ldi	r25, 0x00	; 0
    b9a4:	0e 94 82 1c 	call	0x3904	; 0x3904 <SPI_init>

#if defined(__AVR_ATmega644__)
	#if defined(AVRNETIO)
	/* Power up the MMC-Interface */
	configure_power_up();
    b9a8:	57 9a       	sbi	0x0a, 7	; 10
	power_up();
    b9aa:	5f 9a       	sbi	0x0b, 7	; 11
	#endif
#endif	
    /* initialization procedure */
    sd_raw_card_type = 0;
    b9ac:	10 92 ff 06 	sts	0x06FF, r1
 *
 * \returns 1 if the card is available, 0 if it is not.
 */
uint8_t sd_raw_available()
{
    return get_pin_available() == 0x00;
    b9b0:	89 b1       	in	r24, 0x09	; 9
	#endif
#endif	
    /* initialization procedure */
    sd_raw_card_type = 0;
    
    if(!sd_raw_available())
    b9b2:	82 95       	swap	r24
    b9b4:	86 95       	lsr	r24
    b9b6:	86 95       	lsr	r24
    b9b8:	83 70       	andi	r24, 0x03	; 3
    b9ba:	80 fd       	sbrc	r24, 0
    b9bc:	77 c0       	rjmp	.+238    	; 0xbaac <sd_raw_init+0x120>
    b9be:	10 e0       	ldi	r17, 0x00	; 0
 */
uint8_t sd_raw_rec_byte()
{
	unsigned char data;

	data = SPI_ReadWrite( spi_bus_num, 0xff );
    b9c0:	81 e0       	ldi	r24, 0x01	; 1
    b9c2:	90 e0       	ldi	r25, 0x00	; 0
    b9c4:	6f ef       	ldi	r22, 0xFF	; 255
    b9c6:	0e 94 8f 1c 	call	0x391e	; 0x391e <SPI_ReadWrite>
	{
       return 0;
	}
	
    /* card needs 74 cycles minimum to start up */
    for(uint8_t i = 0; i < 100; ++i)
    b9ca:	1f 5f       	subi	r17, 0xFF	; 255
    b9cc:	14 36       	cpi	r17, 0x64	; 100
    b9ce:	c1 f7       	brne	.-16     	; 0xb9c0 <sd_raw_init+0x34>
	{	
		test = 1;
		LockEthernet();
	}
#endif
	ss_PORT &= ~(1<<ss_PIN);
    b9d0:	5b 98       	cbi	0x0b, 3	; 11
    b9d2:	c0 e0       	ldi	r28, 0x00	; 0
    b9d4:	d0 e0       	ldi	r29, 0x00	; 0

    /* reset card */
    uint8_t response;
    for(uint16_t i = 0; ; ++i)
    {
        response = sd_raw_send_command(CMD_GO_IDLE_STATE, 0);
    b9d6:	80 e0       	ldi	r24, 0x00	; 0
    b9d8:	40 e0       	ldi	r20, 0x00	; 0
    b9da:	50 e0       	ldi	r21, 0x00	; 0
    b9dc:	60 e0       	ldi	r22, 0x00	; 0
    b9de:	70 e0       	ldi	r23, 0x00	; 0
    b9e0:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
        if(response == (1 << R1_IDLE_STATE))
    b9e4:	81 30       	cpi	r24, 0x01	; 1
    b9e6:	39 f0       	breq	.+14     	; 0xb9f6 <sd_raw_init+0x6a>
            break;

        if(i == 0xfff)
    b9e8:	8f e0       	ldi	r24, 0x0F	; 15
    b9ea:	cf 3f       	cpi	r28, 0xFF	; 255
    b9ec:	d8 07       	cpc	r29, r24
    b9ee:	09 f4       	brne	.+2      	; 0xb9f2 <sd_raw_init+0x66>
    b9f0:	5c c0       	rjmp	.+184    	; 0xbaaa <sd_raw_init+0x11e>
    /* address card */
    select_card();

    /* reset card */
    uint8_t response;
    for(uint16_t i = 0; ; ++i)
    b9f2:	21 96       	adiw	r28, 0x01	; 1
    b9f4:	f0 cf       	rjmp	.-32     	; 0xb9d6 <sd_raw_init+0x4a>
    }
    else
#endif
    {
        /* determine SD/MMC card type */
        sd_raw_send_command(CMD_APP, 0);
    b9f6:	87 e3       	ldi	r24, 0x37	; 55
    b9f8:	40 e0       	ldi	r20, 0x00	; 0
    b9fa:	50 e0       	ldi	r21, 0x00	; 0
    b9fc:	60 e0       	ldi	r22, 0x00	; 0
    b9fe:	70 e0       	ldi	r23, 0x00	; 0
    ba00:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
        response = sd_raw_send_command(CMD_SD_SEND_OP_COND, 0);
    ba04:	89 e2       	ldi	r24, 0x29	; 41
    ba06:	40 e0       	ldi	r20, 0x00	; 0
    ba08:	50 e0       	ldi	r21, 0x00	; 0
    ba0a:	60 e0       	ldi	r22, 0x00	; 0
    ba0c:	70 e0       	ldi	r23, 0x00	; 0
    ba0e:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
        if((response & (1 << R1_ILL_COMMAND)) == 0)
    ba12:	82 fd       	sbrc	r24, 2
    ba14:	05 c0       	rjmp	.+10     	; 0xba20 <sd_raw_init+0x94>
        {
            /* card conforms to SD 1 card specification */
            sd_raw_card_type |= (1 << SD_RAW_SPEC_1);
    ba16:	80 91 ff 06 	lds	r24, 0x06FF
    ba1a:	81 60       	ori	r24, 0x01	; 1
    ba1c:	80 93 ff 06 	sts	0x06FF, r24
    ba20:	c0 e0       	ldi	r28, 0x00	; 0
    ba22:	d0 e0       	ldi	r29, 0x00	; 0
    }

    /* wait for card to get ready */
    for(uint16_t i = 0; ; ++i)
    {
        if(sd_raw_card_type & ((1 << SD_RAW_SPEC_1) | (1 << SD_RAW_SPEC_2)))
    ba24:	80 91 ff 06 	lds	r24, 0x06FF
    ba28:	90 e0       	ldi	r25, 0x00	; 0
    ba2a:	83 70       	andi	r24, 0x03	; 3
    ba2c:	90 70       	andi	r25, 0x00	; 0
    ba2e:	89 2b       	or	r24, r25
    ba30:	49 f0       	breq	.+18     	; 0xba44 <sd_raw_init+0xb8>
            uint32_t arg = 0;
#if SD_RAW_SDHC
            if(sd_raw_card_type & (1 << SD_RAW_SPEC_2))
                arg = 0x40000000;
#endif
            sd_raw_send_command(CMD_APP, 0);
    ba32:	87 e3       	ldi	r24, 0x37	; 55
    ba34:	40 e0       	ldi	r20, 0x00	; 0
    ba36:	50 e0       	ldi	r21, 0x00	; 0
    ba38:	60 e0       	ldi	r22, 0x00	; 0
    ba3a:	70 e0       	ldi	r23, 0x00	; 0
    ba3c:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
            response = sd_raw_send_command(CMD_SD_SEND_OP_COND, arg);
    ba40:	89 e2       	ldi	r24, 0x29	; 41
    ba42:	01 c0       	rjmp	.+2      	; 0xba46 <sd_raw_init+0xba>
        }
        else
        {
            response = sd_raw_send_command(CMD_SEND_OP_COND, 0);
    ba44:	81 e0       	ldi	r24, 0x01	; 1
    ba46:	40 e0       	ldi	r20, 0x00	; 0
    ba48:	50 e0       	ldi	r21, 0x00	; 0
    ba4a:	60 e0       	ldi	r22, 0x00	; 0
    ba4c:	70 e0       	ldi	r23, 0x00	; 0
    ba4e:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
        }

		if((response & (1 << R1_IDLE_STATE)) == 0)
    ba52:	80 ff       	sbrs	r24, 0
    ba54:	06 c0       	rjmp	.+12     	; 0xba62 <sd_raw_init+0xd6>
            break;

        if(i == 0x7fff)
    ba56:	8f e7       	ldi	r24, 0x7F	; 127
    ba58:	cf 3f       	cpi	r28, 0xFF	; 255
    ba5a:	d8 07       	cpc	r29, r24
    ba5c:	31 f1       	breq	.+76     	; 0xbaaa <sd_raw_init+0x11e>
            /* MMC card */
        }
    }

    /* wait for card to get ready */
    for(uint16_t i = 0; ; ++i)
    ba5e:	21 96       	adiw	r28, 0x01	; 1
    ba60:	e1 cf       	rjmp	.-62     	; 0xba24 <sd_raw_init+0x98>
        sd_raw_rec_byte();
    }
#endif

    /* set block size to 512 bytes */
    if(sd_raw_send_command(CMD_SET_BLOCKLEN, 512))
    ba62:	80 e1       	ldi	r24, 0x10	; 16
    ba64:	40 e0       	ldi	r20, 0x00	; 0
    ba66:	52 e0       	ldi	r21, 0x02	; 2
    ba68:	60 e0       	ldi	r22, 0x00	; 0
    ba6a:	70 e0       	ldi	r23, 0x00	; 0
    ba6c:	0e 94 b7 5a 	call	0xb56e	; 0xb56e <sd_raw_send_command>
    ba70:	88 23       	and	r24, r24
    ba72:	d9 f4       	brne	.+54     	; 0xbaaa <sd_raw_init+0x11e>
	ss_PORT &= ~(1<<ss_PIN);
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    ba74:	5b 9a       	sbi	0x0b, 3	; 11
//    SPCR &= ~((1 << SPR1) | (1 << SPR0)); /* Clock Frequency: f_OSC / 4 */
//    SPSR |= (1 << SPI2X); /* Doubled Clock Frequency: f_OSC / 2 */

#if !SD_RAW_SAVE_RAM
    /* the first block is likely to be accessed first, so precache it here */
    raw_block_address = (offset_t) -1;
    ba76:	8f ef       	ldi	r24, 0xFF	; 255
    ba78:	9f ef       	ldi	r25, 0xFF	; 255
    ba7a:	af ef       	ldi	r26, 0xFF	; 255
    ba7c:	bf ef       	ldi	r27, 0xFF	; 255
    ba7e:	80 93 fb 06 	sts	0x06FB, r24
    ba82:	90 93 fc 06 	sts	0x06FC, r25
    ba86:	a0 93 fd 06 	sts	0x06FD, r26
    ba8a:	b0 93 fe 06 	sts	0x06FE, r27
#if SD_RAW_WRITE_BUFFERING
    raw_block_written = 1;
#endif
    if(!sd_raw_read(0, raw_block, sizeof(raw_block)))
    ba8e:	60 e0       	ldi	r22, 0x00	; 0
    ba90:	70 e0       	ldi	r23, 0x00	; 0
    ba92:	80 e0       	ldi	r24, 0x00	; 0
    ba94:	90 e0       	ldi	r25, 0x00	; 0
    ba96:	4b ef       	ldi	r20, 0xFB	; 251
    ba98:	54 e0       	ldi	r21, 0x04	; 4
    ba9a:	20 e0       	ldi	r18, 0x00	; 0
    ba9c:	32 e0       	ldi	r19, 0x02	; 2
    ba9e:	0e 94 0d 5b 	call	0xb61a	; 0xb61a <sd_raw_read>
    baa2:	88 23       	and	r24, r24
    baa4:	11 f0       	breq	.+4      	; 0xbaaa <sd_raw_init+0x11e>
    baa6:	81 e0       	ldi	r24, 0x01	; 1
    baa8:	02 c0       	rjmp	.+4      	; 0xbaae <sd_raw_init+0x122>
	ss_PORT &= ~(1<<ss_PIN);
}

void unselect_card()
{
	ss_PORT |= (1<<ss_PIN);
    baaa:	5b 9a       	sbi	0x0b, 3	; 11
    baac:	80 e0       	ldi	r24, 0x00	; 0
        return 0;
    }
#endif

   return 1;
}
    baae:	df 91       	pop	r29
    bab0:	cf 91       	pop	r28
    bab2:	1f 91       	pop	r17
    bab4:	08 95       	ret

0000bab6 <fat_get_next_cluster>:
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
cluster_t fat_get_next_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    bab6:	a2 e0       	ldi	r26, 0x02	; 2
    bab8:	b0 e0       	ldi	r27, 0x00	; 0
    baba:	e1 e6       	ldi	r30, 0x61	; 97
    babc:	fd e5       	ldi	r31, 0x5D	; 93
    babe:	0c 94 c9 6a 	jmp	0xd592	; 0xd592 <__prologue_saves__+0x20>
    bac2:	dc 01       	movw	r26, r24
    if(!fs || cluster_num < 2)
    bac4:	00 97       	sbiw	r24, 0x00	; 0
    bac6:	81 f1       	breq	.+96     	; 0xbb28 <fat_get_next_cluster+0x72>
    bac8:	62 30       	cpi	r22, 0x02	; 2
    baca:	71 05       	cpc	r23, r1
    bacc:	68 f1       	brcs	.+90     	; 0xbb28 <fat_get_next_cluster+0x72>
    else
#endif
    {
        /* read appropriate fat entry */
        uint16_t fat_entry;
        if(!fs->partition->device_read(fs->header.fat_offset + cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
    bace:	ed 91       	ld	r30, X+
    bad0:	fc 91       	ld	r31, X
    bad2:	11 97       	sbiw	r26, 0x01	; 1
    bad4:	66 0f       	add	r22, r22
    bad6:	77 1f       	adc	r23, r23
    bad8:	80 e0       	ldi	r24, 0x00	; 0
    bada:	90 e0       	ldi	r25, 0x00	; 0
    badc:	16 96       	adiw	r26, 0x06	; 6
    bade:	2d 91       	ld	r18, X+
    bae0:	3d 91       	ld	r19, X+
    bae2:	4d 91       	ld	r20, X+
    bae4:	5c 91       	ld	r21, X
    bae6:	19 97       	sbiw	r26, 0x09	; 9
    bae8:	62 0f       	add	r22, r18
    baea:	73 1f       	adc	r23, r19
    baec:	84 1f       	adc	r24, r20
    baee:	95 1f       	adc	r25, r21
    baf0:	01 90       	ld	r0, Z+
    baf2:	f0 81       	ld	r31, Z
    baf4:	e0 2d       	mov	r30, r0
    baf6:	ae 01       	movw	r20, r28
    baf8:	4f 5f       	subi	r20, 0xFF	; 255
    bafa:	5f 4f       	sbci	r21, 0xFF	; 255
    bafc:	22 e0       	ldi	r18, 0x02	; 2
    bafe:	30 e0       	ldi	r19, 0x00	; 0
    bb00:	09 95       	icall
    bb02:	88 23       	and	r24, r24
    bb04:	89 f0       	breq	.+34     	; 0xbb28 <fat_get_next_cluster+0x72>
            return 0;

        /* determine next cluster from fat */
        cluster_num = ltoh16(fat_entry);
    bb06:	29 81       	ldd	r18, Y+1	; 0x01
    bb08:	3a 81       	ldd	r19, Y+2	; 0x02
        
        if(cluster_num == FAT16_CLUSTER_FREE ||
    bb0a:	21 15       	cp	r18, r1
    bb0c:	31 05       	cpc	r19, r1
    bb0e:	71 f0       	breq	.+28     	; 0xbb2c <fat_get_next_cluster+0x76>
    bb10:	8f ef       	ldi	r24, 0xFF	; 255
    bb12:	27 3f       	cpi	r18, 0xF7	; 247
    bb14:	38 07       	cpc	r19, r24
    bb16:	41 f0       	breq	.+16     	; 0xbb28 <fat_get_next_cluster+0x72>
    bb18:	c9 01       	movw	r24, r18
    bb1a:	40 96       	adiw	r24, 0x10	; 16
    bb1c:	07 97       	sbiw	r24, 0x07	; 7
    bb1e:	20 f0       	brcs	.+8      	; 0xbb28 <fat_get_next_cluster+0x72>
    bb20:	8f ef       	ldi	r24, 0xFF	; 255
    bb22:	28 3f       	cpi	r18, 0xF8	; 248
    bb24:	38 07       	cpc	r19, r24
    bb26:	10 f0       	brcs	.+4      	; 0xbb2c <fat_get_next_cluster+0x76>
    bb28:	20 e0       	ldi	r18, 0x00	; 0
    bb2a:	30 e0       	ldi	r19, 0x00	; 0
           (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
            return 0;
    }

    return cluster_num;
}
    bb2c:	c9 01       	movw	r24, r18
    bb2e:	22 96       	adiw	r28, 0x02	; 2
    bb30:	e2 e0       	ldi	r30, 0x02	; 2
    bb32:	0c 94 e5 6a 	jmp	0xd5ca	; 0xd5ca <__epilogue_restores__+0x20>

0000bb36 <fat_free_clusters>:
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat_terminate_clusters
 */
uint8_t fat_free_clusters(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    bb36:	a2 e0       	ldi	r26, 0x02	; 2
    bb38:	b0 e0       	ldi	r27, 0x00	; 0
    bb3a:	e1 ea       	ldi	r30, 0xA1	; 161
    bb3c:	fd e5       	ldi	r31, 0x5D	; 93
    bb3e:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    bb42:	5c 01       	movw	r10, r24
    if(!fs || cluster_num < 2)
    bb44:	00 97       	sbiw	r24, 0x00	; 0
    bb46:	09 f4       	brne	.+2      	; 0xbb4a <fat_free_clusters+0x14>
    bb48:	49 c0       	rjmp	.+146    	; 0xbbdc <fat_free_clusters+0xa6>
    bb4a:	62 30       	cpi	r22, 0x02	; 2
    bb4c:	71 05       	cpc	r23, r1
    bb4e:	08 f4       	brcc	.+2      	; 0xbb52 <fat_free_clusters+0x1c>
    bb50:	45 c0       	rjmp	.+138    	; 0xbbdc <fat_free_clusters+0xa6>
        return 0;

    offset_t fat_offset = fs->header.fat_offset;
    bb52:	dc 01       	movw	r26, r24
    bb54:	16 96       	adiw	r26, 0x06	; 6
    bb56:	6d 90       	ld	r6, X+
    bb58:	7d 90       	ld	r7, X+
    bb5a:	8d 90       	ld	r8, X+
    bb5c:	9c 90       	ld	r9, X
    bb5e:	19 97       	sbiw	r26, 0x09	; 9
#endif
    {
        uint16_t fat_entry;
        while(cluster_num)
        {
            if(!fs->partition->device_read(fat_offset + cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
    bb60:	2e 01       	movw	r4, r28
    bb62:	08 94       	sec
    bb64:	41 1c       	adc	r4, r1
    bb66:	51 1c       	adc	r5, r1
    bb68:	66 0f       	add	r22, r22
    bb6a:	77 1f       	adc	r23, r23
    bb6c:	7b 01       	movw	r14, r22
    bb6e:	00 e0       	ldi	r16, 0x00	; 0
    bb70:	10 e0       	ldi	r17, 0x00	; 0
    bb72:	e6 0c       	add	r14, r6
    bb74:	f7 1c       	adc	r15, r7
    bb76:	08 1d       	adc	r16, r8
    bb78:	19 1d       	adc	r17, r9
    bb7a:	d5 01       	movw	r26, r10
    bb7c:	ed 91       	ld	r30, X+
    bb7e:	fc 91       	ld	r31, X
    bb80:	01 90       	ld	r0, Z+
    bb82:	f0 81       	ld	r31, Z
    bb84:	e0 2d       	mov	r30, r0
    bb86:	c8 01       	movw	r24, r16
    bb88:	b7 01       	movw	r22, r14
    bb8a:	a2 01       	movw	r20, r4
    bb8c:	22 e0       	ldi	r18, 0x02	; 2
    bb8e:	30 e0       	ldi	r19, 0x00	; 0
    bb90:	09 95       	icall
    bb92:	88 23       	and	r24, r24
    bb94:	19 f1       	breq	.+70     	; 0xbbdc <fat_free_clusters+0xa6>
                return 0;

            /* get next cluster of current cluster before freeing current cluster */
            uint16_t cluster_num_next = ltoh16(fat_entry);
    bb96:	c9 80       	ldd	r12, Y+1	; 0x01
    bb98:	da 80       	ldd	r13, Y+2	; 0x02

            if(cluster_num_next == FAT16_CLUSTER_FREE)
    bb9a:	c1 14       	cp	r12, r1
    bb9c:	d1 04       	cpc	r13, r1
    bb9e:	01 f1       	breq	.+64     	; 0xbbe0 <fat_free_clusters+0xaa>
                return 1;
            if(cluster_num_next == FAT16_CLUSTER_BAD ||
    bba0:	c6 01       	movw	r24, r12
    bba2:	40 96       	adiw	r24, 0x10	; 16
    bba4:	08 97       	sbiw	r24, 0x08	; 8
    bba6:	d0 f0       	brcs	.+52     	; 0xbbdc <fat_free_clusters+0xa6>
               (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
                cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
               )
              )
                return 0;
            if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN && cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
    bba8:	b8 ef       	ldi	r27, 0xF8	; 248
    bbaa:	cb 16       	cp	r12, r27
    bbac:	bf ef       	ldi	r27, 0xFF	; 255
    bbae:	db 06       	cpc	r13, r27
    bbb0:	10 f0       	brcs	.+4      	; 0xbbb6 <fat_free_clusters+0x80>
    bbb2:	cc 24       	eor	r12, r12
    bbb4:	dd 24       	eor	r13, r13
                cluster_num_next = 0;

            /* free cluster */
            fat_entry = HTOL16(FAT16_CLUSTER_FREE);
    bbb6:	1a 82       	std	Y+2, r1	; 0x02
    bbb8:	19 82       	std	Y+1, r1	; 0x01
            fs->partition->device_write(fat_offset + cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry));
    bbba:	d5 01       	movw	r26, r10
    bbbc:	ed 91       	ld	r30, X+
    bbbe:	fc 91       	ld	r31, X
    bbc0:	04 80       	ldd	r0, Z+4	; 0x04
    bbc2:	f5 81       	ldd	r31, Z+5	; 0x05
    bbc4:	e0 2d       	mov	r30, r0
    bbc6:	c8 01       	movw	r24, r16
    bbc8:	b7 01       	movw	r22, r14
    bbca:	a2 01       	movw	r20, r4
    bbcc:	22 e0       	ldi	r18, 0x02	; 2
    bbce:	30 e0       	ldi	r19, 0x00	; 0
    bbd0:	09 95       	icall
    bbd2:	b6 01       	movw	r22, r12
    }
    else
#endif
    {
        uint16_t fat_entry;
        while(cluster_num)
    bbd4:	c1 14       	cp	r12, r1
    bbd6:	d1 04       	cpc	r13, r1
    bbd8:	39 f6       	brne	.-114    	; 0xbb68 <fat_free_clusters+0x32>
    bbda:	02 c0       	rjmp	.+4      	; 0xbbe0 <fat_free_clusters+0xaa>
    bbdc:	80 e0       	ldi	r24, 0x00	; 0
    bbde:	01 c0       	rjmp	.+2      	; 0xbbe2 <fat_free_clusters+0xac>
    bbe0:	81 e0       	ldi	r24, 0x01	; 1
            cluster_num = cluster_num_next;
        }
    }

    return 1;
}
    bbe2:	22 96       	adiw	r28, 0x02	; 2
    bbe4:	e0 e1       	ldi	r30, 0x10	; 16
    bbe6:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

0000bbea <fat_append_clusters>:
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
cluster_t fat_append_clusters(const struct fat_fs_struct* fs, cluster_t cluster_num, cluster_t count)
{
    bbea:	aa e0       	ldi	r26, 0x0A	; 10
    bbec:	b0 e0       	ldi	r27, 0x00	; 0
    bbee:	eb ef       	ldi	r30, 0xFB	; 251
    bbf0:	fd e5       	ldi	r31, 0x5D	; 93
    bbf2:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    bbf6:	3c 01       	movw	r6, r24
    bbf8:	2b 01       	movw	r4, r22
    if(!fs)
    bbfa:	00 97       	sbiw	r24, 0x00	; 0
    bbfc:	09 f4       	brne	.+2      	; 0xbc00 <fat_append_clusters+0x16>
    bbfe:	90 c0       	rjmp	.+288    	; 0xbd20 <fat_append_clusters+0x136>
        return 0;

    device_read_t device_read = fs->partition->device_read;
    bc00:	dc 01       	movw	r26, r24
    bc02:	ed 91       	ld	r30, X+
    bc04:	fc 91       	ld	r31, X
    bc06:	11 97       	sbiw	r26, 0x01	; 1
    bc08:	20 81       	ld	r18, Z
    bc0a:	31 81       	ldd	r19, Z+1	; 0x01
    bc0c:	3a 87       	std	Y+10, r19	; 0x0a
    bc0e:	29 87       	std	Y+9, r18	; 0x09
    device_write_t device_write = fs->partition->device_write;
    bc10:	24 80       	ldd	r2, Z+4	; 0x04
    bc12:	35 80       	ldd	r3, Z+5	; 0x05
    offset_t fat_offset = fs->header.fat_offset;
    bc14:	16 96       	adiw	r26, 0x06	; 6
    bc16:	8d 91       	ld	r24, X+
    bc18:	9d 91       	ld	r25, X+
    bc1a:	0d 90       	ld	r0, X+
    bc1c:	bc 91       	ld	r27, X
    bc1e:	a0 2d       	mov	r26, r0
    bc20:	8d 83       	std	Y+5, r24	; 0x05
    bc22:	9e 83       	std	Y+6, r25	; 0x06
    bc24:	af 83       	std	Y+7, r26	; 0x07
    bc26:	b8 87       	std	Y+8, r27	; 0x08

    if(is_fat32)
        cluster_max = fs->header.fat_size / sizeof(fat_entry32);
    else
#endif
        cluster_max = fs->header.fat_size / sizeof(fat_entry16);
    bc28:	f3 01       	movw	r30, r6
    bc2a:	82 85       	ldd	r24, Z+10	; 0x0a
    bc2c:	93 85       	ldd	r25, Z+11	; 0x0b
    bc2e:	a4 85       	ldd	r26, Z+12	; 0x0c
    bc30:	b5 85       	ldd	r27, Z+13	; 0x0d
    bc32:	b6 95       	lsr	r27
    bc34:	a7 95       	ror	r26
    bc36:	97 95       	ror	r25
    bc38:	87 95       	ror	r24
    bc3a:	9c 83       	std	Y+4, r25	; 0x04
    bc3c:	8b 83       	std	Y+3, r24	; 0x03
    bc3e:	4a 01       	movw	r8, r20
    bc40:	cc 24       	eor	r12, r12
    bc42:	dd 24       	eor	r13, r13
    bc44:	42 e0       	ldi	r20, 0x02	; 2
    bc46:	a4 2e       	mov	r10, r20
    bc48:	b1 2c       	mov	r11, r1
    bc4a:	41 c0       	rjmp	.+130    	; 0xbcce <fat_append_clusters+0xe4>
                return 0;
        }
        else
#endif
        {
            if(!device_read(fat_offset + cluster_new * sizeof(fat_entry16), (uint8_t*) &fat_entry16, sizeof(fat_entry16)))
    bc4c:	c5 01       	movw	r24, r10
    bc4e:	88 0f       	add	r24, r24
    bc50:	99 1f       	adc	r25, r25
    bc52:	7c 01       	movw	r14, r24
    bc54:	00 e0       	ldi	r16, 0x00	; 0
    bc56:	10 e0       	ldi	r17, 0x00	; 0
    bc58:	2d 81       	ldd	r18, Y+5	; 0x05
    bc5a:	3e 81       	ldd	r19, Y+6	; 0x06
    bc5c:	4f 81       	ldd	r20, Y+7	; 0x07
    bc5e:	58 85       	ldd	r21, Y+8	; 0x08
    bc60:	e2 0e       	add	r14, r18
    bc62:	f3 1e       	adc	r15, r19
    bc64:	04 1f       	adc	r16, r20
    bc66:	15 1f       	adc	r17, r21
    bc68:	c8 01       	movw	r24, r16
    bc6a:	b7 01       	movw	r22, r14
    bc6c:	ae 01       	movw	r20, r28
    bc6e:	4f 5f       	subi	r20, 0xFF	; 255
    bc70:	5f 4f       	sbci	r21, 0xFF	; 255
    bc72:	22 e0       	ldi	r18, 0x02	; 2
    bc74:	30 e0       	ldi	r19, 0x00	; 0
    bc76:	a9 85       	ldd	r26, Y+9	; 0x09
    bc78:	ba 85       	ldd	r27, Y+10	; 0x0a
    bc7a:	fd 01       	movw	r30, r26
    bc7c:	09 95       	icall
    bc7e:	88 23       	and	r24, r24
    bc80:	09 f4       	brne	.+2      	; 0xbc84 <fat_append_clusters+0x9a>
    bc82:	4e c0       	rjmp	.+156    	; 0xbd20 <fat_append_clusters+0x136>
        }
        else
#endif
        {
            /* check if this is a free cluster */
            if(fat_entry16 != HTOL16(FAT16_CLUSTER_FREE))
    bc84:	89 81       	ldd	r24, Y+1	; 0x01
    bc86:	9a 81       	ldd	r25, Y+2	; 0x02
    bc88:	89 2b       	or	r24, r25
    bc8a:	f1 f4       	brne	.+60     	; 0xbcc8 <fat_append_clusters+0xde>
                continue;

            /* allocate cluster */
            if(cluster_next == 0)
    bc8c:	c1 14       	cp	r12, r1
    bc8e:	d1 04       	cpc	r13, r1
    bc90:	29 f4       	brne	.+10     	; 0xbc9c <fat_append_clusters+0xb2>
                fat_entry16 = HTOL16(FAT16_CLUSTER_LAST_MAX);
    bc92:	ef ef       	ldi	r30, 0xFF	; 255
    bc94:	ff ef       	ldi	r31, 0xFF	; 255
    bc96:	fa 83       	std	Y+2, r31	; 0x02
    bc98:	e9 83       	std	Y+1, r30	; 0x01
    bc9a:	02 c0       	rjmp	.+4      	; 0xbca0 <fat_append_clusters+0xb6>
            else
                fat_entry16 = htol16((uint16_t) cluster_next);
    bc9c:	da 82       	std	Y+2, r13	; 0x02
    bc9e:	c9 82       	std	Y+1, r12	; 0x01

            if(!device_write(fat_offset + cluster_new * sizeof(fat_entry16), (uint8_t*) &fat_entry16, sizeof(fat_entry16)))
    bca0:	c8 01       	movw	r24, r16
    bca2:	b7 01       	movw	r22, r14
    bca4:	ae 01       	movw	r20, r28
    bca6:	4f 5f       	subi	r20, 0xFF	; 255
    bca8:	5f 4f       	sbci	r21, 0xFF	; 255
    bcaa:	22 e0       	ldi	r18, 0x02	; 2
    bcac:	30 e0       	ldi	r19, 0x00	; 0
    bcae:	f1 01       	movw	r30, r2
    bcb0:	09 95       	icall
    bcb2:	88 23       	and	r24, r24
    bcb4:	91 f0       	breq	.+36     	; 0xbcda <fat_append_clusters+0xf0>
                break;
        }

        cluster_next = cluster_new;
        if(--count_left == 0)
    bcb6:	08 94       	sec
    bcb8:	81 08       	sbc	r8, r1
    bcba:	91 08       	sbc	r9, r1
    bcbc:	81 14       	cp	r8, r1
    bcbe:	91 04       	cpc	r9, r1
    bcc0:	11 f4       	brne	.+4      	; 0xbcc6 <fat_append_clusters+0xdc>
    bcc2:	65 01       	movw	r12, r10
    bcc4:	0d c0       	rjmp	.+26     	; 0xbce0 <fat_append_clusters+0xf6>
    bcc6:	65 01       	movw	r12, r10
        cluster_max = fs->header.fat_size / sizeof(fat_entry32);
    else
#endif
        cluster_max = fs->header.fat_size / sizeof(fat_entry16);

    for(cluster_t cluster_new = 2; cluster_new < cluster_max; ++cluster_new)
    bcc8:	08 94       	sec
    bcca:	a1 1c       	adc	r10, r1
    bccc:	b1 1c       	adc	r11, r1
    bcce:	2b 81       	ldd	r18, Y+3	; 0x03
    bcd0:	3c 81       	ldd	r19, Y+4	; 0x04
    bcd2:	a2 16       	cp	r10, r18
    bcd4:	b3 06       	cpc	r11, r19
    bcd6:	08 f4       	brcc	.+2      	; 0xbcda <fat_append_clusters+0xf0>
    bcd8:	b9 cf       	rjmp	.-142    	; 0xbc4c <fat_append_clusters+0x62>
            break;
    }

    do
    {
        if(count_left > 0)
    bcda:	81 14       	cp	r8, r1
    bcdc:	91 04       	cpc	r9, r1
    bcde:	e1 f4       	brne	.+56     	; 0xbd18 <fat_append_clusters+0x12e>
            break;

        /* We allocated a new cluster chain. Now join
         * it with the existing one (if any).
         */
        if(cluster_num >= 2)
    bce0:	32 e0       	ldi	r19, 0x02	; 2
    bce2:	43 16       	cp	r4, r19
    bce4:	51 04       	cpc	r5, r1
    bce6:	f0 f0       	brcs	.+60     	; 0xbd24 <fat_append_clusters+0x13a>
                    break;
            }
            else
#endif
            {
                fat_entry16 = htol16((uint16_t) cluster_next);
    bce8:	da 82       	std	Y+2, r13	; 0x02
    bcea:	c9 82       	std	Y+1, r12	; 0x01

                if(!device_write(fat_offset + cluster_num * sizeof(fat_entry16), (uint8_t*) &fat_entry16, sizeof(fat_entry16)))
    bcec:	44 0c       	add	r4, r4
    bcee:	55 1c       	adc	r5, r5
    bcf0:	b2 01       	movw	r22, r4
    bcf2:	80 e0       	ldi	r24, 0x00	; 0
    bcf4:	90 e0       	ldi	r25, 0x00	; 0
    bcf6:	2d 81       	ldd	r18, Y+5	; 0x05
    bcf8:	3e 81       	ldd	r19, Y+6	; 0x06
    bcfa:	4f 81       	ldd	r20, Y+7	; 0x07
    bcfc:	58 85       	ldd	r21, Y+8	; 0x08
    bcfe:	62 0f       	add	r22, r18
    bd00:	73 1f       	adc	r23, r19
    bd02:	84 1f       	adc	r24, r20
    bd04:	95 1f       	adc	r25, r21
    bd06:	ae 01       	movw	r20, r28
    bd08:	4f 5f       	subi	r20, 0xFF	; 255
    bd0a:	5f 4f       	sbci	r21, 0xFF	; 255
    bd0c:	22 e0       	ldi	r18, 0x02	; 2
    bd0e:	30 e0       	ldi	r19, 0x00	; 0
    bd10:	f1 01       	movw	r30, r2
    bd12:	09 95       	icall
    bd14:	88 23       	and	r24, r24
    bd16:	31 f4       	brne	.+12     	; 0xbd24 <fat_append_clusters+0x13a>
    } while(0);

    /* No space left on device or writing error.
     * Free up all clusters already allocated.
     */
    fat_free_clusters(fs, cluster_next);
    bd18:	c3 01       	movw	r24, r6
    bd1a:	b6 01       	movw	r22, r12
    bd1c:	0e 94 9b 5d 	call	0xbb36	; 0xbb36 <fat_free_clusters>

    return 0;
    bd20:	cc 24       	eor	r12, r12
    bd22:	dd 24       	eor	r13, r13
}
    bd24:	c6 01       	movw	r24, r12
    bd26:	2a 96       	adiw	r28, 0x0a	; 10
    bd28:	e2 e1       	ldi	r30, 0x12	; 18
    bd2a:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000bd2e <fat_clear_cluster_callback>:
 * Callback function for clearing a cluster.
 */
uintptr_t fat_clear_cluster_callback(uint8_t* buffer, offset_t offset, void* p)
{
    return 16;
}
    bd2e:	80 e1       	ldi	r24, 0x10	; 16
    bd30:	90 e0       	ldi	r25, 0x00	; 0
    bd32:	08 95       	ret

0000bd34 <fat_read_file>:
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat_write_file
 */
intptr_t fat_read_file(struct fat_file_struct* fd, uint8_t* buffer, uintptr_t buffer_len)
{
    bd34:	aa e0       	ldi	r26, 0x0A	; 10
    bd36:	b0 e0       	ldi	r27, 0x00	; 0
    bd38:	e0 ea       	ldi	r30, 0xA0	; 160
    bd3a:	fe e5       	ldi	r31, 0x5E	; 94
    bd3c:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    bd40:	2c 01       	movw	r4, r24
    bd42:	7a 83       	std	Y+2, r23	; 0x02
    bd44:	69 83       	std	Y+1, r22	; 0x01
    bd46:	5c 83       	std	Y+4, r21	; 0x04
    bd48:	4b 83       	std	Y+3, r20	; 0x03
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
    bd4a:	00 97       	sbiw	r24, 0x00	; 0
    bd4c:	09 f4       	brne	.+2      	; 0xbd50 <fat_read_file+0x1c>
    bd4e:	09 c1       	rjmp	.+530    	; 0xbf62 <fat_read_file+0x22e>
    bd50:	67 2b       	or	r22, r23
    bd52:	09 f4       	brne	.+2      	; 0xbd56 <fat_read_file+0x22>
    bd54:	06 c1       	rjmp	.+524    	; 0xbf62 <fat_read_file+0x22e>
    bd56:	45 2b       	or	r20, r21
    bd58:	09 f4       	brne	.+2      	; 0xbd5c <fat_read_file+0x28>
    bd5a:	03 c1       	rjmp	.+518    	; 0xbf62 <fat_read_file+0x22e>
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
    bd5c:	dc 01       	movw	r26, r24
    bd5e:	9d 96       	adiw	r26, 0x2d	; 45
    bd60:	ad 90       	ld	r10, X+
    bd62:	bd 90       	ld	r11, X+
    bd64:	cd 90       	ld	r12, X+
    bd66:	dc 90       	ld	r13, X
    bd68:	d0 97       	sbiw	r26, 0x30	; 48
    bd6a:	95 96       	adiw	r26, 0x25	; 37
    bd6c:	2d 91       	ld	r18, X+
    bd6e:	3d 91       	ld	r19, X+
    bd70:	4d 91       	ld	r20, X+
    bd72:	5c 91       	ld	r21, X
    bd74:	98 97       	sbiw	r26, 0x28	; 40
    bd76:	eb 81       	ldd	r30, Y+3	; 0x03
    bd78:	fc 81       	ldd	r31, Y+4	; 0x04
    bd7a:	cf 01       	movw	r24, r30
    bd7c:	a0 e0       	ldi	r26, 0x00	; 0
    bd7e:	b0 e0       	ldi	r27, 0x00	; 0
    bd80:	8a 0d       	add	r24, r10
    bd82:	9b 1d       	adc	r25, r11
    bd84:	ac 1d       	adc	r26, r12
    bd86:	bd 1d       	adc	r27, r13
    bd88:	28 17       	cp	r18, r24
    bd8a:	39 07       	cpc	r19, r25
    bd8c:	4a 07       	cpc	r20, r26
    bd8e:	5b 07       	cpc	r21, r27
    bd90:	40 f4       	brcc	.+16     	; 0xbda2 <fat_read_file+0x6e>
        buffer_len = fd->dir_entry.file_size - fd->pos;
    bd92:	b9 01       	movw	r22, r18
    bd94:	6a 19       	sub	r22, r10
    bd96:	7b 09       	sbc	r23, r11
    bd98:	7c 83       	std	Y+4, r23	; 0x04
    bd9a:	6b 83       	std	Y+3, r22	; 0x03
    if(buffer_len == 0)
    bd9c:	67 2b       	or	r22, r23
    bd9e:	09 f4       	brne	.+2      	; 0xbda2 <fat_read_file+0x6e>
    bda0:	e3 c0       	rjmp	.+454    	; 0xbf68 <fat_read_file+0x234>
        return 0;
    
    uint16_t cluster_size = fd->fs->header.cluster_size;
    bda2:	d2 01       	movw	r26, r4
    bda4:	ed 91       	ld	r30, X+
    bda6:	fc 91       	ld	r31, X
    bda8:	11 97       	sbiw	r26, 0x01	; 1
    bdaa:	20 88       	ldd	r2, Z+16	; 0x10
    bdac:	31 88       	ldd	r3, Z+17	; 0x11
    cluster_t cluster_num = fd->pos_cluster;
    bdae:	d1 96       	adiw	r26, 0x31	; 49
    bdb0:	ed 91       	ld	r30, X+
    bdb2:	fc 91       	ld	r31, X
    bdb4:	d2 97       	sbiw	r26, 0x32	; 50
    bdb6:	fa 87       	std	Y+10, r31	; 0x0a
    bdb8:	e9 87       	std	Y+9, r30	; 0x09
    uintptr_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));

    /* find cluster in which to start reading */
    if(!cluster_num)
    bdba:	ef 2b       	or	r30, r31
    bdbc:	f1 f5       	brne	.+124    	; 0xbe3a <fat_read_file+0x106>
    {
        cluster_num = fd->dir_entry.cluster;
    bdbe:	93 96       	adiw	r26, 0x23	; 35
    bdc0:	2d 91       	ld	r18, X+
    bdc2:	3c 91       	ld	r19, X
    bdc4:	94 97       	sbiw	r26, 0x24	; 36
    bdc6:	3a 87       	std	Y+10, r19	; 0x0a
    bdc8:	29 87       	std	Y+9, r18	; 0x09
        
        if(!cluster_num)
    bdca:	23 2b       	or	r18, r19
    bdcc:	39 f4       	brne	.+14     	; 0xbddc <fat_read_file+0xa8>
        {
            if(!fd->pos)
    bdce:	a1 14       	cp	r10, r1
    bdd0:	b1 04       	cpc	r11, r1
    bdd2:	c1 04       	cpc	r12, r1
    bdd4:	d1 04       	cpc	r13, r1
    bdd6:	09 f4       	brne	.+2      	; 0xbdda <fat_read_file+0xa6>
    bdd8:	c7 c0       	rjmp	.+398    	; 0xbf68 <fat_read_file+0x234>
    bdda:	c3 c0       	rjmp	.+390    	; 0xbf62 <fat_read_file+0x22e>
                return 0;
            else
                return -1;
        }

        if(fd->pos)
    bddc:	a1 14       	cp	r10, r1
    bdde:	b1 04       	cpc	r11, r1
    bde0:	c1 04       	cpc	r12, r1
    bde2:	d1 04       	cpc	r13, r1
    bde4:	51 f1       	breq	.+84     	; 0xbe3a <fat_read_file+0x106>
    bde6:	86 01       	movw	r16, r12
    bde8:	75 01       	movw	r14, r10
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
    bdea:	31 01       	movw	r6, r2
    bdec:	88 24       	eor	r8, r8
    bdee:	99 24       	eor	r9, r9
            {
                pos -= cluster_size;
                cluster_num = fat_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num)
    bdf0:	66 27       	eor	r22, r22
    bdf2:	77 27       	eor	r23, r23
    bdf4:	cb 01       	movw	r24, r22
    bdf6:	66 19       	sub	r22, r6
    bdf8:	77 09       	sbc	r23, r7
    bdfa:	88 09       	sbc	r24, r8
    bdfc:	99 09       	sbc	r25, r9
    bdfe:	6d 83       	std	Y+5, r22	; 0x05
    be00:	7e 83       	std	Y+6, r23	; 0x06
    be02:	8f 83       	std	Y+7, r24	; 0x07
    be04:	98 87       	std	Y+8, r25	; 0x08
    be06:	14 c0       	rjmp	.+40     	; 0xbe30 <fat_read_file+0xfc>
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat_get_next_cluster(fd->fs, cluster_num);
    be08:	d2 01       	movw	r26, r4
    be0a:	8d 91       	ld	r24, X+
    be0c:	9c 91       	ld	r25, X
    be0e:	69 85       	ldd	r22, Y+9	; 0x09
    be10:	7a 85       	ldd	r23, Y+10	; 0x0a
    be12:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
    be16:	9a 87       	std	Y+10, r25	; 0x0a
    be18:	89 87       	std	Y+9, r24	; 0x09
                if(!cluster_num)
    be1a:	89 2b       	or	r24, r25
    be1c:	09 f4       	brne	.+2      	; 0xbe20 <fat_read_file+0xec>
    be1e:	a1 c0       	rjmp	.+322    	; 0xbf62 <fat_read_file+0x22e>
    be20:	6d 81       	ldd	r22, Y+5	; 0x05
    be22:	7e 81       	ldd	r23, Y+6	; 0x06
    be24:	8f 81       	ldd	r24, Y+7	; 0x07
    be26:	98 85       	ldd	r25, Y+8	; 0x08
    be28:	e6 0e       	add	r14, r22
    be2a:	f7 1e       	adc	r15, r23
    be2c:	08 1f       	adc	r16, r24
    be2e:	19 1f       	adc	r17, r25
        }

        if(fd->pos)
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
    be30:	e6 14       	cp	r14, r6
    be32:	f7 04       	cpc	r15, r7
    be34:	08 05       	cpc	r16, r8
    be36:	19 05       	cpc	r17, r9
    be38:	38 f7       	brcc	.-50     	; 0xbe08 <fat_read_file+0xd4>
        return 0;
    
    uint16_t cluster_size = fd->fs->header.cluster_size;
    cluster_t cluster_num = fd->pos_cluster;
    uintptr_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));
    be3a:	08 94       	sec
    be3c:	21 08       	sbc	r2, r1
    be3e:	31 08       	sbc	r3, r1
    be40:	a2 20       	and	r10, r2
    be42:	b3 20       	and	r11, r3
    be44:	08 94       	sec
    be46:	21 1c       	adc	r2, r1
    be48:	31 1c       	adc	r3, r1
    be4a:	cb 80       	ldd	r12, Y+3	; 0x03
    be4c:	dc 80       	ldd	r13, Y+4	; 0x04
    
    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
    be4e:	d2 01       	movw	r26, r4
    be50:	ed 90       	ld	r14, X+
    be52:	fc 90       	ld	r15, X
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    if(!fs || cluster_num < 2)
    be54:	e1 14       	cp	r14, r1
    be56:	f1 04       	cpc	r15, r1
    be58:	09 f1       	breq	.+66     	; 0xbe9c <fat_read_file+0x168>
    be5a:	e9 85       	ldd	r30, Y+9	; 0x09
    be5c:	fa 85       	ldd	r31, Y+10	; 0x0a
    be5e:	e2 30       	cpi	r30, 0x02	; 2
    be60:	f1 05       	cpc	r31, r1
    be62:	e0 f0       	brcs	.+56     	; 0xbe9c <fat_read_file+0x168>
        return 0;

    return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
    be64:	32 97       	sbiw	r30, 0x02	; 2
    be66:	bf 01       	movw	r22, r30
    be68:	80 e0       	ldi	r24, 0x00	; 0
    be6a:	90 e0       	ldi	r25, 0x00	; 0
    be6c:	32 96       	adiw	r30, 0x02	; 2
    be6e:	fa 87       	std	Y+10, r31	; 0x0a
    be70:	e9 87       	std	Y+9, r30	; 0x09
    be72:	d7 01       	movw	r26, r14
    be74:	50 96       	adiw	r26, 0x10	; 16
    be76:	2d 91       	ld	r18, X+
    be78:	3c 91       	ld	r19, X
    be7a:	51 97       	sbiw	r26, 0x11	; 17
    be7c:	40 e0       	ldi	r20, 0x00	; 0
    be7e:	50 e0       	ldi	r21, 0x00	; 0
    be80:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    be84:	9b 01       	movw	r18, r22
    be86:	ac 01       	movw	r20, r24
    be88:	f7 01       	movw	r30, r14
    be8a:	82 89       	ldd	r24, Z+18	; 0x12
    be8c:	93 89       	ldd	r25, Z+19	; 0x13
    be8e:	a4 89       	ldd	r26, Z+20	; 0x14
    be90:	b5 89       	ldd	r27, Z+21	; 0x15
    be92:	28 0f       	add	r18, r24
    be94:	39 1f       	adc	r19, r25
    be96:	4a 1f       	adc	r20, r26
    be98:	5b 1f       	adc	r21, r27
    be9a:	04 c0       	rjmp	.+8      	; 0xbea4 <fat_read_file+0x170>
    be9c:	20 e0       	ldi	r18, 0x00	; 0
    be9e:	30 e0       	ldi	r19, 0x00	; 0
    bea0:	40 e0       	ldi	r20, 0x00	; 0
    bea2:	50 e0       	ldi	r21, 0x00	; 0
    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
    bea4:	81 01       	movw	r16, r2
    bea6:	0a 19       	sub	r16, r10
    bea8:	1b 09       	sbc	r17, r11
    beaa:	c0 16       	cp	r12, r16
    beac:	d1 06       	cpc	r13, r17
    beae:	08 f4       	brcc	.+2      	; 0xbeb2 <fat_read_file+0x17e>
    beb0:	86 01       	movw	r16, r12
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
    beb2:	d7 01       	movw	r26, r14
    beb4:	ed 91       	ld	r30, X+
    beb6:	fc 91       	ld	r31, X
    beb8:	c5 01       	movw	r24, r10
    beba:	a0 e0       	ldi	r26, 0x00	; 0
    bebc:	b0 e0       	ldi	r27, 0x00	; 0
    bebe:	28 0f       	add	r18, r24
    bec0:	39 1f       	adc	r19, r25
    bec2:	4a 1f       	adc	r20, r26
    bec4:	5b 1f       	adc	r21, r27
    bec6:	01 90       	ld	r0, Z+
    bec8:	f0 81       	ld	r31, Z
    beca:	e0 2d       	mov	r30, r0
    becc:	ca 01       	movw	r24, r20
    bece:	b9 01       	movw	r22, r18
    bed0:	49 81       	ldd	r20, Y+1	; 0x01
    bed2:	5a 81       	ldd	r21, Y+2	; 0x02
    bed4:	98 01       	movw	r18, r16
    bed6:	09 95       	icall
    bed8:	88 23       	and	r24, r24
    beda:	41 f1       	breq	.+80     	; 0xbf2c <fat_read_file+0x1f8>
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
    bedc:	c0 1a       	sub	r12, r16
    bede:	d1 0a       	sbc	r13, r17
        fd->pos += copy_length;
    bee0:	c8 01       	movw	r24, r16
    bee2:	a0 e0       	ldi	r26, 0x00	; 0
    bee4:	b0 e0       	ldi	r27, 0x00	; 0
    bee6:	f2 01       	movw	r30, r4
    bee8:	25 a5       	ldd	r18, Z+45	; 0x2d
    beea:	36 a5       	ldd	r19, Z+46	; 0x2e
    beec:	47 a5       	ldd	r20, Z+47	; 0x2f
    beee:	50 a9       	ldd	r21, Z+48	; 0x30
    bef0:	28 0f       	add	r18, r24
    bef2:	39 1f       	adc	r19, r25
    bef4:	4a 1f       	adc	r20, r26
    bef6:	5b 1f       	adc	r21, r27
    bef8:	d2 01       	movw	r26, r4
    befa:	9d 96       	adiw	r26, 0x2d	; 45
    befc:	2d 93       	st	X+, r18
    befe:	3d 93       	st	X+, r19
    bf00:	4d 93       	st	X+, r20
    bf02:	5c 93       	st	X, r21
    bf04:	d0 97       	sbiw	r26, 0x30	; 48

        if(first_cluster_offset + copy_length >= cluster_size)
    bf06:	c8 01       	movw	r24, r16
    bf08:	8a 0d       	add	r24, r10
    bf0a:	9b 1d       	adc	r25, r11
    bf0c:	82 15       	cp	r24, r2
    bf0e:	93 05       	cpc	r25, r3
    bf10:	a0 f0       	brcs	.+40     	; 0xbf3a <fat_read_file+0x206>
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat_get_next_cluster(fd->fs, cluster_num)))
    bf12:	8d 91       	ld	r24, X+
    bf14:	9c 91       	ld	r25, X
    bf16:	69 85       	ldd	r22, Y+9	; 0x09
    bf18:	7a 85       	ldd	r23, Y+10	; 0x0a
    bf1a:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
    bf1e:	9a 87       	std	Y+10, r25	; 0x0a
    bf20:	89 87       	std	Y+9, r24	; 0x09
    bf22:	89 2b       	or	r24, r25
    bf24:	41 f4       	brne	.+16     	; 0xbf36 <fat_read_file+0x202>
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
    bf26:	f2 01       	movw	r30, r4
    bf28:	12 aa       	std	Z+50, r1	; 0x32
    bf2a:	11 aa       	std	Z+49, r1	; 0x31
                return buffer_len - buffer_left;
    bf2c:	4b 81       	ldd	r20, Y+3	; 0x03
    bf2e:	5c 81       	ldd	r21, Y+4	; 0x04
    bf30:	4c 19       	sub	r20, r12
    bf32:	5d 09       	sbc	r21, r13
    bf34:	1b c0       	rjmp	.+54     	; 0xbf6c <fat_read_file+0x238>
    bf36:	aa 24       	eor	r10, r10
    bf38:	bb 24       	eor	r11, r11
            }
        }

        fd->pos_cluster = cluster_num;
    bf3a:	e9 85       	ldd	r30, Y+9	; 0x09
    bf3c:	fa 85       	ldd	r31, Y+10	; 0x0a
    bf3e:	d2 01       	movw	r26, r4
    bf40:	d2 96       	adiw	r26, 0x32	; 50
    bf42:	fc 93       	st	X, r31
    bf44:	ee 93       	st	-X, r30
    bf46:	d1 97       	sbiw	r26, 0x31	; 49

    } while(buffer_left > 0); /* check if we are done */
    bf48:	c1 14       	cp	r12, r1
    bf4a:	d1 04       	cpc	r13, r1
    bf4c:	39 f0       	breq	.+14     	; 0xbf5c <fat_read_file+0x228>
        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
    bf4e:	29 81       	ldd	r18, Y+1	; 0x01
    bf50:	3a 81       	ldd	r19, Y+2	; 0x02
    bf52:	20 0f       	add	r18, r16
    bf54:	31 1f       	adc	r19, r17
    bf56:	3a 83       	std	Y+2, r19	; 0x02
    bf58:	29 83       	std	Y+1, r18	; 0x01
    bf5a:	79 cf       	rjmp	.-270    	; 0xbe4e <fat_read_file+0x11a>

        fd->pos_cluster = cluster_num;

    } while(buffer_left > 0); /* check if we are done */

    return buffer_len;
    bf5c:	4b 81       	ldd	r20, Y+3	; 0x03
    bf5e:	5c 81       	ldd	r21, Y+4	; 0x04
    bf60:	05 c0       	rjmp	.+10     	; 0xbf6c <fat_read_file+0x238>
    bf62:	4f ef       	ldi	r20, 0xFF	; 255
    bf64:	5f ef       	ldi	r21, 0xFF	; 255
    bf66:	02 c0       	rjmp	.+4      	; 0xbf6c <fat_read_file+0x238>
    bf68:	40 e0       	ldi	r20, 0x00	; 0
    bf6a:	50 e0       	ldi	r21, 0x00	; 0
}
    bf6c:	ca 01       	movw	r24, r20
    bf6e:	2a 96       	adiw	r28, 0x0a	; 10
    bf70:	e2 e1       	ldi	r30, 0x12	; 18
    bf72:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000bf76 <fat_reset_dir>:
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat_read_dir
 */
uint8_t fat_reset_dir(struct fat_dir_struct* dd)
{
    bf76:	fc 01       	movw	r30, r24
    if(!dd)
    bf78:	00 97       	sbiw	r24, 0x00	; 0
    bf7a:	11 f4       	brne	.+4      	; 0xbf80 <fat_reset_dir+0xa>
    bf7c:	80 e0       	ldi	r24, 0x00	; 0
    bf7e:	08 95       	ret
        return 0;

    dd->entry_cluster = dd->dir_entry.cluster;
    bf80:	83 a1       	ldd	r24, Z+35	; 0x23
    bf82:	94 a1       	ldd	r25, Z+36	; 0x24
    bf84:	96 a7       	std	Z+46, r25	; 0x2e
    bf86:	85 a7       	std	Z+45, r24	; 0x2d
    dd->entry_offset = 0;
    bf88:	10 aa       	std	Z+48, r1	; 0x30
    bf8a:	17 a6       	std	Z+47, r1	; 0x2f
    bf8c:	81 e0       	ldi	r24, 0x01	; 1
    return 1;
}
    bf8e:	08 95       	ret

0000bf90 <fat_dir_entry_read_callback>:
/**
 * \ingroup fat_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat_dir_entry_read_callback(uint8_t* buffer, offset_t offset, void* p)
{
    bf90:	a0 e0       	ldi	r26, 0x00	; 0
    bf92:	b0 e0       	ldi	r27, 0x00	; 0
    bf94:	ee ec       	ldi	r30, 0xCE	; 206
    bf96:	ff e5       	ldi	r31, 0x5F	; 95
    bf98:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    bf9c:	8c 01       	movw	r16, r24
    bf9e:	6a 01       	movw	r12, r20
    bfa0:	7b 01       	movw	r14, r22
    struct fat_read_dir_callback_arg* arg = p;
    bfa2:	a9 01       	movw	r20, r18
    struct fat_dir_entry_struct* dir_entry = arg->dir_entry;
    bfa4:	d9 01       	movw	r26, r18
    bfa6:	cd 91       	ld	r28, X+
    bfa8:	dc 91       	ld	r29, X
    bfaa:	11 97       	sbiw	r26, 0x01	; 1

    arg->bytes_read += 32;
    bfac:	12 96       	adiw	r26, 0x02	; 2
    bfae:	8d 91       	ld	r24, X+
    bfb0:	9c 91       	ld	r25, X
    bfb2:	13 97       	sbiw	r26, 0x03	; 3
    bfb4:	80 96       	adiw	r24, 0x20	; 32
    bfb6:	13 96       	adiw	r26, 0x03	; 3
    bfb8:	9c 93       	st	X, r25
    bfba:	8e 93       	st	-X, r24
    bfbc:	12 97       	sbiw	r26, 0x02	; 2

    /* skip deleted or empty entries */
    if(buffer[0] == FAT_DIRENTRY_DELETED || !buffer[0])
    bfbe:	f8 01       	movw	r30, r16
    bfc0:	80 81       	ld	r24, Z
    bfc2:	85 3e       	cpi	r24, 0xE5	; 229
    bfc4:	09 f4       	brne	.+2      	; 0xbfc8 <fat_dir_entry_read_callback+0x38>
    bfc6:	aa c0       	rjmp	.+340    	; 0xc11c <fat_dir_entry_read_callback+0x18c>
    bfc8:	88 23       	and	r24, r24
    bfca:	09 f4       	brne	.+2      	; 0xbfce <fat_dir_entry_read_callback+0x3e>
    bfcc:	a7 c0       	rjmp	.+334    	; 0xc11c <fat_dir_entry_read_callback+0x18c>
        return 1;

    if(!dir_entry->entry_offset)
    bfce:	8f a1       	ldd	r24, Y+39	; 0x27
    bfd0:	98 a5       	ldd	r25, Y+40	; 0x28
    bfd2:	a9 a5       	ldd	r26, Y+41	; 0x29
    bfd4:	ba a5       	ldd	r27, Y+42	; 0x2a
    bfd6:	00 97       	sbiw	r24, 0x00	; 0
    bfd8:	a1 05       	cpc	r26, r1
    bfda:	b1 05       	cpc	r27, r1
    bfdc:	21 f4       	brne	.+8      	; 0xbfe6 <fat_dir_entry_read_callback+0x56>
        dir_entry->entry_offset = offset;
    bfde:	cf a2       	std	Y+39, r12	; 0x27
    bfe0:	d8 a6       	std	Y+40, r13	; 0x28
    bfe2:	e9 a6       	std	Y+41, r14	; 0x29
    bfe4:	fa a6       	std	Y+42, r15	; 0x2a
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat_interpret_dir_entry(struct fat_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
    bfe6:	20 97       	sbiw	r28, 0x00	; 0
    bfe8:	09 f4       	brne	.+2      	; 0xbfec <fat_dir_entry_read_callback+0x5c>
    bfea:	9a c0       	rjmp	.+308    	; 0xc120 <fat_dir_entry_read_callback+0x190>
    bfec:	01 15       	cp	r16, r1
    bfee:	11 05       	cpc	r17, r1
    bff0:	09 f4       	brne	.+2      	; 0xbff4 <fat_dir_entry_read_callback+0x64>
    bff2:	96 c0       	rjmp	.+300    	; 0xc120 <fat_dir_entry_read_callback+0x190>
    bff4:	d8 01       	movw	r26, r16
    bff6:	9c 91       	ld	r25, X
    bff8:	99 23       	and	r25, r25
    bffa:	09 f4       	brne	.+2      	; 0xbffe <fat_dir_entry_read_callback+0x6e>
    bffc:	91 c0       	rjmp	.+290    	; 0xc120 <fat_dir_entry_read_callback+0x190>
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
    bffe:	1b 96       	adiw	r26, 0x0b	; 11
    c000:	8c 91       	ld	r24, X
    c002:	8f 30       	cpi	r24, 0x0F	; 15
    c004:	29 f5       	brne	.+74     	; 0xc050 <fat_dir_entry_read_callback+0xc0>
    {
        /* Lfn supports unicode, but we do not, for now.
         * So we assume pure ascii and read only every
         * second byte.
         */
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
    c006:	89 2f       	mov	r24, r25
    c008:	90 e0       	ldi	r25, 0x00	; 0
    c00a:	8f 73       	andi	r24, 0x3F	; 63
    c00c:	90 70       	andi	r25, 0x00	; 0
    c00e:	2d e0       	ldi	r18, 0x0D	; 13
    c010:	30 e0       	ldi	r19, 0x00	; 0
    c012:	82 9f       	mul	r24, r18
    c014:	a0 01       	movw	r20, r0
    c016:	83 9f       	mul	r24, r19
    c018:	50 0d       	add	r21, r0
    c01a:	92 9f       	mul	r25, r18
    c01c:	50 0d       	add	r21, r0
    c01e:	11 24       	eor	r1, r1
    c020:	4d 50       	subi	r20, 0x0D	; 13
    c022:	50 40       	sbci	r21, 0x00	; 0
    c024:	a8 eb       	ldi	r26, 0xB8	; 184
    c026:	b1 e0       	ldi	r27, 0x01	; 1
    c028:	c4 0f       	add	r28, r20
    c02a:	d5 1f       	adc	r29, r21
    c02c:	0d c0       	rjmp	.+26     	; 0xc048 <fat_dir_entry_read_callback+0xb8>
        const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
        for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
            long_name[char_offset + i] = raw_entry[char_mapping[i]];
    c02e:	8d 91       	ld	r24, X+
    c030:	f8 01       	movw	r30, r16
    c032:	e8 0f       	add	r30, r24
    c034:	f1 1d       	adc	r31, r1
    c036:	80 81       	ld	r24, Z
    c038:	89 93       	st	Y+, r24
    c03a:	4f 5f       	subi	r20, 0xFF	; 255
    c03c:	5f 4f       	sbci	r21, 0xFF	; 255
         * So we assume pure ascii and read only every
         * second byte.
         */
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
        const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
        for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
    c03e:	e1 e0       	ldi	r30, 0x01	; 1
    c040:	a5 3c       	cpi	r26, 0xC5	; 197
    c042:	be 07       	cpc	r27, r30
    c044:	09 f4       	brne	.+2      	; 0xc048 <fat_dir_entry_read_callback+0xb8>
    c046:	6a c0       	rjmp	.+212    	; 0xc11c <fat_dir_entry_read_callback+0x18c>
    c048:	4f 31       	cpi	r20, 0x1F	; 31
    c04a:	51 05       	cpc	r21, r1
    c04c:	80 f3       	brcs	.-32     	; 0xc02e <fat_dir_entry_read_callback+0x9e>
    c04e:	66 c0       	rjmp	.+204    	; 0xc11c <fat_dir_entry_read_callback+0x18c>
        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
    c050:	88 81       	ld	r24, Y
    c052:	88 23       	and	r24, r24
    c054:	09 f0       	breq	.+2      	; 0xc058 <fat_dir_entry_read_callback+0xc8>
    c056:	4e c0       	rjmp	.+156    	; 0xc0f4 <fat_dir_entry_read_callback+0x164>
    c058:	b8 01       	movw	r22, r16
    c05a:	de 01       	movw	r26, r28
    c05c:	78 01       	movw	r14, r16
    c05e:	20 e0       	ldi	r18, 0x00	; 0
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
    c060:	f7 01       	movw	r30, r14
    c062:	90 81       	ld	r25, Z
    c064:	90 32       	cpi	r25, 0x20	; 32
    c066:	a1 f0       	breq	.+40     	; 0xc090 <fat_dir_entry_read_callback+0x100>
                    break;
                long_name[i] = raw_entry[i];
    c068:	9c 93       	st	X, r25
                /* Windows NT and later versions do not store LFN entries
                 * for 8.3 names which have a lowercase basename, extension
                 * or both when everything else is uppercase. They use two
                 * extra bits to signal a lowercase basename or extension.
                 */
                if((raw_entry[12] & 0x08) && raw_entry[i] >= 'A' && raw_entry[i] <= 'Z')
    c06a:	f8 01       	movw	r30, r16
    c06c:	84 85       	ldd	r24, Z+12	; 0x0c
    c06e:	83 ff       	sbrs	r24, 3
    c070:	08 c0       	rjmp	.+16     	; 0xc082 <fat_dir_entry_read_callback+0xf2>
    c072:	f7 01       	movw	r30, r14
    c074:	80 81       	ld	r24, Z
    c076:	81 34       	cpi	r24, 0x41	; 65
    c078:	20 f0       	brcs	.+8      	; 0xc082 <fat_dir_entry_read_callback+0xf2>
    c07a:	8b 35       	cpi	r24, 0x5B	; 91
    c07c:	10 f4       	brcc	.+4      	; 0xc082 <fat_dir_entry_read_callback+0xf2>
                    long_name[i] += 'a' - 'A';
    c07e:	90 5e       	subi	r25, 0xE0	; 224
    c080:	9c 93       	st	X, r25
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
    c082:	2f 5f       	subi	r18, 0xFF	; 255
    c084:	08 94       	sec
    c086:	e1 1c       	adc	r14, r1
    c088:	f1 1c       	adc	r15, r1
    c08a:	11 96       	adiw	r26, 0x01	; 1
    c08c:	28 30       	cpi	r18, 0x08	; 8
    c08e:	41 f7       	brne	.-48     	; 0xc060 <fat_dir_entry_read_callback+0xd0>
                 * extra bits to signal a lowercase basename or extension.
                 */
                if((raw_entry[12] & 0x08) && raw_entry[i] >= 'A' && raw_entry[i] <= 'Z')
                    long_name[i] += 'a' - 'A';
            }
            if(long_name[0] == 0x05)
    c090:	88 81       	ld	r24, Y
    c092:	85 30       	cpi	r24, 0x05	; 5
    c094:	11 f4       	brne	.+4      	; 0xc09a <fat_dir_entry_read_callback+0x10a>
                long_name[0] = (char) FAT_DIRENTRY_DELETED;
    c096:	85 ee       	ldi	r24, 0xE5	; 229
    c098:	88 83       	st	Y, r24

            if(raw_entry[8] != ' ')
    c09a:	d8 01       	movw	r26, r16
    c09c:	18 96       	adiw	r26, 0x08	; 8
    c09e:	8c 91       	ld	r24, X
    c0a0:	80 32       	cpi	r24, 0x20	; 32
    c0a2:	21 f1       	breq	.+72     	; 0xc0ec <fat_dir_entry_read_callback+0x15c>
            {
                long_name[i++] = '.';
    c0a4:	fe 01       	movw	r30, r28
    c0a6:	e2 0f       	add	r30, r18
    c0a8:	f1 1d       	adc	r31, r1
    c0aa:	8e e2       	ldi	r24, 0x2E	; 46
    c0ac:	80 83       	st	Z, r24
    c0ae:	32 2f       	mov	r19, r18
    c0b0:	3f 5f       	subi	r19, 0xFF	; 255

                uint8_t j = 8;
                for(; j < 11; ++j)
    c0b2:	2c 5f       	subi	r18, 0xFC	; 252
                {
                    if(raw_entry[j] == ' ')
    c0b4:	fb 01       	movw	r30, r22
    c0b6:	90 85       	ldd	r25, Z+8	; 0x08
    c0b8:	90 32       	cpi	r25, 0x20	; 32
    c0ba:	b9 f0       	breq	.+46     	; 0xc0ea <fat_dir_entry_read_callback+0x15a>
                        break;
                    long_name[i] = raw_entry[j];
    c0bc:	fe 01       	movw	r30, r28
    c0be:	e3 0f       	add	r30, r19
    c0c0:	f1 1d       	adc	r31, r1
    c0c2:	90 83       	st	Z, r25

                    /* See above for the lowercase 8.3 name handling of
                     * Windows NT and later.
                     */
                    if((raw_entry[12] & 0x10) && raw_entry[j] >= 'A' && raw_entry[j] <= 'Z')
    c0c4:	d8 01       	movw	r26, r16
    c0c6:	1c 96       	adiw	r26, 0x0c	; 12
    c0c8:	8c 91       	ld	r24, X
    c0ca:	84 ff       	sbrs	r24, 4
    c0cc:	09 c0       	rjmp	.+18     	; 0xc0e0 <fat_dir_entry_read_callback+0x150>
    c0ce:	db 01       	movw	r26, r22
    c0d0:	18 96       	adiw	r26, 0x08	; 8
    c0d2:	8c 91       	ld	r24, X
    c0d4:	81 34       	cpi	r24, 0x41	; 65
    c0d6:	20 f0       	brcs	.+8      	; 0xc0e0 <fat_dir_entry_read_callback+0x150>
    c0d8:	8b 35       	cpi	r24, 0x5B	; 91
    c0da:	10 f4       	brcc	.+4      	; 0xc0e0 <fat_dir_entry_read_callback+0x150>
                        long_name[i] += 'a' - 'A';
    c0dc:	90 5e       	subi	r25, 0xE0	; 224
    c0de:	90 83       	st	Z, r25

                    ++i;
    c0e0:	3f 5f       	subi	r19, 0xFF	; 255
    c0e2:	6f 5f       	subi	r22, 0xFF	; 255
    c0e4:	7f 4f       	sbci	r23, 0xFF	; 255
            if(raw_entry[8] != ' ')
            {
                long_name[i++] = '.';

                uint8_t j = 8;
                for(; j < 11; ++j)
    c0e6:	32 17       	cp	r19, r18
    c0e8:	29 f7       	brne	.-54     	; 0xc0b4 <fat_dir_entry_read_callback+0x124>
    c0ea:	23 2f       	mov	r18, r19

                    ++i;
                }
            } 

            long_name[i] = '\0';
    c0ec:	fe 01       	movw	r30, r28
    c0ee:	e2 0f       	add	r30, r18
    c0f0:	f1 1d       	adc	r31, r1
    c0f2:	10 82       	st	Z, r1
        }
        
        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
    c0f4:	f8 01       	movw	r30, r16
    c0f6:	83 85       	ldd	r24, Z+11	; 0x0b
    c0f8:	88 a3       	std	Y+32, r24	; 0x20
        dir_entry->cluster = ltoh16(*((uint16_t*) &raw_entry[26]));
    c0fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    c0fc:	93 8d       	ldd	r25, Z+27	; 0x1b
    c0fe:	9a a3       	std	Y+34, r25	; 0x22
    c100:	89 a3       	std	Y+33, r24	; 0x21
#if FAT_FAT32_SUPPORT
        dir_entry->cluster |= ((cluster_t) ltoh16(*((uint16_t*) &raw_entry[20]))) << 16;
#endif
        dir_entry->file_size = ltoh32(*((uint32_t*) &raw_entry[28]));
    c102:	84 8d       	ldd	r24, Z+28	; 0x1c
    c104:	95 8d       	ldd	r25, Z+29	; 0x1d
    c106:	a6 8d       	ldd	r26, Z+30	; 0x1e
    c108:	b7 8d       	ldd	r27, Z+31	; 0x1f
    c10a:	8b a3       	std	Y+35, r24	; 0x23
    c10c:	9c a3       	std	Y+36, r25	; 0x24
    c10e:	ad a3       	std	Y+37, r26	; 0x25
    c110:	be a3       	std	Y+38, r27	; 0x26
        {
            return 1;
        }
        case 2: /* directory entry complete, finish */
        {
            arg->finished = 1;
    c112:	81 e0       	ldi	r24, 0x01	; 1
    c114:	da 01       	movw	r26, r20
    c116:	14 96       	adiw	r26, 0x04	; 4
    c118:	8c 93       	st	X, r24
    c11a:	02 c0       	rjmp	.+4      	; 0xc120 <fat_dir_entry_read_callback+0x190>
            return 0;
    c11c:	81 e0       	ldi	r24, 0x01	; 1
    c11e:	01 c0       	rjmp	.+2      	; 0xc122 <fat_dir_entry_read_callback+0x192>
    c120:	80 e0       	ldi	r24, 0x00	; 0
        }
    }

    return 0;
}
    c122:	cd b7       	in	r28, 0x3d	; 61
    c124:	de b7       	in	r29, 0x3e	; 62
    c126:	e8 e0       	ldi	r30, 0x08	; 8
    c128:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000c12c <fat_clear_cluster>:
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The cluster to clear.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat_clear_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    c12c:	a0 e1       	ldi	r26, 0x10	; 16
    c12e:	b0 e0       	ldi	r27, 0x00	; 0
    c130:	ec e9       	ldi	r30, 0x9C	; 156
    c132:	f0 e6       	ldi	r31, 0x60	; 96
    c134:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    c138:	8c 01       	movw	r16, r24
    if(cluster_num < 2)
    c13a:	62 30       	cpi	r22, 0x02	; 2
    c13c:	71 05       	cpc	r23, r1
    c13e:	10 f4       	brcc	.+4      	; 0xc144 <fat_clear_cluster+0x18>
    c140:	80 e0       	ldi	r24, 0x00	; 0
    c142:	35 c0       	rjmp	.+106    	; 0xc1ae <fat_clear_cluster+0x82>
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    if(!fs || cluster_num < 2)
    c144:	00 97       	sbiw	r24, 0x00	; 0
    c146:	29 f4       	brne	.+10     	; 0xc152 <fat_clear_cluster+0x26>
    c148:	40 e0       	ldi	r20, 0x00	; 0
    c14a:	50 e0       	ldi	r21, 0x00	; 0
    c14c:	60 e0       	ldi	r22, 0x00	; 0
    c14e:	70 e0       	ldi	r23, 0x00	; 0
    c150:	16 c0       	rjmp	.+44     	; 0xc17e <fat_clear_cluster+0x52>
        return 0;

    return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
    c152:	62 50       	subi	r22, 0x02	; 2
    c154:	70 40       	sbci	r23, 0x00	; 0
    c156:	80 e0       	ldi	r24, 0x00	; 0
    c158:	90 e0       	ldi	r25, 0x00	; 0
    c15a:	f8 01       	movw	r30, r16
    c15c:	20 89       	ldd	r18, Z+16	; 0x10
    c15e:	31 89       	ldd	r19, Z+17	; 0x11
    c160:	40 e0       	ldi	r20, 0x00	; 0
    c162:	50 e0       	ldi	r21, 0x00	; 0
    c164:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    c168:	ab 01       	movw	r20, r22
    c16a:	bc 01       	movw	r22, r24
    c16c:	f8 01       	movw	r30, r16
    c16e:	82 89       	ldd	r24, Z+18	; 0x12
    c170:	93 89       	ldd	r25, Z+19	; 0x13
    c172:	a4 89       	ldd	r26, Z+20	; 0x14
    c174:	b5 89       	ldd	r27, Z+21	; 0x15
    c176:	48 0f       	add	r20, r24
    c178:	59 1f       	adc	r21, r25
    c17a:	6a 1f       	adc	r22, r26
    c17c:	7b 1f       	adc	r23, r27
        return 0;

    offset_t cluster_offset = fat_cluster_offset(fs, cluster_num);

    uint8_t zero[16];
    memset(zero, 0, sizeof(zero));
    c17e:	de 01       	movw	r26, r28
    c180:	11 96       	adiw	r26, 0x01	; 1
    c182:	80 e1       	ldi	r24, 0x10	; 16
    c184:	fd 01       	movw	r30, r26
    c186:	11 92       	st	Z+, r1
    c188:	8a 95       	dec	r24
    c18a:	e9 f7       	brne	.-6      	; 0xc186 <fat_clear_cluster+0x5a>
    return fs->partition->device_write_interval(cluster_offset,
    c18c:	f8 01       	movw	r30, r16
    c18e:	80 81       	ld	r24, Z
    c190:	91 81       	ldd	r25, Z+1	; 0x01
    c192:	20 89       	ldd	r18, Z+16	; 0x10
    c194:	31 89       	ldd	r19, Z+17	; 0x11
    c196:	fc 01       	movw	r30, r24
    c198:	c6 80       	ldd	r12, Z+6	; 0x06
    c19a:	d7 80       	ldd	r13, Z+7	; 0x07
    c19c:	cb 01       	movw	r24, r22
    c19e:	ba 01       	movw	r22, r20
    c1a0:	ad 01       	movw	r20, r26
    c1a2:	07 e9       	ldi	r16, 0x97	; 151
    c1a4:	1e e5       	ldi	r17, 0x5E	; 94
    c1a6:	ee 24       	eor	r14, r14
    c1a8:	ff 24       	eor	r15, r15
    c1aa:	f6 01       	movw	r30, r12
    c1ac:	09 95       	icall
                                                zero,
                                                fs->header.cluster_size,
                                                fat_clear_cluster_callback,
                                                0
                                               );
}
    c1ae:	60 96       	adiw	r28, 0x10	; 16
    c1b0:	e8 e0       	ldi	r30, 0x08	; 8
    c1b2:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000c1b6 <fat_read_dir>:
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat_reset_dir
 */
uint8_t fat_read_dir(struct fat_dir_struct* dd, struct fat_dir_entry_struct* dir_entry)
{
    c1b6:	a7 e2       	ldi	r26, 0x27	; 39
    c1b8:	b0 e0       	ldi	r27, 0x00	; 0
    c1ba:	e1 ee       	ldi	r30, 0xE1	; 225
    c1bc:	f0 e6       	ldi	r31, 0x60	; 96
    c1be:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    c1c2:	2c 01       	movw	r4, r24
    c1c4:	7f a3       	std	Y+39, r23	; 0x27
    c1c6:	6e a3       	std	Y+38, r22	; 0x26
    if(!dd || !dir_entry)
    c1c8:	00 97       	sbiw	r24, 0x00	; 0
    c1ca:	09 f4       	brne	.+2      	; 0xc1ce <fat_read_dir+0x18>
    c1cc:	b1 c0       	rjmp	.+354    	; 0xc330 <fat_read_dir+0x17a>
    c1ce:	61 15       	cp	r22, r1
    c1d0:	71 05       	cpc	r23, r1
    c1d2:	09 f4       	brne	.+2      	; 0xc1d6 <fat_read_dir+0x20>
    c1d4:	ad c0       	rjmp	.+346    	; 0xc330 <fat_read_dir+0x17a>
        return 0;

    /* get current position of directory handle */
    struct fat_fs_struct* fs = dd->fs;
    c1d6:	dc 01       	movw	r26, r24
    c1d8:	8d 90       	ld	r8, X+
    c1da:	9c 90       	ld	r9, X
    c1dc:	11 97       	sbiw	r26, 0x01	; 1
    const struct fat_header_struct* header = &fs->header;
    uint16_t cluster_size = header->cluster_size;
    c1de:	f4 01       	movw	r30, r8
    c1e0:	20 88       	ldd	r2, Z+16	; 0x10
    c1e2:	31 88       	ldd	r3, Z+17	; 0x11
    cluster_t cluster_num = dd->entry_cluster;
    c1e4:	9d 96       	adiw	r26, 0x2d	; 45
    c1e6:	ad 90       	ld	r10, X+
    c1e8:	bc 90       	ld	r11, X
    c1ea:	9e 97       	sbiw	r26, 0x2e	; 46
    uint16_t cluster_offset = dd->entry_offset;
    c1ec:	9f 96       	adiw	r26, 0x2f	; 47
    c1ee:	6d 90       	ld	r6, X+
    c1f0:	7c 90       	ld	r7, X
    c1f2:	d0 97       	sbiw	r26, 0x30	; 48
    struct fat_read_dir_callback_arg arg;

    /* reset directory entry */
    memset(dir_entry, 0, sizeof(*dir_entry));
    c1f4:	8b e2       	ldi	r24, 0x2B	; 43
    c1f6:	db 01       	movw	r26, r22
    c1f8:	1d 92       	st	X+, r1
    c1fa:	8a 95       	dec	r24
    c1fc:	e9 f7       	brne	.-6      	; 0xc1f8 <fat_read_dir+0x42>

    /* reset callback arguments */
    memset(&arg, 0, sizeof(arg));
    c1fe:	fe 01       	movw	r30, r28
    c200:	31 96       	adiw	r30, 0x01	; 1
    c202:	85 e0       	ldi	r24, 0x05	; 5
    c204:	df 01       	movw	r26, r30
    c206:	1d 92       	st	X+, r1
    c208:	8a 95       	dec	r24
    c20a:	e9 f7       	brne	.-6      	; 0xc206 <fat_read_dir+0x50>
    arg.dir_entry = dir_entry;

    /* check if we read from the root directory */
    if(cluster_num == 0)
    c20c:	a1 14       	cp	r10, r1
    c20e:	b1 04       	cpc	r11, r1
    c210:	09 f0       	breq	.+2      	; 0xc214 <fat_read_dir+0x5e>
    c212:	76 c0       	rjmp	.+236    	; 0xc300 <fat_read_dir+0x14a>
#if FAT_FAT32_SUPPORT
        if(fs->partition->type == PARTITION_TYPE_FAT32)
            cluster_num = header->root_dir_cluster;
        else
#endif
            cluster_size = header->cluster_zero_offset - header->root_dir_offset;
    c214:	f4 01       	movw	r30, r8
    c216:	22 88       	ldd	r2, Z+18	; 0x12
    c218:	33 88       	ldd	r3, Z+19	; 0x13
    c21a:	86 89       	ldd	r24, Z+22	; 0x16
    c21c:	97 89       	ldd	r25, Z+23	; 0x17
    c21e:	28 1a       	sub	r2, r24
    c220:	39 0a       	sbc	r3, r25
    c222:	6e c0       	rjmp	.+220    	; 0xc300 <fat_read_dir+0x14a>
    uint8_t buffer[32];
    while(!arg.finished)
    {
        /* read directory entries up to the cluster border */
        uint16_t cluster_left = cluster_size - cluster_offset;
        uint32_t pos = cluster_offset;
    c224:	73 01       	movw	r14, r6
    c226:	00 e0       	ldi	r16, 0x00	; 0
    c228:	10 e0       	ldi	r17, 0x00	; 0
        if(cluster_num == 0)
    c22a:	a1 14       	cp	r10, r1
    c22c:	b1 04       	cpc	r11, r1
    c22e:	41 f4       	brne	.+16     	; 0xc240 <fat_read_dir+0x8a>
            pos += header->root_dir_offset;
    c230:	d4 01       	movw	r26, r8
    c232:	56 96       	adiw	r26, 0x16	; 22
    c234:	6d 91       	ld	r22, X+
    c236:	7d 91       	ld	r23, X+
    c238:	8d 91       	ld	r24, X+
    c23a:	9c 91       	ld	r25, X
    c23c:	59 97       	sbiw	r26, 0x19	; 25
    c23e:	2d c0       	rjmp	.+90     	; 0xc29a <fat_read_dir+0xe4>
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    if(!fs || cluster_num < 2)
    c240:	81 14       	cp	r8, r1
    c242:	91 04       	cpc	r9, r1
    c244:	21 f1       	breq	.+72     	; 0xc28e <fat_read_dir+0xd8>
    c246:	b2 e0       	ldi	r27, 0x02	; 2
    c248:	ab 16       	cp	r10, r27
    c24a:	b1 04       	cpc	r11, r1
    c24c:	00 f1       	brcs	.+64     	; 0xc28e <fat_read_dir+0xd8>
        return 0;

    return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
    c24e:	ee ef       	ldi	r30, 0xFE	; 254
    c250:	ff ef       	ldi	r31, 0xFF	; 255
    c252:	ae 0e       	add	r10, r30
    c254:	bf 1e       	adc	r11, r31
    c256:	b5 01       	movw	r22, r10
    c258:	80 e0       	ldi	r24, 0x00	; 0
    c25a:	90 e0       	ldi	r25, 0x00	; 0
    c25c:	22 e0       	ldi	r18, 0x02	; 2
    c25e:	30 e0       	ldi	r19, 0x00	; 0
    c260:	a2 0e       	add	r10, r18
    c262:	b3 1e       	adc	r11, r19
    c264:	d4 01       	movw	r26, r8
    c266:	50 96       	adiw	r26, 0x10	; 16
    c268:	2d 91       	ld	r18, X+
    c26a:	3c 91       	ld	r19, X
    c26c:	51 97       	sbiw	r26, 0x11	; 17
    c26e:	40 e0       	ldi	r20, 0x00	; 0
    c270:	50 e0       	ldi	r21, 0x00	; 0
    c272:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    c276:	9b 01       	movw	r18, r22
    c278:	ac 01       	movw	r20, r24
    c27a:	f4 01       	movw	r30, r8
    c27c:	82 89       	ldd	r24, Z+18	; 0x12
    c27e:	93 89       	ldd	r25, Z+19	; 0x13
    c280:	a4 89       	ldd	r26, Z+20	; 0x14
    c282:	b5 89       	ldd	r27, Z+21	; 0x15
    c284:	28 0f       	add	r18, r24
    c286:	39 1f       	adc	r19, r25
    c288:	4a 1f       	adc	r20, r26
    c28a:	5b 1f       	adc	r21, r27
    c28c:	04 c0       	rjmp	.+8      	; 0xc296 <fat_read_dir+0xe0>
    c28e:	20 e0       	ldi	r18, 0x00	; 0
    c290:	30 e0       	ldi	r19, 0x00	; 0
    c292:	40 e0       	ldi	r20, 0x00	; 0
    c294:	50 e0       	ldi	r21, 0x00	; 0
        uint16_t cluster_left = cluster_size - cluster_offset;
        uint32_t pos = cluster_offset;
        if(cluster_num == 0)
            pos += header->root_dir_offset;
        else
            pos += fat_cluster_offset(fs, cluster_num);
    c296:	ca 01       	movw	r24, r20
    c298:	b9 01       	movw	r22, r18
    c29a:	6e 0d       	add	r22, r14
    c29c:	7f 1d       	adc	r23, r15
    c29e:	80 1f       	adc	r24, r16
    c2a0:	91 1f       	adc	r25, r17

        arg.bytes_read = 0;
    c2a2:	1c 82       	std	Y+4, r1	; 0x04
    c2a4:	1b 82       	std	Y+3, r1	; 0x03
        if(!fs->partition->device_read_interval(pos,
    c2a6:	d4 01       	movw	r26, r8
    c2a8:	ed 91       	ld	r30, X+
    c2aa:	fc 91       	ld	r31, X
    c2ac:	81 01       	movw	r16, r2
    c2ae:	06 19       	sub	r16, r6
    c2b0:	17 09       	sbc	r17, r7
    c2b2:	02 80       	ldd	r0, Z+2	; 0x02
    c2b4:	f3 81       	ldd	r31, Z+3	; 0x03
    c2b6:	e0 2d       	mov	r30, r0
    c2b8:	ae 01       	movw	r20, r28
    c2ba:	4a 5f       	subi	r20, 0xFA	; 250
    c2bc:	5f 4f       	sbci	r21, 0xFF	; 255
    c2be:	20 e2       	ldi	r18, 0x20	; 32
    c2c0:	30 e0       	ldi	r19, 0x00	; 0
    c2c2:	a8 ec       	ldi	r26, 0xC8	; 200
    c2c4:	ea 2e       	mov	r14, r26
    c2c6:	af e5       	ldi	r26, 0x5F	; 95
    c2c8:	fa 2e       	mov	r15, r26
    c2ca:	6e 01       	movw	r12, r28
    c2cc:	08 94       	sec
    c2ce:	c1 1c       	adc	r12, r1
    c2d0:	d1 1c       	adc	r13, r1
    c2d2:	09 95       	icall
    c2d4:	88 23       	and	r24, r24
    c2d6:	61 f1       	breq	.+88     	; 0xc330 <fat_read_dir+0x17a>
                                                fat_dir_entry_read_callback,
                                                &arg)
          )
            return 0;

        cluster_offset += arg.bytes_read;
    c2d8:	8b 81       	ldd	r24, Y+3	; 0x03
    c2da:	9c 81       	ldd	r25, Y+4	; 0x04
    c2dc:	68 0e       	add	r6, r24
    c2de:	79 1e       	adc	r7, r25

        if(cluster_offset >= cluster_size)
    c2e0:	62 14       	cp	r6, r2
    c2e2:	73 04       	cpc	r7, r3
    c2e4:	88 f0       	brcs	.+34     	; 0xc308 <fat_read_dir+0x152>
        {
            /* we reached the cluster border and switch to the next cluster */
            cluster_offset = 0;

            /* get number of next cluster */
            if(!(cluster_num = fat_get_next_cluster(fs, cluster_num)))
    c2e6:	c4 01       	movw	r24, r8
    c2e8:	b5 01       	movw	r22, r10
    c2ea:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
    c2ee:	5c 01       	movw	r10, r24
    c2f0:	66 24       	eor	r6, r6
    c2f2:	77 24       	eor	r7, r7
    c2f4:	00 97       	sbiw	r24, 0x00	; 0
    c2f6:	41 f4       	brne	.+16     	; 0xc308 <fat_read_dir+0x152>
            {
                /* directory entry not found, reset directory handle */
                cluster_num = dd->dir_entry.cluster;
    c2f8:	f2 01       	movw	r30, r4
    c2fa:	a3 a0       	ldd	r10, Z+35	; 0x23
    c2fc:	b4 a0       	ldd	r11, Z+36	; 0x24
    c2fe:	08 c0       	rjmp	.+16     	; 0xc310 <fat_read_dir+0x15a>
    /* reset directory entry */
    memset(dir_entry, 0, sizeof(*dir_entry));

    /* reset callback arguments */
    memset(&arg, 0, sizeof(arg));
    arg.dir_entry = dir_entry;
    c300:	2e a1       	ldd	r18, Y+38	; 0x26
    c302:	3f a1       	ldd	r19, Y+39	; 0x27
    c304:	3a 83       	std	Y+2, r19	; 0x02
    c306:	29 83       	std	Y+1, r18	; 0x01
            cluster_size = header->cluster_zero_offset - header->root_dir_offset;
    }

    /* read entries */
    uint8_t buffer[32];
    while(!arg.finished)
    c308:	8d 81       	ldd	r24, Y+5	; 0x05
    c30a:	88 23       	and	r24, r24
    c30c:	09 f4       	brne	.+2      	; 0xc310 <fat_read_dir+0x15a>
    c30e:	8a cf       	rjmp	.-236    	; 0xc224 <fat_read_dir+0x6e>
                break;
            }
        }
    }

    dd->entry_cluster = cluster_num;
    c310:	d2 01       	movw	r26, r4
    c312:	9e 96       	adiw	r26, 0x2e	; 46
    c314:	bc 92       	st	X, r11
    c316:	ae 92       	st	-X, r10
    c318:	9d 97       	sbiw	r26, 0x2d	; 45
    dd->entry_offset = cluster_offset;
    c31a:	d0 96       	adiw	r26, 0x30	; 48
    c31c:	7c 92       	st	X, r7
    c31e:	6e 92       	st	-X, r6
    c320:	9f 97       	sbiw	r26, 0x2f	; 47

    return dir_entry->long_name[0] != '\0' ? 1 : 0;
    c322:	ee a1       	ldd	r30, Y+38	; 0x26
    c324:	ff a1       	ldd	r31, Y+39	; 0x27
    c326:	80 81       	ld	r24, Z
    c328:	88 23       	and	r24, r24
    c32a:	19 f0       	breq	.+6      	; 0xc332 <fat_read_dir+0x17c>
    c32c:	81 e0       	ldi	r24, 0x01	; 1
    c32e:	01 c0       	rjmp	.+2      	; 0xc332 <fat_read_dir+0x17c>
    c330:	80 e0       	ldi	r24, 0x00	; 0
}
    c332:	a7 96       	adiw	r28, 0x27	; 39
    c334:	e2 e1       	ldi	r30, 0x12	; 18
    c336:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000c33a <fat_find_offset_for_dir_entry>:
 * \param[in] parent The directory in which to search.
 * \param[in] dir_entry The directory entry for which to search space.
 * \returns 0 on failure, a device offset on success.
 */
offset_t fat_find_offset_for_dir_entry(const struct fat_fs_struct* fs, const struct fat_dir_struct* parent, const struct fat_dir_entry_struct* dir_entry)
{
    c33a:	a3 e0       	ldi	r26, 0x03	; 3
    c33c:	b0 e0       	ldi	r27, 0x00	; 0
    c33e:	e3 ea       	ldi	r30, 0xA3	; 163
    c340:	f1 e6       	ldi	r31, 0x61	; 97
    c342:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    c346:	1c 01       	movw	r2, r24
    c348:	9b 01       	movw	r18, r22
    if(!fs || !dir_entry)
    c34a:	00 97       	sbiw	r24, 0x00	; 0
    c34c:	09 f4       	brne	.+2      	; 0xc350 <fat_find_offset_for_dir_entry+0x16>
    c34e:	d2 c0       	rjmp	.+420    	; 0xc4f4 <fat_find_offset_for_dir_entry+0x1ba>
    c350:	41 15       	cp	r20, r1
    c352:	51 05       	cpc	r21, r1
    c354:	09 f4       	brne	.+2      	; 0xc358 <fat_find_offset_for_dir_entry+0x1e>
    c356:	ce c0       	rjmp	.+412    	; 0xc4f4 <fat_find_offset_for_dir_entry+0x1ba>
        return 0;

    /* search for a place where to write the directory entry to disk */
    uint8_t free_dir_entries_needed = (strlen(dir_entry->long_name) + 12) / 13 + 1;
    c358:	fa 01       	movw	r30, r20
    c35a:	01 90       	ld	r0, Z+
    c35c:	00 20       	and	r0, r0
    c35e:	e9 f7       	brne	.-6      	; 0xc35a <fat_find_offset_for_dir_entry+0x20>
    c360:	e4 1b       	sub	r30, r20
    c362:	f5 0b       	sbc	r31, r21
    c364:	cf 01       	movw	r24, r30
    c366:	0b 96       	adiw	r24, 0x0b	; 11
    c368:	6d e0       	ldi	r22, 0x0D	; 13
    c36a:	70 e0       	ldi	r23, 0x00	; 0
    c36c:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    c370:	86 2f       	mov	r24, r22
    c372:	8f 5f       	subi	r24, 0xFF	; 255
    c374:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t free_dir_entries_found = 0;
    cluster_t cluster_num = parent->dir_entry.cluster;
    c376:	d9 01       	movw	r26, r18
    c378:	93 96       	adiw	r26, 0x23	; 35
    c37a:	4d 90       	ld	r4, X+
    c37c:	5c 90       	ld	r5, X
    c37e:	94 97       	sbiw	r26, 0x24	; 36
    offset_t offset_to = 0;
#if FAT_FAT32_SUPPORT
    uint8_t is_fat32 = (fs->partition->type == PARTITION_TYPE_FAT32);
#endif

    if(cluster_num == 0)
    c380:	41 14       	cp	r4, r1
    c382:	51 04       	cpc	r5, r1
    c384:	51 f0       	breq	.+20     	; 0xc39a <fat_find_offset_for_dir_entry+0x60>
    c386:	aa 24       	eor	r10, r10
    c388:	bb 24       	eor	r11, r11
    c38a:	65 01       	movw	r12, r10
    c38c:	ee 24       	eor	r14, r14
    c38e:	ff 24       	eor	r15, r15
    c390:	87 01       	movw	r16, r14
    c392:	66 24       	eor	r6, r6
    c394:	77 24       	eor	r7, r7
    c396:	43 01       	movw	r8, r6
    c398:	0b c0       	rjmp	.+22     	; 0xc3b0 <fat_find_offset_for_dir_entry+0x76>
        }
        else
#endif
        {
            /* we read/write from the root directory entry */
            offset = fs->header.root_dir_offset;
    c39a:	f1 01       	movw	r30, r2
    c39c:	e6 88       	ldd	r14, Z+22	; 0x16
    c39e:	f7 88       	ldd	r15, Z+23	; 0x17
    c3a0:	00 8d       	ldd	r16, Z+24	; 0x18
    c3a2:	11 8d       	ldd	r17, Z+25	; 0x19
            offset_to = fs->header.cluster_zero_offset;
    c3a4:	62 88       	ldd	r6, Z+18	; 0x12
    c3a6:	73 88       	ldd	r7, Z+19	; 0x13
    c3a8:	84 88       	ldd	r8, Z+20	; 0x14
    c3aa:	95 88       	ldd	r9, Z+21	; 0x15
    c3ac:	57 01       	movw	r10, r14
    c3ae:	68 01       	movw	r12, r16
    c3b0:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    
    while(1)
    {
        if(offset == offset_to)
    c3b2:	e6 14       	cp	r14, r6
    c3b4:	f7 04       	cpc	r15, r7
    c3b6:	08 05       	cpc	r16, r8
    c3b8:	19 05       	cpc	r17, r9
    c3ba:	09 f0       	breq	.+2      	; 0xc3be <fat_find_offset_for_dir_entry+0x84>
    c3bc:	6e c0       	rjmp	.+220    	; 0xc49a <fat_find_offset_for_dir_entry+0x160>
        {
            if(cluster_num == 0)
    c3be:	41 14       	cp	r4, r1
    c3c0:	51 04       	cpc	r5, r1
    c3c2:	09 f4       	brne	.+2      	; 0xc3c6 <fat_find_offset_for_dir_entry+0x8c>
    c3c4:	97 c0       	rjmp	.+302    	; 0xc4f4 <fat_find_offset_for_dir_entry+0x1ba>
                /* We iterated through the whole root directory and
                 * could not find enough space for the directory entry.
                 */
                return 0;

            if(offset)
    c3c6:	e1 14       	cp	r14, r1
    c3c8:	f1 04       	cpc	r15, r1
    c3ca:	01 05       	cpc	r16, r1
    c3cc:	11 05       	cpc	r17, r1
    c3ce:	89 f1       	breq	.+98     	; 0xc432 <fat_find_offset_for_dir_entry+0xf8>
            {
                /* We reached a cluster boundary and have to
                 * switch to the next cluster.
                 */

                cluster_t cluster_next = fat_get_next_cluster(fs, cluster_num);
    c3d0:	c1 01       	movw	r24, r2
    c3d2:	b2 01       	movw	r22, r4
    c3d4:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
                if(!cluster_next)
    c3d8:	00 97       	sbiw	r24, 0x00	; 0
    c3da:	51 f5       	brne	.+84     	; 0xc430 <fat_find_offset_for_dir_entry+0xf6>
                {
                    cluster_next = fat_append_clusters(fs, cluster_num, 1);
    c3dc:	c1 01       	movw	r24, r2
    c3de:	b2 01       	movw	r22, r4
    c3e0:	41 e0       	ldi	r20, 0x01	; 1
    c3e2:	50 e0       	ldi	r21, 0x00	; 0
    c3e4:	0e 94 f5 5d 	call	0xbbea	; 0xbbea <fat_append_clusters>
    c3e8:	8c 01       	movw	r16, r24
                    if(!cluster_next)
    c3ea:	00 97       	sbiw	r24, 0x00	; 0
    c3ec:	09 f4       	brne	.+2      	; 0xc3f0 <fat_find_offset_for_dir_entry+0xb6>
    c3ee:	82 c0       	rjmp	.+260    	; 0xc4f4 <fat_find_offset_for_dir_entry+0x1ba>
                        return 0;

                    /* we appended a new cluster and know it is free */
                    dir_entry_offset = fs->header.cluster_zero_offset +
    c3f0:	02 50       	subi	r16, 0x02	; 2
    c3f2:	10 40       	sbci	r17, 0x00	; 0
    c3f4:	b8 01       	movw	r22, r16
    c3f6:	80 e0       	ldi	r24, 0x00	; 0
    c3f8:	90 e0       	ldi	r25, 0x00	; 0
    c3fa:	0e 5f       	subi	r16, 0xFE	; 254
    c3fc:	1f 4f       	sbci	r17, 0xFF	; 255
    c3fe:	d1 01       	movw	r26, r2
    c400:	50 96       	adiw	r26, 0x10	; 16
    c402:	2d 91       	ld	r18, X+
    c404:	3c 91       	ld	r19, X
    c406:	51 97       	sbiw	r26, 0x11	; 17
    c408:	40 e0       	ldi	r20, 0x00	; 0
    c40a:	50 e0       	ldi	r21, 0x00	; 0
    c40c:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    c410:	5b 01       	movw	r10, r22
    c412:	6c 01       	movw	r12, r24
    c414:	f1 01       	movw	r30, r2
    c416:	82 89       	ldd	r24, Z+18	; 0x12
    c418:	93 89       	ldd	r25, Z+19	; 0x13
    c41a:	a4 89       	ldd	r26, Z+20	; 0x14
    c41c:	b5 89       	ldd	r27, Z+21	; 0x15
    c41e:	a8 0e       	add	r10, r24
    c420:	b9 1e       	adc	r11, r25
    c422:	ca 1e       	adc	r12, r26
    c424:	db 1e       	adc	r13, r27
                                       (offset_t) (cluster_next - 2) * fs->header.cluster_size;

                    /* clear cluster to avoid garbage directory entries */
                    fat_clear_cluster(fs, cluster_next);
    c426:	c1 01       	movw	r24, r2
    c428:	b8 01       	movw	r22, r16
    c42a:	0e 94 96 60 	call	0xc12c	; 0xc12c <fat_clear_cluster>
    c42e:	65 c0       	rjmp	.+202    	; 0xc4fa <fat_find_offset_for_dir_entry+0x1c0>

                    break;
    c430:	2c 01       	movw	r4, r24
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    if(!fs || cluster_num < 2)
    c432:	f2 e0       	ldi	r31, 0x02	; 2
    c434:	4f 16       	cp	r4, r31
    c436:	51 04       	cpc	r5, r1
    c438:	20 f4       	brcc	.+8      	; 0xc442 <fat_find_offset_for_dir_entry+0x108>
    c43a:	ee 24       	eor	r14, r14
    c43c:	ff 24       	eor	r15, r15
    c43e:	87 01       	movw	r16, r14
    c440:	1d c0       	rjmp	.+58     	; 0xc47c <fat_find_offset_for_dir_entry+0x142>
        return 0;

    return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
    c442:	2e ef       	ldi	r18, 0xFE	; 254
    c444:	3f ef       	ldi	r19, 0xFF	; 255
    c446:	42 0e       	add	r4, r18
    c448:	53 1e       	adc	r5, r19
    c44a:	b2 01       	movw	r22, r4
    c44c:	80 e0       	ldi	r24, 0x00	; 0
    c44e:	90 e0       	ldi	r25, 0x00	; 0
    c450:	a2 e0       	ldi	r26, 0x02	; 2
    c452:	b0 e0       	ldi	r27, 0x00	; 0
    c454:	4a 0e       	add	r4, r26
    c456:	5b 1e       	adc	r5, r27
    c458:	f1 01       	movw	r30, r2
    c45a:	20 89       	ldd	r18, Z+16	; 0x10
    c45c:	31 89       	ldd	r19, Z+17	; 0x11
    c45e:	40 e0       	ldi	r20, 0x00	; 0
    c460:	50 e0       	ldi	r21, 0x00	; 0
    c462:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    c466:	7b 01       	movw	r14, r22
    c468:	8c 01       	movw	r16, r24
    c46a:	f1 01       	movw	r30, r2
    c46c:	82 89       	ldd	r24, Z+18	; 0x12
    c46e:	93 89       	ldd	r25, Z+19	; 0x13
    c470:	a4 89       	ldd	r26, Z+20	; 0x14
    c472:	b5 89       	ldd	r27, Z+21	; 0x15
    c474:	e8 0e       	add	r14, r24
    c476:	f9 1e       	adc	r15, r25
    c478:	0a 1f       	adc	r16, r26
    c47a:	1b 1f       	adc	r17, r27
                }
                cluster_num = cluster_next;
            }

            offset = fat_cluster_offset(fs, cluster_num);
            offset_to = offset + fs->header.cluster_size;
    c47c:	d1 01       	movw	r26, r2
    c47e:	50 96       	adiw	r26, 0x10	; 16
    c480:	8d 91       	ld	r24, X+
    c482:	9c 91       	ld	r25, X
    c484:	51 97       	sbiw	r26, 0x11	; 17
    c486:	3c 01       	movw	r6, r24
    c488:	88 24       	eor	r8, r8
    c48a:	99 24       	eor	r9, r9
    c48c:	6e 0c       	add	r6, r14
    c48e:	7f 1c       	adc	r7, r15
    c490:	80 1e       	adc	r8, r16
    c492:	91 1e       	adc	r9, r17
    c494:	57 01       	movw	r10, r14
    c496:	68 01       	movw	r12, r16
    c498:	1a 82       	std	Y+2, r1	; 0x02
            free_dir_entries_found = 0;
        }
        
        /* read next lfn or 8.3 entry */
        uint8_t first_char;
        if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
    c49a:	d1 01       	movw	r26, r2
    c49c:	ed 91       	ld	r30, X+
    c49e:	fc 91       	ld	r31, X
    c4a0:	01 90       	ld	r0, Z+
    c4a2:	f0 81       	ld	r31, Z
    c4a4:	e0 2d       	mov	r30, r0
    c4a6:	c8 01       	movw	r24, r16
    c4a8:	b7 01       	movw	r22, r14
    c4aa:	ae 01       	movw	r20, r28
    c4ac:	4f 5f       	subi	r20, 0xFF	; 255
    c4ae:	5f 4f       	sbci	r21, 0xFF	; 255
    c4b0:	21 e0       	ldi	r18, 0x01	; 1
    c4b2:	30 e0       	ldi	r19, 0x00	; 0
    c4b4:	09 95       	icall
    c4b6:	88 23       	and	r24, r24
    c4b8:	e9 f0       	breq	.+58     	; 0xc4f4 <fat_find_offset_for_dir_entry+0x1ba>
            return 0;

        /* check if we found a free directory entry */
        if(first_char == FAT_DIRENTRY_DELETED || !first_char)
    c4ba:	89 81       	ldd	r24, Y+1	; 0x01
    c4bc:	85 3e       	cpi	r24, 0xE5	; 229
    c4be:	11 f0       	breq	.+4      	; 0xc4c4 <fat_find_offset_for_dir_entry+0x18a>
    c4c0:	88 23       	and	r24, r24
    c4c2:	79 f4       	brne	.+30     	; 0xc4e2 <fat_find_offset_for_dir_entry+0x1a8>
        {
            /* check if we have the needed number of available entries */
            ++free_dir_entries_found;
    c4c4:	ba 81       	ldd	r27, Y+2	; 0x02
    c4c6:	bf 5f       	subi	r27, 0xFF	; 255
    c4c8:	ba 83       	std	Y+2, r27	; 0x02
            if(free_dir_entries_found >= free_dir_entries_needed)
    c4ca:	eb 81       	ldd	r30, Y+3	; 0x03
    c4cc:	be 17       	cp	r27, r30
    c4ce:	a8 f4       	brcc	.+42     	; 0xc4fa <fat_find_offset_for_dir_entry+0x1c0>
                break;

            offset += 32;
    c4d0:	80 e2       	ldi	r24, 0x20	; 32
    c4d2:	90 e0       	ldi	r25, 0x00	; 0
    c4d4:	a0 e0       	ldi	r26, 0x00	; 0
    c4d6:	b0 e0       	ldi	r27, 0x00	; 0
    c4d8:	e8 0e       	add	r14, r24
    c4da:	f9 1e       	adc	r15, r25
    c4dc:	0a 1f       	adc	r16, r26
    c4de:	1b 1f       	adc	r17, r27
    c4e0:	68 cf       	rjmp	.-304    	; 0xc3b2 <fat_find_offset_for_dir_entry+0x78>
        }
        else
        {
            offset += 32;
    c4e2:	80 e2       	ldi	r24, 0x20	; 32
    c4e4:	90 e0       	ldi	r25, 0x00	; 0
    c4e6:	a0 e0       	ldi	r26, 0x00	; 0
    c4e8:	b0 e0       	ldi	r27, 0x00	; 0
    c4ea:	e8 0e       	add	r14, r24
    c4ec:	f9 1e       	adc	r15, r25
    c4ee:	0a 1f       	adc	r16, r26
    c4f0:	1b 1f       	adc	r17, r27
    c4f2:	5c cf       	rjmp	.-328    	; 0xc3ac <fat_find_offset_for_dir_entry+0x72>
    c4f4:	aa 24       	eor	r10, r10
    c4f6:	bb 24       	eor	r11, r11
    c4f8:	65 01       	movw	r12, r10
            free_dir_entries_found = 0;
        }
    }

    return dir_entry_offset;
}
    c4fa:	b5 01       	movw	r22, r10
    c4fc:	c6 01       	movw	r24, r12
    c4fe:	23 96       	adiw	r28, 0x03	; 3
    c500:	e2 e1       	ldi	r30, 0x12	; 18
    c502:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000c506 <fat_write_dir_entry>:
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat_write_dir_entry(const struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry)
{
    c506:	a0 e2       	ldi	r26, 0x20	; 32
    c508:	b0 e0       	ldi	r27, 0x00	; 0
    c50a:	e9 e8       	ldi	r30, 0x89	; 137
    c50c:	f2 e6       	ldi	r31, 0x62	; 98
    c50e:	0c 94 ba 6a 	jmp	0xd574	; 0xd574 <__prologue_saves__+0x2>
    c512:	fc 01       	movw	r30, r24
    c514:	8b 01       	movw	r16, r22
    if(!fs || !dir_entry)
    c516:	00 97       	sbiw	r24, 0x00	; 0
    c518:	09 f4       	brne	.+2      	; 0xc51c <fat_write_dir_entry+0x16>
    c51a:	1f c1       	rjmp	.+574    	; 0xc75a <fat_write_dir_entry+0x254>
    c51c:	61 15       	cp	r22, r1
    c51e:	71 05       	cpc	r23, r1
    c520:	09 f4       	brne	.+2      	; 0xc524 <fat_write_dir_entry+0x1e>
    c522:	1b c1       	rjmp	.+566    	; 0xc75a <fat_write_dir_entry+0x254>
        fat_set_file_modification_date(dir_entry, year, month, day);
        fat_set_file_modification_time(dir_entry, hour, min, sec);
    }
#endif

    device_write_t device_write = fs->partition->device_write;
    c524:	01 90       	ld	r0, Z+
    c526:	f0 81       	ld	r31, Z
    c528:	e0 2d       	mov	r30, r0
    c52a:	44 80       	ldd	r4, Z+4	; 0x04
    c52c:	55 80       	ldd	r5, Z+5	; 0x05
    offset_t offset = dir_entry->entry_offset;
    c52e:	db 01       	movw	r26, r22
    c530:	97 96       	adiw	r26, 0x27	; 39
    c532:	ad 90       	ld	r10, X+
    c534:	bd 90       	ld	r11, X+
    c536:	cd 90       	ld	r12, X+
    c538:	dc 90       	ld	r13, X
    c53a:	9a 97       	sbiw	r26, 0x2a	; 42
    const char* name = dir_entry->long_name;
    c53c:	e6 2e       	mov	r14, r22
    c53e:	91 2e       	mov	r9, r17
    uint8_t name_len = strlen(name);
    c540:	fb 01       	movw	r30, r22
    c542:	01 90       	ld	r0, Z+
    c544:	00 20       	and	r0, r0
    c546:	e9 f7       	brne	.-6      	; 0xc542 <fat_write_dir_entry+0x3c>
    c548:	31 97       	sbiw	r30, 0x01	; 1
    c54a:	fe 2e       	mov	r15, r30
    c54c:	f6 1a       	sub	r15, r22
    uint8_t lfn_entry_count = (name_len + 12) / 13;
    c54e:	8f 2d       	mov	r24, r15
    c550:	90 e0       	ldi	r25, 0x00	; 0
    c552:	0c 96       	adiw	r24, 0x0c	; 12
    c554:	6d e0       	ldi	r22, 0x0D	; 13
    c556:	70 e0       	ldi	r23, 0x00	; 0
    c558:	0e 94 69 6a 	call	0xd4d2	; 0xd4d2 <__divmodhi4>
    c55c:	76 2e       	mov	r7, r22
    uint8_t buffer[32];

    /* write 8.3 entry */

    /* generate 8.3 file name */
    memset(&buffer[0], ' ', 11);
    c55e:	ce 01       	movw	r24, r28
    c560:	01 96       	adiw	r24, 0x01	; 1
    c562:	60 e2       	ldi	r22, 0x20	; 32
    c564:	70 e0       	ldi	r23, 0x00	; 0
    c566:	4b e0       	ldi	r20, 0x0B	; 11
    c568:	50 e0       	ldi	r21, 0x00	; 0
    c56a:	0e 94 26 14 	call	0x284c	; 0x284c <memset>
    char* name_ext = strrchr(name, '.');
    c56e:	c8 01       	movw	r24, r16
    c570:	6e e2       	ldi	r22, 0x2E	; 46
    c572:	70 e0       	ldi	r23, 0x00	; 0
    c574:	0e 94 5e 14 	call	0x28bc	; 0x28bc <strrchr>
    c578:	fc 01       	movw	r30, r24
    if(name_ext && *++name_ext)
    c57a:	00 97       	sbiw	r24, 0x00	; 0
    c57c:	e1 f0       	breq	.+56     	; 0xc5b6 <fat_write_dir_entry+0xb0>
    c57e:	9c 01       	movw	r18, r24
    c580:	2f 5f       	subi	r18, 0xFF	; 255
    c582:	3f 4f       	sbci	r19, 0xFF	; 255
    c584:	81 81       	ldd	r24, Z+1	; 0x01
    c586:	88 23       	and	r24, r24
    c588:	b1 f0       	breq	.+44     	; 0xc5b6 <fat_write_dir_entry+0xb0>
    {
        uint8_t name_ext_len = strlen(name_ext);
    c58a:	d9 01       	movw	r26, r18
    c58c:	0d 90       	ld	r0, X+
    c58e:	00 20       	and	r0, r0
    c590:	e9 f7       	brne	.-6      	; 0xc58c <fat_write_dir_entry+0x86>
    c592:	11 97       	sbiw	r26, 0x01	; 1
    c594:	a2 1b       	sub	r26, r18
    c596:	b3 0b       	sbc	r27, r19
        name_len -= name_ext_len + 1;
    c598:	8a 2f       	mov	r24, r26
    c59a:	80 95       	com	r24
    c59c:	f8 0e       	add	r15, r24

        if(name_ext_len > 3)
            name_ext_len = 3;
        
        memcpy(&buffer[8], name_ext, name_ext_len);
    c59e:	be 01       	movw	r22, r28
    c5a0:	67 5f       	subi	r22, 0xF7	; 247
    c5a2:	7f 4f       	sbci	r23, 0xFF	; 255
    c5a4:	4a 2f       	mov	r20, r26
    c5a6:	a4 30       	cpi	r26, 0x04	; 4
    c5a8:	08 f0       	brcs	.+2      	; 0xc5ac <fat_write_dir_entry+0xa6>
    c5aa:	43 e0       	ldi	r20, 0x03	; 3
    c5ac:	cb 01       	movw	r24, r22
    c5ae:	b9 01       	movw	r22, r18
    c5b0:	50 e0       	ldi	r21, 0x00	; 0
    c5b2:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
    c5b6:	ce 01       	movw	r24, r28
    c5b8:	01 96       	adiw	r24, 0x01	; 1
    }
    
    if(name_len <= 8)
    c5ba:	b8 e0       	ldi	r27, 0x08	; 8
    c5bc:	bf 15       	cp	r27, r15
    c5be:	88 f0       	brcs	.+34     	; 0xc5e2 <fat_write_dir_entry+0xdc>
    {
        memcpy(buffer, name, name_len);
    c5c0:	6e 2d       	mov	r22, r14
    c5c2:	79 2d       	mov	r23, r9
    c5c4:	4f 2d       	mov	r20, r15
    c5c6:	50 e0       	ldi	r21, 0x00	; 0
    c5c8:	0e 94 1d 14 	call	0x283a	; 0x283a <memcpy>
         *
         * Theoretically it would be possible to leave
         * the 8.3 entry alone if the basename and the
         * extension have no mixed capitalization.
         */
        if(name[0] == '.' &&
    c5cc:	f8 01       	movw	r30, r16
    c5ce:	80 81       	ld	r24, Z
    c5d0:	8e 32       	cpi	r24, 0x2E	; 46
    c5d2:	31 f5       	brne	.+76     	; 0xc620 <fat_write_dir_entry+0x11a>
    c5d4:	81 81       	ldd	r24, Z+1	; 0x01
    c5d6:	8e 32       	cpi	r24, 0x2E	; 46
    c5d8:	09 f4       	brne	.+2      	; 0xc5dc <fat_write_dir_entry+0xd6>
    c5da:	82 81       	ldd	r24, Z+2	; 0x02
    c5dc:	88 23       	and	r24, r24
    c5de:	f9 f0       	breq	.+62     	; 0xc61e <fat_write_dir_entry+0x118>
    c5e0:	1f c0       	rjmp	.+62     	; 0xc620 <fat_write_dir_entry+0x11a>
          )
            lfn_entry_count = 0;
    }
    else
    {
        memcpy(buffer, name, 8);
    c5e2:	dc 01       	movw	r26, r24
    c5e4:	8e 2d       	mov	r24, r14
    c5e6:	99 2d       	mov	r25, r9
    c5e8:	9c 01       	movw	r18, r24
    c5ea:	f9 01       	movw	r30, r18
    c5ec:	88 e0       	ldi	r24, 0x08	; 8
    c5ee:	01 90       	ld	r0, Z+
    c5f0:	0d 92       	st	X+, r0
    c5f2:	81 50       	subi	r24, 0x01	; 1
    c5f4:	e1 f7       	brne	.-8      	; 0xc5ee <fat_write_dir_entry+0xe8>

        /* Minimize 8.3 name clashes by appending
         * the lower byte of the cluster number.
         */
        uint8_t num = dir_entry->cluster & 0xff;
    c5f6:	d8 01       	movw	r26, r16
    c5f8:	91 96       	adiw	r26, 0x21	; 33
    c5fa:	8c 91       	ld	r24, X
    c5fc:	98 2f       	mov	r25, r24
    c5fe:	92 95       	swap	r25
    c600:	9f 70       	andi	r25, 0x0F	; 15

        buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
    c602:	80 3a       	cpi	r24, 0xA0	; 160
    c604:	10 f4       	brcc	.+4      	; 0xc60a <fat_write_dir_entry+0x104>
    c606:	90 5d       	subi	r25, 0xD0	; 208
    c608:	01 c0       	rjmp	.+2      	; 0xc60c <fat_write_dir_entry+0x106>
    c60a:	9f 59       	subi	r25, 0x9F	; 159
        num &= 0x0f;
    c60c:	8f 70       	andi	r24, 0x0F	; 15
        buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
    c60e:	8a 30       	cpi	r24, 0x0A	; 10
    c610:	10 f4       	brcc	.+4      	; 0xc616 <fat_write_dir_entry+0x110>
    c612:	80 5d       	subi	r24, 0xD0	; 208
    c614:	01 c0       	rjmp	.+2      	; 0xc618 <fat_write_dir_entry+0x112>
    c616:	8f 59       	subi	r24, 0x9F	; 159
        /* Minimize 8.3 name clashes by appending
         * the lower byte of the cluster number.
         */
        uint8_t num = dir_entry->cluster & 0xff;

        buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
    c618:	9f 83       	std	Y+7, r25	; 0x07
        num &= 0x0f;
        buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
    c61a:	88 87       	std	Y+8, r24	; 0x08
    c61c:	01 c0       	rjmp	.+2      	; 0xc620 <fat_write_dir_entry+0x11a>
    c61e:	77 24       	eor	r7, r7
    }
    if(buffer[0] == FAT_DIRENTRY_DELETED)
    c620:	89 81       	ldd	r24, Y+1	; 0x01
    c622:	85 3e       	cpi	r24, 0xE5	; 229
    c624:	11 f4       	brne	.+4      	; 0xc62a <fat_write_dir_entry+0x124>
        buffer[0] = 0x05;
    c626:	85 e0       	ldi	r24, 0x05	; 5
    c628:	89 83       	std	Y+1, r24	; 0x01

    /* fill directory entry buffer */
    memset(&buffer[11], 0, sizeof(buffer) - 11);
    c62a:	2c e0       	ldi	r18, 0x0C	; 12
    c62c:	82 2e       	mov	r8, r18
    c62e:	91 2c       	mov	r9, r1
    c630:	8c 0e       	add	r8, r28
    c632:	9d 1e       	adc	r9, r29
    c634:	85 e1       	ldi	r24, 0x15	; 21
    c636:	f4 01       	movw	r30, r8
    c638:	11 92       	st	Z+, r1
    c63a:	8a 95       	dec	r24
    c63c:	e9 f7       	brne	.-6      	; 0xc638 <fat_write_dir_entry+0x132>
    buffer[0x0b] = dir_entry->attributes;
    c63e:	d8 01       	movw	r26, r16
    c640:	90 96       	adiw	r26, 0x20	; 32
    c642:	8c 91       	ld	r24, X
    c644:	90 97       	sbiw	r26, 0x20	; 32
    c646:	8c 87       	std	Y+12, r24	; 0x0c
    *((uint16_t*) &buffer[0x18]) = htol16(dir_entry->modification_date);
#endif
#if FAT_FAT32_SUPPORT
    *((uint16_t*) &buffer[0x14]) = htol16((uint16_t) (dir_entry->cluster >> 16));
#endif
    *((uint16_t*) &buffer[0x1a]) = htol16(dir_entry->cluster);
    c648:	91 96       	adiw	r26, 0x21	; 33
    c64a:	8d 91       	ld	r24, X+
    c64c:	9c 91       	ld	r25, X
    c64e:	92 97       	sbiw	r26, 0x22	; 34
    c650:	9c 8f       	std	Y+28, r25	; 0x1c
    c652:	8b 8f       	std	Y+27, r24	; 0x1b
    *((uint32_t*) &buffer[0x1c]) = htol32(dir_entry->file_size);
    c654:	93 96       	adiw	r26, 0x23	; 35
    c656:	8d 91       	ld	r24, X+
    c658:	9d 91       	ld	r25, X+
    c65a:	0d 90       	ld	r0, X+
    c65c:	bc 91       	ld	r27, X
    c65e:	a0 2d       	mov	r26, r0
    c660:	8d 8f       	std	Y+29, r24	; 0x1d
    c662:	9e 8f       	std	Y+30, r25	; 0x1e
    c664:	af 8f       	std	Y+31, r26	; 0x1f
    c666:	b8 a3       	std	Y+32, r27	; 0x20

    /* write to disk */
    if(!device_write(offset + (uint16_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
    c668:	67 2d       	mov	r22, r7
    c66a:	70 e0       	ldi	r23, 0x00	; 0
    c66c:	95 e0       	ldi	r25, 0x05	; 5
    c66e:	66 0f       	add	r22, r22
    c670:	77 1f       	adc	r23, r23
    c672:	9a 95       	dec	r25
    c674:	e1 f7       	brne	.-8      	; 0xc66e <fat_write_dir_entry+0x168>
    c676:	80 e0       	ldi	r24, 0x00	; 0
    c678:	90 e0       	ldi	r25, 0x00	; 0
    c67a:	6a 0d       	add	r22, r10
    c67c:	7b 1d       	adc	r23, r11
    c67e:	8c 1d       	adc	r24, r12
    c680:	9d 1d       	adc	r25, r13
    c682:	ae 01       	movw	r20, r28
    c684:	4f 5f       	subi	r20, 0xFF	; 255
    c686:	5f 4f       	sbci	r21, 0xFF	; 255
    c688:	20 e2       	ldi	r18, 0x20	; 32
    c68a:	30 e0       	ldi	r19, 0x00	; 0
    c68c:	f2 01       	movw	r30, r4
    c68e:	09 95       	icall
    c690:	88 23       	and	r24, r24
    c692:	09 f4       	brne	.+2      	; 0xc696 <fat_write_dir_entry+0x190>
    c694:	62 c0       	rjmp	.+196    	; 0xc75a <fat_write_dir_entry+0x254>
        return 0;
    
    /* calculate checksum of 8.3 name */
    uint8_t checksum = buffer[0];
    c696:	e9 80       	ldd	r14, Y+1	; 0x01
    c698:	fe 01       	movw	r30, r28
    c69a:	32 96       	adiw	r30, 0x02	; 2
    for(uint8_t i = 1; i < 11; ++i)
    c69c:	94 01       	movw	r18, r8
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    c69e:	8e 2d       	mov	r24, r14
    c6a0:	86 95       	lsr	r24
    c6a2:	e7 94       	ror	r14
    c6a4:	ee 24       	eor	r14, r14
    c6a6:	e7 94       	ror	r14
    c6a8:	e8 2a       	or	r14, r24
    c6aa:	81 91       	ld	r24, Z+
    c6ac:	e8 0e       	add	r14, r24
    if(!device_write(offset + (uint16_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
        return 0;
    
    /* calculate checksum of 8.3 name */
    uint8_t checksum = buffer[0];
    for(uint8_t i = 1; i < 11; ++i)
    c6ae:	e2 17       	cp	r30, r18
    c6b0:	f3 07       	cpc	r31, r19
    c6b2:	a9 f7       	brne	.-22     	; 0xc69e <fat_write_dir_entry+0x198>
    c6b4:	f7 2c       	mov	r15, r7
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
    /* write lfn entries */
    for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
    {
        memset(buffer, 0xff, sizeof(buffer));
    c6b6:	4e 01       	movw	r8, r28
    c6b8:	08 94       	sec
    c6ba:	81 1c       	adc	r8, r1
    c6bc:	91 1c       	adc	r9, r1
        
        /* set file name */
        const char* long_name_curr = name + (lfn_entry - 1) * 13;
    c6be:	8d e0       	ldi	r24, 0x0D	; 13
    c6c0:	38 2e       	mov	r3, r24
        buffer[0x00] = lfn_entry;
        if(lfn_entry == lfn_entry_count)
            buffer[0x00] |= FAT_DIRENTRY_LFNLAST;

        /* mark as lfn entry */
        buffer[0x0b] = 0x0f;
    c6c2:	bf e0       	ldi	r27, 0x0F	; 15
    c6c4:	6b 2e       	mov	r6, r27
    c6c6:	44 c0       	rjmp	.+136    	; 0xc750 <fat_write_dir_entry+0x24a>
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
    /* write lfn entries */
    for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
    {
        memset(buffer, 0xff, sizeof(buffer));
    c6c8:	c4 01       	movw	r24, r8
    c6ca:	6f ef       	ldi	r22, 0xFF	; 255
    c6cc:	70 e0       	ldi	r23, 0x00	; 0
    c6ce:	40 e2       	ldi	r20, 0x20	; 32
    c6d0:	50 e0       	ldi	r21, 0x00	; 0
    c6d2:	0e 94 26 14 	call	0x284c	; 0x284c <memset>
        
        /* set file name */
        const char* long_name_curr = name + (lfn_entry - 1) * 13;
    c6d6:	f3 9c       	mul	r15, r3
    c6d8:	d0 01       	movw	r26, r0
    c6da:	11 24       	eor	r1, r1
    c6dc:	1d 97       	sbiw	r26, 0x0d	; 13
    c6de:	a0 0f       	add	r26, r16
    c6e0:	b1 1f       	adc	r27, r17
    c6e2:	91 e0       	ldi	r25, 0x01	; 1
        uint8_t i = 1;
        while(i < 0x1f)
        {
            buffer[i++] = *long_name_curr;
    c6e4:	f4 01       	movw	r30, r8
    c6e6:	e9 0f       	add	r30, r25
    c6e8:	f1 1d       	adc	r31, r1
    c6ea:	8c 91       	ld	r24, X
    c6ec:	80 83       	st	Z, r24
    c6ee:	89 2f       	mov	r24, r25
    c6f0:	8f 5f       	subi	r24, 0xFF	; 255
            buffer[i++] = 0;
    c6f2:	f4 01       	movw	r30, r8
    c6f4:	e8 0f       	add	r30, r24
    c6f6:	f1 1d       	adc	r31, r1
    c6f8:	10 82       	st	Z, r1
    c6fa:	9e 5f       	subi	r25, 0xFE	; 254

            switch(i)
    c6fc:	9b 30       	cpi	r25, 0x0B	; 11
    c6fe:	19 f0       	breq	.+6      	; 0xc706 <fat_write_dir_entry+0x200>
    c700:	9a 31       	cpi	r25, 0x1A	; 26
    c702:	21 f4       	brne	.+8      	; 0xc70c <fat_write_dir_entry+0x206>
    c704:	02 c0       	rjmp	.+4      	; 0xc70a <fat_write_dir_entry+0x204>
    c706:	9e e0       	ldi	r25, 0x0E	; 14
    c708:	01 c0       	rjmp	.+2      	; 0xc70c <fat_write_dir_entry+0x206>
    c70a:	9c e1       	ldi	r25, 0x1C	; 28
                case 0x1a:
                    i = 0x1c;
                    break;
            }

            if(!*long_name_curr++)
    c70c:	8c 91       	ld	r24, X
    c70e:	88 23       	and	r24, r24
    c710:	21 f0       	breq	.+8      	; 0xc71a <fat_write_dir_entry+0x214>
        memset(buffer, 0xff, sizeof(buffer));
        
        /* set file name */
        const char* long_name_curr = name + (lfn_entry - 1) * 13;
        uint8_t i = 1;
        while(i < 0x1f)
    c712:	9f 31       	cpi	r25, 0x1F	; 31
    c714:	10 f4       	brcc	.+4      	; 0xc71a <fat_write_dir_entry+0x214>
                case 0x1a:
                    i = 0x1c;
                    break;
            }

            if(!*long_name_curr++)
    c716:	11 96       	adiw	r26, 0x01	; 1
    c718:	e5 cf       	rjmp	.-54     	; 0xc6e4 <fat_write_dir_entry+0x1de>
                break;
        }
        
        /* set index of lfn entry */
        buffer[0x00] = lfn_entry;
    c71a:	f9 82       	std	Y+1, r15	; 0x01
        if(lfn_entry == lfn_entry_count)
    c71c:	f7 14       	cp	r15, r7
    c71e:	19 f4       	brne	.+6      	; 0xc726 <fat_write_dir_entry+0x220>
            buffer[0x00] |= FAT_DIRENTRY_LFNLAST;
    c720:	8f 2d       	mov	r24, r15
    c722:	80 64       	ori	r24, 0x40	; 64
    c724:	89 83       	std	Y+1, r24	; 0x01

        /* mark as lfn entry */
        buffer[0x0b] = 0x0f;
    c726:	6c 86       	std	Y+12, r6	; 0x0c

        /* set 8.3 checksum */
        buffer[0x0d] = checksum;
    c728:	ee 86       	std	Y+14, r14	; 0x0e

        /* clear reserved bytes */
        buffer[0x0c] = 0;
    c72a:	1d 86       	std	Y+13, r1	; 0x0d
        buffer[0x1a] = 0;
    c72c:	1b 8e       	std	Y+27, r1	; 0x1b
        buffer[0x1b] = 0;
    c72e:	1c 8e       	std	Y+28, r1	; 0x1c

        /* write entry */
        device_write(offset, buffer, sizeof(buffer));
    c730:	c6 01       	movw	r24, r12
    c732:	b5 01       	movw	r22, r10
    c734:	a4 01       	movw	r20, r8
    c736:	20 e2       	ldi	r18, 0x20	; 32
    c738:	30 e0       	ldi	r19, 0x00	; 0
    c73a:	f2 01       	movw	r30, r4
    c73c:	09 95       	icall
    
        offset += sizeof(buffer);
    c73e:	80 e2       	ldi	r24, 0x20	; 32
    c740:	90 e0       	ldi	r25, 0x00	; 0
    c742:	a0 e0       	ldi	r26, 0x00	; 0
    c744:	b0 e0       	ldi	r27, 0x00	; 0
    c746:	a8 0e       	add	r10, r24
    c748:	b9 1e       	adc	r11, r25
    c74a:	ca 1e       	adc	r12, r26
    c74c:	db 1e       	adc	r13, r27
    uint8_t checksum = buffer[0];
    for(uint8_t i = 1; i < 11; ++i)
        checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
    /* write lfn entries */
    for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
    c74e:	fa 94       	dec	r15
    c750:	ff 20       	and	r15, r15
    c752:	09 f0       	breq	.+2      	; 0xc756 <fat_write_dir_entry+0x250>
    c754:	b9 cf       	rjmp	.-142    	; 0xc6c8 <fat_write_dir_entry+0x1c2>
    c756:	81 e0       	ldi	r24, 0x01	; 1
    c758:	01 c0       	rjmp	.+2      	; 0xc75c <fat_write_dir_entry+0x256>
    c75a:	80 e0       	ldi	r24, 0x00	; 0
    
        offset += sizeof(buffer);
    }
    
    return 1;
}
    c75c:	a0 96       	adiw	r28, 0x20	; 32
    c75e:	e1 e1       	ldi	r30, 0x11	; 17
    c760:	0c 94 d6 6a 	jmp	0xd5ac	; 0xd5ac <__epilogue_restores__+0x2>

0000c764 <fat_create_file>:
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat_delete_file
 */
uint8_t fat_create_file(struct fat_dir_struct* parent, const char* file, struct fat_dir_entry_struct* dir_entry)
{
    c764:	a0 e0       	ldi	r26, 0x00	; 0
    c766:	b0 e0       	ldi	r27, 0x00	; 0
    c768:	e8 eb       	ldi	r30, 0xB8	; 184
    c76a:	f3 e6       	ldi	r31, 0x63	; 99
    c76c:	0c 94 c1 6a 	jmp	0xd582	; 0xd582 <__prologue_saves__+0x10>
    c770:	8c 01       	movw	r16, r24
    c772:	7b 01       	movw	r14, r22
    c774:	ea 01       	movw	r28, r20
    if(!parent || !file || !file[0] || !dir_entry)
    c776:	00 97       	sbiw	r24, 0x00	; 0
    c778:	09 f4       	brne	.+2      	; 0xc77c <fat_create_file+0x18>
    c77a:	48 c0       	rjmp	.+144    	; 0xc80c <fat_create_file+0xa8>
    c77c:	61 15       	cp	r22, r1
    c77e:	71 05       	cpc	r23, r1
    c780:	09 f4       	brne	.+2      	; 0xc784 <fat_create_file+0x20>
    c782:	44 c0       	rjmp	.+136    	; 0xc80c <fat_create_file+0xa8>
    c784:	fb 01       	movw	r30, r22
    c786:	80 81       	ld	r24, Z
    c788:	88 23       	and	r24, r24
    c78a:	09 f4       	brne	.+2      	; 0xc78e <fat_create_file+0x2a>
    c78c:	3f c0       	rjmp	.+126    	; 0xc80c <fat_create_file+0xa8>
    c78e:	41 15       	cp	r20, r1
    c790:	51 05       	cpc	r21, r1
    c792:	e1 f1       	breq	.+120    	; 0xc80c <fat_create_file+0xa8>
    while(1)
    {
        if(!fat_read_dir(parent, dir_entry))
            break;

        if(strcmp(file, dir_entry->long_name) == 0)
    c794:	b4 2e       	mov	r11, r20
    c796:	ad 2e       	mov	r10, r29
        return 0;

    /* check if the file already exists */
    while(1)
    {
        if(!fat_read_dir(parent, dir_entry))
    c798:	c8 01       	movw	r24, r16
    c79a:	be 01       	movw	r22, r28
    c79c:	0e 94 db 60 	call	0xc1b6	; 0xc1b6 <fat_read_dir>
    c7a0:	88 23       	and	r24, r24
    c7a2:	79 f0       	breq	.+30     	; 0xc7c2 <fat_create_file+0x5e>
            break;

        if(strcmp(file, dir_entry->long_name) == 0)
    c7a4:	c7 01       	movw	r24, r14
    c7a6:	6b 2d       	mov	r22, r11
    c7a8:	7a 2d       	mov	r23, r10
    c7aa:	0e 94 38 14 	call	0x2870	; 0x2870 <strcmp>
    c7ae:	00 97       	sbiw	r24, 0x00	; 0
    c7b0:	99 f7       	brne	.-26     	; 0xc798 <fat_create_file+0x34>
uint8_t fat_reset_dir(struct fat_dir_struct* dd)
{
    if(!dd)
        return 0;

    dd->entry_cluster = dd->dir_entry.cluster;
    c7b2:	f8 01       	movw	r30, r16
    c7b4:	83 a1       	ldd	r24, Z+35	; 0x23
    c7b6:	94 a1       	ldd	r25, Z+36	; 0x24
    c7b8:	96 a7       	std	Z+46, r25	; 0x2e
    c7ba:	85 a7       	std	Z+45, r24	; 0x2d
    dd->entry_offset = 0;
    c7bc:	10 aa       	std	Z+48, r1	; 0x30
    c7be:	17 a6       	std	Z+47, r1	; 0x2f
    c7c0:	25 c0       	rjmp	.+74     	; 0xc80c <fat_create_file+0xa8>
            fat_reset_dir(parent);
            return 0;
        }
    }

    struct fat_fs_struct* fs = parent->fs;
    c7c2:	f8 01       	movw	r30, r16
    c7c4:	c0 80       	ld	r12, Z
    c7c6:	d1 80       	ldd	r13, Z+1	; 0x01

    /* prepare directory entry with values already known */
    memset(dir_entry, 0, sizeof(*dir_entry));
    c7c8:	8b e2       	ldi	r24, 0x2B	; 43
    c7ca:	fe 01       	movw	r30, r28
    c7cc:	11 92       	st	Z+, r1
    c7ce:	8a 95       	dec	r24
    c7d0:	e9 f7       	brne	.-6      	; 0xc7cc <fat_create_file+0x68>
    strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    c7d2:	8b 2d       	mov	r24, r11
    c7d4:	9a 2d       	mov	r25, r10
    c7d6:	b7 01       	movw	r22, r14
    c7d8:	4f e1       	ldi	r20, 0x1F	; 31
    c7da:	50 e0       	ldi	r21, 0x00	; 0
    c7dc:	0e 94 4f 14 	call	0x289e	; 0x289e <strncpy>

    /* find place where to store directory entry */
    if(!(dir_entry->entry_offset = fat_find_offset_for_dir_entry(fs, parent, dir_entry)))
    c7e0:	c6 01       	movw	r24, r12
    c7e2:	b8 01       	movw	r22, r16
    c7e4:	ae 01       	movw	r20, r28
    c7e6:	0e 94 9d 61 	call	0xc33a	; 0xc33a <fat_find_offset_for_dir_entry>
    c7ea:	6f a3       	std	Y+39, r22	; 0x27
    c7ec:	78 a7       	std	Y+40, r23	; 0x28
    c7ee:	89 a7       	std	Y+41, r24	; 0x29
    c7f0:	9a a7       	std	Y+42, r25	; 0x2a
    c7f2:	61 15       	cp	r22, r1
    c7f4:	71 05       	cpc	r23, r1
    c7f6:	81 05       	cpc	r24, r1
    c7f8:	91 05       	cpc	r25, r1
    c7fa:	41 f0       	breq	.+16     	; 0xc80c <fat_create_file+0xa8>
        return 0;
    
    /* write directory entry to disk */
    if(!fat_write_dir_entry(fs, dir_entry))
    c7fc:	c6 01       	movw	r24, r12
    c7fe:	be 01       	movw	r22, r28
    c800:	0e 94 83 62 	call	0xc506	; 0xc506 <fat_write_dir_entry>
    c804:	88 23       	and	r24, r24
    c806:	19 f0       	breq	.+6      	; 0xc80e <fat_create_file+0xaa>
    c808:	81 e0       	ldi	r24, 0x01	; 1
    c80a:	01 c0       	rjmp	.+2      	; 0xc80e <fat_create_file+0xaa>
    c80c:	80 e0       	ldi	r24, 0x00	; 0
        return 0;
    
    return 1;
}
    c80e:	cd b7       	in	r28, 0x3d	; 61
    c810:	de b7       	in	r29, 0x3e	; 62
    c812:	ea e0       	ldi	r30, 0x0A	; 10
    c814:	0c 94 dd 6a 	jmp	0xd5ba	; 0xd5ba <__epilogue_restores__+0x10>

0000c818 <fat_resize_file>:
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat_resize_file(struct fat_file_struct* fd, uint32_t size)
{
    c818:	aa e0       	ldi	r26, 0x0A	; 10
    c81a:	b0 e0       	ldi	r27, 0x00	; 0
    c81c:	e2 e1       	ldi	r30, 0x12	; 18
    c81e:	f4 e6       	ldi	r31, 0x64	; 100
    c820:	0c 94 bb 6a 	jmp	0xd576	; 0xd576 <__prologue_saves__+0x4>
    c824:	2c 01       	movw	r4, r24
    c826:	5a 01       	movw	r10, r20
    c828:	6b 01       	movw	r12, r22
    if(!fd)
    c82a:	00 97       	sbiw	r24, 0x00	; 0
    c82c:	09 f4       	brne	.+2      	; 0xc830 <fat_resize_file+0x18>
    c82e:	e6 c0       	rjmp	.+460    	; 0xc9fc <fat_resize_file+0x1e4>
        return 0;

    cluster_t cluster_num = fd->dir_entry.cluster;
    c830:	dc 01       	movw	r26, r24
    c832:	93 96       	adiw	r26, 0x23	; 35
    c834:	0d 91       	ld	r16, X+
    c836:	1c 91       	ld	r17, X
    c838:	94 97       	sbiw	r26, 0x24	; 36
    uint16_t cluster_size = fd->fs->header.cluster_size;
    c83a:	ed 91       	ld	r30, X+
    c83c:	fc 91       	ld	r31, X
    c83e:	20 89       	ldd	r18, Z+16	; 0x10
    c840:	31 89       	ldd	r19, Z+17	; 0x11
    uint32_t size_new = size;

    do
    {
        if(cluster_num == 0 && size_new == 0)
    c842:	01 15       	cp	r16, r1
    c844:	11 05       	cpc	r17, r1
    c846:	99 f0       	breq	.+38     	; 0xc86e <fat_resize_file+0x56>
    c848:	ab 82       	std	Y+3, r10	; 0x03
    c84a:	bc 82       	std	Y+4, r11	; 0x04
    c84c:	cd 82       	std	Y+5, r12	; 0x05
    c84e:	de 82       	std	Y+6, r13	; 0x06
            /* the file stays empty */
            break;

        /* seek to the next cluster as long as we need the space */
        while(size_new > cluster_size)
    c850:	39 01       	movw	r6, r18
    c852:	88 24       	eor	r8, r8
    c854:	99 24       	eor	r9, r9
                cluster_num = cluster_num_next;
                size_new -= cluster_size;
            }
            else
            {
                break;
    c856:	22 27       	eor	r18, r18
    c858:	33 27       	eor	r19, r19
    c85a:	a9 01       	movw	r20, r18
    c85c:	26 19       	sub	r18, r6
    c85e:	37 09       	sbc	r19, r7
    c860:	48 09       	sbc	r20, r8
    c862:	59 09       	sbc	r21, r9
    c864:	2f 83       	std	Y+7, r18	; 0x07
    c866:	38 87       	std	Y+8, r19	; 0x08
    c868:	49 87       	std	Y+9, r20	; 0x09
    c86a:	5a 87       	std	Y+10, r21	; 0x0a
    c86c:	20 c0       	rjmp	.+64     	; 0xc8ae <fat_resize_file+0x96>
    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint32_t size_new = size;

    do
    {
        if(cluster_num == 0 && size_new == 0)
    c86e:	41 15       	cp	r20, r1
    c870:	51 05       	cpc	r21, r1
    c872:	61 05       	cpc	r22, r1
    c874:	71 05       	cpc	r23, r1
    c876:	09 f4       	brne	.+2      	; 0xc87a <fat_resize_file+0x62>
    c878:	aa c0       	rjmp	.+340    	; 0xc9ce <fat_resize_file+0x1b6>
    c87a:	e6 cf       	rjmp	.-52     	; 0xc848 <fat_resize_file+0x30>

        /* seek to the next cluster as long as we need the space */
        while(size_new > cluster_size)
        {
            /* get next cluster of file */
            cluster_t cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
    c87c:	d2 01       	movw	r26, r4
    c87e:	8d 91       	ld	r24, X+
    c880:	9c 91       	ld	r25, X
    c882:	b8 01       	movw	r22, r16
    c884:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
            if(cluster_num_next)
    c888:	00 97       	sbiw	r24, 0x00	; 0
    c88a:	d9 f0       	breq	.+54     	; 0xc8c2 <fat_resize_file+0xaa>
                cluster_num = cluster_num_next;
                size_new -= cluster_size;
            }
            else
            {
                break;
    c88c:	eb 80       	ldd	r14, Y+3	; 0x03
    c88e:	fc 80       	ldd	r15, Y+4	; 0x04
    c890:	0d 81       	ldd	r16, Y+5	; 0x05
    c892:	1e 81       	ldd	r17, Y+6	; 0x06
    c894:	2f 81       	ldd	r18, Y+7	; 0x07
    c896:	38 85       	ldd	r19, Y+8	; 0x08
    c898:	49 85       	ldd	r20, Y+9	; 0x09
    c89a:	5a 85       	ldd	r21, Y+10	; 0x0a
    c89c:	e2 0e       	add	r14, r18
    c89e:	f3 1e       	adc	r15, r19
    c8a0:	04 1f       	adc	r16, r20
    c8a2:	15 1f       	adc	r17, r21
    c8a4:	eb 82       	std	Y+3, r14	; 0x03
    c8a6:	fc 82       	std	Y+4, r15	; 0x04
    c8a8:	0d 83       	std	Y+5, r16	; 0x05
    c8aa:	1e 83       	std	Y+6, r17	; 0x06
    c8ac:	8c 01       	movw	r16, r24
        if(cluster_num == 0 && size_new == 0)
            /* the file stays empty */
            break;

        /* seek to the next cluster as long as we need the space */
        while(size_new > cluster_size)
    c8ae:	8b 81       	ldd	r24, Y+3	; 0x03
    c8b0:	9c 81       	ldd	r25, Y+4	; 0x04
    c8b2:	ad 81       	ldd	r26, Y+5	; 0x05
    c8b4:	be 81       	ldd	r27, Y+6	; 0x06
    c8b6:	68 16       	cp	r6, r24
    c8b8:	79 06       	cpc	r7, r25
    c8ba:	8a 06       	cpc	r8, r26
    c8bc:	9b 06       	cpc	r9, r27
    c8be:	f0 f2       	brcs	.-68     	; 0xc87c <fat_resize_file+0x64>
    c8c0:	a2 c0       	rjmp	.+324    	; 0xca06 <fat_resize_file+0x1ee>
    c8c2:	78 01       	movw	r14, r16
        {
            /* Allocate new cluster chain and append
             * it to the existing one, if available.
             */
            cluster_t cluster_count = (size_new + cluster_size - 1) / cluster_size;
            cluster_t cluster_new_chain = fat_append_clusters(fd->fs, cluster_num, cluster_count);
    c8c4:	6b 81       	ldd	r22, Y+3	; 0x03
    c8c6:	7c 81       	ldd	r23, Y+4	; 0x04
    c8c8:	8d 81       	ldd	r24, Y+5	; 0x05
    c8ca:	9e 81       	ldd	r25, Y+6	; 0x06
    c8cc:	66 0d       	add	r22, r6
    c8ce:	77 1d       	adc	r23, r7
    c8d0:	88 1d       	adc	r24, r8
    c8d2:	99 1d       	adc	r25, r9
    c8d4:	61 50       	subi	r22, 0x01	; 1
    c8d6:	70 40       	sbci	r23, 0x00	; 0
    c8d8:	80 40       	sbci	r24, 0x00	; 0
    c8da:	90 40       	sbci	r25, 0x00	; 0
    c8dc:	a4 01       	movw	r20, r8
    c8de:	93 01       	movw	r18, r6
    c8e0:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    c8e4:	d2 01       	movw	r26, r4
    c8e6:	8d 91       	ld	r24, X+
    c8e8:	9c 91       	ld	r25, X
    c8ea:	b8 01       	movw	r22, r16
    c8ec:	a9 01       	movw	r20, r18
    c8ee:	0e 94 f5 5d 	call	0xbbea	; 0xbbea <fat_append_clusters>
            if(!cluster_new_chain)
    c8f2:	00 97       	sbiw	r24, 0x00	; 0
    c8f4:	09 f4       	brne	.+2      	; 0xc8f8 <fat_resize_file+0xe0>
    c8f6:	82 c0       	rjmp	.+260    	; 0xc9fc <fat_resize_file+0x1e4>
                return 0;

            if(!cluster_num)
    c8f8:	01 15       	cp	r16, r1
    c8fa:	11 05       	cpc	r17, r1
    c8fc:	21 f4       	brne	.+8      	; 0xc906 <fat_resize_file+0xee>
            {
                cluster_num = cluster_new_chain;
                fd->dir_entry.cluster = cluster_num;
    c8fe:	f2 01       	movw	r30, r4
    c900:	94 a3       	std	Z+36, r25	; 0x24
    c902:	83 a3       	std	Z+35, r24	; 0x23
    c904:	7c 01       	movw	r14, r24
            }
        }

        /* write new directory entry */
        fd->dir_entry.file_size = size;
    c906:	d2 01       	movw	r26, r4
    c908:	95 96       	adiw	r26, 0x25	; 37
    c90a:	ad 92       	st	X+, r10
    c90c:	bd 92       	st	X+, r11
    c90e:	cd 92       	st	X+, r12
    c910:	dc 92       	st	X, r13
    c912:	98 97       	sbiw	r26, 0x28	; 40
        if(size == 0)
    c914:	a1 14       	cp	r10, r1
    c916:	b1 04       	cpc	r11, r1
    c918:	c1 04       	cpc	r12, r1
    c91a:	d1 04       	cpc	r13, r1
    c91c:	21 f4       	brne	.+8      	; 0xc926 <fat_resize_file+0x10e>
            fd->dir_entry.cluster = 0;
    c91e:	94 96       	adiw	r26, 0x24	; 36
    c920:	1c 92       	st	X, r1
    c922:	1e 92       	st	-X, r1
    c924:	93 97       	sbiw	r26, 0x23	; 35
        if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
    c926:	f2 01       	movw	r30, r4
    c928:	81 91       	ld	r24, Z+
    c92a:	91 91       	ld	r25, Z+
    c92c:	bf 01       	movw	r22, r30
    c92e:	0e 94 83 62 	call	0xc506	; 0xc506 <fat_write_dir_entry>
    c932:	88 23       	and	r24, r24
    c934:	09 f4       	brne	.+2      	; 0xc938 <fat_resize_file+0x120>
    c936:	62 c0       	rjmp	.+196    	; 0xc9fc <fat_resize_file+0x1e4>
            return 0;

        if(size == 0)
    c938:	a1 14       	cp	r10, r1
    c93a:	b1 04       	cpc	r11, r1
    c93c:	c1 04       	cpc	r12, r1
    c93e:	d1 04       	cpc	r13, r1
    c940:	29 f4       	brne	.+10     	; 0xc94c <fat_resize_file+0x134>
        {
            /* free all clusters of file */
            fat_free_clusters(fd->fs, cluster_num);
    c942:	f2 01       	movw	r30, r4
    c944:	80 81       	ld	r24, Z
    c946:	91 81       	ldd	r25, Z+1	; 0x01
    c948:	b7 01       	movw	r22, r14
    c94a:	3f c0       	rjmp	.+126    	; 0xc9ca <fat_resize_file+0x1b2>
        }
        else if(size_new <= cluster_size)
    c94c:	0b 81       	ldd	r16, Y+3	; 0x03
    c94e:	1c 81       	ldd	r17, Y+4	; 0x04
    c950:	2d 81       	ldd	r18, Y+5	; 0x05
    c952:	3e 81       	ldd	r19, Y+6	; 0x06
    c954:	60 16       	cp	r6, r16
    c956:	71 06       	cpc	r7, r17
    c958:	82 06       	cpc	r8, r18
    c95a:	93 06       	cpc	r9, r19
    c95c:	c0 f1       	brcs	.+112    	; 0xc9ce <fat_resize_file+0x1b6>
        {
            /* free all clusters no longer needed */
            fat_terminate_clusters(fd->fs, cluster_num);
    c95e:	d2 01       	movw	r26, r4
    c960:	0d 91       	ld	r16, X+
    c962:	1c 91       	ld	r17, X
 * \returns 0 on failure, 1 on success.
 * \see fat_free_clusters
 */
uint8_t fat_terminate_clusters(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    if(!fs || cluster_num < 2)
    c964:	01 15       	cp	r16, r1
    c966:	11 05       	cpc	r17, r1
    c968:	91 f1       	breq	.+100    	; 0xc9ce <fat_resize_file+0x1b6>
    c96a:	b2 e0       	ldi	r27, 0x02	; 2
    c96c:	eb 16       	cp	r14, r27
    c96e:	f1 04       	cpc	r15, r1
    c970:	70 f1       	brcs	.+92     	; 0xc9ce <fat_resize_file+0x1b6>
        return 0;

    /* fetch next cluster before overwriting the cluster entry */
    cluster_t cluster_num_next = fat_get_next_cluster(fs, cluster_num);
    c972:	c8 01       	movw	r24, r16
    c974:	b7 01       	movw	r22, r14
    c976:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
    c97a:	4c 01       	movw	r8, r24
            return 0;
    }
    else
#endif
    {
        uint16_t fat_entry = HTOL16(FAT16_CLUSTER_LAST_MAX);
    c97c:	8f ef       	ldi	r24, 0xFF	; 255
    c97e:	9f ef       	ldi	r25, 0xFF	; 255
    c980:	9a 83       	std	Y+2, r25	; 0x02
    c982:	89 83       	std	Y+1, r24	; 0x01
        if(!fs->partition->device_write(fs->header.fat_offset + cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
    c984:	d8 01       	movw	r26, r16
    c986:	ed 91       	ld	r30, X+
    c988:	fc 91       	ld	r31, X
    c98a:	11 97       	sbiw	r26, 0x01	; 1
    c98c:	ee 0c       	add	r14, r14
    c98e:	ff 1c       	adc	r15, r15
    c990:	b7 01       	movw	r22, r14
    c992:	80 e0       	ldi	r24, 0x00	; 0
    c994:	90 e0       	ldi	r25, 0x00	; 0
    c996:	16 96       	adiw	r26, 0x06	; 6
    c998:	2d 91       	ld	r18, X+
    c99a:	3d 91       	ld	r19, X+
    c99c:	4d 91       	ld	r20, X+
    c99e:	5c 91       	ld	r21, X
    c9a0:	19 97       	sbiw	r26, 0x09	; 9
    c9a2:	62 0f       	add	r22, r18
    c9a4:	73 1f       	adc	r23, r19
    c9a6:	84 1f       	adc	r24, r20
    c9a8:	95 1f       	adc	r25, r21
    c9aa:	04 80       	ldd	r0, Z+4	; 0x04
    c9ac:	f5 81       	ldd	r31, Z+5	; 0x05
    c9ae:	e0 2d       	mov	r30, r0
    c9b0:	ae 01       	movw	r20, r28
    c9b2:	4f 5f       	subi	r20, 0xFF	; 255
    c9b4:	5f 4f       	sbci	r21, 0xFF	; 255
    c9b6:	22 e0       	ldi	r18, 0x02	; 2
    c9b8:	30 e0       	ldi	r19, 0x00	; 0
    c9ba:	09 95       	icall
    c9bc:	88 23       	and	r24, r24
    c9be:	39 f0       	breq	.+14     	; 0xc9ce <fat_resize_file+0x1b6>
            return 0;
    }

    /* free remaining clusters */
    if(cluster_num_next)
    c9c0:	81 14       	cp	r8, r1
    c9c2:	91 04       	cpc	r9, r1
    c9c4:	21 f0       	breq	.+8      	; 0xc9ce <fat_resize_file+0x1b6>
        return fat_free_clusters(fs, cluster_num_next);
    c9c6:	c8 01       	movw	r24, r16
    c9c8:	b4 01       	movw	r22, r8
    c9ca:	0e 94 9b 5d 	call	0xbb36	; 0xbb36 <fat_free_clusters>
        }

    } while(0);

    /* correct file position */
    if(size < fd->pos)
    c9ce:	f2 01       	movw	r30, r4
    c9d0:	85 a5       	ldd	r24, Z+45	; 0x2d
    c9d2:	96 a5       	ldd	r25, Z+46	; 0x2e
    c9d4:	a7 a5       	ldd	r26, Z+47	; 0x2f
    c9d6:	b0 a9       	ldd	r27, Z+48	; 0x30
    c9d8:	a8 16       	cp	r10, r24
    c9da:	b9 06       	cpc	r11, r25
    c9dc:	ca 06       	cpc	r12, r26
    c9de:	db 06       	cpc	r13, r27
    c9e0:	58 f4       	brcc	.+22     	; 0xc9f8 <fat_resize_file+0x1e0>
    {
        fd->pos = size;
    c9e2:	d2 01       	movw	r26, r4
    c9e4:	9d 96       	adiw	r26, 0x2d	; 45
    c9e6:	ad 92       	st	X+, r10
    c9e8:	bd 92       	st	X+, r11
    c9ea:	cd 92       	st	X+, r12
    c9ec:	dc 92       	st	X, r13
    c9ee:	d0 97       	sbiw	r26, 0x30	; 48
        fd->pos_cluster = 0;
    c9f0:	d2 96       	adiw	r26, 0x32	; 50
    c9f2:	1c 92       	st	X, r1
    c9f4:	1e 92       	st	-X, r1
    c9f6:	d1 97       	sbiw	r26, 0x31	; 49
    c9f8:	81 e0       	ldi	r24, 0x01	; 1
    c9fa:	01 c0       	rjmp	.+2      	; 0xc9fe <fat_resize_file+0x1e6>
    c9fc:	80 e0       	ldi	r24, 0x00	; 0
    }

    return 1;
}
    c9fe:	2a 96       	adiw	r28, 0x0a	; 10
    ca00:	e0 e1       	ldi	r30, 0x10	; 16
    ca02:	0c 94 d7 6a 	jmp	0xd5ae	; 0xd5ae <__epilogue_restores__+0x4>

    /* correct file position */
    if(size < fd->pos)
    {
        fd->pos = size;
        fd->pos_cluster = 0;
    ca06:	78 01       	movw	r14, r16
            {
                break;
            }
        }

        if(size_new > cluster_size || cluster_num == 0)
    ca08:	01 15       	cp	r16, r1
    ca0a:	11 05       	cpc	r17, r1
    ca0c:	09 f4       	brne	.+2      	; 0xca10 <fat_resize_file+0x1f8>
    ca0e:	5a cf       	rjmp	.-332    	; 0xc8c4 <fat_resize_file+0xac>
    ca10:	7a cf       	rjmp	.-268    	; 0xc906 <fat_resize_file+0xee>

0000ca12 <fat_seek_file>:
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat_seek_file(struct fat_file_struct* fd, int32_t* offset, uint8_t whence)
{
    ca12:	a0 e0       	ldi	r26, 0x00	; 0
    ca14:	b0 e0       	ldi	r27, 0x00	; 0
    ca16:	ef e0       	ldi	r30, 0x0F	; 15
    ca18:	f5 e6       	ldi	r31, 0x65	; 101
    ca1a:	0c 94 c3 6a 	jmp	0xd586	; 0xd586 <__prologue_saves__+0x14>
    ca1e:	ec 01       	movw	r28, r24
    ca20:	6b 01       	movw	r12, r22
    if(!fd || !offset)
    ca22:	00 97       	sbiw	r24, 0x00	; 0
    ca24:	09 f4       	brne	.+2      	; 0xca28 <fat_seek_file+0x16>
    ca26:	45 c0       	rjmp	.+138    	; 0xcab2 <fat_seek_file+0xa0>
    ca28:	61 15       	cp	r22, r1
    ca2a:	71 05       	cpc	r23, r1
    ca2c:	09 f4       	brne	.+2      	; 0xca30 <fat_seek_file+0x1e>
    ca2e:	41 c0       	rjmp	.+130    	; 0xcab2 <fat_seek_file+0xa0>
        return 0;

    uint32_t new_pos = fd->pos;
    ca30:	8d a5       	ldd	r24, Y+45	; 0x2d
    ca32:	9e a5       	ldd	r25, Y+46	; 0x2e
    ca34:	af a5       	ldd	r26, Y+47	; 0x2f
    ca36:	b8 a9       	ldd	r27, Y+48	; 0x30
    switch(whence)
    ca38:	41 30       	cpi	r20, 0x01	; 1
    ca3a:	59 f0       	breq	.+22     	; 0xca52 <fat_seek_file+0x40>
    ca3c:	41 30       	cpi	r20, 0x01	; 1
    ca3e:	18 f0       	brcs	.+6      	; 0xca46 <fat_seek_file+0x34>
    ca40:	42 30       	cpi	r20, 0x02	; 2
    ca42:	b9 f5       	brne	.+110    	; 0xcab2 <fat_seek_file+0xa0>
    ca44:	0c c0       	rjmp	.+24     	; 0xca5e <fat_seek_file+0x4c>
    {
        case FAT_SEEK_SET:
            new_pos = *offset;
    ca46:	fb 01       	movw	r30, r22
    ca48:	e0 80       	ld	r14, Z
    ca4a:	f1 80       	ldd	r15, Z+1	; 0x01
    ca4c:	02 81       	ldd	r16, Z+2	; 0x02
    ca4e:	13 81       	ldd	r17, Z+3	; 0x03
    ca50:	13 c0       	rjmp	.+38     	; 0xca78 <fat_seek_file+0x66>
            break;
        case FAT_SEEK_CUR:
            new_pos += *offset;
    ca52:	fb 01       	movw	r30, r22
    ca54:	e0 80       	ld	r14, Z
    ca56:	f1 80       	ldd	r15, Z+1	; 0x01
    ca58:	02 81       	ldd	r16, Z+2	; 0x02
    ca5a:	13 81       	ldd	r17, Z+3	; 0x03
    ca5c:	09 c0       	rjmp	.+18     	; 0xca70 <fat_seek_file+0x5e>
            break;
        case FAT_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
    ca5e:	fb 01       	movw	r30, r22
    ca60:	e0 80       	ld	r14, Z
    ca62:	f1 80       	ldd	r15, Z+1	; 0x01
    ca64:	02 81       	ldd	r16, Z+2	; 0x02
    ca66:	13 81       	ldd	r17, Z+3	; 0x03
    ca68:	8d a1       	ldd	r24, Y+37	; 0x25
    ca6a:	9e a1       	ldd	r25, Y+38	; 0x26
    ca6c:	af a1       	ldd	r26, Y+39	; 0x27
    ca6e:	b8 a5       	ldd	r27, Y+40	; 0x28
    ca70:	e8 0e       	add	r14, r24
    ca72:	f9 1e       	adc	r15, r25
    ca74:	0a 1f       	adc	r16, r26
    ca76:	1b 1f       	adc	r17, r27
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size
    ca78:	8d a1       	ldd	r24, Y+37	; 0x25
    ca7a:	9e a1       	ldd	r25, Y+38	; 0x26
    ca7c:	af a1       	ldd	r26, Y+39	; 0x27
    ca7e:	b8 a5       	ldd	r27, Y+40	; 0x28
    ca80:	8e 15       	cp	r24, r14
    ca82:	9f 05       	cpc	r25, r15
    ca84:	a0 07       	cpc	r26, r16
    ca86:	b1 07       	cpc	r27, r17
    ca88:	38 f4       	brcc	.+14     	; 0xca98 <fat_seek_file+0x86>
    ca8a:	ce 01       	movw	r24, r28
    ca8c:	b8 01       	movw	r22, r16
    ca8e:	a7 01       	movw	r20, r14
    ca90:	0e 94 0c 64 	call	0xc818	; 0xc818 <fat_resize_file>
    ca94:	88 23       	and	r24, r24
    ca96:	69 f0       	breq	.+26     	; 0xcab2 <fat_seek_file+0xa0>
       && !fat_resize_file(fd, new_pos)
#endif
       )
        return 0;

    fd->pos = new_pos;
    ca98:	ed a6       	std	Y+45, r14	; 0x2d
    ca9a:	fe a6       	std	Y+46, r15	; 0x2e
    ca9c:	0f a7       	std	Y+47, r16	; 0x2f
    ca9e:	18 ab       	std	Y+48, r17	; 0x30
    fd->pos_cluster = 0;
    caa0:	1a aa       	std	Y+50, r1	; 0x32
    caa2:	19 aa       	std	Y+49, r1	; 0x31

    *offset = (int32_t) new_pos;
    caa4:	f6 01       	movw	r30, r12
    caa6:	e0 82       	st	Z, r14
    caa8:	f1 82       	std	Z+1, r15	; 0x01
    caaa:	02 83       	std	Z+2, r16	; 0x02
    caac:	13 83       	std	Z+3, r17	; 0x03
    caae:	81 e0       	ldi	r24, 0x01	; 1
    cab0:	01 c0       	rjmp	.+2      	; 0xcab4 <fat_seek_file+0xa2>
    return 1;
    cab2:	80 e0       	ldi	r24, 0x00	; 0
}
    cab4:	cd b7       	in	r28, 0x3d	; 61
    cab6:	de b7       	in	r29, 0x3e	; 62
    cab8:	e8 e0       	ldi	r30, 0x08	; 8
    caba:	0c 94 df 6a 	jmp	0xd5be	; 0xd5be <__epilogue_restores__+0x14>

0000cabe <fat_write_file>:
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat_read_file
 */
intptr_t fat_write_file(struct fat_file_struct* fd, const uint8_t* buffer, uintptr_t buffer_len)
{
    cabe:	a6 e0       	ldi	r26, 0x06	; 6
    cac0:	b0 e0       	ldi	r27, 0x00	; 0
    cac2:	e5 e6       	ldi	r30, 0x65	; 101
    cac4:	f5 e6       	ldi	r31, 0x65	; 101
    cac6:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    caca:	9e 83       	std	Y+6, r25	; 0x06
    cacc:	8d 83       	std	Y+5, r24	; 0x05
    cace:	7a 83       	std	Y+2, r23	; 0x02
    cad0:	69 83       	std	Y+1, r22	; 0x01
    cad2:	5c 83       	std	Y+4, r21	; 0x04
    cad4:	4b 83       	std	Y+3, r20	; 0x03
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
    cad6:	00 97       	sbiw	r24, 0x00	; 0
    cad8:	09 f4       	brne	.+2      	; 0xcadc <fat_write_file+0x1e>
    cada:	41 c1       	rjmp	.+642    	; 0xcd5e <fat_write_file+0x2a0>
    cadc:	67 2b       	or	r22, r23
    cade:	09 f4       	brne	.+2      	; 0xcae2 <fat_write_file+0x24>
    cae0:	3e c1       	rjmp	.+636    	; 0xcd5e <fat_write_file+0x2a0>
    cae2:	45 2b       	or	r20, r21
    cae4:	09 f4       	brne	.+2      	; 0xcae8 <fat_write_file+0x2a>
    cae6:	3b c1       	rjmp	.+630    	; 0xcd5e <fat_write_file+0x2a0>
        return -1;
    if(fd->pos > fd->dir_entry.file_size)
    cae8:	dc 01       	movw	r26, r24
    caea:	9d 96       	adiw	r26, 0x2d	; 45
    caec:	8d 90       	ld	r8, X+
    caee:	9d 90       	ld	r9, X+
    caf0:	ad 90       	ld	r10, X+
    caf2:	bc 90       	ld	r11, X
    caf4:	d0 97       	sbiw	r26, 0x30	; 48
    caf6:	fc 01       	movw	r30, r24
    caf8:	85 a1       	ldd	r24, Z+37	; 0x25
    cafa:	96 a1       	ldd	r25, Z+38	; 0x26
    cafc:	a7 a1       	ldd	r26, Z+39	; 0x27
    cafe:	b0 a5       	ldd	r27, Z+40	; 0x28
    cb00:	88 15       	cp	r24, r8
    cb02:	99 05       	cpc	r25, r9
    cb04:	aa 05       	cpc	r26, r10
    cb06:	bb 05       	cpc	r27, r11
    cb08:	08 f4       	brcc	.+2      	; 0xcb0c <fat_write_file+0x4e>
    cb0a:	29 c1       	rjmp	.+594    	; 0xcd5e <fat_write_file+0x2a0>
        return -1;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    cb0c:	01 90       	ld	r0, Z+
    cb0e:	f0 81       	ld	r31, Z
    cb10:	e0 2d       	mov	r30, r0
    cb12:	20 88       	ldd	r2, Z+16	; 0x10
    cb14:	31 88       	ldd	r3, Z+17	; 0x11
    cluster_t cluster_num = fd->pos_cluster;
    cb16:	ad 81       	ldd	r26, Y+5	; 0x05
    cb18:	be 81       	ldd	r27, Y+6	; 0x06
    cb1a:	d1 96       	adiw	r26, 0x31	; 49
    cb1c:	0d 91       	ld	r16, X+
    cb1e:	1c 91       	ld	r17, X
    cb20:	d2 97       	sbiw	r26, 0x32	; 50
    uintptr_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));

    /* find cluster in which to start writing */
    if(!cluster_num)
    cb22:	01 15       	cp	r16, r1
    cb24:	11 05       	cpc	r17, r1
    cb26:	09 f0       	breq	.+2      	; 0xcb2a <fat_write_file+0x6c>
    cb28:	55 c0       	rjmp	.+170    	; 0xcbd4 <fat_write_file+0x116>
    {
        cluster_num = fd->dir_entry.cluster;
    cb2a:	93 96       	adiw	r26, 0x23	; 35
    cb2c:	0d 91       	ld	r16, X+
    cb2e:	1c 91       	ld	r17, X
    cb30:	94 97       	sbiw	r26, 0x24	; 36
        
        if(!cluster_num)
    cb32:	01 15       	cp	r16, r1
    cb34:	11 05       	cpc	r17, r1
    cb36:	a9 f4       	brne	.+42     	; 0xcb62 <fat_write_file+0xa4>
        {
            if(!fd->pos)
    cb38:	81 14       	cp	r8, r1
    cb3a:	91 04       	cpc	r9, r1
    cb3c:	a1 04       	cpc	r10, r1
    cb3e:	b1 04       	cpc	r11, r1
    cb40:	09 f0       	breq	.+2      	; 0xcb44 <fat_write_file+0x86>
    cb42:	0d c1       	rjmp	.+538    	; 0xcd5e <fat_write_file+0x2a0>
            {
                /* empty file */
                fd->dir_entry.cluster = cluster_num = fat_append_clusters(fd->fs, 0, 1);
    cb44:	cf 01       	movw	r24, r30
    cb46:	60 e0       	ldi	r22, 0x00	; 0
    cb48:	70 e0       	ldi	r23, 0x00	; 0
    cb4a:	41 e0       	ldi	r20, 0x01	; 1
    cb4c:	50 e0       	ldi	r21, 0x00	; 0
    cb4e:	0e 94 f5 5d 	call	0xbbea	; 0xbbea <fat_append_clusters>
    cb52:	8c 01       	movw	r16, r24
    cb54:	ed 81       	ldd	r30, Y+5	; 0x05
    cb56:	fe 81       	ldd	r31, Y+6	; 0x06
    cb58:	94 a3       	std	Z+36, r25	; 0x24
    cb5a:	83 a3       	std	Z+35, r24	; 0x23
                if(!cluster_num)
    cb5c:	00 97       	sbiw	r24, 0x00	; 0
    cb5e:	09 f4       	brne	.+2      	; 0xcb62 <fat_write_file+0xa4>
    cb60:	fe c0       	rjmp	.+508    	; 0xcd5e <fat_write_file+0x2a0>
            {
                return -1;
            }
        }

        if(fd->pos)
    cb62:	ad 81       	ldd	r26, Y+5	; 0x05
    cb64:	be 81       	ldd	r27, Y+6	; 0x06
    cb66:	9d 96       	adiw	r26, 0x2d	; 45
    cb68:	cd 90       	ld	r12, X+
    cb6a:	dd 90       	ld	r13, X+
    cb6c:	ed 90       	ld	r14, X+
    cb6e:	fc 90       	ld	r15, X
    cb70:	d0 97       	sbiw	r26, 0x30	; 48
    cb72:	c1 14       	cp	r12, r1
    cb74:	d1 04       	cpc	r13, r1
    cb76:	e1 04       	cpc	r14, r1
    cb78:	f1 04       	cpc	r15, r1
    cb7a:	21 f5       	brne	.+72     	; 0xcbc4 <fat_write_file+0x106>
    cb7c:	2b c0       	rjmp	.+86     	; 0xcbd4 <fat_write_file+0x116>
        {
            uint32_t pos = fd->pos;
            cluster_t cluster_num_next;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
    cb7e:	c4 18       	sub	r12, r4
    cb80:	d5 08       	sbc	r13, r5
    cb82:	e6 08       	sbc	r14, r6
    cb84:	f7 08       	sbc	r15, r7
                cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
    cb86:	ed 81       	ldd	r30, Y+5	; 0x05
    cb88:	fe 81       	ldd	r31, Y+6	; 0x06
    cb8a:	80 81       	ld	r24, Z
    cb8c:	91 81       	ldd	r25, Z+1	; 0x01
    cb8e:	b8 01       	movw	r22, r16
    cb90:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
                if(!cluster_num_next && pos == 0)
    cb94:	00 97       	sbiw	r24, 0x00	; 0
    cb96:	11 f0       	breq	.+4      	; 0xcb9c <fat_write_file+0xde>
    cb98:	8c 01       	movw	r16, r24
    cb9a:	17 c0       	rjmp	.+46     	; 0xcbca <fat_write_file+0x10c>
    cb9c:	c1 14       	cp	r12, r1
    cb9e:	d1 04       	cpc	r13, r1
    cba0:	e1 04       	cpc	r14, r1
    cba2:	f1 04       	cpc	r15, r1
    cba4:	09 f0       	breq	.+2      	; 0xcba8 <fat_write_file+0xea>
    cba6:	db c0       	rjmp	.+438    	; 0xcd5e <fat_write_file+0x2a0>
                    /* the file exactly ends on a cluster boundary, and we append to it */
                    cluster_num_next = fat_append_clusters(fd->fs, cluster_num, 1);
    cba8:	ad 81       	ldd	r26, Y+5	; 0x05
    cbaa:	be 81       	ldd	r27, Y+6	; 0x06
    cbac:	8d 91       	ld	r24, X+
    cbae:	9c 91       	ld	r25, X
    cbb0:	b8 01       	movw	r22, r16
    cbb2:	41 e0       	ldi	r20, 0x01	; 1
    cbb4:	50 e0       	ldi	r21, 0x00	; 0
    cbb6:	0e 94 f5 5d 	call	0xbbea	; 0xbbea <fat_append_clusters>
                if(!cluster_num_next)
    cbba:	00 97       	sbiw	r24, 0x00	; 0
    cbbc:	09 f4       	brne	.+2      	; 0xcbc0 <fat_write_file+0x102>
    cbbe:	cf c0       	rjmp	.+414    	; 0xcd5e <fat_write_file+0x2a0>
    cbc0:	8c 01       	movw	r16, r24
    cbc2:	03 c0       	rjmp	.+6      	; 0xcbca <fat_write_file+0x10c>

        if(fd->pos)
        {
            uint32_t pos = fd->pos;
            cluster_t cluster_num_next;
            while(pos >= cluster_size)
    cbc4:	21 01       	movw	r4, r2
    cbc6:	66 24       	eor	r6, r6
    cbc8:	77 24       	eor	r7, r7
    cbca:	c4 14       	cp	r12, r4
    cbcc:	d5 04       	cpc	r13, r5
    cbce:	e6 04       	cpc	r14, r6
    cbd0:	f7 04       	cpc	r15, r7
    cbd2:	a8 f6       	brcc	.-86     	; 0xcb7e <fat_write_file+0xc0>
        return -1;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    cluster_t cluster_num = fd->pos_cluster;
    uintptr_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));
    cbd4:	08 94       	sec
    cbd6:	21 08       	sbc	r2, r1
    cbd8:	31 08       	sbc	r3, r1
    cbda:	82 20       	and	r8, r2
    cbdc:	93 20       	and	r9, r3
    cbde:	08 94       	sec
    cbe0:	21 1c       	adc	r2, r1
    cbe2:	31 1c       	adc	r3, r1
    cbe4:	ab 80       	ldd	r10, Y+3	; 0x03
    cbe6:	bc 80       	ldd	r11, Y+4	; 0x04
    
    /* write data */
    do
    {
        /* calculate data size to write to cluster */
        offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
    cbe8:	ed 81       	ldd	r30, Y+5	; 0x05
    cbea:	fe 81       	ldd	r31, Y+6	; 0x06
    cbec:	c0 80       	ld	r12, Z
    cbee:	d1 80       	ldd	r13, Z+1	; 0x01
 * \param[in] cluster_num The cluster whose offset to calculate.
 * \returns The cluster offset.
 */
offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
{
    if(!fs || cluster_num < 2)
    cbf0:	c1 14       	cp	r12, r1
    cbf2:	d1 04       	cpc	r13, r1
    cbf4:	f9 f0       	breq	.+62     	; 0xcc34 <fat_write_file+0x176>
    cbf6:	02 30       	cpi	r16, 0x02	; 2
    cbf8:	11 05       	cpc	r17, r1
    cbfa:	e0 f0       	brcs	.+56     	; 0xcc34 <fat_write_file+0x176>
        return 0;

    return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
    cbfc:	02 50       	subi	r16, 0x02	; 2
    cbfe:	10 40       	sbci	r17, 0x00	; 0
    cc00:	b8 01       	movw	r22, r16
    cc02:	80 e0       	ldi	r24, 0x00	; 0
    cc04:	90 e0       	ldi	r25, 0x00	; 0
    cc06:	0e 5f       	subi	r16, 0xFE	; 254
    cc08:	1f 4f       	sbci	r17, 0xFF	; 255
    cc0a:	d6 01       	movw	r26, r12
    cc0c:	50 96       	adiw	r26, 0x10	; 16
    cc0e:	2d 91       	ld	r18, X+
    cc10:	3c 91       	ld	r19, X
    cc12:	51 97       	sbiw	r26, 0x11	; 17
    cc14:	40 e0       	ldi	r20, 0x00	; 0
    cc16:	50 e0       	ldi	r21, 0x00	; 0
    cc18:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    cc1c:	9b 01       	movw	r18, r22
    cc1e:	ac 01       	movw	r20, r24
    cc20:	f6 01       	movw	r30, r12
    cc22:	82 89       	ldd	r24, Z+18	; 0x12
    cc24:	93 89       	ldd	r25, Z+19	; 0x13
    cc26:	a4 89       	ldd	r26, Z+20	; 0x14
    cc28:	b5 89       	ldd	r27, Z+21	; 0x15
    cc2a:	28 0f       	add	r18, r24
    cc2c:	39 1f       	adc	r19, r25
    cc2e:	4a 1f       	adc	r20, r26
    cc30:	5b 1f       	adc	r21, r27
    cc32:	04 c0       	rjmp	.+8      	; 0xcc3c <fat_write_file+0x17e>
    cc34:	20 e0       	ldi	r18, 0x00	; 0
    cc36:	30 e0       	ldi	r19, 0x00	; 0
    cc38:	40 e0       	ldi	r20, 0x00	; 0
    cc3a:	50 e0       	ldi	r21, 0x00	; 0
    /* write data */
    do
    {
        /* calculate data size to write to cluster */
        offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
        uint16_t write_length = cluster_size - first_cluster_offset;
    cc3c:	71 01       	movw	r14, r2
    cc3e:	e8 18       	sub	r14, r8
    cc40:	f9 08       	sbc	r15, r9
    cc42:	ae 14       	cp	r10, r14
    cc44:	bf 04       	cpc	r11, r15
    cc46:	08 f4       	brcc	.+2      	; 0xcc4a <fat_write_file+0x18c>
    cc48:	75 01       	movw	r14, r10
        if(write_length > buffer_left)
            write_length = buffer_left;

        /* write data which fits into the current cluster */
        if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
    cc4a:	d6 01       	movw	r26, r12
    cc4c:	ed 91       	ld	r30, X+
    cc4e:	fc 91       	ld	r31, X
    cc50:	c4 01       	movw	r24, r8
    cc52:	a0 e0       	ldi	r26, 0x00	; 0
    cc54:	b0 e0       	ldi	r27, 0x00	; 0
    cc56:	28 0f       	add	r18, r24
    cc58:	39 1f       	adc	r19, r25
    cc5a:	4a 1f       	adc	r20, r26
    cc5c:	5b 1f       	adc	r21, r27
    cc5e:	04 80       	ldd	r0, Z+4	; 0x04
    cc60:	f5 81       	ldd	r31, Z+5	; 0x05
    cc62:	e0 2d       	mov	r30, r0
    cc64:	ca 01       	movw	r24, r20
    cc66:	b9 01       	movw	r22, r18
    cc68:	49 81       	ldd	r20, Y+1	; 0x01
    cc6a:	5a 81       	ldd	r21, Y+2	; 0x02
    cc6c:	97 01       	movw	r18, r14
    cc6e:	09 95       	icall
    cc70:	88 23       	and	r24, r24
    cc72:	09 f4       	brne	.+2      	; 0xcc76 <fat_write_file+0x1b8>
    cc74:	48 c0       	rjmp	.+144    	; 0xcd06 <fat_write_file+0x248>
            break;

        /* calculate new file position */
        buffer += write_length;
        buffer_left -= write_length;
    cc76:	ae 18       	sub	r10, r14
    cc78:	bf 08       	sbc	r11, r15
        fd->pos += write_length;
    cc7a:	c7 01       	movw	r24, r14
    cc7c:	a0 e0       	ldi	r26, 0x00	; 0
    cc7e:	b0 e0       	ldi	r27, 0x00	; 0
    cc80:	ed 81       	ldd	r30, Y+5	; 0x05
    cc82:	fe 81       	ldd	r31, Y+6	; 0x06
    cc84:	25 a5       	ldd	r18, Z+45	; 0x2d
    cc86:	36 a5       	ldd	r19, Z+46	; 0x2e
    cc88:	47 a5       	ldd	r20, Z+47	; 0x2f
    cc8a:	50 a9       	ldd	r21, Z+48	; 0x30
    cc8c:	28 0f       	add	r18, r24
    cc8e:	39 1f       	adc	r19, r25
    cc90:	4a 1f       	adc	r20, r26
    cc92:	5b 1f       	adc	r21, r27
    cc94:	25 a7       	std	Z+45, r18	; 0x2d
    cc96:	36 a7       	std	Z+46, r19	; 0x2e
    cc98:	47 a7       	std	Z+47, r20	; 0x2f
    cc9a:	50 ab       	std	Z+48, r21	; 0x30

        if(first_cluster_offset + write_length >= cluster_size)
    cc9c:	c7 01       	movw	r24, r14
    cc9e:	88 0d       	add	r24, r8
    cca0:	99 1d       	adc	r25, r9
    cca2:	82 15       	cp	r24, r2
    cca4:	93 05       	cpc	r25, r3
    cca6:	08 f1       	brcs	.+66     	; 0xccea <fat_write_file+0x22c>
        {
            /* we are on a cluster boundary, so get the next cluster */
            cluster_t cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
    cca8:	80 81       	ld	r24, Z
    ccaa:	91 81       	ldd	r25, Z+1	; 0x01
    ccac:	b8 01       	movw	r22, r16
    ccae:	0e 94 5b 5d 	call	0xbab6	; 0xbab6 <fat_get_next_cluster>
            if(!cluster_num_next && buffer_left > 0)
    ccb2:	00 97       	sbiw	r24, 0x00	; 0
    ccb4:	11 f0       	breq	.+4      	; 0xccba <fat_write_file+0x1fc>
    ccb6:	8c 01       	movw	r16, r24
    ccb8:	16 c0       	rjmp	.+44     	; 0xcce6 <fat_write_file+0x228>
    ccba:	a1 14       	cp	r10, r1
    ccbc:	b1 04       	cpc	r11, r1
    ccbe:	59 f0       	breq	.+22     	; 0xccd6 <fat_write_file+0x218>
                /* we reached the last cluster, append a new one */
                cluster_num_next = fat_append_clusters(fd->fs, cluster_num, 1);
    ccc0:	ed 81       	ldd	r30, Y+5	; 0x05
    ccc2:	fe 81       	ldd	r31, Y+6	; 0x06
    ccc4:	80 81       	ld	r24, Z
    ccc6:	91 81       	ldd	r25, Z+1	; 0x01
    ccc8:	b8 01       	movw	r22, r16
    ccca:	41 e0       	ldi	r20, 0x01	; 1
    cccc:	50 e0       	ldi	r21, 0x00	; 0
    ccce:	0e 94 f5 5d 	call	0xbbea	; 0xbbea <fat_append_clusters>
            if(!cluster_num_next)
    ccd2:	00 97       	sbiw	r24, 0x00	; 0
    ccd4:	39 f4       	brne	.+14     	; 0xcce4 <fat_write_file+0x226>
            {
                fd->pos_cluster = 0;
    ccd6:	ad 81       	ldd	r26, Y+5	; 0x05
    ccd8:	be 81       	ldd	r27, Y+6	; 0x06
    ccda:	d2 96       	adiw	r26, 0x32	; 50
    ccdc:	1c 92       	st	X, r1
    ccde:	1e 92       	st	-X, r1
    cce0:	d1 97       	sbiw	r26, 0x31	; 49
    cce2:	11 c0       	rjmp	.+34     	; 0xcd06 <fat_write_file+0x248>
                break;
    cce4:	8c 01       	movw	r16, r24
    cce6:	88 24       	eor	r8, r8
    cce8:	99 24       	eor	r9, r9

            cluster_num = cluster_num_next;
            first_cluster_offset = 0;
        }

        fd->pos_cluster = cluster_num;
    ccea:	ed 81       	ldd	r30, Y+5	; 0x05
    ccec:	fe 81       	ldd	r31, Y+6	; 0x06
    ccee:	12 ab       	std	Z+50, r17	; 0x32
    ccf0:	01 ab       	std	Z+49, r16	; 0x31

    } while(buffer_left > 0); /* check if we are done */
    ccf2:	a1 14       	cp	r10, r1
    ccf4:	b1 04       	cpc	r11, r1
    ccf6:	39 f0       	breq	.+14     	; 0xcd06 <fat_write_file+0x248>
        /* write data which fits into the current cluster */
        if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
            break;

        /* calculate new file position */
        buffer += write_length;
    ccf8:	89 81       	ldd	r24, Y+1	; 0x01
    ccfa:	9a 81       	ldd	r25, Y+2	; 0x02
    ccfc:	8e 0d       	add	r24, r14
    ccfe:	9f 1d       	adc	r25, r15
    cd00:	9a 83       	std	Y+2, r25	; 0x02
    cd02:	89 83       	std	Y+1, r24	; 0x01
    cd04:	71 cf       	rjmp	.-286    	; 0xcbe8 <fat_write_file+0x12a>
        fd->pos_cluster = cluster_num;

    } while(buffer_left > 0); /* check if we are done */

    /* update directory entry */
    if(fd->pos > fd->dir_entry.file_size)
    cd06:	ed 81       	ldd	r30, Y+5	; 0x05
    cd08:	fe 81       	ldd	r31, Y+6	; 0x06
    cd0a:	85 a5       	ldd	r24, Z+45	; 0x2d
    cd0c:	96 a5       	ldd	r25, Z+46	; 0x2e
    cd0e:	a7 a5       	ldd	r26, Z+47	; 0x2f
    cd10:	b0 a9       	ldd	r27, Z+48	; 0x30
    cd12:	e5 a0       	ldd	r14, Z+37	; 0x25
    cd14:	f6 a0       	ldd	r15, Z+38	; 0x26
    cd16:	07 a1       	ldd	r16, Z+39	; 0x27
    cd18:	10 a5       	ldd	r17, Z+40	; 0x28
    cd1a:	e8 16       	cp	r14, r24
    cd1c:	f9 06       	cpc	r15, r25
    cd1e:	0a 07       	cpc	r16, r26
    cd20:	1b 07       	cpc	r17, r27
    cd22:	c0 f4       	brcc	.+48     	; 0xcd54 <fat_write_file+0x296>
    {
        uint32_t size_old = fd->dir_entry.file_size;

        /* update file size */
        fd->dir_entry.file_size = fd->pos;
    cd24:	85 a3       	std	Z+37, r24	; 0x25
    cd26:	96 a3       	std	Z+38, r25	; 0x26
    cd28:	a7 a3       	std	Z+39, r26	; 0x27
    cd2a:	b0 a7       	std	Z+40, r27	; 0x28
        /* write directory entry */
        if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
    cd2c:	81 91       	ld	r24, Z+
    cd2e:	91 91       	ld	r25, Z+
    cd30:	bf 01       	movw	r22, r30
    cd32:	0e 94 83 62 	call	0xc506	; 0xc506 <fat_write_dir_entry>
    cd36:	88 23       	and	r24, r24
    cd38:	69 f4       	brne	.+26     	; 0xcd54 <fat_write_file+0x296>
        {
            /* We do not return an error here since we actually wrote
             * some data to disk. So we calculate the amount of data
             * we wrote to disk and which lies within the old file size.
             */
            buffer_left = fd->pos - size_old;
    cd3a:	ad 81       	ldd	r26, Y+5	; 0x05
    cd3c:	be 81       	ldd	r27, Y+6	; 0x06
    cd3e:	9d 96       	adiw	r26, 0x2d	; 45
    cd40:	ad 90       	ld	r10, X+
    cd42:	bc 90       	ld	r11, X
    cd44:	9e 97       	sbiw	r26, 0x2e	; 46
    cd46:	ae 18       	sub	r10, r14
    cd48:	bf 08       	sbc	r11, r15
            fd->pos = size_old;
    cd4a:	fd 01       	movw	r30, r26
    cd4c:	e5 a6       	std	Z+45, r14	; 0x2d
    cd4e:	f6 a6       	std	Z+46, r15	; 0x2e
    cd50:	07 a7       	std	Z+47, r16	; 0x2f
    cd52:	10 ab       	std	Z+48, r17	; 0x30
        }
    }

    return buffer_len - buffer_left;
    cd54:	4b 81       	ldd	r20, Y+3	; 0x03
    cd56:	5c 81       	ldd	r21, Y+4	; 0x04
    cd58:	4a 19       	sub	r20, r10
    cd5a:	5b 09       	sbc	r21, r11
    cd5c:	02 c0       	rjmp	.+4      	; 0xcd62 <fat_write_file+0x2a4>
    cd5e:	4f ef       	ldi	r20, 0xFF	; 255
    cd60:	5f ef       	ldi	r21, 0xFF	; 255
}
    cd62:	ca 01       	movw	r24, r20
    cd64:	26 96       	adiw	r28, 0x06	; 6
    cd66:	e2 e1       	ldi	r30, 0x12	; 18
    cd68:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

0000cd6c <fat_close_dir>:
 * \param[in] dd The directory descriptor to close.
 * \see fat_open_dir
 */
void fat_close_dir(struct fat_dir_struct* dd)
{
    if(dd)
    cd6c:	00 97       	sbiw	r24, 0x00	; 0
    cd6e:	11 f0       	breq	.+4      	; 0xcd74 <fat_close_dir+0x8>
#if USE_DYNAMIC_MEMORY
        free(dd);
    cd70:	0e 94 22 12 	call	0x2444	; 0x2444 <free>
    cd74:	08 95       	ret

0000cd76 <fat_close_file>:
 * \param[in] fd The file handle of the file to close.
 * \see fat_open_file
 */
void fat_close_file(struct fat_file_struct* fd)
{
    if(fd)
    cd76:	00 97       	sbiw	r24, 0x00	; 0
    cd78:	11 f0       	breq	.+4      	; 0xcd7e <fat_close_file+0x8>
#if USE_DYNAMIC_MEMORY
        free(fd);
    cd7a:	0e 94 22 12 	call	0x2444	; 0x2444 <free>
    cd7e:	08 95       	ret

0000cd80 <fat_open_dir>:
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat_close_dir
 */
struct fat_dir_struct* fat_open_dir(struct fat_fs_struct* fs, const struct fat_dir_entry_struct* dir_entry)
{
    cd80:	0f 93       	push	r16
    cd82:	1f 93       	push	r17
    cd84:	cf 93       	push	r28
    cd86:	df 93       	push	r29
    cd88:	8c 01       	movw	r16, r24
    cd8a:	eb 01       	movw	r28, r22
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT_ATTRIB_DIR))
    cd8c:	00 97       	sbiw	r24, 0x00	; 0
    cd8e:	21 f1       	breq	.+72     	; 0xcdd8 <fat_open_dir+0x58>
    cd90:	61 15       	cp	r22, r1
    cd92:	71 05       	cpc	r23, r1
    cd94:	09 f1       	breq	.+66     	; 0xcdd8 <fat_open_dir+0x58>
    cd96:	88 a1       	ldd	r24, Y+32	; 0x20
    cd98:	84 ff       	sbrs	r24, 4
    cd9a:	1e c0       	rjmp	.+60     	; 0xcdd8 <fat_open_dir+0x58>
        return 0;

#if USE_DYNAMIC_MEMORY
    struct fat_dir_struct* dd = malloc(sizeof(*dd));
    cd9c:	81 e3       	ldi	r24, 0x31	; 49
    cd9e:	90 e0       	ldi	r25, 0x00	; 0
    cda0:	0e 94 78 11 	call	0x22f0	; 0x22f0 <malloc>
    cda4:	fc 01       	movw	r30, r24
    cda6:	9c 01       	movw	r18, r24
    if(!dd)
    cda8:	00 97       	sbiw	r24, 0x00	; 0
    cdaa:	c1 f0       	breq	.+48     	; 0xcddc <fat_open_dir+0x5c>
    }
    if(i >= FAT_DIR_COUNT)
        return 0;
#endif
    
    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    cdac:	ac 01       	movw	r20, r24
    cdae:	4e 5f       	subi	r20, 0xFE	; 254
    cdb0:	5f 4f       	sbci	r21, 0xFF	; 255
    cdb2:	be 01       	movw	r22, r28
    cdb4:	8b e2       	ldi	r24, 0x2B	; 43
    cdb6:	db 01       	movw	r26, r22
    cdb8:	0d 90       	ld	r0, X+
    cdba:	bd 01       	movw	r22, r26
    cdbc:	da 01       	movw	r26, r20
    cdbe:	0d 92       	st	X+, r0
    cdc0:	ad 01       	movw	r20, r26
    cdc2:	81 50       	subi	r24, 0x01	; 1
    cdc4:	c1 f7       	brne	.-16     	; 0xcdb6 <fat_open_dir+0x36>
    dd->fs = fs;
    cdc6:	11 83       	std	Z+1, r17	; 0x01
    cdc8:	00 83       	st	Z, r16
    dd->entry_cluster = dir_entry->cluster;
    cdca:	89 a1       	ldd	r24, Y+33	; 0x21
    cdcc:	9a a1       	ldd	r25, Y+34	; 0x22
    cdce:	96 a7       	std	Z+46, r25	; 0x2e
    cdd0:	85 a7       	std	Z+45, r24	; 0x2d
    dd->entry_offset = 0;
    cdd2:	10 aa       	std	Z+48, r1	; 0x30
    cdd4:	17 a6       	std	Z+47, r1	; 0x2f
    cdd6:	02 c0       	rjmp	.+4      	; 0xcddc <fat_open_dir+0x5c>

    return dd;
    cdd8:	20 e0       	ldi	r18, 0x00	; 0
    cdda:	30 e0       	ldi	r19, 0x00	; 0
}
    cddc:	c9 01       	movw	r24, r18
    cdde:	df 91       	pop	r29
    cde0:	cf 91       	pop	r28
    cde2:	1f 91       	pop	r17
    cde4:	0f 91       	pop	r16
    cde6:	08 95       	ret

0000cde8 <fat_open_file>:
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat_close_file
 */
struct fat_file_struct* fat_open_file(struct fat_fs_struct* fs, const struct fat_dir_entry_struct* dir_entry)
{
    cde8:	0f 93       	push	r16
    cdea:	1f 93       	push	r17
    cdec:	cf 93       	push	r28
    cdee:	df 93       	push	r29
    cdf0:	8c 01       	movw	r16, r24
    cdf2:	eb 01       	movw	r28, r22
    if(!fs || !dir_entry || (dir_entry->attributes & FAT_ATTRIB_DIR))
    cdf4:	00 97       	sbiw	r24, 0x00	; 0
    cdf6:	31 f1       	breq	.+76     	; 0xce44 <fat_open_file+0x5c>
    cdf8:	61 15       	cp	r22, r1
    cdfa:	71 05       	cpc	r23, r1
    cdfc:	19 f1       	breq	.+70     	; 0xce44 <fat_open_file+0x5c>
    cdfe:	88 a1       	ldd	r24, Y+32	; 0x20
    ce00:	84 fd       	sbrc	r24, 4
    ce02:	20 c0       	rjmp	.+64     	; 0xce44 <fat_open_file+0x5c>
        return 0;

#if USE_DYNAMIC_MEMORY
    struct fat_file_struct* fd = malloc(sizeof(*fd));
    ce04:	83 e3       	ldi	r24, 0x33	; 51
    ce06:	90 e0       	ldi	r25, 0x00	; 0
    ce08:	0e 94 78 11 	call	0x22f0	; 0x22f0 <malloc>
    ce0c:	fc 01       	movw	r30, r24
    ce0e:	9c 01       	movw	r18, r24
    if(!fd)
    ce10:	00 97       	sbiw	r24, 0x00	; 0
    ce12:	d1 f0       	breq	.+52     	; 0xce48 <fat_open_file+0x60>
    }
    if(i >= FAT_FILE_COUNT)
        return 0;
#endif
    
    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    ce14:	ac 01       	movw	r20, r24
    ce16:	4e 5f       	subi	r20, 0xFE	; 254
    ce18:	5f 4f       	sbci	r21, 0xFF	; 255
    ce1a:	be 01       	movw	r22, r28
    ce1c:	8b e2       	ldi	r24, 0x2B	; 43
    ce1e:	db 01       	movw	r26, r22
    ce20:	0d 90       	ld	r0, X+
    ce22:	bd 01       	movw	r22, r26
    ce24:	da 01       	movw	r26, r20
    ce26:	0d 92       	st	X+, r0
    ce28:	ad 01       	movw	r20, r26
    ce2a:	81 50       	subi	r24, 0x01	; 1
    ce2c:	c1 f7       	brne	.-16     	; 0xce1e <fat_open_file+0x36>
    fd->fs = fs;
    ce2e:	11 83       	std	Z+1, r17	; 0x01
    ce30:	00 83       	st	Z, r16
    fd->pos = 0;
    ce32:	15 a6       	std	Z+45, r1	; 0x2d
    ce34:	16 a6       	std	Z+46, r1	; 0x2e
    ce36:	17 a6       	std	Z+47, r1	; 0x2f
    ce38:	10 aa       	std	Z+48, r1	; 0x30
    fd->pos_cluster = dir_entry->cluster;
    ce3a:	89 a1       	ldd	r24, Y+33	; 0x21
    ce3c:	9a a1       	ldd	r25, Y+34	; 0x22
    ce3e:	92 ab       	std	Z+50, r25	; 0x32
    ce40:	81 ab       	std	Z+49, r24	; 0x31
    ce42:	02 c0       	rjmp	.+4      	; 0xce48 <fat_open_file+0x60>

    return fd;
    ce44:	20 e0       	ldi	r18, 0x00	; 0
    ce46:	30 e0       	ldi	r19, 0x00	; 0
}
    ce48:	c9 01       	movw	r24, r18
    ce4a:	df 91       	pop	r29
    ce4c:	cf 91       	pop	r28
    ce4e:	1f 91       	pop	r17
    ce50:	0f 91       	pop	r16
    ce52:	08 95       	ret

0000ce54 <fat_open>:
 * \param[in] partition Discriptor of partition on which the filesystem resides.
 * \returns 0 on error, a FAT filesystem descriptor on success.
 * \see fat_close
 */
struct fat_fs_struct* fat_open(struct partition_struct* partition)
{
    ce54:	ac e2       	ldi	r26, 0x2C	; 44
    ce56:	b0 e0       	ldi	r27, 0x00	; 0
    ce58:	e0 e3       	ldi	r30, 0x30	; 48
    ce5a:	f7 e6       	ldi	r31, 0x67	; 103
    ce5c:	0c 94 b9 6a 	jmp	0xd572	; 0xd572 <__prologue_saves__>
    ce60:	1c 01       	movw	r2, r24
    if(!partition ||
    ce62:	00 97       	sbiw	r24, 0x00	; 0
    ce64:	09 f4       	brne	.+2      	; 0xce68 <fat_open+0x14>
    ce66:	5a c1       	rjmp	.+692    	; 0xd11c <fat_open+0x2c8>
    ce68:	dc 01       	movw	r26, r24
    ce6a:	14 96       	adiw	r26, 0x04	; 4
    ce6c:	8d 91       	ld	r24, X+
    ce6e:	9c 91       	ld	r25, X
    ce70:	15 97       	sbiw	r26, 0x05	; 5
    ce72:	89 2b       	or	r24, r25
    ce74:	09 f4       	brne	.+2      	; 0xce78 <fat_open+0x24>
    ce76:	52 c1       	rjmp	.+676    	; 0xd11c <fat_open+0x2c8>
    ce78:	16 96       	adiw	r26, 0x06	; 6
    ce7a:	8d 91       	ld	r24, X+
    ce7c:	9c 91       	ld	r25, X
    ce7e:	17 97       	sbiw	r26, 0x07	; 7
    ce80:	89 2b       	or	r24, r25
    ce82:	09 f4       	brne	.+2      	; 0xce86 <fat_open+0x32>
    ce84:	4b c1       	rjmp	.+662    	; 0xd11c <fat_open+0x2c8>
#endif
      )
        return 0;

#if USE_DYNAMIC_MEMORY
    struct fat_fs_struct* fs = malloc(sizeof(*fs));
    ce86:	8a e1       	ldi	r24, 0x1A	; 26
    ce88:	90 e0       	ldi	r25, 0x00	; 0
    ce8a:	0e 94 78 11 	call	0x22f0	; 0x22f0 <malloc>
    ce8e:	6c 01       	movw	r12, r24
    ce90:	9c a7       	std	Y+44, r25	; 0x2c
    ce92:	8b a7       	std	Y+43, r24	; 0x2b
    if(!fs)
    ce94:	00 97       	sbiw	r24, 0x00	; 0
    ce96:	09 f4       	brne	.+2      	; 0xce9a <fat_open+0x46>
    ce98:	43 c1       	rjmp	.+646    	; 0xd120 <fat_open+0x2cc>
    }
    if(i >= FAT_FS_COUNT)
        return 0;
#endif

    memset(fs, 0, sizeof(*fs));
    ce9a:	8a e1       	ldi	r24, 0x1A	; 26
    ce9c:	f6 01       	movw	r30, r12
    ce9e:	11 92       	st	Z+, r1
    cea0:	8a 95       	dec	r24
    cea2:	e9 f7       	brne	.-6      	; 0xce9e <fat_open+0x4a>

    fs->partition = partition;
    cea4:	d6 01       	movw	r26, r12
    cea6:	2d 92       	st	X+, r2
    cea8:	3c 92       	st	X, r3
#if FAT_FAT32_SUPPORT
    uint8_t buffer[37];
#else
    uint8_t buffer[25];
#endif
    offset_t partition_offset = (offset_t) partition->offset * 512;
    ceaa:	d1 01       	movw	r26, r2
    ceac:	19 96       	adiw	r26, 0x09	; 9
    ceae:	2d 91       	ld	r18, X+
    ceb0:	3d 91       	ld	r19, X+
    ceb2:	4d 91       	ld	r20, X+
    ceb4:	5c 91       	ld	r21, X
    ceb6:	1c 97       	sbiw	r26, 0x0c	; 12
    ceb8:	89 e0       	ldi	r24, 0x09	; 9
    ceba:	22 0f       	add	r18, r18
    cebc:	33 1f       	adc	r19, r19
    cebe:	44 1f       	adc	r20, r20
    cec0:	55 1f       	adc	r21, r21
    cec2:	8a 95       	dec	r24
    cec4:	d1 f7       	brne	.-12     	; 0xceba <fat_open+0x66>
    cec6:	2a a3       	std	Y+34, r18	; 0x22
    cec8:	3b a3       	std	Y+35, r19	; 0x23
    ceca:	4c a3       	std	Y+36, r20	; 0x24
    cecc:	5d a3       	std	Y+37, r21	; 0x25
    if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
    cece:	ca 01       	movw	r24, r20
    ced0:	b9 01       	movw	r22, r18
    ced2:	65 5f       	subi	r22, 0xF5	; 245
    ced4:	7f 4f       	sbci	r23, 0xFF	; 255
    ced6:	8f 4f       	sbci	r24, 0xFF	; 255
    ced8:	9f 4f       	sbci	r25, 0xFF	; 255
    ceda:	ed 91       	ld	r30, X+
    cedc:	fc 91       	ld	r31, X
    cede:	ae 01       	movw	r20, r28
    cee0:	4f 5f       	subi	r20, 0xFF	; 255
    cee2:	5f 4f       	sbci	r21, 0xFF	; 255
    cee4:	29 e1       	ldi	r18, 0x19	; 25
    cee6:	30 e0       	ldi	r19, 0x00	; 0
    cee8:	09 95       	icall
    ceea:	88 23       	and	r24, r24
    ceec:	09 f4       	brne	.+2      	; 0xcef0 <fat_open+0x9c>
    ceee:	1e c1       	rjmp	.+572    	; 0xd12c <fat_open+0x2d8>
        return 0;

    uint16_t bytes_per_sector = ltoh16(*((uint16_t*) &buffer[0x00]));
    cef0:	e9 81       	ldd	r30, Y+1	; 0x01
    cef2:	fa 81       	ldd	r31, Y+2	; 0x02
    cef4:	ff a3       	std	Y+39, r31	; 0x27
    cef6:	ee a3       	std	Y+38, r30	; 0x26
    uint16_t reserved_sectors = ltoh16(*((uint16_t*) &buffer[0x03]));
    cef8:	2c 81       	ldd	r18, Y+4	; 0x04
    cefa:	3d 81       	ldd	r19, Y+5	; 0x05
    uint8_t sectors_per_cluster = buffer[0x02];
    cefc:	fb 81       	ldd	r31, Y+3	; 0x03
    cefe:	f8 a7       	std	Y+40, r31	; 0x28
    uint8_t fat_copies = buffer[0x05];
    cf00:	4e 81       	ldd	r20, Y+6	; 0x06
    uint16_t max_root_entries = ltoh16(*((uint16_t*) &buffer[0x06]));
    cf02:	8f 81       	ldd	r24, Y+7	; 0x07
    cf04:	98 85       	ldd	r25, Y+8	; 0x08
    cf06:	9a a7       	std	Y+42, r25	; 0x2a
    cf08:	89 a7       	std	Y+41, r24	; 0x29
    uint16_t sector_count_16 = ltoh16(*((uint16_t*) &buffer[0x08]));
    cf0a:	e9 85       	ldd	r30, Y+9	; 0x09
    cf0c:	fa 85       	ldd	r31, Y+10	; 0x0a
    uint16_t sectors_per_fat = ltoh16(*((uint16_t*) &buffer[0x0b]));
    cf0e:	6c 85       	ldd	r22, Y+12	; 0x0c
    cf10:	7d 85       	ldd	r23, Y+13	; 0x0d
    uint32_t sector_count = ltoh32(*((uint32_t*) &buffer[0x15]));
    cf12:	4e 88       	ldd	r4, Y+22	; 0x16
    cf14:	5f 88       	ldd	r5, Y+23	; 0x17
    cf16:	68 8c       	ldd	r6, Y+24	; 0x18
    cf18:	79 8c       	ldd	r7, Y+25	; 0x19
#if FAT_FAT32_SUPPORT
    uint32_t sectors_per_fat32 = ltoh32(*((uint32_t*) &buffer[0x19]));
    uint32_t cluster_root_dir = ltoh32(*((uint32_t*) &buffer[0x21]));
#endif

    if(sector_count == 0)
    cf1a:	41 14       	cp	r4, r1
    cf1c:	51 04       	cpc	r5, r1
    cf1e:	61 04       	cpc	r6, r1
    cf20:	71 04       	cpc	r7, r1
    cf22:	31 f4       	brne	.+12     	; 0xcf30 <fat_open+0xdc>
    {
        if(sector_count_16 == 0)
    cf24:	30 97       	sbiw	r30, 0x00	; 0
    cf26:	09 f4       	brne	.+2      	; 0xcf2a <fat_open+0xd6>
    cf28:	01 c1       	rjmp	.+514    	; 0xd12c <fat_open+0x2d8>
            /* illegal volume size */
            return 0;
        else
            sector_count = sector_count_16;
    cf2a:	2f 01       	movw	r4, r30
    cf2c:	66 24       	eor	r6, r6
    cf2e:	77 24       	eor	r7, r7
        sectors_per_fat32 = sectors_per_fat;
    else if(sectors_per_fat32 == 0)
        /* this is neither FAT16 nor FAT32 */
        return 0;
#else
    if(sectors_per_fat == 0)
    cf30:	61 15       	cp	r22, r1
    cf32:	71 05       	cpc	r23, r1
    cf34:	09 f4       	brne	.+2      	; 0xcf38 <fat_open+0xe4>
    cf36:	fa c0       	rjmp	.+500    	; 0xd12c <fat_open+0x2d8>
#if FAT_FAT32_SUPPORT
                                 - sectors_per_fat32 * fat_copies
#else
                                 - (uint32_t) sectors_per_fat * fat_copies
#endif
                                 - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
    cf38:	c9 01       	movw	r24, r18
    cf3a:	a0 e0       	ldi	r26, 0x00	; 0
    cf3c:	b0 e0       	ldi	r27, 0x00	; 0
    cf3e:	8e 8f       	std	Y+30, r24	; 0x1e
    cf40:	9f 8f       	std	Y+31, r25	; 0x1f
    cf42:	a8 a3       	std	Y+32, r26	; 0x20
    cf44:	b9 a3       	std	Y+33, r27	; 0x21
    cf46:	80 e0       	ldi	r24, 0x00	; 0
    cf48:	90 e0       	ldi	r25, 0x00	; 0
    cf4a:	24 2f       	mov	r18, r20
    cf4c:	30 e0       	ldi	r19, 0x00	; 0
    cf4e:	40 e0       	ldi	r20, 0x00	; 0
    cf50:	50 e0       	ldi	r21, 0x00	; 0
    cf52:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    cf56:	6a 8f       	std	Y+26, r22	; 0x1a
    cf58:	7b 8f       	std	Y+27, r23	; 0x1b
    cf5a:	8c 8f       	std	Y+28, r24	; 0x1c
    cf5c:	9d 8f       	std	Y+29, r25	; 0x1d
    uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
    cf5e:	83 01       	movw	r16, r6
    cf60:	72 01       	movw	r14, r4
    cf62:	2e 8d       	ldd	r18, Y+30	; 0x1e
    cf64:	3f 8d       	ldd	r19, Y+31	; 0x1f
    cf66:	48 a1       	ldd	r20, Y+32	; 0x20
    cf68:	59 a1       	ldd	r21, Y+33	; 0x21
    cf6a:	e2 1a       	sub	r14, r18
    cf6c:	f3 0a       	sbc	r15, r19
    cf6e:	04 0b       	sbc	r16, r20
    cf70:	15 0b       	sbc	r17, r21
    cf72:	e6 1a       	sub	r14, r22
    cf74:	f7 0a       	sbc	r15, r23
    cf76:	08 0b       	sbc	r16, r24
    cf78:	19 0b       	sbc	r17, r25
    cf7a:	8e a1       	ldd	r24, Y+38	; 0x26
    cf7c:	9f a1       	ldd	r25, Y+39	; 0x27
    cf7e:	01 97       	sbiw	r24, 0x01	; 1
    cf80:	29 a5       	ldd	r18, Y+41	; 0x29
    cf82:	3a a5       	ldd	r19, Y+42	; 0x2a
    cf84:	b5 e0       	ldi	r27, 0x05	; 5
    cf86:	22 0f       	add	r18, r18
    cf88:	33 1f       	adc	r19, r19
    cf8a:	ba 95       	dec	r27
    cf8c:	e1 f7       	brne	.-8      	; 0xcf86 <fat_open+0x132>
    cf8e:	82 0f       	add	r24, r18
    cf90:	93 1f       	adc	r25, r19
    cf92:	6e a1       	ldd	r22, Y+38	; 0x26
    cf94:	7f a1       	ldd	r23, Y+39	; 0x27
    cf96:	0e 94 55 6a 	call	0xd4aa	; 0xd4aa <__udivmodhi4>
    cf9a:	80 e0       	ldi	r24, 0x00	; 0
    cf9c:	90 e0       	ldi	r25, 0x00	; 0
    cf9e:	e6 1a       	sub	r14, r22
    cfa0:	f7 0a       	sbc	r15, r23
    cfa2:	08 0b       	sbc	r16, r24
    cfa4:	19 0b       	sbc	r17, r25
    cfa6:	88 a5       	ldd	r24, Y+40	; 0x28
    cfa8:	28 2f       	mov	r18, r24
    cfaa:	30 e0       	ldi	r19, 0x00	; 0
    cfac:	40 e0       	ldi	r20, 0x00	; 0
    cfae:	50 e0       	ldi	r21, 0x00	; 0
    cfb0:	c8 01       	movw	r24, r16
    cfb2:	b7 01       	movw	r22, r14
    cfb4:	0e 94 7c 6a 	call	0xd4f8	; 0xd4f8 <__udivmodsi4>
    cfb8:	79 01       	movw	r14, r18
    cfba:	8a 01       	movw	r16, r20
    if(data_cluster_count < 4085)
    cfbc:	95 ef       	ldi	r25, 0xF5	; 245
    cfbe:	e9 16       	cp	r14, r25
    cfc0:	9f e0       	ldi	r25, 0x0F	; 15
    cfc2:	f9 06       	cpc	r15, r25
    cfc4:	90 e0       	ldi	r25, 0x00	; 0
    cfc6:	09 07       	cpc	r16, r25
    cfc8:	90 e0       	ldi	r25, 0x00	; 0
    cfca:	19 07       	cpc	r17, r25
    cfcc:	08 f4       	brcc	.+2      	; 0xcfd0 <fat_open+0x17c>
    cfce:	ae c0       	rjmp	.+348    	; 0xd12c <fat_open+0x2d8>
        /* this is a FAT12, not supported */
        return 0;
    else if(data_cluster_count < 65525)
    cfd0:	a5 ef       	ldi	r26, 0xF5	; 245
    cfd2:	ea 16       	cp	r14, r26
    cfd4:	af ef       	ldi	r26, 0xFF	; 255
    cfd6:	fa 06       	cpc	r15, r26
    cfd8:	a0 e0       	ldi	r26, 0x00	; 0
    cfda:	0a 07       	cpc	r16, r26
    cfdc:	a0 e0       	ldi	r26, 0x00	; 0
    cfde:	1a 07       	cpc	r17, r26
    cfe0:	20 f4       	brcc	.+8      	; 0xcfea <fat_open+0x196>
        /* this is a FAT16 */
        partition->type = PARTITION_TYPE_FAT16;
    cfe2:	86 e0       	ldi	r24, 0x06	; 6
    cfe4:	f1 01       	movw	r30, r2
    cfe6:	80 87       	std	Z+8, r24	; 0x08
    cfe8:	04 c0       	rjmp	.+8      	; 0xcff2 <fat_open+0x19e>
    else
        /* this is a FAT32 */
        partition->type = PARTITION_TYPE_FAT32;
    cfea:	8b e0       	ldi	r24, 0x0B	; 11
    cfec:	d1 01       	movw	r26, r2
    cfee:	18 96       	adiw	r26, 0x08	; 8
    cff0:	8c 93       	st	X, r24

    /* fill header information */
    struct fat_header_struct* header = &fs->header;
    memset(header, 0, sizeof(*header));
    cff2:	c6 01       	movw	r24, r12
    cff4:	02 96       	adiw	r24, 0x02	; 2
    cff6:	fc 01       	movw	r30, r24
    cff8:	88 e1       	ldi	r24, 0x18	; 24
    cffa:	df 01       	movw	r26, r30
    cffc:	1d 92       	st	X+, r1
    cffe:	8a 95       	dec	r24
    d000:	e9 f7       	brne	.-6      	; 0xcffc <fat_open+0x1a8>
    
    header->size = (offset_t) sector_count * bytes_per_sector;
    d002:	ee a1       	ldd	r30, Y+38	; 0x26
    d004:	ff a1       	ldd	r31, Y+39	; 0x27
    d006:	4f 01       	movw	r8, r30
    d008:	aa 24       	eor	r10, r10
    d00a:	bb 24       	eor	r11, r11
    d00c:	c3 01       	movw	r24, r6
    d00e:	b2 01       	movw	r22, r4
    d010:	a5 01       	movw	r20, r10
    d012:	94 01       	movw	r18, r8
    d014:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    d018:	d6 01       	movw	r26, r12
    d01a:	12 96       	adiw	r26, 0x02	; 2
    d01c:	6d 93       	st	X+, r22
    d01e:	7d 93       	st	X+, r23
    d020:	8d 93       	st	X+, r24
    d022:	9c 93       	st	X, r25
    d024:	15 97       	sbiw	r26, 0x05	; 5

    header->fat_offset = /* jump to partition */
    d026:	c5 01       	movw	r24, r10
    d028:	b4 01       	movw	r22, r8
    d02a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    d02c:	3f 8d       	ldd	r19, Y+31	; 0x1f
    d02e:	48 a1       	ldd	r20, Y+32	; 0x20
    d030:	59 a1       	ldd	r21, Y+33	; 0x21
    d032:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    d036:	2a a1       	ldd	r18, Y+34	; 0x22
    d038:	3b a1       	ldd	r19, Y+35	; 0x23
    d03a:	4c a1       	ldd	r20, Y+36	; 0x24
    d03c:	5d a1       	ldd	r21, Y+37	; 0x25
    d03e:	26 0f       	add	r18, r22
    d040:	37 1f       	adc	r19, r23
    d042:	48 1f       	adc	r20, r24
    d044:	59 1f       	adc	r21, r25
    d046:	d6 01       	movw	r26, r12
    d048:	16 96       	adiw	r26, 0x06	; 6
    d04a:	2d 93       	st	X+, r18
    d04c:	3d 93       	st	X+, r19
    d04e:	4d 93       	st	X+, r20
    d050:	5c 93       	st	X, r21
    d052:	19 97       	sbiw	r26, 0x09	; 9
                         partition_offset +
                         /* jump to fat */
                         (offset_t) reserved_sectors * bytes_per_sector;
    header->fat_size = (data_cluster_count + 2) * (partition->type == PARTITION_TYPE_FAT16 ? 2 : 4);
    d054:	f1 01       	movw	r30, r2
    d056:	80 85       	ldd	r24, Z+8	; 0x08
    d058:	86 30       	cpi	r24, 0x06	; 6
    d05a:	29 f0       	breq	.+10     	; 0xd066 <fat_open+0x212>
    d05c:	64 e0       	ldi	r22, 0x04	; 4
    d05e:	70 e0       	ldi	r23, 0x00	; 0
    d060:	80 e0       	ldi	r24, 0x00	; 0
    d062:	90 e0       	ldi	r25, 0x00	; 0
    d064:	04 c0       	rjmp	.+8      	; 0xd06e <fat_open+0x21a>
    d066:	62 e0       	ldi	r22, 0x02	; 2
    d068:	70 e0       	ldi	r23, 0x00	; 0
    d06a:	80 e0       	ldi	r24, 0x00	; 0
    d06c:	90 e0       	ldi	r25, 0x00	; 0
    d06e:	22 e0       	ldi	r18, 0x02	; 2
    d070:	30 e0       	ldi	r19, 0x00	; 0
    d072:	40 e0       	ldi	r20, 0x00	; 0
    d074:	50 e0       	ldi	r21, 0x00	; 0
    d076:	e2 0e       	add	r14, r18
    d078:	f3 1e       	adc	r15, r19
    d07a:	04 1f       	adc	r16, r20
    d07c:	15 1f       	adc	r17, r21
    d07e:	a8 01       	movw	r20, r16
    d080:	97 01       	movw	r18, r14
    d082:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    d086:	d6 01       	movw	r26, r12
    d088:	1a 96       	adiw	r26, 0x0a	; 10
    d08a:	6d 93       	st	X+, r22
    d08c:	7d 93       	st	X+, r23
    d08e:	8d 93       	st	X+, r24
    d090:	9c 93       	st	X, r25
    d092:	1d 97       	sbiw	r26, 0x0d	; 13

    header->sector_size = bytes_per_sector;
    d094:	ee a1       	ldd	r30, Y+38	; 0x26
    d096:	ff a1       	ldd	r31, Y+39	; 0x27
    d098:	1f 96       	adiw	r26, 0x0f	; 15
    d09a:	fc 93       	st	X, r31
    d09c:	ee 93       	st	-X, r30
    d09e:	1e 97       	sbiw	r26, 0x0e	; 14
    header->cluster_size = (uint16_t) bytes_per_sector * sectors_per_cluster;
    d0a0:	f8 a5       	ldd	r31, Y+40	; 0x28
    d0a2:	8f 2f       	mov	r24, r31
    d0a4:	90 e0       	ldi	r25, 0x00	; 0
    d0a6:	9c 01       	movw	r18, r24
    d0a8:	4e a1       	ldd	r20, Y+38	; 0x26
    d0aa:	5f a1       	ldd	r21, Y+39	; 0x27
    d0ac:	24 9f       	mul	r18, r20
    d0ae:	c0 01       	movw	r24, r0
    d0b0:	25 9f       	mul	r18, r21
    d0b2:	90 0d       	add	r25, r0
    d0b4:	34 9f       	mul	r19, r20
    d0b6:	90 0d       	add	r25, r0
    d0b8:	11 24       	eor	r1, r1
    d0ba:	51 96       	adiw	r26, 0x11	; 17
    d0bc:	9c 93       	st	X, r25
    d0be:	8e 93       	st	-X, r24
    d0c0:	50 97       	sbiw	r26, 0x10	; 16

#if FAT_FAT32_SUPPORT
    if(partition->type == PARTITION_TYPE_FAT16)
#endif
    {
        header->root_dir_offset = /* jump to fats */
    d0c2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    d0c4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    d0c6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    d0c8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    d0ca:	a5 01       	movw	r20, r10
    d0cc:	94 01       	movw	r18, r8
    d0ce:	0e 94 36 6a 	call	0xd46c	; 0xd46c <__mulsi3>
    d0d2:	d6 01       	movw	r26, r12
    d0d4:	16 96       	adiw	r26, 0x06	; 6
    d0d6:	2d 91       	ld	r18, X+
    d0d8:	3d 91       	ld	r19, X+
    d0da:	4d 91       	ld	r20, X+
    d0dc:	5c 91       	ld	r21, X
    d0de:	19 97       	sbiw	r26, 0x09	; 9
    d0e0:	62 0f       	add	r22, r18
    d0e2:	73 1f       	adc	r23, r19
    d0e4:	84 1f       	adc	r24, r20
    d0e6:	95 1f       	adc	r25, r21
    d0e8:	f6 01       	movw	r30, r12
    d0ea:	66 8b       	std	Z+22, r22	; 0x16
    d0ec:	77 8b       	std	Z+23, r23	; 0x17
    d0ee:	80 8f       	std	Z+24, r24	; 0x18
    d0f0:	91 8f       	std	Z+25, r25	; 0x19
                                  header->fat_offset +
                                  /* jump to root directory entries */
                                  (offset_t) fat_copies * sectors_per_fat * bytes_per_sector;

        header->cluster_zero_offset = /* jump to root directory entries */
    d0f2:	a9 a5       	ldd	r26, Y+41	; 0x29
    d0f4:	ba a5       	ldd	r27, Y+42	; 0x2a
    d0f6:	9d 01       	movw	r18, r26
    d0f8:	40 e0       	ldi	r20, 0x00	; 0
    d0fa:	50 e0       	ldi	r21, 0x00	; 0
    d0fc:	a5 e0       	ldi	r26, 0x05	; 5
    d0fe:	22 0f       	add	r18, r18
    d100:	33 1f       	adc	r19, r19
    d102:	44 1f       	adc	r20, r20
    d104:	55 1f       	adc	r21, r21
    d106:	aa 95       	dec	r26
    d108:	d1 f7       	brne	.-12     	; 0xd0fe <fat_open+0x2aa>
    d10a:	62 0f       	add	r22, r18
    d10c:	73 1f       	adc	r23, r19
    d10e:	84 1f       	adc	r24, r20
    d110:	95 1f       	adc	r25, r21
    d112:	62 8b       	std	Z+18, r22	; 0x12
    d114:	73 8b       	std	Z+19, r23	; 0x13
    d116:	84 8b       	std	Z+20, r24	; 0x14
    d118:	95 8b       	std	Z+21, r25	; 0x15
    d11a:	02 c0       	rjmp	.+4      	; 0xd120 <fat_open+0x2cc>
    d11c:	1c a6       	std	Y+44, r1	; 0x2c
    d11e:	1b a6       	std	Y+43, r1	; 0x2b
#endif
        return 0;
    }
    
    return fs;
}
    d120:	8b a5       	ldd	r24, Y+43	; 0x2b
    d122:	9c a5       	ldd	r25, Y+44	; 0x2c
    d124:	ac 96       	adiw	r28, 0x2c	; 44
    d126:	e2 e1       	ldi	r30, 0x12	; 18
    d128:	0c 94 d5 6a 	jmp	0xd5aa	; 0xd5aa <__epilogue_restores__>

    fs->partition = partition;
    if(!fat_read_header(fs))
    {
#if USE_DYNAMIC_MEMORY
        free(fs);
    d12c:	c6 01       	movw	r24, r12
    d12e:	0e 94 22 12 	call	0x2444	; 0x2444 <free>
    d132:	f4 cf       	rjmp	.-24     	; 0xd11c <fat_open+0x2c8>

0000d134 <fat_get_dir_entry_of_path>:
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat_read_dir
 */
uint8_t fat_get_dir_entry_of_path(struct fat_fs_struct* fs, const char* path, struct fat_dir_entry_struct* dir_entry)
{
    d134:	a0 e0       	ldi	r26, 0x00	; 0
    d136:	b0 e0       	ldi	r27, 0x00	; 0
    d138:	e0 ea       	ldi	r30, 0xA0	; 160
    d13a:	f8 e6       	ldi	r31, 0x68	; 104
    d13c:	0c 94 bd 6a 	jmp	0xd57a	; 0xd57a <__prologue_saves__+0x8>
    d140:	4c 01       	movw	r8, r24
    d142:	eb 01       	movw	r28, r22
    d144:	7a 01       	movw	r14, r20
    if(!fs || !path || path[0] == '\0' || !dir_entry)
    d146:	00 97       	sbiw	r24, 0x00	; 0
    d148:	09 f4       	brne	.+2      	; 0xd14c <fat_get_dir_entry_of_path+0x18>
    d14a:	6b c0       	rjmp	.+214    	; 0xd222 <fat_get_dir_entry_of_path+0xee>
    d14c:	61 15       	cp	r22, r1
    d14e:	71 05       	cpc	r23, r1
    d150:	09 f4       	brne	.+2      	; 0xd154 <fat_get_dir_entry_of_path+0x20>
    d152:	67 c0       	rjmp	.+206    	; 0xd222 <fat_get_dir_entry_of_path+0xee>
    d154:	88 81       	ld	r24, Y
    d156:	88 23       	and	r24, r24
    d158:	09 f4       	brne	.+2      	; 0xd15c <fat_get_dir_entry_of_path+0x28>
    d15a:	63 c0       	rjmp	.+198    	; 0xd222 <fat_get_dir_entry_of_path+0xee>
    d15c:	41 15       	cp	r20, r1
    d15e:	51 05       	cpc	r21, r1
    d160:	09 f4       	brne	.+2      	; 0xd164 <fat_get_dir_entry_of_path+0x30>
    d162:	5f c0       	rjmp	.+190    	; 0xd222 <fat_get_dir_entry_of_path+0xee>
        return 0;

    if(path[0] == '/')
    d164:	8f 32       	cpi	r24, 0x2F	; 47
    d166:	09 f4       	brne	.+2      	; 0xd16a <fat_get_dir_entry_of_path+0x36>
        ++path;
    d168:	21 96       	adiw	r28, 0x01	; 1

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    d16a:	8b e2       	ldi	r24, 0x2B	; 43
    d16c:	f7 01       	movw	r30, r14
    d16e:	11 92       	st	Z+, r1
    d170:	8a 95       	dec	r24
    d172:	e9 f7       	brne	.-6      	; 0xd16e <fat_get_dir_entry_of_path+0x3a>
    dir_entry->attributes = FAT_ATTRIB_DIR;
    d174:	80 e1       	ldi	r24, 0x10	; 16
    d176:	f7 01       	movw	r30, r14
    d178:	80 a3       	std	Z+32, r24	; 0x20
        
        /* read directory entries */
        while(fat_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
    d17a:	37 01       	movw	r6, r14
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT_ATTRIB_DIR;

    while(1)
    {
        if(path[0] == '\0')
    d17c:	88 81       	ld	r24, Y
    d17e:	88 23       	and	r24, r24
    d180:	09 f4       	brne	.+2      	; 0xd184 <fat_get_dir_entry_of_path+0x50>
    d182:	51 c0       	rjmp	.+162    	; 0xd226 <fat_get_dir_entry_of_path+0xf2>
            return 1;

        struct fat_dir_struct* dd = fat_open_dir(fs, dir_entry);
    d184:	c4 01       	movw	r24, r8
    d186:	b7 01       	movw	r22, r14
    d188:	0e 94 c0 66 	call	0xcd80	; 0xcd80 <fat_open_dir>
    d18c:	6c 01       	movw	r12, r24
        if(!dd)
    d18e:	00 97       	sbiw	r24, 0x00	; 0
    d190:	09 f4       	brne	.+2      	; 0xd194 <fat_get_dir_entry_of_path+0x60>
    d192:	47 c0       	rjmp	.+142    	; 0xd222 <fat_get_dir_entry_of_path+0xee>
            break;

        /* extract the next hierarchy we will search for */
        const char* sub_path = strchr(path, '/');
    d194:	ce 01       	movw	r24, r28
    d196:	6f e2       	ldi	r22, 0x2F	; 47
    d198:	70 e0       	ldi	r23, 0x00	; 0
    d19a:	0e 94 2d 14 	call	0x285a	; 0x285a <strchr>
        uint8_t length_to_sep;
        if(sub_path)
    d19e:	00 97       	sbiw	r24, 0x00	; 0
    d1a0:	39 f0       	breq	.+14     	; 0xd1b0 <fat_get_dir_entry_of_path+0x7c>
        {
            length_to_sep = sub_path - path;
    d1a2:	48 2f       	mov	r20, r24
    d1a4:	4c 1b       	sub	r20, r28
            ++sub_path;
    d1a6:	5c 01       	movw	r10, r24
    d1a8:	08 94       	sec
    d1aa:	a1 1c       	adc	r10, r1
    d1ac:	b1 1c       	adc	r11, r1
    d1ae:	2d c0       	rjmp	.+90     	; 0xd20a <fat_get_dir_entry_of_path+0xd6>
        }
        else
        {
            length_to_sep = strlen(path);
    d1b0:	fe 01       	movw	r30, r28
    d1b2:	01 90       	ld	r0, Z+
    d1b4:	00 20       	and	r0, r0
    d1b6:	e9 f7       	brne	.-6      	; 0xd1b2 <fat_get_dir_entry_of_path+0x7e>
    d1b8:	31 97       	sbiw	r30, 0x01	; 1
    d1ba:	4e 2f       	mov	r20, r30
    d1bc:	4c 1b       	sub	r20, r28
            sub_path = path + length_to_sep;
    d1be:	5e 01       	movw	r10, r28
    d1c0:	a4 0e       	add	r10, r20
    d1c2:	b1 1c       	adc	r11, r1
    d1c4:	22 c0       	rjmp	.+68     	; 0xd20a <fat_get_dir_entry_of_path+0xd6>
        
        /* read directory entries */
        while(fat_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
    d1c6:	f3 01       	movw	r30, r6
    d1c8:	01 90       	ld	r0, Z+
    d1ca:	00 20       	and	r0, r0
    d1cc:	e9 f7       	brne	.-6      	; 0xd1c8 <fat_get_dir_entry_of_path+0x94>
    d1ce:	31 97       	sbiw	r30, 0x01	; 1
    d1d0:	e6 19       	sub	r30, r6
    d1d2:	f7 09       	sbc	r31, r7
    d1d4:	e0 17       	cp	r30, r16
    d1d6:	f1 07       	cpc	r31, r17
    d1d8:	d1 f4       	brne	.+52     	; 0xd20e <fat_get_dir_entry_of_path+0xda>
    d1da:	ce 01       	movw	r24, r28
    d1dc:	b3 01       	movw	r22, r6
    d1de:	a8 01       	movw	r20, r16
    d1e0:	0e 94 41 14 	call	0x2882	; 0x2882 <strncmp>
    d1e4:	00 97       	sbiw	r24, 0x00	; 0
    d1e6:	99 f4       	brne	.+38     	; 0xd20e <fat_get_dir_entry_of_path+0xda>
                strncmp(path, dir_entry->long_name, length_to_sep) != 0))
                continue;

            fat_close_dir(dd);
    d1e8:	c6 01       	movw	r24, r12
    d1ea:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>
            dd = 0;

            if(path[length_to_sep] == '\0')
    d1ee:	0c 0f       	add	r16, r28
    d1f0:	1d 1f       	adc	r17, r29
    d1f2:	f8 01       	movw	r30, r16
    d1f4:	80 81       	ld	r24, Z
    d1f6:	88 23       	and	r24, r24
    d1f8:	b1 f0       	breq	.+44     	; 0xd226 <fat_get_dir_entry_of_path+0xf2>
                /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT_ATTRIB_DIR)
    d1fa:	f7 01       	movw	r30, r14
    d1fc:	80 a1       	ldd	r24, Z+32	; 0x20
    d1fe:	84 ff       	sbrs	r24, 4
    d200:	10 c0       	rjmp	.+32     	; 0xd222 <fat_get_dir_entry_of_path+0xee>
    d202:	e5 01       	movw	r28, r10
    d204:	cc 24       	eor	r12, r12
    d206:	dd 24       	eor	r13, r13
    d208:	08 c0       	rjmp	.+16     	; 0xd21a <fat_get_dir_entry_of_path+0xe6>
        
        /* read directory entries */
        while(fat_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
    d20a:	04 2f       	mov	r16, r20
    d20c:	10 e0       	ldi	r17, 0x00	; 0
            length_to_sep = strlen(path);
            sub_path = path + length_to_sep;
        }
        
        /* read directory entries */
        while(fat_read_dir(dd, dir_entry))
    d20e:	c6 01       	movw	r24, r12
    d210:	b7 01       	movw	r22, r14
    d212:	0e 94 db 60 	call	0xc1b6	; 0xc1b6 <fat_read_dir>
    d216:	88 23       	and	r24, r24
    d218:	b1 f6       	brne	.-84     	; 0xd1c6 <fat_get_dir_entry_of_path+0x92>

            /* a parent of the file exists, but not the file itself */
            return 0;
        }

        fat_close_dir(dd);
    d21a:	c6 01       	movw	r24, r12
    d21c:	0e 94 b6 66 	call	0xcd6c	; 0xcd6c <fat_close_dir>
    d220:	ad cf       	rjmp	.-166    	; 0xd17c <fat_get_dir_entry_of_path+0x48>
    }
    d222:	80 e0       	ldi	r24, 0x00	; 0
    d224:	01 c0       	rjmp	.+2      	; 0xd228 <fat_get_dir_entry_of_path+0xf4>
    d226:	81 e0       	ldi	r24, 0x01	; 1
    
    return 0;
}
    d228:	cd b7       	in	r28, 0x3d	; 61
    d22a:	de b7       	in	r29, 0x3e	; 62
    d22c:	ee e0       	ldi	r30, 0x0E	; 14
    d22e:	0c 94 d9 6a 	jmp	0xd5b2	; 0xd5b2 <__epilogue_restores__+0x8>

0000d232 <partition_open>:
 *                  as a single partition (e.g. for "super floppy" use).
 * \returns 0 on failure, a partition descriptor on success.
 * \see partition_close
 */
struct partition_struct* partition_open(device_read_t device_read, device_read_interval_t device_read_interval, device_write_t device_write, device_write_interval_t device_write_interval, int8_t index)
{
    d232:	8f 92       	push	r8
    d234:	9f 92       	push	r9
    d236:	af 92       	push	r10
    d238:	bf 92       	push	r11
    d23a:	cf 92       	push	r12
    d23c:	df 92       	push	r13
    d23e:	ef 92       	push	r14
    d240:	ff 92       	push	r15
    d242:	0f 93       	push	r16
    d244:	df 93       	push	r29
    d246:	cf 93       	push	r28
    d248:	cd b7       	in	r28, 0x3d	; 61
    d24a:	de b7       	in	r29, 0x3e	; 62
    d24c:	60 97       	sbiw	r28, 0x10	; 16
    d24e:	0f b6       	in	r0, 0x3f	; 63
    d250:	f8 94       	cli
    d252:	de bf       	out	0x3e, r29	; 62
    d254:	0f be       	out	0x3f, r0	; 63
    d256:	cd bf       	out	0x3d, r28	; 61
    d258:	7c 01       	movw	r14, r24
    d25a:	6b 01       	movw	r12, r22
    d25c:	5a 01       	movw	r10, r20
    d25e:	49 01       	movw	r8, r18
    struct partition_struct* new_partition = 0;
    uint8_t buffer[0x10];

    if(!device_read || !device_read_interval || index >= 4)
    d260:	00 97       	sbiw	r24, 0x00	; 0
    d262:	09 f4       	brne	.+2      	; 0xd266 <partition_open+0x34>
    d264:	9e c0       	rjmp	.+316    	; 0xd3a2 <partition_open+0x170>
    d266:	61 15       	cp	r22, r1
    d268:	71 05       	cpc	r23, r1
    d26a:	09 f4       	brne	.+2      	; 0xd26e <partition_open+0x3c>
    d26c:	9a c0       	rjmp	.+308    	; 0xd3a2 <partition_open+0x170>
    d26e:	04 30       	cpi	r16, 0x04	; 4
    d270:	0c f0       	brlt	.+2      	; 0xd274 <partition_open+0x42>
    d272:	97 c0       	rjmp	.+302    	; 0xd3a2 <partition_open+0x170>
        return 0;

    if(index >= 0)
    d274:	07 fd       	sbrc	r16, 7
    d276:	1d c0       	rjmp	.+58     	; 0xd2b2 <partition_open+0x80>
    {
        /* read specified partition table index */
        if(!device_read(0x01be + index * 0x10, buffer, sizeof(buffer)))
    d278:	60 2f       	mov	r22, r16
    d27a:	77 27       	eor	r23, r23
    d27c:	67 fd       	sbrc	r22, 7
    d27e:	70 95       	com	r23
    d280:	a4 e0       	ldi	r26, 0x04	; 4
    d282:	66 0f       	add	r22, r22
    d284:	77 1f       	adc	r23, r23
    d286:	aa 95       	dec	r26
    d288:	e1 f7       	brne	.-8      	; 0xd282 <partition_open+0x50>
    d28a:	62 54       	subi	r22, 0x42	; 66
    d28c:	7e 4f       	sbci	r23, 0xFE	; 254
    d28e:	88 27       	eor	r24, r24
    d290:	77 fd       	sbrc	r23, 7
    d292:	80 95       	com	r24
    d294:	98 2f       	mov	r25, r24
    d296:	ae 01       	movw	r20, r28
    d298:	4f 5f       	subi	r20, 0xFF	; 255
    d29a:	5f 4f       	sbci	r21, 0xFF	; 255
    d29c:	20 e1       	ldi	r18, 0x10	; 16
    d29e:	30 e0       	ldi	r19, 0x00	; 0
    d2a0:	f7 01       	movw	r30, r14
    d2a2:	09 95       	icall
    d2a4:	88 23       	and	r24, r24
    d2a6:	09 f4       	brne	.+2      	; 0xd2aa <partition_open+0x78>
    d2a8:	7c c0       	rjmp	.+248    	; 0xd3a2 <partition_open+0x170>
            return 0;

        /* abort on empty partition entry */
        if(buffer[4] == 0x00)
    d2aa:	8d 81       	ldd	r24, Y+5	; 0x05
    d2ac:	88 23       	and	r24, r24
    d2ae:	09 f4       	brne	.+2      	; 0xd2b2 <partition_open+0x80>
    d2b0:	78 c0       	rjmp	.+240    	; 0xd3a2 <partition_open+0x170>
            return 0;
    }

    /* allocate partition descriptor */
#if USE_DYNAMIC_MEMORY
    new_partition = malloc(sizeof(*new_partition));
    d2b2:	81 e1       	ldi	r24, 0x11	; 17
    d2b4:	90 e0       	ldi	r25, 0x00	; 0
    d2b6:	0e 94 78 11 	call	0x22f0	; 0x22f0 <malloc>
    d2ba:	fc 01       	movw	r30, r24
    d2bc:	bc 01       	movw	r22, r24
    if(!new_partition)
    d2be:	00 97       	sbiw	r24, 0x00	; 0
    d2c0:	09 f4       	brne	.+2      	; 0xd2c4 <partition_open+0x92>
    d2c2:	71 c0       	rjmp	.+226    	; 0xd3a6 <partition_open+0x174>
    }
    if(i >= PARTITION_COUNT)
        return 0;
#endif

    memset(new_partition, 0, sizeof(*new_partition));
    d2c4:	81 e1       	ldi	r24, 0x11	; 17
    d2c6:	df 01       	movw	r26, r30
    d2c8:	1d 92       	st	X+, r1
    d2ca:	8a 95       	dec	r24
    d2cc:	e9 f7       	brne	.-6      	; 0xd2c8 <partition_open+0x96>

    /* fill partition descriptor */
    new_partition->device_read = device_read;
    d2ce:	f1 82       	std	Z+1, r15	; 0x01
    d2d0:	e0 82       	st	Z, r14
    new_partition->device_read_interval = device_read_interval;
    d2d2:	d3 82       	std	Z+3, r13	; 0x03
    d2d4:	c2 82       	std	Z+2, r12	; 0x02
    new_partition->device_write = device_write;
    d2d6:	b5 82       	std	Z+5, r11	; 0x05
    d2d8:	a4 82       	std	Z+4, r10	; 0x04
    new_partition->device_write_interval = device_write_interval;
    d2da:	97 82       	std	Z+7, r9	; 0x07
    d2dc:	86 82       	std	Z+6, r8	; 0x06

    if(index >= 0)
    d2de:	07 fd       	sbrc	r16, 7
    d2e0:	5d c0       	rjmp	.+186    	; 0xd39c <partition_open+0x16a>
    {
        new_partition->type = buffer[4];
    d2e2:	8d 81       	ldd	r24, Y+5	; 0x05
    d2e4:	80 87       	std	Z+8, r24	; 0x08
        new_partition->offset = ((uint32_t) buffer[8]) |
    d2e6:	2a 85       	ldd	r18, Y+10	; 0x0a
    d2e8:	30 e0       	ldi	r19, 0x00	; 0
    d2ea:	40 e0       	ldi	r20, 0x00	; 0
    d2ec:	50 e0       	ldi	r21, 0x00	; 0
    d2ee:	54 2f       	mov	r21, r20
    d2f0:	43 2f       	mov	r20, r19
    d2f2:	32 2f       	mov	r19, r18
    d2f4:	22 27       	eor	r18, r18
    d2f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    d2f8:	90 e0       	ldi	r25, 0x00	; 0
    d2fa:	a0 e0       	ldi	r26, 0x00	; 0
    d2fc:	b0 e0       	ldi	r27, 0x00	; 0
    d2fe:	dc 01       	movw	r26, r24
    d300:	99 27       	eor	r25, r25
    d302:	88 27       	eor	r24, r24
    d304:	28 2b       	or	r18, r24
    d306:	39 2b       	or	r19, r25
    d308:	4a 2b       	or	r20, r26
    d30a:	5b 2b       	or	r21, r27
    d30c:	89 85       	ldd	r24, Y+9	; 0x09
    d30e:	90 e0       	ldi	r25, 0x00	; 0
    d310:	a0 e0       	ldi	r26, 0x00	; 0
    d312:	b0 e0       	ldi	r27, 0x00	; 0
    d314:	28 2b       	or	r18, r24
    d316:	39 2b       	or	r19, r25
    d318:	4a 2b       	or	r20, r26
    d31a:	5b 2b       	or	r21, r27
    d31c:	8c 85       	ldd	r24, Y+12	; 0x0c
    d31e:	90 e0       	ldi	r25, 0x00	; 0
    d320:	a0 e0       	ldi	r26, 0x00	; 0
    d322:	b0 e0       	ldi	r27, 0x00	; 0
    d324:	b8 2f       	mov	r27, r24
    d326:	aa 27       	eor	r26, r26
    d328:	99 27       	eor	r25, r25
    d32a:	88 27       	eor	r24, r24
    d32c:	28 2b       	or	r18, r24
    d32e:	39 2b       	or	r19, r25
    d330:	4a 2b       	or	r20, r26
    d332:	5b 2b       	or	r21, r27
    d334:	fb 01       	movw	r30, r22
    d336:	21 87       	std	Z+9, r18	; 0x09
    d338:	32 87       	std	Z+10, r19	; 0x0a
    d33a:	43 87       	std	Z+11, r20	; 0x0b
    d33c:	54 87       	std	Z+12, r21	; 0x0c
                                ((uint32_t) buffer[9] << 8) |
                                ((uint32_t) buffer[10] << 16) |
                                ((uint32_t) buffer[11] << 24);
        new_partition->length = ((uint32_t) buffer[12]) |
    d33e:	2e 85       	ldd	r18, Y+14	; 0x0e
    d340:	30 e0       	ldi	r19, 0x00	; 0
    d342:	40 e0       	ldi	r20, 0x00	; 0
    d344:	50 e0       	ldi	r21, 0x00	; 0
    d346:	54 2f       	mov	r21, r20
    d348:	43 2f       	mov	r20, r19
    d34a:	32 2f       	mov	r19, r18
    d34c:	22 27       	eor	r18, r18
    d34e:	8f 85       	ldd	r24, Y+15	; 0x0f
    d350:	90 e0       	ldi	r25, 0x00	; 0
    d352:	a0 e0       	ldi	r26, 0x00	; 0
    d354:	b0 e0       	ldi	r27, 0x00	; 0
    d356:	dc 01       	movw	r26, r24
    d358:	99 27       	eor	r25, r25
    d35a:	88 27       	eor	r24, r24
    d35c:	28 2b       	or	r18, r24
    d35e:	39 2b       	or	r19, r25
    d360:	4a 2b       	or	r20, r26
    d362:	5b 2b       	or	r21, r27
    d364:	8d 85       	ldd	r24, Y+13	; 0x0d
    d366:	90 e0       	ldi	r25, 0x00	; 0
    d368:	a0 e0       	ldi	r26, 0x00	; 0
    d36a:	b0 e0       	ldi	r27, 0x00	; 0
    d36c:	28 2b       	or	r18, r24
    d36e:	39 2b       	or	r19, r25
    d370:	4a 2b       	or	r20, r26
    d372:	5b 2b       	or	r21, r27
    d374:	88 89       	ldd	r24, Y+16	; 0x10
    d376:	90 e0       	ldi	r25, 0x00	; 0
    d378:	a0 e0       	ldi	r26, 0x00	; 0
    d37a:	b0 e0       	ldi	r27, 0x00	; 0
    d37c:	b8 2f       	mov	r27, r24
    d37e:	aa 27       	eor	r26, r26
    d380:	99 27       	eor	r25, r25
    d382:	88 27       	eor	r24, r24
    d384:	28 2b       	or	r18, r24
    d386:	39 2b       	or	r19, r25
    d388:	4a 2b       	or	r20, r26
    d38a:	5b 2b       	or	r21, r27
    d38c:	db 01       	movw	r26, r22
    d38e:	1d 96       	adiw	r26, 0x0d	; 13
    d390:	2d 93       	st	X+, r18
    d392:	3d 93       	st	X+, r19
    d394:	4d 93       	st	X+, r20
    d396:	5c 93       	st	X, r21
    d398:	50 97       	sbiw	r26, 0x10	; 16
    d39a:	05 c0       	rjmp	.+10     	; 0xd3a6 <partition_open+0x174>
                                ((uint32_t) buffer[14] << 16) |
                                ((uint32_t) buffer[15] << 24);
    }
    else
    {
        new_partition->type = 0xff;
    d39c:	8f ef       	ldi	r24, 0xFF	; 255
    d39e:	80 87       	std	Z+8, r24	; 0x08
    d3a0:	02 c0       	rjmp	.+4      	; 0xd3a6 <partition_open+0x174>
    d3a2:	60 e0       	ldi	r22, 0x00	; 0
    d3a4:	70 e0       	ldi	r23, 0x00	; 0
    }

    return new_partition;
}
    d3a6:	cb 01       	movw	r24, r22
    d3a8:	60 96       	adiw	r28, 0x10	; 16
    d3aa:	0f b6       	in	r0, 0x3f	; 63
    d3ac:	f8 94       	cli
    d3ae:	de bf       	out	0x3e, r29	; 62
    d3b0:	0f be       	out	0x3f, r0	; 63
    d3b2:	cd bf       	out	0x3d, r28	; 61
    d3b4:	cf 91       	pop	r28
    d3b6:	df 91       	pop	r29
    d3b8:	0f 91       	pop	r16
    d3ba:	ff 90       	pop	r15
    d3bc:	ef 90       	pop	r14
    d3be:	df 90       	pop	r13
    d3c0:	cf 90       	pop	r12
    d3c2:	bf 90       	pop	r11
    d3c4:	af 90       	pop	r10
    d3c6:	9f 90       	pop	r9
    d3c8:	8f 90       	pop	r8
    d3ca:	08 95       	ret

0000d3cc <FILE_init>:

struct partition_struct* partition;
struct fat_fs_struct* fs;

int FILE_init( void )
{
    d3cc:	0f 93       	push	r16
    d3ce:	df 93       	push	r29
    d3d0:	cf 93       	push	r28
    d3d2:	cd b7       	in	r28, 0x3d	; 61
    d3d4:	de b7       	in	r29, 0x3e	; 62
    d3d6:	ab 97       	sbiw	r28, 0x2b	; 43
    d3d8:	0f b6       	in	r0, 0x3f	; 63
    d3da:	f8 94       	cli
    d3dc:	de bf       	out	0x3e, r29	; 62
    d3de:	0f be       	out	0x3f, r0	; 63
    d3e0:	cd bf       	out	0x3d, r28	; 61
        /* open first partition */
        partition = partition_open(sd_raw_read,
    d3e2:	8d e0       	ldi	r24, 0x0D	; 13
    d3e4:	9b e5       	ldi	r25, 0x5B	; 91
    d3e6:	65 e9       	ldi	r22, 0x95	; 149
    d3e8:	7b e5       	ldi	r23, 0x5B	; 91
    d3ea:	42 ee       	ldi	r20, 0xE2	; 226
    d3ec:	5b e5       	ldi	r21, 0x5B	; 91
    d3ee:	21 e8       	ldi	r18, 0x81	; 129
    d3f0:	3c e5       	ldi	r19, 0x5C	; 92
    d3f2:	00 e0       	ldi	r16, 0x00	; 0
    d3f4:	0e 94 19 69 	call	0xd232	; 0xd232 <partition_open>
    d3f8:	90 93 f0 0b 	sts	0x0BF0, r25
    d3fc:	80 93 ef 0b 	sts	0x0BEF, r24
                                                            0,
#endif
                                                            0
                                                           );

        if(!partition)
    d400:	89 2b       	or	r24, r25
    d402:	89 f4       	brne	.+34     	; 0xd426 <FILE_init+0x5a>
        {
            /* If the partition did not open, assume the storage device
             * is a "superfloppy", i.e. has no MBR.
             */
            partition = partition_open(sd_raw_read,
    d404:	8d e0       	ldi	r24, 0x0D	; 13
    d406:	9b e5       	ldi	r25, 0x5B	; 91
    d408:	65 e9       	ldi	r22, 0x95	; 149
    d40a:	7b e5       	ldi	r23, 0x5B	; 91
    d40c:	42 ee       	ldi	r20, 0xE2	; 226
    d40e:	5b e5       	ldi	r21, 0x5B	; 91
    d410:	21 e8       	ldi	r18, 0x81	; 129
    d412:	3c e5       	ldi	r19, 0x5C	; 92
    d414:	0f ef       	ldi	r16, 0xFF	; 255
    d416:	0e 94 19 69 	call	0xd232	; 0xd232 <partition_open>
    d41a:	90 93 f0 0b 	sts	0x0BF0, r25
    d41e:	80 93 ef 0b 	sts	0x0BEF, r24
                                       0,
                                       0,
#endif
                                       -1
                                      );
            if(!partition)
    d422:	89 2b       	or	r24, r25
    d424:	b1 f0       	breq	.+44     	; 0xd452 <FILE_init+0x86>
			}
				
        }

        /* open file system */
        fs = fat_open(partition);
    d426:	80 91 ef 0b 	lds	r24, 0x0BEF
    d42a:	90 91 f0 0b 	lds	r25, 0x0BF0
    d42e:	0e 94 2a 67 	call	0xce54	; 0xce54 <fat_open>
    d432:	90 93 ee 0b 	sts	0x0BEE, r25
    d436:	80 93 ed 0b 	sts	0x0BED, r24
        if(!fs)
    d43a:	00 97       	sbiw	r24, 0x00	; 0
    d43c:	51 f0       	breq	.+20     	; 0xd452 <FILE_init+0x86>
            return( FILESYSTEM_FAILED );
        }

		struct fat_dir_entry_struct directory;

        fat_get_dir_entry_of_path(fs, "/", &directory);
    d43e:	61 e3       	ldi	r22, 0x31	; 49
    d440:	71 e0       	ldi	r23, 0x01	; 1
    d442:	ae 01       	movw	r20, r28
    d444:	4f 5f       	subi	r20, 0xFF	; 255
    d446:	5f 4f       	sbci	r21, 0xFF	; 255
    d448:	0e 94 9a 68 	call	0xd134	; 0xd134 <fat_get_dir_entry_of_path>
    d44c:	20 e0       	ldi	r18, 0x00	; 0
    d44e:	30 e0       	ldi	r19, 0x00	; 0
    d450:	02 c0       	rjmp	.+4      	; 0xd456 <FILE_init+0x8a>
                    while(spaces--)
                        printf_P(PSTR(" "));
                    printf_P( PSTR("%ld\r\n"),dir_entry.file_size);
                }
*/
	return( FILESYSTEM_OK );
    d452:	2f ef       	ldi	r18, 0xFF	; 255
    d454:	3f ef       	ldi	r19, 0xFF	; 255
}
    d456:	c9 01       	movw	r24, r18
    d458:	ab 96       	adiw	r28, 0x2b	; 43
    d45a:	0f b6       	in	r0, 0x3f	; 63
    d45c:	f8 94       	cli
    d45e:	de bf       	out	0x3e, r29	; 62
    d460:	0f be       	out	0x3f, r0	; 63
    d462:	cd bf       	out	0x3d, r28	; 61
    d464:	cf 91       	pop	r28
    d466:	df 91       	pop	r29
    d468:	0f 91       	pop	r16
    d46a:	08 95       	ret

0000d46c <__mulsi3>:
    d46c:	62 9f       	mul	r22, r18
    d46e:	d0 01       	movw	r26, r0
    d470:	73 9f       	mul	r23, r19
    d472:	f0 01       	movw	r30, r0
    d474:	82 9f       	mul	r24, r18
    d476:	e0 0d       	add	r30, r0
    d478:	f1 1d       	adc	r31, r1
    d47a:	64 9f       	mul	r22, r20
    d47c:	e0 0d       	add	r30, r0
    d47e:	f1 1d       	adc	r31, r1
    d480:	92 9f       	mul	r25, r18
    d482:	f0 0d       	add	r31, r0
    d484:	83 9f       	mul	r24, r19
    d486:	f0 0d       	add	r31, r0
    d488:	74 9f       	mul	r23, r20
    d48a:	f0 0d       	add	r31, r0
    d48c:	65 9f       	mul	r22, r21
    d48e:	f0 0d       	add	r31, r0
    d490:	99 27       	eor	r25, r25
    d492:	72 9f       	mul	r23, r18
    d494:	b0 0d       	add	r27, r0
    d496:	e1 1d       	adc	r30, r1
    d498:	f9 1f       	adc	r31, r25
    d49a:	63 9f       	mul	r22, r19
    d49c:	b0 0d       	add	r27, r0
    d49e:	e1 1d       	adc	r30, r1
    d4a0:	f9 1f       	adc	r31, r25
    d4a2:	bd 01       	movw	r22, r26
    d4a4:	cf 01       	movw	r24, r30
    d4a6:	11 24       	eor	r1, r1
    d4a8:	08 95       	ret

0000d4aa <__udivmodhi4>:
    d4aa:	aa 1b       	sub	r26, r26
    d4ac:	bb 1b       	sub	r27, r27
    d4ae:	51 e1       	ldi	r21, 0x11	; 17
    d4b0:	07 c0       	rjmp	.+14     	; 0xd4c0 <__udivmodhi4_ep>

0000d4b2 <__udivmodhi4_loop>:
    d4b2:	aa 1f       	adc	r26, r26
    d4b4:	bb 1f       	adc	r27, r27
    d4b6:	a6 17       	cp	r26, r22
    d4b8:	b7 07       	cpc	r27, r23
    d4ba:	10 f0       	brcs	.+4      	; 0xd4c0 <__udivmodhi4_ep>
    d4bc:	a6 1b       	sub	r26, r22
    d4be:	b7 0b       	sbc	r27, r23

0000d4c0 <__udivmodhi4_ep>:
    d4c0:	88 1f       	adc	r24, r24
    d4c2:	99 1f       	adc	r25, r25
    d4c4:	5a 95       	dec	r21
    d4c6:	a9 f7       	brne	.-22     	; 0xd4b2 <__udivmodhi4_loop>
    d4c8:	80 95       	com	r24
    d4ca:	90 95       	com	r25
    d4cc:	bc 01       	movw	r22, r24
    d4ce:	cd 01       	movw	r24, r26
    d4d0:	08 95       	ret

0000d4d2 <__divmodhi4>:
    d4d2:	97 fb       	bst	r25, 7
    d4d4:	09 2e       	mov	r0, r25
    d4d6:	07 26       	eor	r0, r23
    d4d8:	0a d0       	rcall	.+20     	; 0xd4ee <__divmodhi4_neg1>
    d4da:	77 fd       	sbrc	r23, 7
    d4dc:	04 d0       	rcall	.+8      	; 0xd4e6 <__divmodhi4_neg2>
    d4de:	e5 df       	rcall	.-54     	; 0xd4aa <__udivmodhi4>
    d4e0:	06 d0       	rcall	.+12     	; 0xd4ee <__divmodhi4_neg1>
    d4e2:	00 20       	and	r0, r0
    d4e4:	1a f4       	brpl	.+6      	; 0xd4ec <__divmodhi4_exit>

0000d4e6 <__divmodhi4_neg2>:
    d4e6:	70 95       	com	r23
    d4e8:	61 95       	neg	r22
    d4ea:	7f 4f       	sbci	r23, 0xFF	; 255

0000d4ec <__divmodhi4_exit>:
    d4ec:	08 95       	ret

0000d4ee <__divmodhi4_neg1>:
    d4ee:	f6 f7       	brtc	.-4      	; 0xd4ec <__divmodhi4_exit>
    d4f0:	90 95       	com	r25
    d4f2:	81 95       	neg	r24
    d4f4:	9f 4f       	sbci	r25, 0xFF	; 255
    d4f6:	08 95       	ret

0000d4f8 <__udivmodsi4>:
    d4f8:	a1 e2       	ldi	r26, 0x21	; 33
    d4fa:	1a 2e       	mov	r1, r26
    d4fc:	aa 1b       	sub	r26, r26
    d4fe:	bb 1b       	sub	r27, r27
    d500:	fd 01       	movw	r30, r26
    d502:	0d c0       	rjmp	.+26     	; 0xd51e <__udivmodsi4_ep>

0000d504 <__udivmodsi4_loop>:
    d504:	aa 1f       	adc	r26, r26
    d506:	bb 1f       	adc	r27, r27
    d508:	ee 1f       	adc	r30, r30
    d50a:	ff 1f       	adc	r31, r31
    d50c:	a2 17       	cp	r26, r18
    d50e:	b3 07       	cpc	r27, r19
    d510:	e4 07       	cpc	r30, r20
    d512:	f5 07       	cpc	r31, r21
    d514:	20 f0       	brcs	.+8      	; 0xd51e <__udivmodsi4_ep>
    d516:	a2 1b       	sub	r26, r18
    d518:	b3 0b       	sbc	r27, r19
    d51a:	e4 0b       	sbc	r30, r20
    d51c:	f5 0b       	sbc	r31, r21

0000d51e <__udivmodsi4_ep>:
    d51e:	66 1f       	adc	r22, r22
    d520:	77 1f       	adc	r23, r23
    d522:	88 1f       	adc	r24, r24
    d524:	99 1f       	adc	r25, r25
    d526:	1a 94       	dec	r1
    d528:	69 f7       	brne	.-38     	; 0xd504 <__udivmodsi4_loop>
    d52a:	60 95       	com	r22
    d52c:	70 95       	com	r23
    d52e:	80 95       	com	r24
    d530:	90 95       	com	r25
    d532:	9b 01       	movw	r18, r22
    d534:	ac 01       	movw	r20, r24
    d536:	bd 01       	movw	r22, r26
    d538:	cf 01       	movw	r24, r30
    d53a:	08 95       	ret

0000d53c <__divmodsi4>:
    d53c:	97 fb       	bst	r25, 7
    d53e:	09 2e       	mov	r0, r25
    d540:	05 26       	eor	r0, r21
    d542:	0e d0       	rcall	.+28     	; 0xd560 <__divmodsi4_neg1>
    d544:	57 fd       	sbrc	r21, 7
    d546:	04 d0       	rcall	.+8      	; 0xd550 <__divmodsi4_neg2>
    d548:	d7 df       	rcall	.-82     	; 0xd4f8 <__udivmodsi4>
    d54a:	0a d0       	rcall	.+20     	; 0xd560 <__divmodsi4_neg1>
    d54c:	00 1c       	adc	r0, r0
    d54e:	38 f4       	brcc	.+14     	; 0xd55e <__divmodsi4_exit>

0000d550 <__divmodsi4_neg2>:
    d550:	50 95       	com	r21
    d552:	40 95       	com	r20
    d554:	30 95       	com	r19
    d556:	21 95       	neg	r18
    d558:	3f 4f       	sbci	r19, 0xFF	; 255
    d55a:	4f 4f       	sbci	r20, 0xFF	; 255
    d55c:	5f 4f       	sbci	r21, 0xFF	; 255

0000d55e <__divmodsi4_exit>:
    d55e:	08 95       	ret

0000d560 <__divmodsi4_neg1>:
    d560:	f6 f7       	brtc	.-4      	; 0xd55e <__divmodsi4_exit>
    d562:	90 95       	com	r25
    d564:	80 95       	com	r24
    d566:	70 95       	com	r23
    d568:	61 95       	neg	r22
    d56a:	7f 4f       	sbci	r23, 0xFF	; 255
    d56c:	8f 4f       	sbci	r24, 0xFF	; 255
    d56e:	9f 4f       	sbci	r25, 0xFF	; 255
    d570:	08 95       	ret

0000d572 <__prologue_saves__>:
    d572:	2f 92       	push	r2
    d574:	3f 92       	push	r3
    d576:	4f 92       	push	r4
    d578:	5f 92       	push	r5
    d57a:	6f 92       	push	r6
    d57c:	7f 92       	push	r7
    d57e:	8f 92       	push	r8
    d580:	9f 92       	push	r9
    d582:	af 92       	push	r10
    d584:	bf 92       	push	r11
    d586:	cf 92       	push	r12
    d588:	df 92       	push	r13
    d58a:	ef 92       	push	r14
    d58c:	ff 92       	push	r15
    d58e:	0f 93       	push	r16
    d590:	1f 93       	push	r17
    d592:	cf 93       	push	r28
    d594:	df 93       	push	r29
    d596:	cd b7       	in	r28, 0x3d	; 61
    d598:	de b7       	in	r29, 0x3e	; 62
    d59a:	ca 1b       	sub	r28, r26
    d59c:	db 0b       	sbc	r29, r27
    d59e:	0f b6       	in	r0, 0x3f	; 63
    d5a0:	f8 94       	cli
    d5a2:	de bf       	out	0x3e, r29	; 62
    d5a4:	0f be       	out	0x3f, r0	; 63
    d5a6:	cd bf       	out	0x3d, r28	; 61
    d5a8:	09 94       	ijmp

0000d5aa <__epilogue_restores__>:
    d5aa:	2a 88       	ldd	r2, Y+18	; 0x12
    d5ac:	39 88       	ldd	r3, Y+17	; 0x11
    d5ae:	48 88       	ldd	r4, Y+16	; 0x10
    d5b0:	5f 84       	ldd	r5, Y+15	; 0x0f
    d5b2:	6e 84       	ldd	r6, Y+14	; 0x0e
    d5b4:	7d 84       	ldd	r7, Y+13	; 0x0d
    d5b6:	8c 84       	ldd	r8, Y+12	; 0x0c
    d5b8:	9b 84       	ldd	r9, Y+11	; 0x0b
    d5ba:	aa 84       	ldd	r10, Y+10	; 0x0a
    d5bc:	b9 84       	ldd	r11, Y+9	; 0x09
    d5be:	c8 84       	ldd	r12, Y+8	; 0x08
    d5c0:	df 80       	ldd	r13, Y+7	; 0x07
    d5c2:	ee 80       	ldd	r14, Y+6	; 0x06
    d5c4:	fd 80       	ldd	r15, Y+5	; 0x05
    d5c6:	0c 81       	ldd	r16, Y+4	; 0x04
    d5c8:	1b 81       	ldd	r17, Y+3	; 0x03
    d5ca:	aa 81       	ldd	r26, Y+2	; 0x02
    d5cc:	b9 81       	ldd	r27, Y+1	; 0x01
    d5ce:	ce 0f       	add	r28, r30
    d5d0:	d1 1d       	adc	r29, r1
    d5d2:	0f b6       	in	r0, 0x3f	; 63
    d5d4:	f8 94       	cli
    d5d6:	de bf       	out	0x3e, r29	; 62
    d5d8:	0f be       	out	0x3f, r0	; 63
    d5da:	cd bf       	out	0x3d, r28	; 61
    d5dc:	ed 01       	movw	r28, r26
    d5de:	08 95       	ret

0000d5e0 <isspace>:
    d5e0:	91 11       	cpse	r25, r1
    d5e2:	06 c0       	rjmp	.+12     	; 0xd5f0 <__ctype_isfalse>
    d5e4:	80 32       	cpi	r24, 0x20	; 32
    d5e6:	19 f0       	breq	.+6      	; 0xd5ee <isspace+0xe>
    d5e8:	89 50       	subi	r24, 0x09	; 9
    d5ea:	85 50       	subi	r24, 0x05	; 5
    d5ec:	d0 f7       	brcc	.-12     	; 0xd5e2 <isspace+0x2>
    d5ee:	08 95       	ret

0000d5f0 <__ctype_isfalse>:
    d5f0:	99 27       	eor	r25, r25
    d5f2:	88 27       	eor	r24, r24

0000d5f4 <__ctype_istrue>:
    d5f4:	08 95       	ret

0000d5f6 <_exit>:
    d5f6:	f8 94       	cli

0000d5f8 <__stop_program>:
    d5f8:	ff cf       	rjmp	.-2      	; 0xd5f8 <__stop_program>
